//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// ec_wtcc.cu
//
// Code generation for function 'ec_wtcc'
//

// Include files
#include "ec_wtcc.h"
#include "_coder_ec_wtcc_mex.h"
#include "ec_wtcc_types.h"
#include "rt_nonfinite.h"
#include "MWCUBLASUtils.hpp"
#include "MWCUFFTPlanManager.hpp"
#include "MWCUSOLVERUtils.hpp"
#include "MWCudaDimUtility.hpp"
#include "MWCudaMemoryFunctions.hpp"
#include "MWErrorCodeUtils.hpp"
#include "MWLaunchParametersUtilities.hpp"
#include "cufft.h"
#include "lapacke.h"
#include "math_constants.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include <algorithm>
#include <cfloat>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>

// Type Definitions
struct emxArray_real_T
{
  real_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_int32_T
{
  int32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_creal32_T
{
  creal32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_uint32_T
{
  uint32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_ptrdiff_t
{
  ptrdiff_t *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_char_T
{
  char_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

// Variable Definitions
emlrtCTX emlrtRootTLSGlobal{ nullptr };

emlrtContext emlrtContextGlobal{ true, // bFirstTime
  false,                               // bInitialized
  131643U,                             // fVersionInfo
  nullptr,                             // fErrorFunction
  "ec_wtcc",                           // fFunctionName
  nullptr,                             // fRTCallStack
  false,                               // bDebugMode

  { 3334663369U, 2606893378U, 3553281593U, 3751928550U },// fSigWrd
  nullptr                              // fSigMem
};

static emlrtMCInfo emlrtMCI{ 53,       // lineNo
  19,                                  // colNo
  "flt2str",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/flt2str.m"// pName
};

static emlrtMCInfo b_emlrtMCI{ 53,     // lineNo
  14,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo c_emlrtMCI{ 55,     // lineNo
  15,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo d_emlrtMCI{ 14,     // lineNo
  25,                                  // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtMCInfo e_emlrtMCI{ 14,     // lineNo
  9,                                   // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtRTEInfo emlrtRTEI{ 1,      // lineNo
  20,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo b_emlrtRTEI{ 19,   // lineNo
  21,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo c_emlrtRTEI{ 23,   // lineNo
  29,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo d_emlrtRTEI{ 23,   // lineNo
  41,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo e_emlrtRTEI{ 999,  // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo f_emlrtRTEI{ 1000, // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo g_emlrtRTEI{ 1009, // lineNo
  13,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo h_emlrtRTEI{ 28,   // lineNo
  9,                                   // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo i_emlrtRTEI{ 129,  // lineNo
  6,                                   // colNo
  "applyBinaryScalarFunction",         // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyBinaryScalarFunction.m"// pName
};

static emlrtRTEInfo j_emlrtRTEI{ 33,   // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo k_emlrtRTEI{ 18,   // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo l_emlrtRTEI{ 60,   // lineNo
  20,                                  // colNo
  "bsxfun",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/bsxfun.m"// pName
};

static emlrtRTEInfo m_emlrtRTEI{ 31,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo n_emlrtRTEI{ 26,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo o_emlrtRTEI{ 33,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo p_emlrtRTEI{ 27,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo q_emlrtRTEI{ 102,  // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo r_emlrtRTEI{ 30,   // lineNo
  21,                                  // colNo
  "applyScalarFunction",               // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyScalarFunction.m"// pName
};

static emlrtRTEInfo s_emlrtRTEI{ 135,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo t_emlrtRTEI{ 34,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo u_emlrtRTEI{ 143,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo v_emlrtRTEI{ 1,    // lineNo
  1,                                   // colNo
  "cuFFTNDCallback",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/cuFFTNDCallback.p"// pName
};

static emlrtRTEInfo w_emlrtRTEI{ 138,  // lineNo
  19,                                  // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo x_emlrtRTEI{ 138,  // lineNo
  6,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo y_emlrtRTEI{ 161,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo ab_emlrtRTEI{ 180, // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo bb_emlrtRTEI{ 15,  // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo cb_emlrtRTEI{ 16,  // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo db_emlrtRTEI{ 18,  // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo eb_emlrtRTEI{ 25,  // lineNo
  1,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo fb_emlrtRTEI{ 30,  // lineNo
  27,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo gb_emlrtRTEI{ 47,  // lineNo
  28,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo hb_emlrtRTEI{ 83,  // lineNo
  1,                                   // colNo
  "ifft",                              // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/ifft.m"// pName
};

static emlrtRTEInfo ib_emlrtRTEI{ 47,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo jb_emlrtRTEI{ 49,  // lineNo
  31,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo kb_emlrtRTEI{ 216, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo lb_emlrtRTEI{ 75,  // lineNo
  5,                                   // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo mb_emlrtRTEI{ 88,  // lineNo
  13,                                  // colNo
  "eml_mtimes_helper",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static emlrtRTEInfo nb_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "stencil_codegen",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/stencil_codegen.p"// pName
};

static emlrtRTEInfo ob_emlrtRTEI{ 172, // lineNo
  20,                                  // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo pb_emlrtRTEI{ 53,  // lineNo
  7,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo qb_emlrtRTEI{ 217, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo rb_emlrtRTEI{ 218, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo sb_emlrtRTEI{ 50,  // lineNo
  23,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo tb_emlrtRTEI{ 50,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo ub_emlrtRTEI{ 219, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo vb_emlrtRTEI{ 220, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo wb_emlrtRTEI{ 154, // lineNo
  1,                                   // colNo
  "resample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/resample.m"// pName
};

static emlrtRTEInfo xb_emlrtRTEI{ 37,  // lineNo
  20,                                  // colNo
  "kaiser",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/kaiser.m"// pName
};

static emlrtRTEInfo yb_emlrtRTEI{ 816, // lineNo
  63,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ac_emlrtRTEI{ 245, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo bc_emlrtRTEI{ 243, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo cc_emlrtRTEI{ 816, // lineNo
  17,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo dc_emlrtRTEI{ 247, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ec_emlrtRTEI{ 258, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo fc_emlrtRTEI{ 274, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo gc_emlrtRTEI{ 275, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo hc_emlrtRTEI{ 276, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ic_emlrtRTEI{ 777, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo jc_emlrtRTEI{ 277, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo kc_emlrtRTEI{ 286, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo lc_emlrtRTEI{ 778, // lineNo
  15,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo mc_emlrtRTEI{ 281, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo nc_emlrtRTEI{ 341, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo oc_emlrtRTEI{ 347, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo pc_emlrtRTEI{ 345, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo qc_emlrtRTEI{ 76,  // lineNo
  9,                                   // colNo
  "eml_mtimes_helper",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static emlrtRTEInfo rc_emlrtRTEI{ 38,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo sc_emlrtRTEI{ 21,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo tc_emlrtRTEI{ 341, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo uc_emlrtRTEI{ 31,  // lineNo
  29,                                  // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo vc_emlrtRTEI{ 61,  // lineNo
  9,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo wc_emlrtRTEI{ 27,  // lineNo
  23,                                  // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo xc_emlrtRTEI{ 49,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo yc_emlrtRTEI{ 47,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo ad_emlrtRTEI{ 1,   // lineNo
  21,                                  // colNo
  "flipud",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/flipud.m"// pName
};

static emlrtRTEInfo bd_emlrtRTEI{ 92,  // lineNo
  22,                                  // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo cd_emlrtRTEI{ 91,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo dd_emlrtRTEI{ 105, // lineNo
  1,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo ed_emlrtRTEI{ 36,  // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo fd_emlrtRTEI{ 68,  // lineNo
  9,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo gd_emlrtRTEI{ 353, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo hd_emlrtRTEI{ 355, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo id_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "upfirdnGPUImpl",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+codegenable/+gpu/upfirdnGPUImpl.p"// pName
};

static emlrtRTEInfo jd_emlrtRTEI{ 119, // lineNo
  5,                                   // colNo
  "qrsolve",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/qrsolve.m"// pName
};

static emlrtRTEInfo kd_emlrtRTEI{ 71,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo ld_emlrtRTEI{ 158, // lineNo
  24,                                  // colNo
  "mtimes",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+blas/mtimes.m"// pName
};

static emlrtRTEInfo nd_emlrtRTEI{ 91,  // lineNo
  14,                                  // colNo
  "downsample",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/downsample.m"// pName
};

static emlrtRTEInfo od_emlrtRTEI{ 83,  // lineNo
  13,                                  // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo pd_emlrtRTEI{ 17,  // lineNo
  5,                                   // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo qd_emlrtRTEI{ 13,  // lineNo
  1,                                   // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo rd_emlrtRTEI{ 37,  // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo sd_emlrtRTEI{ 23,  // lineNo
  6,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo td_emlrtRTEI{ 23,  // lineNo
  12,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo ud_emlrtRTEI{ 170, // lineNo
  5,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo vd_emlrtRTEI{ 1276,// lineNo
  30,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo wd_emlrtRTEI{ 1276,// lineNo
  25,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo xd_emlrtRTEI{ 16,  // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo yd_emlrtRTEI{ 32,  // lineNo
  18,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo ae_emlrtRTEI{ 34,  // lineNo
  42,                                  // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo be_emlrtRTEI{ 32,  // lineNo
  13,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo ce_emlrtRTEI{ 151, // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo de_emlrtRTEI{ 216, // lineNo
  39,                                  // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ee_emlrtRTEI{ 30,  // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo fe_emlrtRTEI{ 47,  // lineNo
  23,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo ge_emlrtRTEI{ 45,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo he_emlrtRTEI{ 217, // lineNo
  39,                                  // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ie_emlrtRTEI{ 49,  // lineNo
  13,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo je_emlrtRTEI{ 220, // lineNo
  7,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ke_emlrtRTEI{ 816, // lineNo
  22,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo le_emlrtRTEI{ 253, // lineNo
  20,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo me_emlrtRTEI{ 274, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ne_emlrtRTEI{ 275, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo oe_emlrtRTEI{ 276, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo pe_emlrtRTEI{ 778, // lineNo
  27,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo qe_emlrtRTEI{ 277, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo re_emlrtRTEI{ 778, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo se_emlrtRTEI{ 15,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo te_emlrtRTEI{ 295, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ue_emlrtRTEI{ 355, // lineNo
  17,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ve_emlrtRTEI{ 297, // lineNo
  46,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo we_emlrtRTEI{ 27,  // lineNo
  1,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo xe_emlrtRTEI{ 88,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo ye_emlrtRTEI{ 298, // lineNo
  39,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo af_emlrtRTEI{ 22,  // lineNo
  23,                                  // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo bf_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "gpu_conv2_kernel",                  // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+images/gpu_conv2_kernel.p"// pName
};

static emlrtRTEInfo cf_emlrtRTEI{ 14,  // lineNo
  15,                                  // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo df_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "_coder_ec_wtcc_api",                // fName
  ""                                   // pName
};

static emlrtRTEInfo ef_emlrtRTEI{ 297, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ff_emlrtRTEI{ 297, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo gf_emlrtRTEI{ 295, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo hf_emlrtRTEI{ 295, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static char_T (*global_gpu_cv)[128];
static real_T (*global_gpu_table100)[100];
static boolean_T gpuConstsCopied_ec_wtcc;

// Function Declarations
static int64_T b_computeEndIdx(int64_T start, int64_T end, int64_T stride);
static real32_T b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23]);
static real32_T b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier);
static uint16_T *b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, int32_T ret_size[2]);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real32_T *ret);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret);
static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location);
static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString);
static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location);
static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5);
static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5);
static void binary_expand_op_10(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2]);
static void binary_expand_op_4(emxArray_real32_T *in1, const emxArray_real32_T
  *in2, const emxArray_real32_T *in3, const emxArray_real32_T *in4);
static void binary_expand_op_5(emxArray_creal32_T *in1, const emxArray_real_T
  *in2, const emxArray_creal32_T *in3);
static void binary_expand_op_6(emxArray_creal32_T *in1, const emxArray_creal32_T
  *in2, const emxArray_creal32_T *in3);
static void binary_expand_op_9(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3);
static real32_T (*c_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
  parentId))[2];
static real32_T (*c_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2];
static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line);
namespace coder
{
  namespace internal
  {
    static void warning();
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride);
static uint64_T computeNumIters(int64_T ub);
static uint64_T computeNumIters(int32_T ub, int32_T b_ub);
static uint64_T computeNumIters(int32_T ub);
static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line);
static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line);
static real_T d_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId);
static int32_T div_s32(int32_T numerator, int32_T denominator);
static
#ifdef __CUDACC__

__device__
#endif

int32_T div_s32_device(int32_T numerator, int32_T denominator);
static real32_T e_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId);
static __global__ void ec_wtcc_kernel1(creal_T *dc, creal_T *dc6);
static __global__ void ec_wtcc_kernel10(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel100(const emxArray_real_T a, const int32_T
  ix, const int32_T lidx, const int32_T bcoef, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1000(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1001(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1002(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1003(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1004(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv57);
static __global__ void ec_wtcc_kernel1005(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv74);
static __global__ void ec_wtcc_kernel1006(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv74, const emxArray_int32_T iv57,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel1007(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel101(const int32_T b, emxArray_real_T dv23);
static __global__ void ec_wtcc_kernel102(const emxArray_real_T dv23, const
  emxArray_real_T h, const int32_T b_h, emxArray_real_T h1);
static __global__ void ec_wtcc_kernel103(const real_T halfh, const
  emxArray_real_T h1, const real_T toler, const int32_T b_h1, emxArray_real32_T
  opts_filter);
static __global__ void ec_wtcc_kernel1036(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1037(const emxArray_real32_T opts_x, const
  int32_T fb_SignalPad, const int32_T i71, const int32_T omega_tmp2,
  emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel1038(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1039(const emxArray_real32_T w, const
  int32_T lidx, const int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel104(const int32_T halfh, emxArray_real32_T
  h);
static __global__ void ec_wtcc_kernel1040(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1041(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T fb_SignalPad, const int32_T
  b, emxArray_real32_T b_y1, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel1042(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1043(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1044(const emxArray_real32_T yCol, real32_T
  *cv_re);
static __global__ void ec_wtcc_kernel1045(const real32_T *cv_re, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1046(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1047(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv43);
static __global__ void ec_wtcc_kernel1048(const emxArray_real32_T h, const
  emxArray_int32_T iv43, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1049(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T toler,
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel105(const emxArray_uint32_T y, const real_T
  halfh, const int32_T b_y, emxArray_int32_T iv19);
static __global__ void ec_wtcc_kernel1050(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1051(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1052(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1053(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv42);
static __global__ void ec_wtcc_kernel1054(const emxArray_real32_T yCol, const
  emxArray_int32_T iv42, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1055(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel1056(const emxArray_real32_T b_y1, const
  int32_T wtc, emxArray_real32_T opts_x);
static __global__ void ec_wtcc_kernel1057(const emxArray_real32_T b_y1, const
  int32_T c_y1, const int32_T d_y1, emxArray_real32_T opts_x, int32_T
  opts_x_dim0, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel1058(const emxArray_real32_T opts_x, const
  int32_T b_opts_x, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel1059(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel106(const emxArray_real32_T opts_filter,
  const emxArray_int32_T iv19, const int32_T b_iv19, emxArray_real32_T h);
static __global__ void ec_wtcc_kernel1060(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel1061(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel1062(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1063(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel1064(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel1065(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1066(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1067(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1068(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel1069(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel107(const emxArray_real32_T opts_x, const
  int32_T b_opts_x, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel1070(const emxArray_real32_T y, const
  int32_T iv9, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel1071(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1072(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel1073(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1074(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1075(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1076(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1077(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1078(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv71);
static __global__ void ec_wtcc_kernel1079(const emxArray_real32_T h, const
  emxArray_int32_T iv71, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel108(const emxArray_real32_T b_y1, const
  int32_T b, emxArray_real32_T opts_x);
static __global__ void ec_wtcc_kernel1080(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T toler,
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1081(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1082(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1083(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1084(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1085(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv73);
static __global__ void ec_wtcc_kernel1086(const emxArray_real32_T yCol, const
  emxArray_int32_T iv73, const int32_T iv9, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1087(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel1088(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1089(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel109(const emxArray_creal32_T crossCFS,
  const int32_T b, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel1090(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel1091(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1092(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel1093(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel1094(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1095(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1096(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1097(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel1098(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel1099(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel11(emxArray_real_T fb_Omega);
static __global__ void ec_wtcc_kernel110(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel1100(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1101(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1102(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1103(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv48);
static __global__ void ec_wtcc_kernel1104(const emxArray_real32_T a, const
  emxArray_int32_T iv48, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1105(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1106(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1107(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1108(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1109(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel111(const emxArray_real_T m, const int32_T
  b_m, emxArray_real_T k);
static __global__ void ec_wtcc_kernel1110(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv53);
static __global__ void ec_wtcc_kernel1111(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv53, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1112(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1113(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1114(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1115(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1116(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1117(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv56);
static __global__ void ec_wtcc_kernel1118(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv72);
static __global__ void ec_wtcc_kernel1119(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv72, const emxArray_int32_T iv56,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel112(const int32_T k, emxArray_real_T G);
static __global__ void ec_wtcc_kernel1120(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel113(const int32_T k, emxArray_real_T b);
static __global__ void ec_wtcc_kernel114(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T dv29);
static __global__ void ec_wtcc_kernel1149(const emxArray_real32_T opts_x, const
  int32_T b_opts_x, emxArray_real32_T xCol);
static __global__ void ec_wtcc_kernel115(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T dv31, emxArray_real_T dv29);
static __global__ void ec_wtcc_kernel1150(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1151(const emxArray_real32_T xCol, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel1152(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel1153(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1154(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel1155(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel1156(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1157(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1158(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1159(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel116(const int32_T b, emxArray_real_T dv31);
static __global__ void ec_wtcc_kernel1160(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel1161(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel1162(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1163(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel1164(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1165(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel1166(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1167(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1168(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1169(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel117(const emxArray_real_T k, const
  emxArray_real_T dv31, const emxArray_real_T dv29, const real_T a, const
  int32_T b, emxArray_real_T b_b);
static __global__ void ec_wtcc_kernel1170(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv59);
static __global__ void ec_wtcc_kernel1171(const emxArray_real32_T a, const
  emxArray_int32_T iv59, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1172(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1173(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1174(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1175(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1176(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1177(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv62);
static __global__ void ec_wtcc_kernel1178(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv62, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1179(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel118(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1180(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1181(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1182(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1183(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1184(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv63);
static __global__ void ec_wtcc_kernel1185(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv80);
static __global__ void ec_wtcc_kernel1186(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv80, const emxArray_int32_T iv63,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel1187(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel119(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T y, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel12(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T fb_Omega);
static __global__ void ec_wtcc_kernel120(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel121(const emxArray_real_T y, const real_T a,
  const emxArray_real_T b_y, const real_T b_a, const int32_T b, emxArray_real_T
  b_b);
static __global__ void ec_wtcc_kernel1216(const emxArray_real32_T opts_x, const
  int32_T b_opts_x, emxArray_real32_T xCol);
static __global__ void ec_wtcc_kernel1217(const int32_T b, emxArray_uint32_T y);
static __global__ void ec_wtcc_kernel1218(const creal_T *dc6, const real_T
  table100[100], const creal_T dc7, const creal_T *dc, const int32_T bcoef,
  const int32_T ix, const int32_T lidx, const int32_T i, const int64_T b,
  emxArray_real_T dv23, real_T q1_dim0, real_T q1_dim1, real_T q1_dim2, real_T
  q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6, real_T q1_dim7,
  real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3, real_T p1_dim4,
  real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0, real_T q2_dim1,
  real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5, real_T q2_dim6,
  real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2, real_T p2_dim3,
  real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7, real_T q4_dim0,
  real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4, real_T q4_dim5,
  real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1, real_T p4_dim2,
  real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6, real_T p4_dim7,
  real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3, real_T c_dim4,
  real_T c_dim5, real_T c_dim6);
static __global__ void ec_wtcc_kernel1219(const emxArray_real_T a, const int32_T
  b_a, emxArray_real_T x);
static __global__ void ec_wtcc_kernel122(const real_T fa, const real_T r, const
  int32_T bcoef, const int32_T i1Start, const int32_T b, emxArray_real_T sinc4A,
  emxArray_real_T sinc3A, emxArray_real_T sinc2A, emxArray_real_T sinc1A);
static __global__ void ec_wtcc_kernel1220(const emxArray_real_T x, const int32_T
  b, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1221(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1222(const int32_T omega_tmp2,
  emxArray_real_T a);
static __global__ void ec_wtcc_kernel1223(const int32_T G, emxArray_int32_T jpvt);
static __global__ void ec_wtcc_kernel1224(const int32_T b, const int32_T nsubs,
  emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel1225(const int32_T b, emxArray_real_T tau);
static __global__ void ec_wtcc_kernel1226(const int32_T i, const int64_T b,
  emxArray_real_T tau);
static __global__ void ec_wtcc_kernel1227(const int32_T nsubs, emxArray_int32_T
  jpvt);
static __global__ void ec_wtcc_kernel1228(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1229(const int32_T omega_tmp2,
  emxArray_real_T b);
static __global__ void ec_wtcc_kernel123(const emxArray_real_T sinc4A, const
  emxArray_real_T sinc2A, const real_T fa, const emxArray_real_T sinc3A, const
  emxArray_real_T sinc1A, const real_T r, const int32_T bcoef, const int32_T b,
  const int32_T c, emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel1230(const emxArray_real_T b, const
  emxArray_int32_T jpvt, const int32_T nsubs, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1231(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1232(emxArray_real_T a);
static __global__ void ec_wtcc_kernel1233(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel1234(const emxArray_real32_T wtc, const
  int32_T b_wtc, emxArray_real32_T opts_x);
static __global__ void ec_wtcc_kernel1235(const emxArray_real32_T wtc, const
  int32_T b_wtc, const int32_T c_wtc, emxArray_real32_T opts_x, int32_T
  opts_x_dim0, int32_T wtc_dim0);
static __global__ void ec_wtcc_kernel1236(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel1237(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv17);
static __global__ void ec_wtcc_kernel1238(const emxArray_creal32_T a, const
  emxArray_int32_T iv17, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel1239(const emxArray_creal32_T expanded,
  const real_T a, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel124(const real_T T, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel1240(const int32_T smooth,
  emxArray_creal32_T crossCFS);
static __global__ void ec_wtcc_kernel1241(const int32_T smooth,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel1242(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv16);
static __global__ void ec_wtcc_kernel1243(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv18);
static __global__ void ec_wtcc_kernel1244(const emxArray_creal32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_creal32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1245(const emxArray_creal32_T smooth, const
  int32_T iv9_dim0, const emxArray_int32_T iv18, const emxArray_int32_T iv16,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel1246(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1247(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T crossCFS,
  int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel1248(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1249(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T smooth);
static __global__ void ec_wtcc_kernel125(const emxArray_real_T b, const int32_T
  c, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel1250(const int32_T crossCFS,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1251(const emxArray_creal32_T crossCFS,
  const int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T
  cfsDFT_dim0, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel1252(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1253(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1254(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1255(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv13);
static __global__ void ec_wtcc_kernel1256(const emxArray_real32_T a, const
  emxArray_int32_T iv13, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1257(const real_T a, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1258(const int32_T smooth,
  emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel1259(const real_T a, const
  emxArray_real32_T smooth, emxArray_real32_T b_smooth);
static __global__ void ec_wtcc_kernel126(const emxArray_real_T b0, const int32_T
  b_b0, emxArray_real_T b);
static __global__ void ec_wtcc_kernel1260(const emxArray_real32_T smooth,
  emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel1261(const int32_T smooth,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1262(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv12);
static __global__ void ec_wtcc_kernel1263(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv14);
static __global__ void ec_wtcc_kernel1264(const emxArray_real32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_real32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1265(const emxArray_real32_T smooth, const
  int32_T iv9_dim0, const emxArray_int32_T iv14, const emxArray_int32_T iv12,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel1266(const real_T a, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T halfh,
  const int32_T b, const int32_T c, emxArray_real32_T cfs2, int32_T
  expanded_dim0, int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel1267(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1268(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel1269(const int32_T cfs2, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel127(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1270(const emxArray_real32_T cfs2, const
  int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0,
  int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel1271(const emxArray_real32_T cfs2, const
  int32_T b_cfs2, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1272(const int32_T ix, const int32_T lidx,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1273(const int32_T ix, const int32_T cfsDFT,
  const int32_T lidx, emxArray_creal32_T b_cfsDFT, int32_T cfsDFT_dim0);
static __global__ void ec_wtcc_kernel1274(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1275(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1276(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv10);
static __global__ void ec_wtcc_kernel1277(const emxArray_real32_T a, const
  emxArray_int32_T iv10, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1278(const real_T a, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1279(const int32_T smooth,
  emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel128(const emxArray_real_T a, const int32_T
  ix, const int32_T lidx, const int32_T offsetH, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1280(const real_T a, const
  emxArray_real32_T smooth, emxArray_real32_T b_smooth);
static __global__ void ec_wtcc_kernel1281(const emxArray_real32_T smooth,
  emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel1282(const int32_T smooth,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1283(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv9);
static __global__ void ec_wtcc_kernel1284(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv11);
static __global__ void ec_wtcc_kernel1285(const emxArray_real32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_real32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1286(const emxArray_real32_T smooth, const
  int32_T iv9_dim0, const emxArray_int32_T iv11, const emxArray_int32_T iv9,
  const int32_T b_iv9, const int32_T c_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel1287(const real_T a, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T halfh,
  const int32_T b, const int32_T c, emxArray_real32_T cfs1, int32_T
  expanded_dim0, int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel1288(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1289(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel129(const emxArray_real_T a, const int32_T
  ix, const int32_T lidx, const int32_T bcoef, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1290(const int32_T cfs1, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel1291(const emxArray_real32_T cfs1, const
  int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0,
  int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel1292(const emxArray_real32_T cfs1, const
  int32_T b_cfs1, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1293(const int32_T ix, const int32_T lidx,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1294(const int32_T ix, const int32_T cfsDFT,
  const int32_T lidx, emxArray_creal32_T b_cfsDFT, int32_T cfsDFT_dim0);
static __global__ void ec_wtcc_kernel1295(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1296(creal32_T *cfsposdft, int32_T
  cfsposdft_dim1);
static __global__ void ec_wtcc_kernel1297(const creal32_T *cfsposdft, const
  emxArray_creal32_T b_cfsposdft, const int32_T c_cfsposdft, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel1298(const int32_T b, emxArray_creal32_T
  xposdft, uint32_T xSize_dim1);
static __global__ void ec_wtcc_kernel1299(creal32_T *cfsposdft, int32_T
  cfsposdft_dim1);
static __global__ void ec_wtcc_kernel13(emxArray_real_T y);
static __global__ void ec_wtcc_kernel130(const int32_T b, emxArray_real_T dv27);
static __global__ void ec_wtcc_kernel1300(const creal32_T *cfsposdft, const
  emxArray_creal32_T b_cfsposdft, const int32_T c_cfsposdft, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel1301(const int32_T b, emxArray_creal32_T
  xposdft, uint32_T xSize_dim1);
static __global__ void ec_wtcc_kernel1302(const emxArray_real_T somega, const
  int32_T b_somega, emxArray_real_T w);
static __global__ void ec_wtcc_kernel1303(const emxArray_real_T w, const int32_T
  b_w, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel1304(const int32_T b, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel1305(const emxArray_real_T w, const int32_T
  b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1306(const emxArray_real_T y, const
  emxArray_real_T expnt, const int32_T b_expnt, emxArray_real_T daughter);
static __global__ void ec_wtcc_kernel1307(const int32_T lidx, emxArray_real_T
  daughter);
static __global__ void ec_wtcc_kernel1308(const emxArray_real_T fb_Omega, const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T somega, int32_T somega_dim0);
static __global__ void ec_wtcc_kernel1309(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel131(const emxArray_real_T dv27, const
  emxArray_real_T h, const int32_T b_h, emxArray_real_T h1);
static __global__ void ec_wtcc_kernel1310(const char_T cv[128], char_T wav[4],
  char_T wname[4], char_T a_dim0, char_T a_dim1, char_T a_dim2, char_T a_dim3);
static __global__ void ec_wtcc_kernel1311(real_T interval[650]);
static __global__ void ec_wtcc_kernel1312(real_T interval[650]);
static __global__ void ec_wtcc_kernel1313(const int32_T offsetH, real_T
  interval[650]);
static __global__ void ec_wtcc_kernel1314(real_T interval[650]);
static __global__ void ec_wtcc_kernel1315(real_T interval[650]);
static __global__ void ec_wtcc_kernel1316(const int32_T offsetH, real_T
  interval[650]);
static __global__ void ec_wtcc_kernel1317(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1318(const emxArray_real_T y, const real_T
  fa, const int32_T b, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel1319(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_wtcc_kernel132(const real_T halfh, const
  emxArray_real_T h1, const real_T toler, const int32_T b_h1, emxArray_real32_T
  opts_filter);
static __global__ void ec_wtcc_kernel1320(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1321(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1322(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1323(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1324(const real_T x_data[9735], const
  int32_T b, real_T dv15_data[9735]);
static __global__ void ec_wtcc_kernel1325(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1326(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1327(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv15_data[9735], const int32_T dv15_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1328(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1329(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel133(const int32_T halfh, emxArray_real32_T
  h);
static __global__ void ec_wtcc_kernel1330(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1331(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1332(const real_T x_data[9735], const
  int32_T b, real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1333(const real_T x_data[9735], const
  real_T y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_wtcc_kernel1334(const real_T a_data[9735], const
  int32_T b, real_T dv9_data[9735]);
static __global__ void ec_wtcc_kernel1335(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1336(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1337(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv9_data[9735], const int32_T dv9_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1338(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1339(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel134(const emxArray_uint32_T y, const real_T
  halfh, const int32_T b_y, emxArray_int32_T iv93);
static __global__ void ec_wtcc_kernel1340(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1341(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1342(const real_T x_data[9735], const
  int32_T b, real_T dv8_data[9735]);
static __global__ void ec_wtcc_kernel1343(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1344(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1345(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv8_data[9735], const int32_T dv8_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1346(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1347(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1348(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1349(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel135(const emxArray_real32_T opts_filter,
  const emxArray_int32_T iv93, const int32_T b_iv93, emxArray_real32_T h);
static __global__ void ec_wtcc_kernel1350(const real_T x_data[9735], const
  int32_T b, real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1351(const real_T x_data[9735], const
  real_T y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_wtcc_kernel1352(const real_T a_data[9735], const
  int32_T b, real_T dv2_data[9735]);
static __global__ void ec_wtcc_kernel1353(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1354(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1355(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv2_data[9735], const int32_T dv2_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel136(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel137(const emxArray_creal32_T b_y1, const
  int32_T b, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel138(const emxArray_creal32_T opts_x, const
  int32_T b, emxArray_real32_T fv);
static __global__ void ec_wtcc_kernel139(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel14(const emxArray_real_T y, const real_T s,
  const int32_T b, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel140(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel141(const real_T toler, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel142(const emxArray_real32_T h, const
  emxArray_creal32_T yCol, real32_T *cv_re, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel143(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel144(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel145(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel146(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel147(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel148(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel149(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel15(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_wtcc_kernel150(const emxArray_creal32_T y, const
  int32_T iv9, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel151(emxArray_real_T y);
static __global__ void ec_wtcc_kernel152(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel153(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel154(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel155(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel156(const emxArray_real32_T h, real32_T
  *f13);
static __global__ void ec_wtcc_kernel157(const real32_T *f13, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel158(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel159(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel16(const emxArray_real_T somega, const
  int32_T b_somega, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel160(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv162);
static __global__ void ec_wtcc_kernel161(const emxArray_real32_T h, const
  emxArray_int32_T iv162, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel162(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel163(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel164(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel165(const emxArray_real32_T h, real32_T
  *f12);
static __global__ void ec_wtcc_kernel166(const real32_T *f12, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel167(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel168(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel169(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel17(const int32_T b, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel170(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv164);
static __global__ void ec_wtcc_kernel171(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv164, const int32_T iv9, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel172(const emxArray_creal32_T expanded,
  const int32_T nsubs, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel173(const real32_T cv_im, const real32_T
  cv_re, const int32_T nsubs, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel174(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel175(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel176(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel177(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel178(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel179(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel18(const emxArray_real_T somega, const
  emxArray_real_T expnt, const int32_T b_expnt, emxArray_real_T daughter);
static __global__ void ec_wtcc_kernel180(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel181(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel182(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel183(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel184(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel185(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f28, real32_T *f29);
static __global__ void ec_wtcc_kernel186(const real32_T *f29, const real32_T
  *f28, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel187(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel188(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel189(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv142);
static __global__ void ec_wtcc_kernel19(const emxArray_real_T daughter, const
  int32_T b_daughter, emxArray_real32_T psihat);
static __global__ void ec_wtcc_kernel190(const emxArray_creal32_T a, const
  emxArray_int32_T iv142, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel191(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel192(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel193(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel194(const emxArray_real32_T h, real32_T
  *f19);
static __global__ void ec_wtcc_kernel195(const real32_T *f19, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel196(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel197(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel198(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv144);
static __global__ void ec_wtcc_kernel199(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv144, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel2(const int32_T ix, const int32_T lidx,
  const emxArray_real32_T x, const int32_T b_x, emxArray_real32_T y,
  emxArray_real32_T c_x, int32_T x_dim0);
static __global__ void ec_wtcc_kernel20(const emxArray_real32_T x, const int32_T
  b_x, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel200(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel201(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel202(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel203(const emxArray_real32_T h, real32_T
  *f18);
static __global__ void ec_wtcc_kernel204(const real32_T *f18, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel205(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel206(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel207(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel208(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv149);
static __global__ void ec_wtcc_kernel209(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv167);
static __global__ void ec_wtcc_kernel21(const emxArray_real32_T x, const int32_T
  b, emxArray_real32_T b_x);
static __global__ void ec_wtcc_kernel210(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv167, const emxArray_int32_T iv149,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel211(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel212(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel22(const int32_T fb_SignalPad, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel23(const emxArray_real32_T x, const int32_T
  b, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel24(const emxArray_real32_T xv, const
  int32_T b_xv, emxArray_creal32_T xposdft);
static __global__ void ec_wtcc_kernel243(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel244(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel245(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel246(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel247(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel248(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel249(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel25(const emxArray_creal32_T xposdft, const
  emxArray_real32_T psihat, const int32_T bcoef, const int32_T cfsposdft, const
  int32_T lidx, emxArray_creal32_T b_cfsposdft, int32_T psihat_dim0, int32_T
  cfsposdft_dim0);
static __global__ void ec_wtcc_kernel250(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel251(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel252(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel253(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel254(emxArray_real_T y);
static __global__ void ec_wtcc_kernel255(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel256(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel257(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel258(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel259(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f32, real32_T *f33);
static __global__ void ec_wtcc_kernel26(const int32_T xSize, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel260(const real32_T *f33, const real32_T
  *f32, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel261(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel262(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel263(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv148);
static __global__ void ec_wtcc_kernel264(const emxArray_creal32_T a, const
  emxArray_int32_T iv148, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel265(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel266(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel267(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel268(const emxArray_real32_T h, real32_T
  *f23);
static __global__ void ec_wtcc_kernel269(const real32_T *f23, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel27(const emxArray_real_T daughter, const
  int32_T b_daughter, emxArray_real32_T psihat);
static __global__ void ec_wtcc_kernel270(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel271(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel272(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv152);
static __global__ void ec_wtcc_kernel273(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv152, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel274(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel275(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel276(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel277(const emxArray_real32_T h, real32_T
  *f22);
static __global__ void ec_wtcc_kernel278(const real32_T *f22, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel279(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel28(const emxArray_real32_T y, const int32_T
  b_y, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel280(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel281(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel282(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv155);
static __global__ void ec_wtcc_kernel283(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv172);
static __global__ void ec_wtcc_kernel284(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv172, const emxArray_int32_T iv155,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel285(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel286(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel29(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel3(const char_T cv[128], char_T wname[4],
  char_T wav[4], char_T a_dim0, char_T a_dim1, char_T a_dim2, char_T a_dim3);
static __global__ void ec_wtcc_kernel30(const int32_T fb_SignalPad, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel31(const emxArray_real32_T x, const int32_T
  b, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel317(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel318(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel319(const real_T toler, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel32(const emxArray_real32_T xv, const
  int32_T b_xv, emxArray_creal32_T xposdft);
static __global__ void ec_wtcc_kernel320(const emxArray_real32_T h, const
  emxArray_creal32_T yCol, real32_T *cv_re, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel321(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel322(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel323(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel324(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel325(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel326(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel327(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel328(const emxArray_creal32_T y, const
  int32_T iv9, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel329(emxArray_real_T y);
static __global__ void ec_wtcc_kernel33(const emxArray_creal32_T xposdft, const
  emxArray_real32_T psihat, const int32_T bcoef, const int32_T cfsposdft, const
  int32_T lidx, emxArray_creal32_T b_cfsposdft, int32_T psihat_dim0, int32_T
  cfsposdft_dim0);
static __global__ void ec_wtcc_kernel330(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T
  opts_x);
static __global__ void ec_wtcc_kernel331(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel332(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel333(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel334(const emxArray_real32_T h, real32_T
  *f11);
static __global__ void ec_wtcc_kernel335(const real32_T *f11, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel336(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel337(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel338(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv161);
static __global__ void ec_wtcc_kernel339(const emxArray_real32_T h, const
  emxArray_int32_T iv161, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel34(const int32_T xSize, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel340(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel341(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel342(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel343(const emxArray_real32_T h, real32_T
  *f10);
static __global__ void ec_wtcc_kernel344(const real32_T *f10, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel345(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel346(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel347(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel348(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv163);
static __global__ void ec_wtcc_kernel349(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv163, const int32_T iv9, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel35(const emxArray_creal32_T cfspos, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel350(const emxArray_creal32_T expanded,
  const int32_T nsubs, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel351(const real32_T cv_im, const real32_T
  cv_re, const int32_T nsubs, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel352(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel353(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel354(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel355(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel356(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel357(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel358(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel359(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel36(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel360(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel361(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel362(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel363(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f26, real32_T *f27);
static __global__ void ec_wtcc_kernel364(const real32_T *f27, const real32_T
  *f26, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel365(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel366(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel367(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv141);
static __global__ void ec_wtcc_kernel368(const emxArray_creal32_T a, const
  emxArray_int32_T iv141, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel369(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel37(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel370(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel371(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel372(const emxArray_real32_T h, real32_T
  *f17);
static __global__ void ec_wtcc_kernel373(const real32_T *f17, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel374(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel375(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel376(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv143);
static __global__ void ec_wtcc_kernel377(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv143, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel378(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel379(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel38(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel380(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel381(const emxArray_real32_T h, real32_T
  *f16);
static __global__ void ec_wtcc_kernel382(const real32_T *f16, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel383(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel384(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel385(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel386(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv147);
static __global__ void ec_wtcc_kernel387(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv166);
static __global__ void ec_wtcc_kernel388(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv166, const emxArray_int32_T iv147,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel389(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel39(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel390(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel4(real_T interval[650]);
static __global__ void ec_wtcc_kernel40(const int32_T cfs1, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel41(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel42(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel421(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel422(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel423(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel424(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel425(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel426(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel427(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel428(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel429(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel43(const int32_T xSize, emxArray_creal32_T
  y);
static __global__ void ec_wtcc_kernel430(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel431(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel432(emxArray_real_T y);
static __global__ void ec_wtcc_kernel433(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel434(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel435(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel436(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel437(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f30, real32_T *f31);
static __global__ void ec_wtcc_kernel438(const real32_T *f31, const real32_T
  *f30, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel439(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel44(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_real32_T smooth);
static __global__ void ec_wtcc_kernel440(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel441(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv146);
static __global__ void ec_wtcc_kernel442(const emxArray_creal32_T a, const
  emxArray_int32_T iv146, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel443(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel444(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel445(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel446(const emxArray_real32_T h, real32_T
  *f21);
static __global__ void ec_wtcc_kernel447(const real32_T *f21, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel448(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel449(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel45(const emxArray_real32_T smooth, const
  int32_T b, emxArray_real32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel450(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv151);
static __global__ void ec_wtcc_kernel451(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv151, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel452(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel453(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel454(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel455(const emxArray_real32_T h, real32_T
  *f20);
static __global__ void ec_wtcc_kernel456(const real32_T *f20, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel457(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel458(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel459(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel46(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel460(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv154);
static __global__ void ec_wtcc_kernel461(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv171);
static __global__ void ec_wtcc_kernel462(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv171, const emxArray_int32_T iv154,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel463(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel464(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel47(const real_T a, const emxArray_real32_T
  b_a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel48(const emxArray_real32_T c, const int32_T
  b_c, emxArray_real32_T cfs1, int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel49(const emxArray_creal32_T cfspos, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel495(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel496(const emxArray_creal32_T opts_x, const
  int32_T fb_SignalPad, const int32_T i269, const int32_T omega_tmp2,
  emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel497(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel498(const emxArray_creal32_T w, const
  int32_T lidx, const int32_T b, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel499(emxArray_real_T y);
static __global__ void ec_wtcc_kernel5(real_T interval[650]);
static __global__ void ec_wtcc_kernel50(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel500(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T fb_SignalPad, const int32_T
  b, emxArray_creal32_T b_y1, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel501(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel502(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel503(const emxArray_creal32_T yCol,
  creal32_T *cfsposdft);
static __global__ void ec_wtcc_kernel504(const creal32_T *cfsposdft, const
  emxArray_real32_T h, real32_T *f8, real32_T *f9);
static __global__ void ec_wtcc_kernel505(const real32_T *f9, const real32_T *f8,
  emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel506(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel507(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv140);
static __global__ void ec_wtcc_kernel508(const emxArray_real32_T h, const
  emxArray_int32_T iv140, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel509(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const real_T toler,
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel51(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel510(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel511(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel512(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel513(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv139);
static __global__ void ec_wtcc_kernel514(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv139, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel515(const emxArray_creal32_T expanded,
  const int32_T nsubs, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel516(const real32_T cv_im, const real32_T
  cv_re, const int32_T nsubs, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel517(const emxArray_creal32_T b_y1, const
  int32_T crossCFS, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel518(const emxArray_creal32_T b_y1, const
  int32_T c_y1, const int32_T d_y1, emxArray_creal32_T opts_x, int32_T
  opts_x_dim0, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel519(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel52(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel520(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel521(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel522(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel523(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel524(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel525(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel526(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel527(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel528(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel529(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel53(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel530(const emxArray_creal32_T y, const
  int32_T iv9, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel531(emxArray_real_T y);
static __global__ void ec_wtcc_kernel532(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel533(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel534(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel535(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel536(const emxArray_real32_T h, real32_T *f7);
static __global__ void ec_wtcc_kernel537(const real32_T *f7, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel538(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel539(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel54(const int32_T cfs2, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel540(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv168);
static __global__ void ec_wtcc_kernel541(const emxArray_real32_T h, const
  emxArray_int32_T iv168, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel542(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const real_T toler,
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel543(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel544(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel545(const emxArray_real32_T h, real32_T *f6);
static __global__ void ec_wtcc_kernel546(const real32_T *f6, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel547(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel548(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel549(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel55(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel550(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv170);
static __global__ void ec_wtcc_kernel551(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv170, const int32_T iv9, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel552(const emxArray_creal32_T expanded,
  const int32_T nsubs, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel553(const real32_T cv_im, const real32_T
  cv_re, const int32_T nsubs, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel554(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel555(const emxArray_creal32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel556(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel557(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel558(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel559(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel56(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel560(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel561(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel562(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel563(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel564(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel565(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f24, real32_T *f25);
static __global__ void ec_wtcc_kernel566(const real32_T *f25, const real32_T
  *f24, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel567(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel568(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel569(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv145);
static __global__ void ec_wtcc_kernel57(const int32_T xSize, emxArray_creal32_T
  y);
static __global__ void ec_wtcc_kernel570(const emxArray_creal32_T a, const
  emxArray_int32_T iv145, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel571(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel572(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel573(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel574(const emxArray_real32_T h, real32_T
  *f15);
static __global__ void ec_wtcc_kernel575(const real32_T *f15, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel576(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel577(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel578(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv150);
static __global__ void ec_wtcc_kernel579(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv150, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel58(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_real32_T smooth);
static __global__ void ec_wtcc_kernel580(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel581(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel582(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel583(const emxArray_real32_T h, real32_T
  *f14);
static __global__ void ec_wtcc_kernel584(const real32_T *f14, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel585(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel586(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel587(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel588(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv153);
static __global__ void ec_wtcc_kernel589(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv169);
static __global__ void ec_wtcc_kernel59(const emxArray_real32_T smooth, const
  int32_T b, emxArray_real32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel590(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv169, const emxArray_int32_T iv153,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel591(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel592(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel6(const int32_T offsetH, real_T interval
  [650]);
static __global__ void ec_wtcc_kernel60(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel61(const real_T a, const emxArray_real32_T
  b_a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel62(const emxArray_real32_T c, const int32_T
  b_c, emxArray_real32_T cfs2, int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel623(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T xCol);
static __global__ void ec_wtcc_kernel624(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel625(const emxArray_creal32_T xCol, const
  int32_T ix, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel626(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel627(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel628(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel629(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel63(const emxArray_creal32_T cfspos, const
  emxArray_creal32_T b_cfspos, const int32_T c_cfspos, emxArray_creal32_T
  crossCFS);
static __global__ void ec_wtcc_kernel630(const emxArray_creal32_T w, const
  int32_T iv9, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel631(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel632(const emxArray_creal32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel633(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel634(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel635(emxArray_real_T y);
static __global__ void ec_wtcc_kernel636(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel637(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel638(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel639(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel64(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel640(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f36, real32_T *f37);
static __global__ void ec_wtcc_kernel641(const real32_T *f37, const real32_T
  *f36, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel642(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel643(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel644(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv156);
static __global__ void ec_wtcc_kernel645(const emxArray_creal32_T a, const
  emxArray_int32_T iv156, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel646(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel647(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel648(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel649(const emxArray_real32_T h, real32_T
  *f35);
static __global__ void ec_wtcc_kernel65(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel650(const real32_T *f35, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel651(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel652(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel653(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv159);
static __global__ void ec_wtcc_kernel654(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv159, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel655(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T origSiz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel656(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel657(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel658(const emxArray_real32_T h, real32_T
  *f34);
static __global__ void ec_wtcc_kernel659(const real32_T *f34, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel66(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel660(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel661(const emxArray_creal32_T yCol, const
  int32_T iv9, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel662(const int32_T OH, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel663(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv160);
static __global__ void ec_wtcc_kernel664(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv177);
static __global__ void ec_wtcc_kernel665(const emxArray_creal32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv177, const emxArray_int32_T iv160,
  const int32_T iv9, const int32_T b_iv9, emxArray_creal32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel666(const int32_T bcoef, const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel667(const real32_T cv_im, const real32_T
  cv_re, const int32_T bcoef, const int32_T nsubs, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel67(const int32_T crossCFS,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel68(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel69(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel698(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T xCol);
static __global__ void ec_wtcc_kernel699(const int32_T b, emxArray_uint32_T y);
static __global__ void ec_wtcc_kernel7(real_T interval[650]);
static __global__ void ec_wtcc_kernel70(const int32_T xSize, emxArray_creal32_T
  smooth);
static __global__ void ec_wtcc_kernel700(const creal_T *dc6, const real_T
  table100[100], const creal_T dc7, const creal_T *dc, const int32_T bcoef,
  const int32_T ix, const int32_T lidx, const int32_T i, const int64_T b,
  emxArray_real_T dv27, real_T q1_dim0, real_T q1_dim1, real_T q1_dim2, real_T
  q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6, real_T q1_dim7,
  real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3, real_T p1_dim4,
  real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0, real_T q2_dim1,
  real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5, real_T q2_dim6,
  real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2, real_T p2_dim3,
  real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7, real_T q4_dim0,
  real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4, real_T q4_dim5,
  real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1, real_T p4_dim2,
  real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6, real_T p4_dim7,
  real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3, real_T c_dim4,
  real_T c_dim5, real_T c_dim6);
static __global__ void ec_wtcc_kernel701(const emxArray_real_T a, const int32_T
  b_a, emxArray_real_T x);
static __global__ void ec_wtcc_kernel702(const emxArray_real_T x, const int32_T
  b, emxArray_real_T h);
static __global__ void ec_wtcc_kernel703(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel704(const int32_T omega_tmp2,
  emxArray_real_T a);
static __global__ void ec_wtcc_kernel705(const int32_T G, emxArray_int32_T jpvt);
static __global__ void ec_wtcc_kernel706(const int32_T b, const int32_T nsubs,
  emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel707(const int32_T b, emxArray_real_T tau);
static __global__ void ec_wtcc_kernel708(const int32_T i, const int64_T b,
  emxArray_real_T tau);
static __global__ void ec_wtcc_kernel709(const int32_T nsubs, emxArray_int32_T
  jpvt);
static __global__ void ec_wtcc_kernel71(const emxArray_creal32_T smooth, const
  int32_T b, emxArray_creal32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel710(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel711(const int32_T omega_tmp2,
  emxArray_real_T b);
static __global__ void ec_wtcc_kernel712(const emxArray_real_T b, const
  emxArray_int32_T jpvt, const int32_T nsubs, emxArray_real_T a);
static __global__ void ec_wtcc_kernel713(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel714(emxArray_real_T a);
static __global__ void ec_wtcc_kernel715(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel716(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel717(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, const int32_T c_crossCFS, emxArray_creal32_T opts_x,
  int32_T opts_x_dim0, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel718(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel719(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel72(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel720(const real_T toler, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel721(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel722(const emxArray_real32_T h, const
  emxArray_real32_T yCol, real32_T *cv_re, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel723(const real32_T *cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel724(const emxArray_real32_T c,
  emxArray_real32_T w);
static __global__ void ec_wtcc_kernel725(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel726(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel727(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel728(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel729(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel73(const emxArray_creal32_T a, const real_T
  b_a, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel730(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel731(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel732(const emxArray_real32_T y, const
  int32_T iv9, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel733(emxArray_real_T y);
static __global__ void ec_wtcc_kernel734(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel735(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel736(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel737(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel738(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel739(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel74(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel740(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv65);
static __global__ void ec_wtcc_kernel741(const emxArray_real32_T h, const
  emxArray_int32_T iv65, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel742(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const int32_T
  origSiz[2], const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel743(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel744(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel745(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel746(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel747(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv67);
static __global__ void ec_wtcc_kernel748(const emxArray_real32_T yCol, const
  emxArray_int32_T iv67, const int32_T iv9, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel749(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel75(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T crossCFS, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel750(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel751(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel752(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel753(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel754(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel755(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel756(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel757(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel758(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel759(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel76(const emxArray_creal32_T crossCFS, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel760(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel761(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel762(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel763(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel764(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel765(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv45);
static __global__ void ec_wtcc_kernel766(const emxArray_real32_T a, const
  emxArray_int32_T iv45, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel767(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel768(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel769(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel77(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel770(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel771(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel772(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv47);
static __global__ void ec_wtcc_kernel773(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv47, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel774(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel775(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel776(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel777(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel778(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel779(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv52);
static __global__ void ec_wtcc_kernel78(const emxArray_real32_T cfs2, const
  emxArray_real32_T cfs1, const emxArray_real32_T y, const int32_T b_y,
  emxArray_real32_T wtc);
static __global__ void ec_wtcc_kernel780(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv70);
static __global__ void ec_wtcc_kernel781(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv70, const emxArray_int32_T iv52,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel782(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel79(const int32_T lidx, emxArray_real32_T
  wtc);
static __global__ void ec_wtcc_kernel8(real_T interval[650]);
static __global__ void ec_wtcc_kernel80(const emxArray_real32_T wtc, const
  int32_T b, emxArray_real32_T opts_x);
static __global__ void ec_wtcc_kernel81(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel811(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel812(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel813(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel814(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel815(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel816(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel817(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel818(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel819(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel82(const emxArray_real_T m, const int32_T
  b_m, emxArray_real_T k);
static __global__ void ec_wtcc_kernel820(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel821(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel822(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel823(emxArray_real_T y);
static __global__ void ec_wtcc_kernel824(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel825(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel826(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel827(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel828(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel829(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel83(const int32_T k, emxArray_real_T G);
static __global__ void ec_wtcc_kernel830(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel831(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv51);
static __global__ void ec_wtcc_kernel832(const emxArray_real32_T a, const
  emxArray_int32_T iv51, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel833(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel834(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel835(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel836(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel837(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel838(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv55);
static __global__ void ec_wtcc_kernel839(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv55, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel84(const int32_T k, emxArray_real_T b);
static __global__ void ec_wtcc_kernel840(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel841(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel842(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel843(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel844(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel845(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv58);
static __global__ void ec_wtcc_kernel846(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv75);
static __global__ void ec_wtcc_kernel847(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv75, const emxArray_int32_T iv58,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel848(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel85(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T dv25);
static __global__ void ec_wtcc_kernel86(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T dv26, emxArray_real_T dv25);
static __global__ void ec_wtcc_kernel87(const int32_T b, emxArray_real_T dv26);
static __global__ void ec_wtcc_kernel877(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel878(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel879(const real_T toler, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel88(const emxArray_real_T k, const
  emxArray_real_T dv26, const emxArray_real_T dv25, const real_T a, const
  int32_T b, emxArray_real_T b_b);
static __global__ void ec_wtcc_kernel880(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel881(const emxArray_real32_T h, const
  emxArray_real32_T yCol, real32_T *cv_re, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel882(const real32_T *cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel883(const emxArray_real32_T c,
  emxArray_real32_T w);
static __global__ void ec_wtcc_kernel884(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel885(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel886(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel887(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel888(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel889(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel89(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T y);
static __global__ void ec_wtcc_kernel890(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel891(const emxArray_real32_T y, const
  int32_T iv9, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel892(emxArray_real_T y);
static __global__ void ec_wtcc_kernel893(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_real32_T opts_x);
static __global__ void ec_wtcc_kernel894(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel895(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel896(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel897(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel898(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel899(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv64);
static __global__ void ec_wtcc_kernel9(const int32_T offsetH, real_T interval
  [650]);
static __global__ void ec_wtcc_kernel90(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T y, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel900(const emxArray_real32_T h, const
  emxArray_int32_T iv64, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel901(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const int32_T
  origSiz[2], const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel902(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel903(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel904(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel905(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel906(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv66);
static __global__ void ec_wtcc_kernel907(const emxArray_real32_T yCol, const
  emxArray_int32_T iv66, const int32_T iv9, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel908(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel909(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel91(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel910(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel911(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel912(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel913(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel914(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel915(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel916(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel917(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel918(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel919(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel92(const emxArray_real_T y, const real_T a,
  const emxArray_real_T b_y, const real_T b_a, const int32_T b, emxArray_real_T
  b_b);
static __global__ void ec_wtcc_kernel920(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel921(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel922(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel923(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel924(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv44);
static __global__ void ec_wtcc_kernel925(const emxArray_real32_T a, const
  emxArray_int32_T iv44, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel926(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel927(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel928(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel929(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel93(const real_T fa, const real_T r, const
  int32_T bcoef, const int32_T i1Start, const int32_T b, emxArray_real_T sinc4A,
  emxArray_real_T sinc3A, emxArray_real_T sinc2A, emxArray_real_T sinc1A);
static __global__ void ec_wtcc_kernel930(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel931(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv46);
static __global__ void ec_wtcc_kernel932(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv46, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel933(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel934(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel935(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel936(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel937(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel938(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv50);
static __global__ void ec_wtcc_kernel939(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv69);
static __global__ void ec_wtcc_kernel94(const emxArray_real_T sinc4A, const
  emxArray_real_T sinc2A, const real_T fa, const emxArray_real_T sinc3A, const
  emxArray_real_T sinc1A, const real_T r, const int32_T bcoef, const int32_T b,
  const int32_T c, emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel940(const emxArray_real32_T yCol, const
  int32_T iv9_dim0, const emxArray_int32_T iv69, const emxArray_int32_T iv50,
  const int32_T iv9, const int32_T b_iv9, emxArray_real32_T expanded, int32_T
  expanded_dim0);
static __global__ void ec_wtcc_kernel941(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel95(const real_T T, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel96(const emxArray_real_T b, const int32_T c,
  emxArray_real_T b0);
static __global__ void ec_wtcc_kernel97(const emxArray_real_T b0, const int32_T
  b_b0, emxArray_real_T b);
static __global__ void ec_wtcc_kernel970(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel971(const emxArray_real32_T opts_x, const
  int32_T ix, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel972(const emxArray_real32_T yCol, const
  int32_T origSiz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel973(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel974(const int32_T bcoef, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_wtcc_kernel975(const int32_T ix, const int32_T bcoef,
  const int32_T nsubs, int32_T origSiz[2]);
static __global__ void ec_wtcc_kernel976(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel977(const emxArray_real32_T w, const
  int32_T iv9, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel978(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T ix, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel979(const emxArray_real32_T w, const
  int32_T iv9_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel98(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel980(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel981(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel982(emxArray_real_T y);
static __global__ void ec_wtcc_kernel983(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_real32_T opts_x, int32_T opts_x_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel984(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel985(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel986(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel987(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel988(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel989(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel99(const emxArray_real_T a, const int32_T
  ix, const int32_T lidx, const int32_T offsetH, emxArray_real_T h);
static __global__ void ec_wtcc_kernel990(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv49);
static __global__ void ec_wtcc_kernel991(const emxArray_real32_T a, const
  emxArray_int32_T iv49, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel992(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel993(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel994(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel995(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel996(const int32_T OH, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel997(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv54);
static __global__ void ec_wtcc_kernel998(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv54, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel999(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static void ec_wtcc_once();
static void emlrtExitTimeCleanupDtorFcn(const void *r);
static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real32_T *y);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real32_T *y);
static uint16_T *emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier, int32_T y_size[2]);
static uint16_T *emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, int32_T y_size[2]);
static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier);
static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId);
static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23]);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23]);
static const mxArray *emlrt_marshallOut(const cell_wrap_0 u_data[], const
  int32_T u_size[2]);
static void emxEnsureCapacity_cell_wrap_0(cell_wrap_0 data[65534], const int32_T
  size[2], int32_T oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_creal32_T(emxArray_creal32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxExpand_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex, const emlrtRTEInfo *srcLocation);
static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct);
static void emxFree_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray);
static void emxFree_char_T(emxArray_char_T **pEmxArray);
static void emxFree_creal32_T(emxArray_creal32_T **pEmxArray);
static void emxFree_int32_T(emxArray_int32_T **pEmxArray);
static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray);
static void emxFree_real32_T(emxArray_real32_T **pEmxArray);
static void emxFree_real_T(emxArray_real_T **pEmxArray);
static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray);
static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush);
static void emxInit_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray);
static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_creal32_T(emxArray_creal32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_real32_T(emxArray_real32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxTrim_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex);
static real32_T (*f_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2];
static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
  *location);
static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
  m3, emlrtMCInfo *location);
static void gpuEmxEnsureCapacity_creal32_T(const emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_real32_T(const emxArray_real32_T *cpu,
  emxArray_real32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy);
static void gpuEmxFree_creal32_T(emxArray_creal32_T *gpu);
static void gpuEmxFree_int32_T(emxArray_int32_T *gpu);
static void gpuEmxFree_real32_T(emxArray_real32_T *gpu);
static void gpuEmxFree_real_T(emxArray_real_T *gpu);
static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu);
static void gpuEmxMemcpyCpuToGpu_creal32_T(emxArray_creal32_T *gpu, const
  emxArray_creal32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_real32_T(emxArray_real32_T *gpu, const
  emxArray_real32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu);
static void gpuEmxMemcpyGpuToCpu_creal32_T(emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu);
static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu);
static void gpuEmxMemcpyGpuToCpu_real32_T(emxArray_real32_T *cpu,
  emxArray_real32_T *gpu);
static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu);
static void gpuEmxReset_creal32_T(emxArray_creal32_T *gpu);
static void gpuEmxReset_int32_T(emxArray_int32_T *gpu);
static void gpuEmxReset_real32_T(emxArray_real32_T *gpu);
static void gpuEmxReset_real_T(emxArray_real_T *gpu);
static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu);
static const mxArray *length(const mxArray *m1, emlrtMCInfo *location);
static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString);
static real_T rt_powd_snf(real_T u0, real_T u1);
static real_T rt_remd_snf(real_T u0, real_T u1);

// Function Definitions
static int64_T b_computeEndIdx(int64_T start, int64_T end, int64_T stride)
{
  int64_T newEnd;
  newEnd = -1L;
  if ((stride > 0L) && (start <= end)) {
    newEnd = (end - start) / stride;
  } else if ((stride < 0L) && (end <= start)) {
    newEnd = (start - end) / -stride;
  }

  return newEnd;
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23])
{
  static const int32_T dims[2]{ 1, 23 };

  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0]);
  emlrtImportCharArrayR2015b(emlrtRootTLSGlobal, src, &ret[0], 23);
  emlrtDestroyArray(&src);
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret)
{
  static const int32_T dims[2]{ 1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ false, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0], &bv[0], &iv[0]);
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_char_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  emlrtImportArrayR2015b(emlrtRootTLSGlobal, src, &ret->data[0], 1, false);
  emlrtDestroyArray(&src);
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real32_T *ret)
{
  static const int32_T dims[2]{ -1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ true, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret->allocatedSize = iv[0] * iv[1];
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_real32_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  ret->data = static_cast<real32_T *>(emlrtMxGetData(src));
  ret->canFreeData = false;
  emlrtDestroyArray(&src);
}

static real32_T b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId)
{
  real32_T y;
  y = e_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static real32_T b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier)
{
  emlrtMsgIdentifier thisId;
  real32_T y;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = b_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}

static uint16_T *b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, int32_T ret_size[2])
{
  static const int32_T dims[2]{ 65534, 2 };

  int32_T iv[2];
  uint16_T *ret_data;
  boolean_T bv[2]{ true, false };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "uint16", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret_size[0] = iv[0];
  ret_size[1] = iv[1];
  ret_data = static_cast<uint16_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret_data;
}

static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = m;
  pArrays[1] = m1;
  emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 0, nullptr, 2, &pArrays[0], "feval",
                        true, location);
}

static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  fn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "sprintf", true, location);
}

static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &ef_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in3->size[0] == 1) {
    b_in1->size[0] = in1->size[0];
  } else {
    b_in1->size[0] = in3->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &ef_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  if (in3->size[0] == 1) {
    b = in1->size[0];
  } else {
    b = in3->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + (in2 * in3->data[i * stride_1_0]
      - in4 * in5->data[i * stride_1_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &ff_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  int32_T stride_2_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &gf_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b_in1->size[0] = in1->size[0];
  } else if (in5->size[0] == 1) {
    b_in1->size[0] = in3->size[0];
  } else {
    b_in1->size[0] = in5->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &gf_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_2_0 = (in5->size[0] != 1);
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b = in1->size[0];
  } else if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + in2 * (in3->data[i * stride_1_0]
      - in4->data[i * stride_1_0]) / (in5->data[i * stride_2_0] * in5->data[i *
      stride_2_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &hf_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_10(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2])
{
  int32_T stride_0_1;
  int32_T stride_1_1;
  in1_size[0] = 1;
  in1_size[1] = in4_size[1];
  stride_0_1 = (in2_size[1] != 1);
  stride_1_1 = (in3_size[1] != 1);
  for (int32_T i{0}; i < in4_size[1]; i++) {
    in1_data[i] = in2_data[i * stride_0_1] * in3_data[i * stride_1_1] *
      in4_data[i];
  }
}

static void binary_expand_op_4(emxArray_real32_T *in1, const emxArray_real32_T
  *in2, const emxArray_real32_T *in3, const emxArray_real32_T *in4)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T aux_2_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  int32_T stride_2_0;
  int32_T stride_2_1;
  i = in1->size[0] * in1->size[1];
  if (in4->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in4->size[0];
  }

  if (b == 1) {
    in1->size[0] = in2->size[0];
  } else if (in4->size[0] == 1) {
    in1->size[0] = in3->size[0];
  } else {
    in1->size[0] = in4->size[0];
  }

  if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  if (b == 1) {
    in1->size[1] = in2->size[1];
  } else if (in4->size[1] == 1) {
    in1->size[1] = in3->size[1];
  } else {
    in1->size[1] = in4->size[1];
  }

  emxEnsureCapacity_real32_T(in1, i, &vb_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  stride_2_0 = (in4->size[0] != 1);
  stride_2_1 = (in4->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  aux_2_1 = 0;
  if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  if (b == 1) {
    b = in2->size[1];
  } else if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in4->size[0] == 1) {
      c = in3->size[0];
    } else {
      c = in4->size[0];
    }

    if (c == 1) {
      c = in2->size[0];
    } else if (in4->size[0] == 1) {
      c = in3->size[0];
    } else {
      c = in4->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = in2->data[i1 * stride_0_0 + in2->size[0]
        * aux_0_1] / (in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1] *
                      in4->data[i1 * stride_2_0 + in4->size[0] * aux_2_1]);
    }

    aux_2_1 += stride_2_1;
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_5(emxArray_creal32_T *in1, const emxArray_real_T
  *in2, const emxArray_creal32_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_creal32_T(in1, i, &sb_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i].re = static_cast<real32_T>(in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1]) * in3->data[i1 * stride_1_0 +
        in3->size[0] * aux_1_1].re;
      in1->data[i1 + in1->size[0] * i].im = static_cast<real32_T>(in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1]) * in3->data[i1 * stride_1_0 +
        in3->size[0] * aux_1_1].im;
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_6(emxArray_creal32_T *in1, const emxArray_creal32_T
  *in2, const emxArray_creal32_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_creal32_T(in1, i, &rb_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      real32_T in3_im;
      real32_T in3_re;
      in3_re = in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1].re;
      in3_im = -in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1].im;
      in1->data[i1 + in1->size[0] * i].re = in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].re * in3_re - in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].im * in3_im;
      in1->data[i1 + in1->size[0] * i].im = in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].re * in3_im + in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].im * in3_re;
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_9(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_real_T(in1, i, &t_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = 5.43656365691809 * in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1] * static_cast<real_T>(in3->data[i1 *
        stride_1_0 + in3->size[0] * aux_1_1] < 0.99999999999999978);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static real32_T (*c_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
  parentId))[2]
{
  real32_T (*y)[2];
  y = f_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}
static real32_T (*c_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
*identifier))[2]
{
  emlrtMsgIdentifier thisId;
  real32_T (*y)[2];
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = c_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}

static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line)
{
  if (errCode != cudaSuccess) {
    b_raiseCudaError(errCode, file, b_line, cudaGetErrorName(errCode),
                     cudaGetErrorString(errCode));
  }
}

//
//
namespace coder
{
  namespace internal
  {
    static void warning()
    {
      static const int32_T iv[2]{ 1, 7 };

      static const int32_T iv1[2]{ 1, 7 };

      static const int32_T iv2[2]{ 1, 39 };

      static const char_T msgID[39]{ 's', 'i', 'g', 'n', 'a', 'l', ':', 'c', 'h',
        'e', 'c', 'k', '_', 'o', 'r', 'd', 'e', 'r', ':', 'I', 'n', 'v', 'a',
        'l', 'i', 'd', 'O', 'r', 'd', 'e', 'r', 'R', 'o', 'u', 'n', 'd', 'i',
        'n', 'g' };

      static const char_T b_u[7]{ 'm', 'e', 's', 's', 'a', 'g', 'e' };

      static const char_T u[7]{ 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

      const mxArray *b_y;
      const mxArray *c_y;
      const mxArray *m;
      const mxArray *m1;
      const mxArray *m2;
      const mxArray *y;
      y = nullptr;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &u[0]);
      emlrtAssign(&y, m);
      b_y = nullptr;
      m1 = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m1, &b_u[0]);
      emlrtAssign(&b_y, m1);
      c_y = nullptr;
      m2 = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 39, m2, &msgID[0]);
      emlrtAssign(&c_y, m2);
      b_feval(y, feval(b_y, c_y, &d_emlrtMCI), &e_emlrtMCI);
    }
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride)
{
  int64_T newEnd;
  newEnd = -1L;
  if ((stride > 0L) && (start <= end)) {
    newEnd = (end - start) / stride;
  } else if ((stride < 0L) && (end <= start)) {
    newEnd = (start - end) / -stride;
  }

  return newEnd;
}

static uint64_T computeNumIters(int64_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0L) {
    numIters = static_cast<uint64_T>(ub + 1L);
  }

  return numIters;
}

static uint64_T computeNumIters(int32_T ub, int32_T b_ub)
{
  uint64_T n;
  uint64_T numIters;
  n = 0UL;
  if (ub >= 0) {
    n = static_cast<uint64_T>(ub + 1);
  }

  numIters = n;
  n = 0UL;
  if (b_ub >= 0) {
    n = static_cast<uint64_T>(b_ub + 1);
  }

  numIters *= n;
  return numIters;
}

static uint64_T computeNumIters(int32_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0) {
    numIters = static_cast<uint64_T>(ub + 1);
  }

  return numIters;
}

static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUBLAS_STATUS_SUCCESS) {
    cublasGetErrorName(errCode, &errName);
    cublasGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUSOLVER_STATUS_SUCCESS) {
    cusolverGetErrorName(errCode, &errName);
    cusolverGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static real_T d_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId)
{
  static const int32_T dims{ 0 };

  real_T ret;
  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "double", false, 0U, (
    const void *)&dims);
  ret = *static_cast<real_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret;
}

static int32_T div_s32(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    emlrtDivisionByZeroErrorR2012b(nullptr, emlrtRootTLSGlobal);
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static __device__ int32_T div_s32_device(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if (static_cast<int32_T>(numerator < 0) != static_cast<int32_T>(denominator <
         0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static real32_T e_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId)
{
  static const int32_T dims{ 0 };

  real32_T ret;
  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 0U, (
    const void *)&dims);
  ret = *static_cast<real32_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret;
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1(creal_T *dc,
  creal_T *dc6)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    dc6->re = CUDART_INF;
    dc->re = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel10(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel100(const
  emxArray_real_T a, const int32_T ix, const int32_T lidx, const int32_T bcoef,
  emxArray_real_T h)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    h.data[div_s32_device(bcoef - lidx, ix) + 1] = a.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1000(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1001(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1002(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1003(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1004(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv57)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv57.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1005(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv74)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv74.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1006(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv74,
  const emxArray_int32_T iv57, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv57.data[kk] + expanded_dim0 * iv74.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1007(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel101(const
  int32_T b, emxArray_real_T dv23)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv23.data[itime] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel102(const
  emxArray_real_T dv23, const emxArray_real_T h, const int32_T b_h,
  emxArray_real_T h1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h1.data[itime] = h.data[itime] * dv23.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel103(const real_T
  halfh, const emxArray_real_T h1, const real_T toler, const int32_T b_h1,
  emxArray_real32_T opts_filter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_filter.data[itime] = static_cast<real32_T>(toler * h1.data[itime] /
      halfh);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1036(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1037(const
  emxArray_real32_T opts_x, const int32_T fb_SignalPad, const int32_T i71, const
  int32_T omega_tmp2, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[i71 * itime] = opts_x.data[fb_SignalPad];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1038(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1039(const
  emxArray_real32_T w, const int32_T lidx, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[lidx * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel104(const
  int32_T halfh, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(halfh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1040
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1041(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  fb_SignalPad, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime + y1_dim0 * fb_SignalPad] = y.data[static_cast<int32_T>(T +
      b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1042(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1043(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1044(const
  emxArray_real32_T yCol, real32_T *cv_re)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *cv_re = yCol.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1045(const
  real32_T *cv_re, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = h.data[0] * *cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1046(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1047(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv43)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv43.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1048(const
  emxArray_real32_T h, const emxArray_int32_T iv43, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv43.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1049(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const real_T toler, const int32_T b, emxArray_real32_T
  w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx);
    cv = 0.0F;
    kk = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < kk; m++) {
      int32_T k;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * yCol.data[(static_cast<int32_T>(toler) - m) -
        1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel105(const
  emxArray_uint32_T y, const real_T halfh, const int32_T b_y, emxArray_int32_T
  iv19)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv19.data[itime] = static_cast<int32_T>(halfh + static_cast<real_T>
      (y.data[itime]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1050(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1051(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1052(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1053(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv42)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv42.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1054(const
  emxArray_real32_T yCol, const emxArray_int32_T iv42, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv42.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1055(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx);
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1056(const
  emxArray_real32_T b_y1, const int32_T wtc, emxArray_real32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(wtc);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1057(const
  emxArray_real32_T b_y1, const int32_T c_y1, const int32_T d_y1,
  emxArray_real32_T opts_x, int32_T opts_x_dim0, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(d_y1) + 1UL) * (static_cast<uint64_T>(c_y1) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y1) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y1) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = b_y1.data[itime + y1_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1058(const
  emxArray_real32_T opts_x, const int32_T b_opts_x, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1059(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel106(const
  emxArray_real32_T opts_filter, const emxArray_int32_T iv19, const int32_T
  b_iv19, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_iv19);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[iv19.data[itime] - 1] = opts_filter.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1060(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1061(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1062(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1063(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1064(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1065(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1066(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1067(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1068(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1069(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel107(const
  emxArray_real32_T opts_x, const int32_T b_opts_x, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1070(const
  emxArray_real32_T y, const int32_T iv9, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1071
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1072(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1073(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1074(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1075(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1076(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1077(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1078(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv71)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv71.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1079(const
  emxArray_real32_T h, const emxArray_int32_T iv71, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv71.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel108(const
  emxArray_real32_T b_y1, const int32_T b, emxArray_real32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1080(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const real_T toler, const int32_T b, emxArray_real32_T
  w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < icounter; m++) {
      int32_T k;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * yCol.data[(static_cast<int32_T>(toler) - m) -
        1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1081(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1082(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1083(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1084(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1085(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv73)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv73.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1086(const
  emxArray_real32_T yCol, const emxArray_int32_T iv73, const int32_T iv9,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv73.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1087(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1088(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1089(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel109(const
  emxArray_creal32_T crossCFS, const int32_T b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1090(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1091
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1092(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1093(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1094(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1095(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1096(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1097(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1098(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1099(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel11(emxArray_real_T
  fb_Omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    fb_Omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel110(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime) + 0.5;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1100(const
  real32_T cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1101(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1102(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1103(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv48)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv48.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1104(const
  emxArray_real32_T a, const emxArray_int32_T iv48, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv48.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1105(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1106(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1107(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1108(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1109(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel111(const
  emxArray_real_T m, const int32_T b_m, emxArray_real_T k)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_m);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    k.data[itime] = m.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1110(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv53)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv53.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1111(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv53, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv53.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1112(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1113(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1114(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1115(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1116(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1117(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv56)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv56.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1118(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv72)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv72.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1119(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv72,
  const emxArray_int32_T iv56, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv56.data[kk] + expanded_dim0 * iv72.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel112(const
  int32_T k, emxArray_real_T G)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    G.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1120(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel113(const
  int32_T k, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel114(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T dv29)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv29.data[itime] = 6.2831853071795862 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1149(const
  emxArray_real32_T opts_x, const int32_T b_opts_x, emxArray_real32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel115(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T dv31,
  emxArray_real_T dv29)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    dv29.data[b_k] = cos(dv29.data[b_k]);
    dv31.data[b_k] = 6.2831853071795862 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1150(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1151(const
  emxArray_real32_T xCol, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = xCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1152(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1153
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1154(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1155(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1156(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1157(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1158(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1159(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel116(const
  int32_T b, emxArray_real_T dv31)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv31.data[k] = cos(dv31.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1160(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1161(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1162
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1163(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1164(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1165(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1166(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1167(const
  real32_T cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1168(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1169(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel117(const
  emxArray_real_T k, const emxArray_real_T dv31, const emxArray_real_T dv29,
  const real_T a, const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * (dv29.data[itime] - dv31.data[itime]) / (k.data[itime]
      * k.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1170(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv59)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv59.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1171(const
  emxArray_real32_T a, const emxArray_int32_T iv59, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv59.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1172(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1173(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1174(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1175(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1176(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1177(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv62)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv62.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1178(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv62, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv62.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1179(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel118(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = 2.0 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1180(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1181(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1182(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1183(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1184(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv63)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv63.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1185(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv80)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv80.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1186(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv80,
  const emxArray_int32_T iv63, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv63.data[kk] + expanded_dim0 * iv80.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1187(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel119(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T y,
  emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    if (fabs(b_y.data[b_k]) < 1.0020841800044864E-292) {
      b_y.data[b_k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * b_y.data[b_k];
      i2Map = sin(i2Map) / i2Map;
      b_y.data[b_k] = i2Map;
    }

    y.data[b_k] = 2.0 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel12(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T fb_Omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel120(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    if (fabs(y.data[k]) < 1.0020841800044864E-292) {
      y.data[k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * y.data[k];
      i2Map = sin(i2Map) / i2Map;
      y.data[k] = i2Map;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel121(const
  emxArray_real_T y, const real_T a, const emxArray_real_T b_y, const real_T b_a,
  const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += b_a * b_y.data[itime] - a * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1216(const
  emxArray_real32_T opts_x, const int32_T b_opts_x, emxArray_real32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1217(const
  int32_T b, emxArray_uint32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<uint32_T>(itime) + 1U;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1218(const
  creal_T *dc6, const real_T table100[100], const creal_T dc7, const creal_T *dc,
  const int32_T bcoef, const int32_T ix, const int32_T lidx, const int32_T i,
  const int64_T b, emxArray_real_T dv23, real_T q1_dim0, real_T q1_dim1, real_T
  q1_dim2, real_T q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6,
  real_T q1_dim7, real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3,
  real_T p1_dim4, real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0,
  real_T q2_dim1, real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5,
  real_T q2_dim6, real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2,
  real_T p2_dim3, real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7,
  real_T q4_dim0, real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4,
  real_T q4_dim5, real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1,
  real_T p4_dim2, real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6,
  real_T p4_dim7, real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3,
  real_T c_dim4, real_T c_dim5, real_T c_dim6)
{
  __shared__ real_T p1_shared[8];
  __shared__ real_T p2_shared[8];
  __shared__ real_T p4_shared[8];
  __shared__ real_T q1_shared[8];
  __shared__ real_T q2_shared[8];
  __shared__ real_T q4_shared[8];
  __shared__ real_T c_shared[7];
  creal_T z;
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  int32_T itime;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    p1_shared[0] = p1_dim0;
    p1_shared[1] = p1_dim1;
    p1_shared[2] = p1_dim2;
    p1_shared[3] = p1_dim3;
    p1_shared[4] = p1_dim4;
    p1_shared[5] = p1_dim5;
    p1_shared[6] = p1_dim6;
    p1_shared[7] = p1_dim7;
    q1_shared[0] = q1_dim0;
    q1_shared[1] = q1_dim1;
    q1_shared[2] = q1_dim2;
    q1_shared[3] = q1_dim3;
    q1_shared[4] = q1_dim4;
    q1_shared[5] = q1_dim5;
    q1_shared[6] = q1_dim6;
    q1_shared[7] = q1_dim7;
    p2_shared[0] = p2_dim0;
    p2_shared[1] = p2_dim1;
    p2_shared[2] = p2_dim2;
    p2_shared[3] = p2_dim3;
    p2_shared[4] = p2_dim4;
    p2_shared[5] = p2_dim5;
    p2_shared[6] = p2_dim6;
    p2_shared[7] = p2_dim7;
    q2_shared[0] = q2_dim0;
    q2_shared[1] = q2_dim1;
    q2_shared[2] = q2_dim2;
    q2_shared[3] = q2_dim3;
    q2_shared[4] = q2_dim4;
    q2_shared[5] = q2_dim5;
    q2_shared[6] = q2_dim6;
    q2_shared[7] = q2_dim7;
    p4_shared[0] = p4_dim0;
    p4_shared[1] = p4_dim1;
    p4_shared[2] = p4_dim2;
    p4_shared[3] = p4_dim3;
    p4_shared[4] = p4_dim4;
    p4_shared[5] = p4_dim5;
    p4_shared[6] = p4_dim6;
    p4_shared[7] = p4_dim7;
    q4_shared[0] = q4_dim0;
    q4_shared[1] = q4_dim1;
    q4_shared[2] = q4_dim2;
    q4_shared[3] = q4_dim3;
    q4_shared[4] = q4_dim4;
    q4_shared[5] = q4_dim5;
    q4_shared[6] = q4_dim6;
    q4_shared[7] = q4_dim7;
    c_shared[0] = c_dim0;
    c_shared[1] = c_dim1;
    c_shared[2] = c_dim2;
    c_shared[3] = c_dim3;
    c_shared[4] = c_dim4;
    c_shared[5] = c_dim5;
    c_shared[6] = c_dim6;
  }

  __syncthreads();
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal_T tmp;
    creal_T zd;
    int64_T k;
    real_T tkd1mtk;
    k = static_cast<int64_T>(idx);
    tkd1mtk = static_cast<real_T>(lidx + (((static_cast<int32_T>
      (static_cast<int64_T>(i) + k) - ix) - 1) << 1)) / (static_cast<real_T>
      (bcoef) - 1.0);
    zd.re = 5.0 * sqrt((1.0 - tkd1mtk) * (tkd1mtk + 1.0));
    if (isnan(zd.re)) {
      tmp = *dc;
    } else {
      creal_T dk;
      creal_T p1;
      creal_T pt;
      real_T aa;
      real_T ack;
      real_T ak;
      real_T b_atol;
      real_T bb;
      real_T i2Map;
      real_T im;
      real_T re;
      int32_T ocol;
      int32_T orow;
      boolean_T guard1;
      orow = 0;
      i2Map = hypot(zd.re, 0.0);
      if (i2Map > 1.0737418235E+9) {
        orow = 4;
      } else if (i2Map > 32767.999992370605) {
        orow = 3;
      }

      tmp.re = 0.0;
      tmp.im = 0.0;
      bb = hypot(zd.re, 0.0);
      guard1 = false;
      if (bb <= 2.0) {
        ocol = 0;
        b_atol = hypot(zd.re, 0.0);
        if (b_atol == 0.0) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else if (b_atol < 2.2250738585072014E-305) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else {
          pt.re = 0.5 * zd.re;
          if (b_atol > 4.7170688552396617E-153) {
            dk.re = pt.re * pt.re;
            ack = hypot(dk.re, 0.0);
          } else {
            dk.re = 0.0;
            ack = 0.0;
          }

          i2Map = pt.re;
          if (log(i2Map) * 0.0 > -700.92179369444591) {
            b_atol = 2.2204460492503131E-16 * ack;
            pt.re = 1.0;
            pt.im = 0.0;
            if (!static_cast<int32_T>(ack < 2.2204460492503131E-16)) {
              p1.re = 1.0;
              p1.im = 0.0;
              ak = 3.0;
              i2Map = 1.0;
              aa = 2.0;
              do {
                tkd1mtk = 1.0 / i2Map;
                re = p1.re * dk.re - p1.im * 0.0;
                im = p1.re * 0.0 + p1.im * dk.re;
                p1.re = tkd1mtk * re;
                p1.im = tkd1mtk * im;
                pt.re += p1.re;
                pt.im += p1.im;
                i2Map += ak;
                ak += 2.0;
                aa = aa * ack * tkd1mtk;
              } while (!!static_cast<int32_T>(aa > b_atol));
            }

            i2Map = pt.re - pt.im * 0.0;
            tkd1mtk = pt.re * 0.0 + pt.im;
            tmp.re = i2Map - tkd1mtk * 0.0;
            tmp.im = i2Map * 0.0 + tkd1mtk;
          } else {
            ocol = 1;
            if (ack > 0.0) {
              ocol = -1;
            }
          }
        }

        if (ocol < 0) {
          itime = 1;
        } else {
          itime = ocol;
        }

        if ((1 - itime != 0) && (ocol < 0)) {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        if (bb < 21.784271729432426) {
          creal_T ck;
          creal_T cs1;
          creal_T cs2;
          int32_T b_i;
          int32_T icounter;
          boolean_T errflag;
          boolean_T exitg1;
          ocol = 0;
          b_atol = hypot(zd.re, 0.0);
          aa = floor(b_atol);
          ck.re = (aa + 1.0) / zd.re;
          cs2.re = 2.0 / zd.re;
          p1.re = 0.0;
          p1.im = 0.0;
          cs1.re = 1.0;
          cs1.im = 0.0;
          ack = ((aa + 1.0) + 1.0) / b_atol;
          tkd1mtk = ack + sqrt(ack * ack - 1.0);
          i2Map = tkd1mtk * tkd1mtk;
          bb = (i2Map + i2Map) / ((i2Map - 1.0) * (tkd1mtk - 1.0)) /
            2.2204460492503131E-16;
          ak = aa + 1.0;
          errflag = true;
          icounter = 0;
          b_i = 1;
          exitg1 = false;
          while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) && (b_i
                  < 81)) {
            icounter++;
            pt = cs1;
            tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
            i2Map = ck.re * cs1.im + 0.0 * cs1.re;
            cs1.re = p1.re - tkd1mtk;
            cs1.im = p1.im - i2Map;
            p1 = pt;
            ck.re += cs2.re;
            if (hypot(cs1.re, cs1.im) > bb * ak * ak) {
              errflag = false;
              exitg1 = true;
            } else {
              ak++;
              b_i++;
            }
          }

          if (errflag) {
            ocol = -2;
          } else {
            int32_T kk;
            boolean_T guard2;
            icounter++;
            kk = 0;
            guard2 = false;
            if (static_cast<int32_T>(aa) <= 0) {
              p1.re = 0.0;
              p1.im = 0.0;
              cs1.re = 1.0;
              cs1.im = 0.0;
              ck.re = 1.0 / zd.re;
              bb = sqrt(1.0 / b_atol / 2.2204460492503131E-16);
              itime = 1;
              errflag = true;
              b_i = 1;
              exitg1 = false;
              while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                     (b_i < 81)) {
                kk++;
                pt = cs1;
                tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
                i2Map = ck.re * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re - tkd1mtk;
                cs1.im = p1.im - i2Map;
                p1 = pt;
                ck.re += cs2.re;
                i2Map = hypot(cs1.re, cs1.im);
                if (i2Map >= bb * ak * ak) {
                  if (itime == 2) {
                    errflag = false;
                    exitg1 = true;
                  } else {
                    ack = hypot(ck.re, 0.0);
                    tkd1mtk = fmin(ack + sqrt(ack * ack - 1.0), i2Map / hypot
                                   (pt.re, pt.im));
                    bb *= sqrt(tkd1mtk / (tkd1mtk * tkd1mtk - 1.0));
                    itime = 2;
                    b_i++;
                  }
                } else {
                  b_i++;
                }
              }

              if (errflag) {
                ocol = -2;
              } else {
                guard2 = true;
              }
            } else {
              guard2 = true;
            }

            if (guard2) {
              itime = icounter + static_cast<int32_T>(aa);
              kk++;
              if (itime >= kk) {
                kk = itime;
              }

              aa = static_cast<real_T>(kk);
              p1.re = 0.0;
              p1.im = 0.0;
              cs1 = dc7;
              bb = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  bb = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) + (static_cast<real_T>
                    (kk) + 1.0) * ((static_cast<real_T>(kk) + 1.0) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) +
                    (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  bb = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  bb = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((static_cast<
                    real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  bb = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              tkd1mtk = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) +
                    (static_cast<real_T>(kk) + 1.0) * ((static_cast<real_T>(kk)
                    + 1.0) * (i2Map / tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) + (((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  tkd1mtk = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  tkd1mtk = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) *
                    ((((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                      tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((
                    static_cast<real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  tkd1mtk = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              i2Map = exp(bb - tkd1mtk);
              dk.re = 0.0;
              dk.im = 0.0;
              for (b_i = 0; b_i < kk; b_i++) {
                pt = cs1;
                tkd1mtk = aa * cs2.re;
                ack = aa * 0.0;
                bb = tkd1mtk * cs1.re - ack * cs1.im;
                ack = tkd1mtk * cs1.im + ack * cs1.re;
                cs1.re = p1.re + bb;
                cs1.im = p1.im + ack;
                p1 = pt;
                ack = i2Map * (1.0 - 0.0 / aa);
                dk.re += (ack + i2Map) * pt.re;
                dk.im += (ack + i2Map) * pt.im;
                i2Map = ack;
                aa--;
              }

              tmp = cs1;
              pt.re = log(cs2.re);
              re = 0.0 * pt.re;
              im = 0.0 * pt.re;
              pt.re = re + zd.re;
              cs1.re += dk.re;
              cs1.im += dk.im;
              p1.re = 1.0 / hypot(cs1.re, cs1.im);
              if (pt.re == 0.0) {
                pt.re = cos(im);
                pt.im = sin(im);
              } else if (im == 0.0) {
                i2Map = pt.re;
                pt.re = exp(i2Map);
                pt.im = 0.0;
              } else {
                pt.re = CUDART_NAN;
                pt.im = CUDART_NAN;
              }

              i2Map = pt.re * p1.re - pt.im * 0.0;
              tkd1mtk = pt.re * 0.0 + pt.im * p1.re;
              ack = cs1.re * p1.re + cs1.im * 0.0;
              bb = cs1.re * 0.0 - cs1.im * p1.re;
              pt.re = i2Map * ack - tkd1mtk * bb;
              pt.im = i2Map * bb + tkd1mtk * ack;
              re = tmp.re * pt.re - tmp.im * pt.im;
              im = tmp.re * pt.im + tmp.im * pt.re;
              tmp.re = re;
              tmp.im = im;
            }
          }

          if (ocol < 0) {
            if (ocol == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        } else {
          ocol = 0;
          i2Map = sqrt(0.15915494309189535 / zd.re);
          if (zd.re > 700.92179369444591) {
            ocol = -1;
            tmp = *dc;
          } else {
            creal_T ck;
            creal_T cs1;
            creal_T cs2;
            int32_T b_i;
            boolean_T errflag;
            boolean_T exitg1;
            if (zd.re == 0.0) {
              pt.re = 1.0;
            } else {
              pt.re = exp(zd.re);
            }

            p1.re = i2Map * pt.re;
            p1.im = i2Map * 0.0;
            pt.re = 8.0 * zd.re;
            pt.im = 0.0;
            ack = 8.0 * hypot(zd.re, 0.0);
            i2Map = -1.0;
            b_atol = 2.2204460492503131E-16 / ack;
            tkd1mtk = 1.0;
            cs1.re = 1.0;
            cs1.im = 0.0;
            cs2.re = 1.0;
            cs2.im = 0.0;
            ck.re = 1.0;
            ck.im = 0.0;
            ak = 0.0;
            aa = 1.0;
            bb = ack;
            dk = pt;
            errflag = true;
            b_i = 1;
            exitg1 = false;
            while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                   (b_i < 46)) {
              ck.re *= i2Map;
              ck.im *= i2Map;
              if (ck.im == 0.0) {
                re = ck.re / dk.re;
                im = 0.0;
              } else if (ck.re == 0.0) {
                re = 0.0;
                im = CUDART_NAN;
              } else {
                re = ck.re / dk.re;
                im = CUDART_NAN;
              }

              ck.re = re;
              ck.im = im;
              cs2.re += re;
              cs2.im += im;
              tkd1mtk = -tkd1mtk;
              cs1.re += re * tkd1mtk;
              cs1.im += im * tkd1mtk;
              dk.re += pt.re;
              aa = aa * fabs(i2Map) / bb;
              bb += ack;
              ak += 8.0;
              i2Map -= ak;
              if (aa <= b_atol) {
                errflag = false;
                exitg1 = true;
              } else {
                b_i++;
              }
            }

            if (errflag) {
              ocol = -2;
            } else {
              if (zd.re + zd.re < 700.92179369444591) {
                pt.re = -2.0 * zd.re;
                if (pt.re == 0.0) {
                  pt.re = 1.0;
                  pt.im = -0.0;
                } else {
                  i2Map = pt.re;
                  pt.re = exp(i2Map);
                  pt.im = 0.0;
                }

                re = pt.re * cs2.re - pt.im * cs2.im;
                im = pt.re * cs2.im + pt.im * cs2.re;
                cs1.re += re * 0.0 - im * 0.0;
                cs1.im += re * 0.0 + im * 0.0;
              }

              tmp.re = cs1.re * p1.re - cs1.im * p1.im;
              tmp.im = cs1.re * p1.im + cs1.im * p1.re;
            }
          }

          if (ocol < 0) {
            if (ocol == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        }
      }

      if (itime < 0) {
        if (itime == -2) {
          orow = 5;
        } else {
          orow = 2;
        }
      }

      if (orow == 5) {
        tmp = *dc;
      } else if (orow == 2) {
        tmp = *dc6;
      }

      if (zd.re > 0.0) {
        i2Map = tmp.re;
        tmp.re = i2Map;
        tmp.im = 0.0;
      }
    }

    if (tmp.im == 0.0) {
      z.re = tmp.re / 27.239871823604449;
      z.im = 0.0;
    } else if (tmp.re == 0.0) {
      z.re = 0.0;
      z.im = CUDART_NAN;
    } else {
      z.re = tmp.re / 27.239871823604449;
      z.im = CUDART_NAN;
    }

    dv23.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = hypot
      (z.re, z.im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1219(const
  emxArray_real_T a, const int32_T b_a, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel122(const real_T
  fa, const real_T r, const int32_T bcoef, const int32_T i1Start, const int32_T
  b, emxArray_real_T sinc4A, emxArray_real_T sinc3A, emxArray_real_T sinc2A,
  emxArray_real_T sinc1A)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T ack;
    real_T bb;
    real_T i2Map;
    real_T tkd1mtk;
    int32_T kk;
    uint32_T i1Map;
    kk = static_cast<int32_T>(idx);
    i1Map = (static_cast<uint32_T>(kk) + static_cast<uint32_T>(i1Start)) + 1U;
    tkd1mtk = (static_cast<real_T>(kk) + 1.0) - static_cast<real_T>(bcoef);
    ack = r * static_cast<real_T>(i1Map);
    i2Map = fa * static_cast<real_T>(i1Map);
    bb = r * tkd1mtk;
    tkd1mtk *= fa;
    if (fabs(ack) < 1.0020841800044864E-292) {
      sinc1A.data[kk] = 1.0;
    } else {
      ack *= 3.1415926535897931;
      sinc1A.data[kk] = sin(ack) / ack;
    }

    if (fabs(i2Map) < 1.0020841800044864E-292) {
      sinc2A.data[kk] = 1.0;
    } else {
      i2Map *= 3.1415926535897931;
      sinc2A.data[kk] = sin(i2Map) / i2Map;
    }

    if (fabs(bb) < 1.0020841800044864E-292) {
      sinc3A.data[kk] = 1.0;
    } else {
      bb *= 3.1415926535897931;
      sinc3A.data[kk] = sin(bb) / bb;
    }

    if (fabs(tkd1mtk) < 1.0020841800044864E-292) {
      sinc4A.data[kk] = 1.0;
    } else {
      tkd1mtk *= 3.1415926535897931;
      sinc4A.data[kk] = sin(tkd1mtk) / tkd1mtk;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1220(const
  emxArray_real_T x, const int32_T b, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.5 * x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1221(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1222(const
  int32_T omega_tmp2, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1223(const
  int32_T G, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    jpvt.data[itime] = 0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1224(const
  int32_T b, const int32_T nsubs, emxArray_real_T G, int32_T G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(nsubs) + 1UL) * (static_cast<uint64_T>(b) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b) + 1UL));
    G.data[kk * G_dim0 + i] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1225(const
  int32_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    tau.data[k] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1226(const
  int32_T i, const int64_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int64_T k;
    k = static_cast<int64_T>(idx);
    tau.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1227(const
  int32_T nsubs, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    jpvt.data[k] = k + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1228(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1229(const
  int32_T omega_tmp2, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel123(const
  emxArray_real_T sinc4A, const emxArray_real_T sinc2A, const real_T fa, const
  emxArray_real_T sinc3A, const emxArray_real_T sinc1A, const real_T r, const
  int32_T bcoef, const int32_T b, const int32_T c, emxArray_real_T G, int32_T
  G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T itime;
    int32_T kk;
    uint32_T i1Map;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    i1Map = (static_cast<uint32_T>(itime) + static_cast<uint32_T>(kk)) + 1U;
    i2Map = static_cast<real_T>(itime - kk) + static_cast<real_T>(bcoef);
    G.data[itime + G_dim0 * kk] += 0.25 * (r * (sinc1A.data[static_cast<int32_T>
      (i1Map) - 1] + sinc3A.data[static_cast<int32_T>(i2Map) - 1]) - fa *
      (sinc2A.data[static_cast<int32_T>(i1Map) - 1] + sinc4A.data
       [static_cast<int32_T>(i2Map) - 1]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1230(const
  emxArray_real_T b, const emxArray_int32_T jpvt, const int32_T nsubs,
  emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    a.data[jpvt.data[i] - 1] = b.data[i];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1231(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 4.0 * b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1232
  (emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] /= 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1233(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1234(const
  emxArray_real32_T wtc, const int32_T b_wtc, emxArray_real32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_wtc);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = wtc.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1235(const
  emxArray_real32_T wtc, const int32_T b_wtc, const int32_T c_wtc,
  emxArray_real32_T opts_x, int32_T opts_x_dim0, int32_T wtc_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_wtc) + 1UL) * (static_cast<uint64_T>(b_wtc)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_wtc) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_wtc) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = wtc.data[itime + wtc_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1236(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1237(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv17)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv17.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1238(const
  emxArray_creal32_T a, const emxArray_int32_T iv17, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv17.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1239(const
  emxArray_creal32_T expanded, const real_T a, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = static_cast<real32_T>(a) * expanded.data[orow].re;
    c.data[orow].im = static_cast<real32_T>(a) * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel124(const real_T T,
  emxArray_real_T b0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b0.data[0] = T;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1240(const
  int32_T smooth, emxArray_creal32_T crossCFS)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    crossCFS.data[itime].re = 0.0F;
    crossCFS.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1241(const
  int32_T smooth, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1242(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv16)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv16.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1243(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv18)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv18.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1244(const
  emxArray_creal32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_creal32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1245(const
  emxArray_creal32_T smooth, const int32_T iv9_dim0, const emxArray_int32_T iv18,
  const emxArray_int32_T iv16, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv16.data[kk] + expanded_dim0 * iv18.data[itime]] =
      smooth.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1246(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1247(const
  real32_T cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T crossCFS, int32_T crossCFS_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    crossCFS.data[nsubs + crossCFS_dim0 * bcoef].re = cv_re;
    crossCFS.data[nsubs + crossCFS_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1248(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1249(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      smooth.data[itime].re = cv / cfsposdft->re;
      smooth.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      smooth.data[itime].re = 0.0F;
      smooth.data[itime].im = ai / cfsposdft->re;
    } else {
      smooth.data[itime].re = cv / cfsposdft->re;
      smooth.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel125(const
  emxArray_real_T b, const int32_T c, emxArray_real_T b0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b0.data[itime + 1] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1250(const
  int32_T crossCFS, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1251(const
  emxArray_creal32_T crossCFS, const int32_T b, const int32_T c,
  emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0, int32_T crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[itime + cfsDFT_dim0 * kk] = crossCFS.data[itime + crossCFS_dim0 *
      kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1252(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, emxArray_creal32_T
  cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1253(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1254(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1255(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv13)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv13.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1256(const
  emxArray_real32_T a, const emxArray_int32_T iv13, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv13.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1257(const
  real_T a, const emxArray_real32_T expanded, const int32_T b, emxArray_real32_T
  c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1258(const
  int32_T smooth, emxArray_real32_T cfs2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs2.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1259(const real_T
  a, const emxArray_real32_T smooth, emxArray_real32_T b_smooth)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b_smooth.data[0] = smooth.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel126(const
  emxArray_real_T b0, const int32_T b_b0, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b0);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = b0.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1260(const
  emxArray_real32_T smooth, emxArray_real32_T cfs2)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfs2.data[0] = smooth.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1261(const
  int32_T smooth, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1262(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv12)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv12.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1263(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv14)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv14.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1264(const
  emxArray_real32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_real32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1265(const
  emxArray_real32_T smooth, const int32_T iv9_dim0, const emxArray_int32_T iv14,
  const emxArray_int32_T iv12, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv12.data[kk] + expanded_dim0 * iv14.data[itime]] =
      smooth.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1266(const
  real_T a, const emxArray_real32_T expanded, const emxArray_int32_T rows, const
  real_T halfh, const int32_T b, const int32_T c, emxArray_real32_T cfs2,
  int32_T expanded_dim0, int32_T cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    kk = static_cast<int32_T>(halfh);
    for (int32_T m{0}; m < kk; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * static_cast<real32_T>
        (a);
    }

    cfs2.data[orow + cfs2_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1267(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1268(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      y.data[itime].re = 0.0F;
      y.data[itime].im = ai / cfsposdft->re;
    } else {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1269(const
  int32_T cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel127(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1270(const
  emxArray_real32_T cfs2, const int32_T b, const int32_T c, emxArray_creal32_T
  cfsDFT, int32_T cfsDFT_dim0, int32_T cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[itime + cfsDFT_dim0 * kk].re = cfs2.data[itime + cfs2_dim0 * kk];
    cfsDFT.data[itime + cfsDFT_dim0 * kk].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1271(const
  emxArray_real32_T cfs2, const int32_T b_cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = cfs2.data[itime];
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1272(const
  int32_T ix, const int32_T lidx, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    cfsDFT.data[(ix - i) - 1].re = cfsDFT.data[i + 1].re;
    cfsDFT.data[(ix - i) - 1].im = -cfsDFT.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1273(const
  int32_T ix, const int32_T cfsDFT, const int32_T lidx, emxArray_creal32_T
  b_cfsDFT, int32_T cfsDFT_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>(cfsDFT)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsDFT) + 1UL));
    i = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) /
      (static_cast<uint64_T>(cfsDFT) + 1UL));
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((ix - i) - 1)].re = b_cfsDFT.data[kk +
      cfsDFT_dim0 * (i + 1)].re;
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((ix - i) - 1)].im = -b_cfsDFT.data[kk +
      cfsDFT_dim0 * (i + 1)].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1274(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1275(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1276(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv10)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv10.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1277(const
  emxArray_real32_T a, const emxArray_int32_T iv10, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv10.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1278(const
  real_T a, const emxArray_real32_T expanded, const int32_T b, emxArray_real32_T
  c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1279(const
  int32_T smooth, emxArray_real32_T cfs1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs1.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel128(const
  emxArray_real_T a, const int32_T ix, const int32_T lidx, const int32_T offsetH,
  emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(offsetH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = a.data[lidx + ix * itime] / 2.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1280(const real_T
  a, const emxArray_real32_T smooth, emxArray_real32_T b_smooth)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b_smooth.data[0] = smooth.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1281(const
  emxArray_real32_T smooth, emxArray_real32_T cfs1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfs1.data[0] = smooth.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1282(const
  int32_T smooth, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1283(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv9)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv9.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1284(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv11)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv11.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1285(const
  emxArray_real32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_real32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1286(const
  emxArray_real32_T smooth, const int32_T iv9_dim0, const emxArray_int32_T iv11,
  const emxArray_int32_T iv9, const int32_T b_iv9, const int32_T c_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_iv9) + 1UL) * (static_cast<uint64_T>(b_iv9)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_iv9) + 1UL));
    expanded.data[iv9.data[kk] + expanded_dim0 * iv11.data[itime]] =
      smooth.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1287(const
  real_T a, const emxArray_real32_T expanded, const emxArray_int32_T rows, const
  real_T halfh, const int32_T b, const int32_T c, emxArray_real32_T cfs1,
  int32_T expanded_dim0, int32_T cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    kk = static_cast<int32_T>(halfh);
    for (int32_T m{0}; m < kk; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * static_cast<real32_T>
        (a);
    }

    cfs1.data[orow + cfs1_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1288(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1289(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      y.data[itime].re = 0.0F;
      y.data[itime].im = ai / cfsposdft->re;
    } else {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel129(const
  emxArray_real_T a, const int32_T ix, const int32_T lidx, const int32_T bcoef,
  emxArray_real_T h)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    h.data[div_s32_device(bcoef - lidx, ix) + 1] = a.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1290(const
  int32_T cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1291(const
  emxArray_real32_T cfs1, const int32_T b, const int32_T c, emxArray_creal32_T
  cfsDFT, int32_T cfsDFT_dim0, int32_T cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[itime + cfsDFT_dim0 * kk].re = cfs1.data[itime + cfs1_dim0 * kk];
    cfsDFT.data[itime + cfsDFT_dim0 * kk].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1292(const
  emxArray_real32_T cfs1, const int32_T b_cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = cfs1.data[itime];
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1293(const
  int32_T ix, const int32_T lidx, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    cfsDFT.data[(ix - i) - 1].re = cfsDFT.data[i + 1].re;
    cfsDFT.data[(ix - i) - 1].im = -cfsDFT.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1294(const
  int32_T ix, const int32_T cfsDFT, const int32_T lidx, emxArray_creal32_T
  b_cfsDFT, int32_T cfsDFT_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>(cfsDFT)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsDFT) + 1UL));
    i = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) /
      (static_cast<uint64_T>(cfsDFT) + 1UL));
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((ix - i) - 1)].re = b_cfsDFT.data[kk +
      cfsDFT_dim0 * (i + 1)].re;
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((ix - i) - 1)].im = -b_cfsDFT.data[kk +
      cfsDFT_dim0 * (i + 1)].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1295(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1296(creal32_T
  *cfsposdft, int32_T cfsposdft_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(cfsposdft_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1297(const
  creal32_T *cfsposdft, const emxArray_creal32_T b_cfsposdft, const int32_T
  c_cfsposdft, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfsposdft);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfsposdft.data[itime].re;
    ai = b_cfsposdft.data[itime].im;
    if (ai == 0.0F) {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      cfspos.data[itime].re = 0.0F;
      cfspos.data[itime].im = ai / cfsposdft->re;
    } else {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1298(const
  int32_T b, emxArray_creal32_T xposdft, uint32_T xSize_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].re = xposdft.data[i
      + 1].re;
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].im =
      -xposdft.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1299(creal32_T
  *cfsposdft, int32_T cfsposdft_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(cfsposdft_dim1);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel13(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel130(const
  int32_T b, emxArray_real_T dv27)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv27.data[itime] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1300(const
  creal32_T *cfsposdft, const emxArray_creal32_T b_cfsposdft, const int32_T
  c_cfsposdft, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfsposdft);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfsposdft.data[itime].re;
    ai = b_cfsposdft.data[itime].im;
    if (ai == 0.0F) {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      cfspos.data[itime].re = 0.0F;
      cfspos.data[itime].im = ai / cfsposdft->re;
    } else {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1301(const
  int32_T b, emxArray_creal32_T xposdft, uint32_T xSize_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].re = xposdft.data[i
      + 1].re;
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].im =
      -xposdft.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1302(const
  emxArray_real_T somega, const int32_T b_somega, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_somega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = (somega.data[itime] - 5.0) / 0.6;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1303(const
  emxArray_real_T w, const int32_T b_w, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_w);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expnt.data[itime] = -1.0 / (1.0 - w.data[itime] * w.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1304(const
  int32_T b, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    expnt.data[k] = exp(expnt.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1305(const
  emxArray_real_T w, const int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = fabs(w.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1306(const
  emxArray_real_T y, const emxArray_real_T expnt, const int32_T b_expnt,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_expnt);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 5.43656365691809 * expnt.data[itime] *
      static_cast<real_T>(y.data[itime] < 0.99999999999999978);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1307(const
  int32_T lidx, emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    if (isnan(daughter.data[i])) {
      daughter.data[i] = 0.0;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1308(const
  emxArray_real_T fb_Omega, const emxArray_real_T fb_Scales, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T somega, int32_T somega_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_fb_Scales) + 1UL));
    somega.data[kk + somega_dim0 * itime] = fb_Scales.data[kk] *
      fb_Omega.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1309(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel131(const
  emxArray_real_T dv27, const emxArray_real_T h, const int32_T b_h,
  emxArray_real_T h1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h1.data[itime] = h.data[itime] * dv27.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1310(const char_T
  cv[128], char_T wav[4], char_T wname[4], char_T a_dim0, char_T a_dim1, char_T
  a_dim2, char_T a_dim3)
{
  __shared__ char_T a_shared[4];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    a_shared[0] = a_dim0;
    a_shared[1] = a_dim1;
    a_shared[2] = a_dim2;
    a_shared[3] = a_dim3;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 4) {
    wname[k] = cv[static_cast<int32_T>(a_shared[k])];
    wav[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(a_shared[k])])];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1311(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel1312(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1313(const int32_T
  offsetH, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[offsetH];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1314(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel1315(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1316(const int32_T
  offsetH, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[offsetH];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1317
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1318(const
  emxArray_real_T y, const real_T fa, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(fa, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1319(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel132(const real_T
  halfh, const emxArray_real_T h1, const real_T toler, const int32_T b_h1,
  emxArray_real32_T opts_filter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_filter.data[itime] = static_cast<real32_T>(toler * h1.data[itime] /
      halfh);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1320(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1321(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1322(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1323(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1324(const
  real_T x_data[9735], const int32_T b, real_T dv15_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv15_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1325(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1326(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1327(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv15_data[9735],
  const int32_T dv15_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv15_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv15_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1328(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1329(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel133(const
  int32_T halfh, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(halfh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1330(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1331(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1332(const
  real_T x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1333(const
  real_T x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T
  a_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1334(const
  real_T a_data[9735], const int32_T b, real_T dv9_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv9_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1335(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1336(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1337(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv9_data[9735],
  const int32_T dv9_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv9_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv9_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1338(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1339(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel134(const
  emxArray_uint32_T y, const real_T halfh, const int32_T b_y, emxArray_int32_T
  iv93)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv93.data[itime] = static_cast<int32_T>(halfh + static_cast<real_T>
      (y.data[itime]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1340(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1341(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1342(const
  real_T x_data[9735], const int32_T b, real_T dv8_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv8_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1343(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1344(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1345(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv8_data[9735],
  const int32_T dv8_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv8_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv8_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1346(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1347(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1348(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1349(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel135(const
  emxArray_real32_T opts_filter, const emxArray_int32_T iv93, const int32_T
  b_iv93, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_iv93);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[iv93.data[itime] - 1] = opts_filter.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1350(const
  real_T x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1351(const
  real_T x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T
  a_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1352(const
  real_T a_data[9735], const int32_T b, real_T dv2_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv2_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1353(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1354(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1355(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv2_data[9735],
  const int32_T dv2_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv2_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv2_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel136(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel137(const
  emxArray_creal32_T b_y1, const int32_T b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel138(const
  emxArray_creal32_T opts_x, const int32_T b, emxArray_real32_T fv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    fv.data[k] = atan2f(opts_x.data[k].im, opts_x.data[k].re);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel139(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel14(const
  emxArray_real_T y, const real_T s, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(s, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel140(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel141(const real_T
  toler, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel142(const
  emxArray_real32_T h, const emxArray_creal32_T yCol, real32_T *cv_re,
  emxArray_creal32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel143(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel144(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel145(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel146(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel147(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel148(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel149(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel15(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel150(const
  emxArray_creal32_T y, const int32_T iv9, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel151
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel152(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel153(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel154(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel155(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel156(const
  emxArray_real32_T h, real32_T *f13)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f13 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel157(const real32_T
  *f13, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f13;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel158(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel159(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel16(const
  emxArray_real_T somega, const int32_T b_somega, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_somega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expnt.data[itime] = -((somega.data[itime] - 6.0) * (somega.data[itime] - 6.0))
      / 2.0 * static_cast<real_T>(somega.data[itime] > 0.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel160(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv162)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv162.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel161(const
  emxArray_real32_T h, const emxArray_int32_T iv162, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv162.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel162(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const int32_T origSiz[2], const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    for (int32_T m{0}; m < icounter; m++) {
      creal32_T b_b;
      int32_T k;
      b_b = yCol.data[(icounter - m) - 1];
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.re += expanded.data[k - 1] * b_b.re;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.im += expanded.data[k - 1] * b_b.im;
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel163(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel164(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel165(const
  emxArray_real32_T h, real32_T *f12)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f12 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel166(const real32_T
  *f12, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f12;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel167(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel168(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel169(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel17(const int32_T
  b, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    expnt.data[k] = exp(expnt.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel170(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv164)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv164.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel171(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv164, const int32_T iv9,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv164.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel172(const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[k - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel173(const real32_T
  cv_im, const real32_T cv_re, const int32_T nsubs, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs].re = cv_re;
    w.data[nsubs].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel174(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel175(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel176
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel177(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel178(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel179(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel18(const
  emxArray_real_T somega, const emxArray_real_T expnt, const int32_T b_expnt,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_expnt);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 2.0 * expnt.data[itime] * static_cast<real_T>
      (somega.data[itime] > 0.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel180(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel181(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel182(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel183(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel184(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel185(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f28, real32_T *f29)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f29 = cv_re * a.data[0].re;
    *f28 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel186(const real32_T
  *f29, const real32_T *f28, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f28;
    c.data[0].re = *f29;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel187(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel188(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel189(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv142)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv142.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel19(const
  emxArray_real_T daughter, const int32_T b_daughter, emxArray_real32_T psihat)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_daughter);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    psihat.data[itime] = static_cast<real32_T>(daughter.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel190(const
  emxArray_creal32_T a, const emxArray_int32_T iv142, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv142.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel191(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel192(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel193(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel194(const
  emxArray_real32_T h, real32_T *f19)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f19 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel195(const real32_T
  *f19, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f19;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel196(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel197(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel198(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv144)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv144.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel199(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv144, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv144.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel2(const int32_T
  ix, const int32_T lidx, const emxArray_real32_T x, const int32_T b_x,
  emxArray_real32_T y, emxArray_real32_T c_x, int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_x.data[itime] = x.data[itime + x_dim0 * (lidx - 1)];
    y.data[itime] = x.data[itime + x_dim0 * (ix - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel20(const
  emxArray_real32_T x, const int32_T b_x, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel200(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel201(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel202(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel203(const
  emxArray_real32_T h, real32_T *f18)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f18 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel204(const real32_T
  *f18, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f18;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel205(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel206(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel207(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel208(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv149)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv149.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel209(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv167)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv167.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel21(const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T b_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_x.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel210(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv167,
  const emxArray_int32_T iv149, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv149.data[kk] + expanded_dim0 * iv167.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel211(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel212(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel22(const int32_T
  fb_SignalPad, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T kk;
    real32_T cv;
    kk = static_cast<int32_T>(idx);
    icounter = (fb_SignalPad - kk) - 1;
    cv = x.data[kk];
    x.data[kk] = x.data[icounter];
    x.data[icounter] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel23(const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel24(const
  emxArray_real32_T xv, const int32_T b_xv, emxArray_creal32_T xposdft)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xv);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xposdft.data[itime].re = xv.data[itime];
    xposdft.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel243(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel244(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel245
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel246(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel247(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel248(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel249(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel25(const
  emxArray_creal32_T xposdft, const emxArray_real32_T psihat, const int32_T
  bcoef, const int32_T cfsposdft, const int32_T lidx, emxArray_creal32_T
  b_cfsposdft, int32_T psihat_dim0, int32_T cfsposdft_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>
    (cfsposdft) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T k;
    int32_T kk;
    icounter = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsposdft) +
      1UL));
    k = static_cast<int32_T>((idx - static_cast<uint64_T>(icounter)) / (
      static_cast<uint64_T>(cfsposdft) + 1UL));
    itime = bcoef * k + 1;
    kk = static_cast<int32_T>(psihat_dim0 != 1);
    b_cfsposdft.data[icounter + cfsposdft_dim0 * k].re = psihat.data[kk *
      icounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].re;
    b_cfsposdft.data[icounter + cfsposdft_dim0 * k].im = psihat.data[kk *
      icounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel250(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel251(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel252(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel253(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel254
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel255(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel256(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel257(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel258(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel259(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f32, real32_T *f33)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f33 = cv_re * a.data[0].re;
    *f32 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel26(const int32_T
  xSize, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfspos.data[itime].re = 0.0F;
    cfspos.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel260(const real32_T
  *f33, const real32_T *f32, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f32;
    c.data[0].re = *f33;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel261(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel262(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel263(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv148)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv148.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel264(const
  emxArray_creal32_T a, const emxArray_int32_T iv148, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv148.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel265(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel266(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel267(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel268(const
  emxArray_real32_T h, real32_T *f23)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f23 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel269(const real32_T
  *f23, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f23;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel27(const
  emxArray_real_T daughter, const int32_T b_daughter, emxArray_real32_T psihat)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_daughter);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    psihat.data[itime] = static_cast<real32_T>(daughter.data[itime]);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel270(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel271(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel272(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv152)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv152.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel273(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv152, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv152.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel274(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel275(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel276(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel277(const
  emxArray_real32_T h, real32_T *f22)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f22 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel278(const real32_T
  *f22, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f22;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel279(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel28(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel280(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel281(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel282(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv155)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv155.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel283(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv172)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv172.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel284(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv172,
  const emxArray_int32_T iv155, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv155.data[kk] + expanded_dim0 * iv172.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel285(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel286(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel29(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel3(const char_T cv
  [128], char_T wname[4], char_T wav[4], char_T a_dim0, char_T a_dim1, char_T
  a_dim2, char_T a_dim3)
{
  __shared__ char_T a_shared[4];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    a_shared[0] = a_dim0;
    a_shared[1] = a_dim1;
    a_shared[2] = a_dim2;
    a_shared[3] = a_dim3;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 4) {
    wav[k] = cv[static_cast<int32_T>(a_shared[k])];
    wname[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(a_shared[k])])];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel30(const int32_T
  fb_SignalPad, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T kk;
    real32_T cv;
    kk = static_cast<int32_T>(idx);
    icounter = (fb_SignalPad - kk) - 1;
    cv = x.data[kk];
    x.data[kk] = x.data[icounter];
    x.data[icounter] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel31(const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel317(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel318(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel319(const real_T
  toler, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel32(const
  emxArray_real32_T xv, const int32_T b_xv, emxArray_creal32_T xposdft)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xv);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xposdft.data[itime].re = xv.data[itime];
    xposdft.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel320(const
  emxArray_real32_T h, const emxArray_creal32_T yCol, real32_T *cv_re,
  emxArray_creal32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel321(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel322(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel323(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel324(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel325(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel326(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel327(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel328(const
  emxArray_creal32_T y, const int32_T iv9, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel329
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel33(const
  emxArray_creal32_T xposdft, const emxArray_real32_T psihat, const int32_T
  bcoef, const int32_T cfsposdft, const int32_T lidx, emxArray_creal32_T
  b_cfsposdft, int32_T psihat_dim0, int32_T cfsposdft_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>
    (cfsposdft) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T k;
    int32_T kk;
    icounter = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsposdft) +
      1UL));
    k = static_cast<int32_T>((idx - static_cast<uint64_T>(icounter)) / (
      static_cast<uint64_T>(cfsposdft) + 1UL));
    itime = bcoef * k + 1;
    kk = static_cast<int32_T>(psihat_dim0 != 1);
    b_cfsposdft.data[icounter + cfsposdft_dim0 * k].re = psihat.data[kk *
      icounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].re;
    b_cfsposdft.data[icounter + cfsposdft_dim0 * k].im = psihat.data[kk *
      icounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel330(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel331(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel332(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel333(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel334(const
  emxArray_real32_T h, real32_T *f11)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f11 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel335(const real32_T
  *f11, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f11;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel336(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel337(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel338(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv161)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv161.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel339(const
  emxArray_real32_T h, const emxArray_int32_T iv161, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv161.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel34(const int32_T
  xSize, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfspos.data[itime].re = 0.0F;
    cfspos.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel340(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const int32_T origSiz[2], const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    for (int32_T m{0}; m < icounter; m++) {
      creal32_T b_b;
      int32_T k;
      b_b = yCol.data[(icounter - m) - 1];
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.re += expanded.data[k - 1] * b_b.re;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.im += expanded.data[k - 1] * b_b.im;
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel341(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel342(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel343(const
  emxArray_real32_T h, real32_T *f10)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f10 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel344(const real32_T
  *f10, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f10;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel345(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel346(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel347(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel348(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv163)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv163.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel349(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv163, const int32_T iv9,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv163.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel35(const
  emxArray_creal32_T cfspos, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(cfspos.data[k].re, cfspos.data[k].im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel350(const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[k - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel351(const real32_T
  cv_im, const real32_T cv_re, const int32_T nsubs, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs].re = cv_re;
    w.data[nsubs].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel352(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel353(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel354
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel355(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel356(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel357(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel358(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel359(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel36(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T cfs1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    cfs1.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel360(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel361(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel362(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel363(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f26, real32_T *f27)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f27 = cv_re * a.data[0].re;
    *f26 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel364(const real32_T
  *f27, const real32_T *f26, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f26;
    c.data[0].re = *f27;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel365(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel366(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel367(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv141)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv141.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel368(const
  emxArray_creal32_T a, const emxArray_int32_T iv141, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv141.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel369(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel37(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel370(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel371(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel372(const
  emxArray_real32_T h, real32_T *f17)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f17 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel373(const real32_T
  *f17, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f17;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel374(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel375(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel376(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv143)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv143.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel377(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv143, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv143.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel378(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel379(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel38(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel380(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel381(const
  emxArray_real32_T h, real32_T *f16)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f16 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel382(const real32_T
  *f16, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f16;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel383(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel384(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel385(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel386(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv147)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv147.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel387(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv166)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv166.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel388(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv166,
  const emxArray_int32_T iv147, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv147.data[kk] + expanded_dim0 * iv166.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel389(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel39(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel390(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel4(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel40(const int32_T
  cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel41(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel42(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel421(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel422(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel423
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel424(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel425(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel426(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel427(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel428(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel429(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel43(const int32_T
  xSize, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime].re = 0.0F;
    y.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel430(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel431(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel432
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel433(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel434(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel435(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel436(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel437(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f30, real32_T *f31)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f31 = cv_re * a.data[0].re;
    *f30 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel438(const real32_T
  *f31, const real32_T *f30, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f30;
    c.data[0].re = *f31;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel439(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel44(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_real32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime] = y.data[itime].re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel440(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel441(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv146)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv146.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel442(const
  emxArray_creal32_T a, const emxArray_int32_T iv146, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv146.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel443(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel444(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel445(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel446(const
  emxArray_real32_T h, real32_T *f21)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f21 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel447(const real32_T
  *f21, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f21;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel448(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel449(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel45(const
  emxArray_real32_T smooth, const int32_T b, emxArray_real32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel450(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv151)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv151.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel451(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv151, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv151.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel452(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel453(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel454(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel455(const
  emxArray_real32_T h, real32_T *f20)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f20 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel456(const real32_T
  *f20, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f20;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel457(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel458(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel459(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel46(const int32_T
  a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel460(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv154)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv154.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel461(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv171)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv171.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel462(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv171,
  const emxArray_int32_T iv154, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv154.data[kk] + expanded_dim0 * iv171.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel463(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel464(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel47(const real_T a,
  const emxArray_real32_T b_a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = b_a.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel48(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T cfs1, int32_T
  cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs1.data[cfs1_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel49(const
  emxArray_creal32_T cfspos, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(cfspos.data[k].re, cfspos.data[k].im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel495(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel496(const
  emxArray_creal32_T opts_x, const int32_T fb_SignalPad, const int32_T i269,
  const int32_T omega_tmp2, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[i269 * itime] = opts_x.data[fb_SignalPad];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel497(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel498(const
  emxArray_creal32_T w, const int32_T lidx, const int32_T b, emxArray_creal32_T
  y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[lidx * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel499
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel5(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel50(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T cfs2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    cfs2.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel500(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  fb_SignalPad, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime + y1_dim0 * fb_SignalPad] = y.data[static_cast<int32_T>(T +
      b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel501(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel502(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel503(const
  emxArray_creal32_T yCol, creal32_T *cfsposdft)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *cfsposdft = yCol.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel504(const
  creal32_T *cfsposdft, const emxArray_real32_T h, real32_T *f8, real32_T *f9)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f9 = h.data[0] * cfsposdft->re;
    *f8 = h.data[0] * cfsposdft->im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel505(const real32_T
  *f9, const real32_T *f8, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = *f8;
    w.data[0].re = *f9;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel506(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel507(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv140)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv140.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel508(const
  emxArray_real32_T h, const emxArray_int32_T iv140, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv140.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel509(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const real_T toler, const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T kk;
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    cv.re = 0.0F;
    cv.im = 0.0F;
    kk = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < kk; m++) {
      creal32_T b_b;
      int32_T k;
      b_b = yCol.data[(static_cast<int32_T>(toler) - m) - 1];
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.re += expanded.data[k - 1] * b_b.re;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.im += expanded.data[k - 1] * b_b.im;
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel51(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel510(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel511(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel512(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel513(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv139)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv139.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel514(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv139, const int32_T
  omega_tmp2, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv139.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel515(const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if ((nsubs + 1 < 0) && (k < MAX_int32_T - nsubs)) {
      k = MIN_int32_T;
    } else if ((nsubs + 1 > 0) && (k > 2147483646 - nsubs)) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[k - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel516(const real32_T
  cv_im, const real32_T cv_re, const int32_T nsubs, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs].re = cv_re;
    w.data[nsubs].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel517(const
  emxArray_creal32_T b_y1, const int32_T crossCFS, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel518(const
  emxArray_creal32_T b_y1, const int32_T c_y1, const int32_T d_y1,
  emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(d_y1) + 1UL) * (static_cast<uint64_T>(c_y1) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y1) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y1) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = b_y1.data[itime + y1_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel519(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel52(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel520(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel521(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel522(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel523(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel524(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel525(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel526(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel527(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel528(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel529(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel53(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel530(const
  emxArray_creal32_T y, const int32_T iv9, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel531
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel532(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel533(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel534(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel535(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel536(const
  emxArray_real32_T h, real32_T *f7)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f7 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel537(const real32_T
  *f7, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f7;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel538(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel539(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel54(const int32_T
  cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel540(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv168)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv168.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel541(const
  emxArray_real32_T h, const emxArray_int32_T iv168, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv168.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel542(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const real_T toler, const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < icounter; m++) {
      creal32_T b_b;
      int32_T k;
      b_b = yCol.data[(static_cast<int32_T>(toler) - m) - 1];
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.re += expanded.data[k - 1] * b_b.re;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv.im += expanded.data[k - 1] * b_b.im;
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel543(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel544(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel545(const
  emxArray_real32_T h, real32_T *f6)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f6 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel546(const real32_T
  *f6, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f6;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel547(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel548(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel549(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel55(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel550(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv170)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv170.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel551(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv170, const int32_T iv9,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv170.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel552(const
  emxArray_creal32_T expanded, const int32_T nsubs, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[k - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel553(const real32_T
  cv_im, const real32_T cv_re, const int32_T nsubs, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs].re = cv_re;
    w.data[nsubs].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel554(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel555(const
  emxArray_creal32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel556
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel557(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel558(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel559(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel56(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel560(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel561(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel562(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel563(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel564(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel565(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f24, real32_T *f25)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f25 = cv_re * a.data[0].re;
    *f24 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel566(const real32_T
  *f25, const real32_T *f24, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f24;
    c.data[0].re = *f25;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel567(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel568(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel569(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv145)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv145.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel57(const int32_T
  xSize, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime].re = 0.0F;
    y.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel570(const
  emxArray_creal32_T a, const emxArray_int32_T iv145, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv145.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel571(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel572(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel573(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel574(const
  emxArray_real32_T h, real32_T *f15)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f15 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel575(const real32_T
  *f15, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f15;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel576(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel577(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel578(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv150)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv150.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel579(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv150, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv150.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel58(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_real32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime] = y.data[itime].re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel580(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel581(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel582(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel583(const
  emxArray_real32_T h, real32_T *f14)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f14 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel584(const real32_T
  *f14, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f14;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel585(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel586(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel587(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel588(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv153)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv153.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel589(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv169)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv169.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel59(const
  emxArray_real32_T smooth, const int32_T b, emxArray_real32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel590(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv169,
  const emxArray_int32_T iv153, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv153.data[kk] + expanded_dim0 * iv169.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel591(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel592(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel6(const int32_T
  offsetH, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[offsetH];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel60(const int32_T
  a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel61(const real_T a,
  const emxArray_real32_T b_a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = b_a.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel62(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T cfs2, int32_T
  cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs2.data[cfs2_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel623(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel624(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel625(const
  emxArray_creal32_T xCol, const int32_T ix, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = xCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel626
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel627(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel628(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel629(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel63(const
  emxArray_creal32_T cfspos, const emxArray_creal32_T b_cfspos, const int32_T
  c_cfspos, emxArray_creal32_T crossCFS)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfspos);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfspos.data[itime].re;
    ai = -b_cfspos.data[itime].im;
    crossCFS.data[itime].re = cfspos.data[itime].re * cv - cfspos.data[itime].im
      * ai;
    crossCFS.data[itime].im = cfspos.data[itime].re * ai + cfspos.data[itime].im
      * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel630(const
  emxArray_creal32_T w, const int32_T iv9, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel631(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T
  b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel632(const
  emxArray_creal32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel633(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel634(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel635
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel636(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel637(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel638(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel639(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel64(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel640(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f36, real32_T *f37)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f37 = cv_re * a.data[0].re;
    *f36 = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel641(const real32_T
  *f37, const real32_T *f36, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f36;
    c.data[0].re = *f37;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel642(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel643(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel644(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv156)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv156.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel645(const
  emxArray_creal32_T a, const emxArray_int32_T iv156, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv156.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel646(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow].re = cv_re * expanded.data[orow].re;
    c.data[orow].im = cv_re * expanded.data[orow].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel647(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel648(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel649(const
  emxArray_real32_T h, real32_T *f35)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f35 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel65(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel650(const real32_T
  *f35, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f35;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel651(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel652(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel653(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv159)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv159.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel654(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv159, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv159.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel655(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T k;
        b_b = yCol.data[((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) -
          1];
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.re;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * b_b.im;
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel656(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel657(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel658(const
  emxArray_real32_T h, real32_T *f34)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f34 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel659(const real32_T
  *f34, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f34;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel66(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel660(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel661(const
  emxArray_creal32_T yCol, const int32_T iv9, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel662(const
  int32_T OH, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel663(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv160)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv160.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel664(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv177)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv177.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel665(const
  emxArray_creal32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv177,
  const emxArray_int32_T iv160, const int32_T iv9, const int32_T b_iv9,
  emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv160.data[kk] + expanded_dim0 * iv177.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel666(const
  int32_T bcoef, const emxArray_creal32_T expanded, const int32_T nsubs, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = rows.data[itime];
    if (k > 2147483646 - nsubs) {
      k = MAX_int32_T;
    } else {
      k = (nsubs + k) + 1;
    }

    newIm.data[itime] = expanded.data[(k + expanded_dim0 * bcoef) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel667(const real32_T
  cv_im, const real32_T cv_re, const int32_T bcoef, const int32_T nsubs,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nsubs + w_dim0 * bcoef].re = cv_re;
    w.data[nsubs + w_dim0 * bcoef].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel67(const int32_T
  crossCFS, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel68(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel69(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel698(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel699(const
  int32_T b, emxArray_uint32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<uint32_T>(itime) + 1U;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel7(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel70(const int32_T
  xSize, emxArray_creal32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime].re = 0.0F;
    smooth.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel700(const
  creal_T *dc6, const real_T table100[100], const creal_T dc7, const creal_T *dc,
  const int32_T bcoef, const int32_T ix, const int32_T lidx, const int32_T i,
  const int64_T b, emxArray_real_T dv27, real_T q1_dim0, real_T q1_dim1, real_T
  q1_dim2, real_T q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6,
  real_T q1_dim7, real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3,
  real_T p1_dim4, real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0,
  real_T q2_dim1, real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5,
  real_T q2_dim6, real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2,
  real_T p2_dim3, real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7,
  real_T q4_dim0, real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4,
  real_T q4_dim5, real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1,
  real_T p4_dim2, real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6,
  real_T p4_dim7, real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3,
  real_T c_dim4, real_T c_dim5, real_T c_dim6)
{
  __shared__ real_T p1_shared[8];
  __shared__ real_T p2_shared[8];
  __shared__ real_T p4_shared[8];
  __shared__ real_T q1_shared[8];
  __shared__ real_T q2_shared[8];
  __shared__ real_T q4_shared[8];
  __shared__ real_T c_shared[7];
  creal_T z;
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  int32_T itime;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    p1_shared[0] = p1_dim0;
    p1_shared[1] = p1_dim1;
    p1_shared[2] = p1_dim2;
    p1_shared[3] = p1_dim3;
    p1_shared[4] = p1_dim4;
    p1_shared[5] = p1_dim5;
    p1_shared[6] = p1_dim6;
    p1_shared[7] = p1_dim7;
    q1_shared[0] = q1_dim0;
    q1_shared[1] = q1_dim1;
    q1_shared[2] = q1_dim2;
    q1_shared[3] = q1_dim3;
    q1_shared[4] = q1_dim4;
    q1_shared[5] = q1_dim5;
    q1_shared[6] = q1_dim6;
    q1_shared[7] = q1_dim7;
    p2_shared[0] = p2_dim0;
    p2_shared[1] = p2_dim1;
    p2_shared[2] = p2_dim2;
    p2_shared[3] = p2_dim3;
    p2_shared[4] = p2_dim4;
    p2_shared[5] = p2_dim5;
    p2_shared[6] = p2_dim6;
    p2_shared[7] = p2_dim7;
    q2_shared[0] = q2_dim0;
    q2_shared[1] = q2_dim1;
    q2_shared[2] = q2_dim2;
    q2_shared[3] = q2_dim3;
    q2_shared[4] = q2_dim4;
    q2_shared[5] = q2_dim5;
    q2_shared[6] = q2_dim6;
    q2_shared[7] = q2_dim7;
    p4_shared[0] = p4_dim0;
    p4_shared[1] = p4_dim1;
    p4_shared[2] = p4_dim2;
    p4_shared[3] = p4_dim3;
    p4_shared[4] = p4_dim4;
    p4_shared[5] = p4_dim5;
    p4_shared[6] = p4_dim6;
    p4_shared[7] = p4_dim7;
    q4_shared[0] = q4_dim0;
    q4_shared[1] = q4_dim1;
    q4_shared[2] = q4_dim2;
    q4_shared[3] = q4_dim3;
    q4_shared[4] = q4_dim4;
    q4_shared[5] = q4_dim5;
    q4_shared[6] = q4_dim6;
    q4_shared[7] = q4_dim7;
    c_shared[0] = c_dim0;
    c_shared[1] = c_dim1;
    c_shared[2] = c_dim2;
    c_shared[3] = c_dim3;
    c_shared[4] = c_dim4;
    c_shared[5] = c_dim5;
    c_shared[6] = c_dim6;
  }

  __syncthreads();
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal_T tmp;
    creal_T zd;
    int64_T k;
    real_T tkd1mtk;
    k = static_cast<int64_T>(idx);
    tkd1mtk = static_cast<real_T>(lidx + (((static_cast<int32_T>
      (static_cast<int64_T>(i) + k) - ix) - 1) << 1)) / (static_cast<real_T>
      (bcoef) - 1.0);
    zd.re = 5.0 * sqrt((1.0 - tkd1mtk) * (tkd1mtk + 1.0));
    if (isnan(zd.re)) {
      tmp = *dc;
    } else {
      creal_T dk;
      creal_T p1;
      creal_T pt;
      real_T aa;
      real_T ack;
      real_T ak;
      real_T b_atol;
      real_T bb;
      real_T i2Map;
      real_T im;
      real_T re;
      int32_T ocol;
      int32_T orow;
      boolean_T guard1;
      orow = 0;
      i2Map = hypot(zd.re, 0.0);
      if (i2Map > 1.0737418235E+9) {
        orow = 4;
      } else if (i2Map > 32767.999992370605) {
        orow = 3;
      }

      tmp.re = 0.0;
      tmp.im = 0.0;
      bb = hypot(zd.re, 0.0);
      guard1 = false;
      if (bb <= 2.0) {
        ocol = 0;
        b_atol = hypot(zd.re, 0.0);
        if (b_atol == 0.0) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else if (b_atol < 2.2250738585072014E-305) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else {
          pt.re = 0.5 * zd.re;
          if (b_atol > 4.7170688552396617E-153) {
            dk.re = pt.re * pt.re;
            ack = hypot(dk.re, 0.0);
          } else {
            dk.re = 0.0;
            ack = 0.0;
          }

          i2Map = pt.re;
          if (log(i2Map) * 0.0 > -700.92179369444591) {
            b_atol = 2.2204460492503131E-16 * ack;
            pt.re = 1.0;
            pt.im = 0.0;
            if (!static_cast<int32_T>(ack < 2.2204460492503131E-16)) {
              p1.re = 1.0;
              p1.im = 0.0;
              ak = 3.0;
              i2Map = 1.0;
              aa = 2.0;
              do {
                tkd1mtk = 1.0 / i2Map;
                re = p1.re * dk.re - p1.im * 0.0;
                im = p1.re * 0.0 + p1.im * dk.re;
                p1.re = tkd1mtk * re;
                p1.im = tkd1mtk * im;
                pt.re += p1.re;
                pt.im += p1.im;
                i2Map += ak;
                ak += 2.0;
                aa = aa * ack * tkd1mtk;
              } while (!!static_cast<int32_T>(aa > b_atol));
            }

            i2Map = pt.re - pt.im * 0.0;
            tkd1mtk = pt.re * 0.0 + pt.im;
            tmp.re = i2Map - tkd1mtk * 0.0;
            tmp.im = i2Map * 0.0 + tkd1mtk;
          } else {
            ocol = 1;
            if (ack > 0.0) {
              ocol = -1;
            }
          }
        }

        if (ocol < 0) {
          itime = 1;
        } else {
          itime = ocol;
        }

        if ((1 - itime != 0) && (ocol < 0)) {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        if (bb < 21.784271729432426) {
          creal_T ck;
          creal_T cs1;
          creal_T cs2;
          int32_T b_i;
          int32_T icounter;
          boolean_T errflag;
          boolean_T exitg1;
          ocol = 0;
          b_atol = hypot(zd.re, 0.0);
          aa = floor(b_atol);
          ck.re = (aa + 1.0) / zd.re;
          cs2.re = 2.0 / zd.re;
          p1.re = 0.0;
          p1.im = 0.0;
          cs1.re = 1.0;
          cs1.im = 0.0;
          ack = ((aa + 1.0) + 1.0) / b_atol;
          tkd1mtk = ack + sqrt(ack * ack - 1.0);
          i2Map = tkd1mtk * tkd1mtk;
          bb = (i2Map + i2Map) / ((i2Map - 1.0) * (tkd1mtk - 1.0)) /
            2.2204460492503131E-16;
          ak = aa + 1.0;
          errflag = true;
          icounter = 0;
          b_i = 1;
          exitg1 = false;
          while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) && (b_i
                  < 81)) {
            icounter++;
            pt = cs1;
            tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
            i2Map = ck.re * cs1.im + 0.0 * cs1.re;
            cs1.re = p1.re - tkd1mtk;
            cs1.im = p1.im - i2Map;
            p1 = pt;
            ck.re += cs2.re;
            if (hypot(cs1.re, cs1.im) > bb * ak * ak) {
              errflag = false;
              exitg1 = true;
            } else {
              ak++;
              b_i++;
            }
          }

          if (errflag) {
            ocol = -2;
          } else {
            int32_T kk;
            boolean_T guard2;
            icounter++;
            kk = 0;
            guard2 = false;
            if (static_cast<int32_T>(aa) <= 0) {
              p1.re = 0.0;
              p1.im = 0.0;
              cs1.re = 1.0;
              cs1.im = 0.0;
              ck.re = 1.0 / zd.re;
              bb = sqrt(1.0 / b_atol / 2.2204460492503131E-16);
              itime = 1;
              errflag = true;
              b_i = 1;
              exitg1 = false;
              while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                     (b_i < 81)) {
                kk++;
                pt = cs1;
                tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
                i2Map = ck.re * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re - tkd1mtk;
                cs1.im = p1.im - i2Map;
                p1 = pt;
                ck.re += cs2.re;
                i2Map = hypot(cs1.re, cs1.im);
                if (i2Map >= bb * ak * ak) {
                  if (itime == 2) {
                    errflag = false;
                    exitg1 = true;
                  } else {
                    ack = hypot(ck.re, 0.0);
                    tkd1mtk = fmin(ack + sqrt(ack * ack - 1.0), i2Map / hypot
                                   (pt.re, pt.im));
                    bb *= sqrt(tkd1mtk / (tkd1mtk * tkd1mtk - 1.0));
                    itime = 2;
                    b_i++;
                  }
                } else {
                  b_i++;
                }
              }

              if (errflag) {
                ocol = -2;
              } else {
                guard2 = true;
              }
            } else {
              guard2 = true;
            }

            if (guard2) {
              itime = icounter + static_cast<int32_T>(aa);
              kk++;
              if (itime >= kk) {
                kk = itime;
              }

              aa = static_cast<real_T>(kk);
              p1.re = 0.0;
              p1.im = 0.0;
              cs1 = dc7;
              bb = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  bb = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) + (static_cast<real_T>
                    (kk) + 1.0) * ((static_cast<real_T>(kk) + 1.0) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) +
                    (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  bb = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  bb = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((static_cast<
                    real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  bb = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              tkd1mtk = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) +
                    (static_cast<real_T>(kk) + 1.0) * ((static_cast<real_T>(kk)
                    + 1.0) * (i2Map / tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) + (((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  tkd1mtk = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  tkd1mtk = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) *
                    ((((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                      tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((
                    static_cast<real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  tkd1mtk = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              i2Map = exp(bb - tkd1mtk);
              dk.re = 0.0;
              dk.im = 0.0;
              for (b_i = 0; b_i < kk; b_i++) {
                pt = cs1;
                tkd1mtk = aa * cs2.re;
                ack = aa * 0.0;
                bb = tkd1mtk * cs1.re - ack * cs1.im;
                ack = tkd1mtk * cs1.im + ack * cs1.re;
                cs1.re = p1.re + bb;
                cs1.im = p1.im + ack;
                p1 = pt;
                ack = i2Map * (1.0 - 0.0 / aa);
                dk.re += (ack + i2Map) * pt.re;
                dk.im += (ack + i2Map) * pt.im;
                i2Map = ack;
                aa--;
              }

              tmp = cs1;
              pt.re = log(cs2.re);
              re = 0.0 * pt.re;
              im = 0.0 * pt.re;
              pt.re = re + zd.re;
              cs1.re += dk.re;
              cs1.im += dk.im;
              p1.re = 1.0 / hypot(cs1.re, cs1.im);
              if (pt.re == 0.0) {
                pt.re = cos(im);
                pt.im = sin(im);
              } else if (im == 0.0) {
                i2Map = pt.re;
                pt.re = exp(i2Map);
                pt.im = 0.0;
              } else {
                pt.re = CUDART_NAN;
                pt.im = CUDART_NAN;
              }

              i2Map = pt.re * p1.re - pt.im * 0.0;
              tkd1mtk = pt.re * 0.0 + pt.im * p1.re;
              ack = cs1.re * p1.re + cs1.im * 0.0;
              bb = cs1.re * 0.0 - cs1.im * p1.re;
              pt.re = i2Map * ack - tkd1mtk * bb;
              pt.im = i2Map * bb + tkd1mtk * ack;
              re = tmp.re * pt.re - tmp.im * pt.im;
              im = tmp.re * pt.im + tmp.im * pt.re;
              tmp.re = re;
              tmp.im = im;
            }
          }

          if (ocol < 0) {
            if (ocol == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        } else {
          ocol = 0;
          i2Map = sqrt(0.15915494309189535 / zd.re);
          if (zd.re > 700.92179369444591) {
            ocol = -1;
            tmp = *dc;
          } else {
            creal_T ck;
            creal_T cs1;
            creal_T cs2;
            int32_T b_i;
            boolean_T errflag;
            boolean_T exitg1;
            if (zd.re == 0.0) {
              pt.re = 1.0;
            } else {
              pt.re = exp(zd.re);
            }

            p1.re = i2Map * pt.re;
            p1.im = i2Map * 0.0;
            pt.re = 8.0 * zd.re;
            pt.im = 0.0;
            ack = 8.0 * hypot(zd.re, 0.0);
            i2Map = -1.0;
            b_atol = 2.2204460492503131E-16 / ack;
            tkd1mtk = 1.0;
            cs1.re = 1.0;
            cs1.im = 0.0;
            cs2.re = 1.0;
            cs2.im = 0.0;
            ck.re = 1.0;
            ck.im = 0.0;
            ak = 0.0;
            aa = 1.0;
            bb = ack;
            dk = pt;
            errflag = true;
            b_i = 1;
            exitg1 = false;
            while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                   (b_i < 46)) {
              ck.re *= i2Map;
              ck.im *= i2Map;
              if (ck.im == 0.0) {
                re = ck.re / dk.re;
                im = 0.0;
              } else if (ck.re == 0.0) {
                re = 0.0;
                im = CUDART_NAN;
              } else {
                re = ck.re / dk.re;
                im = CUDART_NAN;
              }

              ck.re = re;
              ck.im = im;
              cs2.re += re;
              cs2.im += im;
              tkd1mtk = -tkd1mtk;
              cs1.re += re * tkd1mtk;
              cs1.im += im * tkd1mtk;
              dk.re += pt.re;
              aa = aa * fabs(i2Map) / bb;
              bb += ack;
              ak += 8.0;
              i2Map -= ak;
              if (aa <= b_atol) {
                errflag = false;
                exitg1 = true;
              } else {
                b_i++;
              }
            }

            if (errflag) {
              ocol = -2;
            } else {
              if (zd.re + zd.re < 700.92179369444591) {
                pt.re = -2.0 * zd.re;
                if (pt.re == 0.0) {
                  pt.re = 1.0;
                  pt.im = -0.0;
                } else {
                  i2Map = pt.re;
                  pt.re = exp(i2Map);
                  pt.im = 0.0;
                }

                re = pt.re * cs2.re - pt.im * cs2.im;
                im = pt.re * cs2.im + pt.im * cs2.re;
                cs1.re += re * 0.0 - im * 0.0;
                cs1.im += re * 0.0 + im * 0.0;
              }

              tmp.re = cs1.re * p1.re - cs1.im * p1.im;
              tmp.im = cs1.re * p1.im + cs1.im * p1.re;
            }
          }

          if (ocol < 0) {
            if (ocol == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        }
      }

      if (itime < 0) {
        if (itime == -2) {
          orow = 5;
        } else {
          orow = 2;
        }
      }

      if (orow == 5) {
        tmp = *dc;
      } else if (orow == 2) {
        tmp = *dc6;
      }

      if (zd.re > 0.0) {
        i2Map = tmp.re;
        tmp.re = i2Map;
        tmp.im = 0.0;
      }
    }

    if (tmp.im == 0.0) {
      z.re = tmp.re / 27.239871823604449;
      z.im = 0.0;
    } else if (tmp.re == 0.0) {
      z.re = 0.0;
      z.im = CUDART_NAN;
    } else {
      z.re = tmp.re / 27.239871823604449;
      z.im = CUDART_NAN;
    }

    dv27.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = hypot
      (z.re, z.im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel701(const
  emxArray_real_T a, const int32_T b_a, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel702(const
  emxArray_real_T x, const int32_T b, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.5 * x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel703(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel704(const
  int32_T omega_tmp2, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel705(const
  int32_T G, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    jpvt.data[itime] = 0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel706(const
  int32_T b, const int32_T nsubs, emxArray_real_T G, int32_T G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(nsubs) + 1UL) * (static_cast<uint64_T>(b) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b) + 1UL));
    G.data[kk * G_dim0 + i] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel707(const
  int32_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    tau.data[k] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel708(const
  int32_T i, const int64_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int64_T k;
    k = static_cast<int64_T>(idx);
    tau.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel709(const
  int32_T nsubs, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    jpvt.data[k] = k + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel71(const
  emxArray_creal32_T smooth, const int32_T b, emxArray_creal32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel710(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel711(const
  int32_T omega_tmp2, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel712(const
  emxArray_real_T b, const emxArray_int32_T jpvt, const int32_T nsubs,
  emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    a.data[jpvt.data[i] - 1] = b.data[i];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel713(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 4.0 * b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel714
  (emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] /= 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel715(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel716(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, emxArray_creal32_T
  opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel717(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, const int32_T
  c_crossCFS, emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T
  crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_crossCFS) + 1UL) * (static_cast<uint64_T>
    (b_crossCFS) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_crossCFS) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_crossCFS) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = crossCFS.data[itime + crossCFS_dim0 *
      kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel718(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel719(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel72(const int32_T
  a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel720(const real_T
  toler, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel721(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel722(const
  emxArray_real32_T h, const emxArray_real32_T yCol, real32_T *cv_re,
  emxArray_real32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel723(const real32_T
  *cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * *cv_re;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel724(const
  emxArray_real32_T c, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    w.data[0] = c.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel725(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel726(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel727(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel728(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel729(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel73(const
  emxArray_creal32_T a, const real_T b_a, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = static_cast<real32_T>(b_a) * a.data[0].re;
    *f = static_cast<real32_T>(b_a) * a.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel730(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel731(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel732(const
  emxArray_real32_T y, const int32_T iv9, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel733
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel734(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel735(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel736(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel737(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel738(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel739(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel74(const real32_T *
  f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel740(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv65)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv65.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel741(const
  emxArray_real32_T h, const emxArray_int32_T iv65, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv65.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel742(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b,
  emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    for (int32_T m{0}; m < icounter; m++) {
      int32_T k;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * yCol.data[(icounter - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel743(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel744(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel745(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel746(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel747(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv67)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv67.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel748(const
  emxArray_real32_T yCol, const emxArray_int32_T iv67, const int32_T iv9,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv67.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel749(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel75(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T crossCFS, int32_T
  crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    crossCFS.data[crossCFS_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel750(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel751(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel752(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel753
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel754(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel755(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel756(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel757(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel758(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel759(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel76(const
  emxArray_creal32_T crossCFS, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(crossCFS.data[k].re, crossCFS.data[k].im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel760(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel761(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel762(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel763(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel764(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel765(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv45)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv45.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel766(const
  emxArray_real32_T a, const emxArray_int32_T iv45, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv45.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel767(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel768(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel769(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel77(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel770(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel771(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel772(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv47)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv47.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel773(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv47, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv47.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel774(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel775(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel776(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel777(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel778(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel779(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv52)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv52.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel78(const
  emxArray_real32_T cfs2, const emxArray_real32_T cfs1, const emxArray_real32_T
  y, const int32_T b_y, emxArray_real32_T wtc)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    wtc.data[itime] = y.data[itime] / (cfs1.data[itime] * cfs2.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel780(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv70)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv70.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel781(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv70,
  const emxArray_int32_T iv52, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv52.data[kk] + expanded_dim0 * iv70.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel782(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel79(const int32_T
  lidx, emxArray_real32_T wtc)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    if (wtc.data[i] > 1.0F) {
      wtc.data[i] = 1.0F;
    }
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel8(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel80(const
  emxArray_real32_T wtc, const int32_T b, emxArray_real32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = wtc.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel81(const int32_T
  b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime) + 0.5;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel811(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel812(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel813(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel814
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel815(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel816(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel817(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel818(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel819(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel82(const
  emxArray_real_T m, const int32_T b_m, emxArray_real_T k)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_m);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    k.data[itime] = m.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel820(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel821(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel822(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel823
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel824(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel825(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel826(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel827(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel828(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel829(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel83(const int32_T
  k, emxArray_real_T G)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    G.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel830(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel831(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv51)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv51.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel832(const
  emxArray_real32_T a, const emxArray_int32_T iv51, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv51.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel833(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel834(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel835(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel836(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel837(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel838(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv55)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv55.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel839(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv55, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv55.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel84(const int32_T
  k, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel840(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel841(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel842(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel843(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel844(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel845(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv58)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv58.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel846(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv75)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv75.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel847(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv75,
  const emxArray_int32_T iv58, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv58.data[kk] + expanded_dim0 * iv75.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel848(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel85(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T dv25)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv25.data[itime] = 6.2831853071795862 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel86(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T dv26,
  emxArray_real_T dv25)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    dv25.data[b_k] = cos(dv25.data[b_k]);
    dv26.data[b_k] = 6.2831853071795862 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel87(const int32_T
  b, emxArray_real_T dv26)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv26.data[k] = cos(dv26.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel877(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel878(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel879(const real_T
  toler, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel88(const
  emxArray_real_T k, const emxArray_real_T dv26, const emxArray_real_T dv25,
  const real_T a, const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * (dv25.data[itime] - dv26.data[itime]) / (k.data[itime]
      * k.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel880(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel881(const
  emxArray_real32_T h, const emxArray_real32_T yCol, real32_T *cv_re,
  emxArray_real32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel882(const real32_T
  *cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * *cv_re;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel883(const
  emxArray_real32_T c, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    w.data[0] = c.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel884(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel885(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel886(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel887(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel888(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel889(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel89(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = 2.0 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel890(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel891(const
  emxArray_real32_T y, const int32_T iv9, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel892
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel893(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_real32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel894(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel895(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel896(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel897(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel898(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel899(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv64)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv64.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel9(const int32_T
  offsetH, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[offsetH];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel90(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T y,
  emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    if (fabs(b_y.data[b_k]) < 1.0020841800044864E-292) {
      b_y.data[b_k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * b_y.data[b_k];
      i2Map = sin(i2Map) / i2Map;
      b_y.data[b_k] = i2Map;
    }

    y.data[b_k] = 2.0 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel900(const
  emxArray_real32_T h, const emxArray_int32_T iv64, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv64.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel901(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const int32_T origSiz[2], const int32_T b,
  emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    for (int32_T m{0}; m < icounter; m++) {
      int32_T k;
      k = rows.data[m];
      if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
        k = MIN_int32_T;
      } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * yCol.data[(icounter - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel902(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel903(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel904(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel905(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel906(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv66)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv66.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel907(const
  emxArray_real32_T yCol, const emxArray_int32_T iv66, const int32_T iv9,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv66.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel908(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[k - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[orow] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel909(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel91(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    if (fabs(y.data[k]) < 1.0020841800044864E-292) {
      y.data[k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * y.data[k];
      i2Map = sin(i2Map) / i2Map;
      y.data[k] = i2Map;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel910(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel911(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel912
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel913(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel914(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel915(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel916(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel917(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel918(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel919(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel92(const
  emxArray_real_T y, const real_T a, const emxArray_real_T b_y, const real_T b_a,
  const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += b_a * b_y.data[itime] - a * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel920(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel921(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel922(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel923(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel924(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv44)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv44.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel925(const
  emxArray_real32_T a, const emxArray_int32_T iv44, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv44.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel926(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel927(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel928(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel929(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel93(const real_T
  fa, const real_T r, const int32_T bcoef, const int32_T i1Start, const int32_T
  b, emxArray_real_T sinc4A, emxArray_real_T sinc3A, emxArray_real_T sinc2A,
  emxArray_real_T sinc1A)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T ack;
    real_T bb;
    real_T i2Map;
    real_T tkd1mtk;
    int32_T kk;
    uint32_T i1Map;
    kk = static_cast<int32_T>(idx);
    i1Map = (static_cast<uint32_T>(kk) + static_cast<uint32_T>(i1Start)) + 1U;
    tkd1mtk = (static_cast<real_T>(kk) + 1.0) - static_cast<real_T>(bcoef);
    ack = r * static_cast<real_T>(i1Map);
    i2Map = fa * static_cast<real_T>(i1Map);
    bb = r * tkd1mtk;
    tkd1mtk *= fa;
    if (fabs(ack) < 1.0020841800044864E-292) {
      sinc1A.data[kk] = 1.0;
    } else {
      ack *= 3.1415926535897931;
      sinc1A.data[kk] = sin(ack) / ack;
    }

    if (fabs(i2Map) < 1.0020841800044864E-292) {
      sinc2A.data[kk] = 1.0;
    } else {
      i2Map *= 3.1415926535897931;
      sinc2A.data[kk] = sin(i2Map) / i2Map;
    }

    if (fabs(bb) < 1.0020841800044864E-292) {
      sinc3A.data[kk] = 1.0;
    } else {
      bb *= 3.1415926535897931;
      sinc3A.data[kk] = sin(bb) / bb;
    }

    if (fabs(tkd1mtk) < 1.0020841800044864E-292) {
      sinc4A.data[kk] = 1.0;
    } else {
      tkd1mtk *= 3.1415926535897931;
      sinc4A.data[kk] = sin(tkd1mtk) / tkd1mtk;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel930(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel931(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv46)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv46.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel932(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv46, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv46.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel933(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if (k > 2147483646 - ocol) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel934(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel935(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel936(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel937(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel938(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv50)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv50.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel939(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv69)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv69.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel94(const
  emxArray_real_T sinc4A, const emxArray_real_T sinc2A, const real_T fa, const
  emxArray_real_T sinc3A, const emxArray_real_T sinc1A, const real_T r, const
  int32_T bcoef, const int32_T b, const int32_T c, emxArray_real_T G, int32_T
  G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T itime;
    int32_T kk;
    uint32_T i1Map;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    i1Map = (static_cast<uint32_T>(itime) + static_cast<uint32_T>(kk)) + 1U;
    i2Map = static_cast<real_T>(itime - kk) + static_cast<real_T>(bcoef);
    G.data[itime + G_dim0 * kk] += 0.25 * (r * (sinc1A.data[static_cast<int32_T>
      (i1Map) - 1] + sinc3A.data[static_cast<int32_T>(i2Map) - 1]) - fa *
      (sinc2A.data[static_cast<int32_T>(i1Map) - 1] + sinc4A.data
       [static_cast<int32_T>(i2Map) - 1]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel940(const
  emxArray_real32_T yCol, const int32_T iv9_dim0, const emxArray_int32_T iv69,
  const emxArray_int32_T iv50, const int32_T iv9, const int32_T b_iv9,
  emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_iv9) + 1UL) * (static_cast<uint64_T>(iv9) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(iv9) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(iv9) + 1UL));
    expanded.data[iv50.data[kk] + expanded_dim0 * iv69.data[itime]] =
      yCol.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel941(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T k;
      k = rows.data[m];
      if (k > 2147483646 - orow) {
        k = MAX_int32_T;
      } else {
        k = (orow + k) + 1;
      }

      cv += expanded.data[(k + expanded_dim0 * ocol) - 1] * h.data[(h_dim0 - m)
        - 1];
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel95(const real_T T,
  emxArray_real_T b0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b0.data[0] = T;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel96(const
  emxArray_real_T b, const int32_T c, emxArray_real_T b0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b0.data[itime + 1] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel97(const
  emxArray_real_T b0, const int32_T b_b0, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b0);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = b0.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel970(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel971(const
  emxArray_real32_T opts_x, const int32_T ix, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[ix * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel972(const
  emxArray_real32_T yCol, const int32_T origSiz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(origSiz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel973
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel974(const
  int32_T bcoef, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T kk;
    kk = lshift[0];
    lshift[0] = lshift[1 - bcoef];
    lshift[1 - bcoef] = kk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel975(const int32_T
  ix, const int32_T bcoef, const int32_T nsubs, int32_T origSiz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    origSiz[nsubs - 1] = div_s32_device(bcoef, ix) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel976(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel977(const
  emxArray_real32_T w, const int32_T iv9, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(iv9);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel978(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T ix, const int32_T b,
  const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[ix * kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel979(const
  emxArray_real32_T w, const int32_T iv9_dim0, const int32_T b, const int32_T c,
  emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + iv9_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel98(const int32_T
  G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel980(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel981(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel982
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel983(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_real32_T opts_x, int32_T opts_x_dim0, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel984(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel985(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel986(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel987(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel988(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel989(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel99(const
  emxArray_real_T a, const int32_T ix, const int32_T lidx, const int32_T offsetH,
  emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(offsetH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = a.data[lidx + ix * itime] / 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel990(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv49)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv49.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel991(const
  emxArray_real32_T a, const emxArray_int32_T iv49, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv49.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel992(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T orow;
    orow = static_cast<int32_T>(idx);
    c.data[orow] = expanded.data[orow] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel993(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel994(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel995(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel996(const
  int32_T OH, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(OH);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel997(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv54)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    itime = static_cast<int32_T>(idx);
    k = y.data[itime];
    if ((offsetH < 0) && (k < MIN_int32_T - offsetH)) {
      k = MIN_int32_T;
    } else if ((offsetH > 0) && (k > MAX_int32_T - offsetH)) {
      k = MAX_int32_T;
    } else {
      k += offsetH;
    }

    iv54.data[itime] = k - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel998(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv54, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv54.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel999(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T origSiz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T ocol;
    int32_T orow;
    real32_T cv;
    orow = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(orow)) / (
      static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    icounter = origSiz[0];
    itime = origSiz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T i;
        int32_T k;
        k = rows.data[m];
        if ((orow + 1 < 0) && (k < MAX_int32_T - orow)) {
          i = MIN_int32_T;
        } else if ((orow + 1 > 0) && (k > 2147483646 - orow)) {
          i = MAX_int32_T;
        } else {
          i = (orow + k) + 1;
        }

        k = cols.data[n];
        if ((ocol + 1 < 0) && (k < MAX_int32_T - ocol)) {
          k = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (k > 2147483646 - ocol)) {
          k = MAX_int32_T;
        } else {
          k = (ocol + k) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (k - 1)) - 1] * yCol.data
          [((icounter - m) + origSiz[0] * ((origSiz[1] - n) - 1)) - 1];
      }
    }

    w.data[orow + w_dim0 * ocol] = cv;
  }
}

static void ec_wtcc_once()
{
  mex_InitInfAndNan();
  checkCudaError(mwCudaMalloc(&global_gpu_cv, sizeof(char_T [128])), __FILE__,
                 __LINE__);
  checkCudaError(mwCudaMalloc(&global_gpu_table100, sizeof(real_T [100])),
                 __FILE__, __LINE__);
}

static void emlrtExitTimeCleanupDtorFcn(const void *r)
{
  emlrtExitTimeCleanup(&emlrtContextGlobal);
}

static uint16_T *emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier, int32_T y_size[2])
{
  emlrtMsgIdentifier thisId;
  uint16_T *y_data;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y_data = emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId, y_size);
  emlrtDestroyArray(&b_nullptr);
  return y_data;
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23])
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23])
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(a__output_of_sprintf_), &thisId, y);
  emlrtDestroyArray(&a__output_of_sprintf_);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real32_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real32_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId, y);
  emlrtDestroyArray(&b_nullptr);
}

static uint16_T *emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, int32_T y_size[2])
{
  uint16_T *y_data;
  y_data = b_emlrt_marshallIn(emlrtAlias(u), parentId, y_size);
  emlrtDestroyArray(&u);
  return y_data;
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(tmpStr), &thisId, y);
  emlrtDestroyArray(&tmpStr);
}

static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId)
{
  real_T y;
  y = d_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier)
{
  emlrtMsgIdentifier thisId;
  real_T y;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = emlrt_marshallIn(emlrtAlias(a__output_of_length_), &thisId);
  emlrtDestroyArray(&a__output_of_length_);
  return y;
}

static const mxArray *emlrt_marshallOut(const cell_wrap_0 u_data[], const
  int32_T u_size[2])
{
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T iv[2];
  int32_T n;
  real32_T *pData;
  y = nullptr;
  emlrtAssign(&y, emlrtCreateCellArrayR2014a(2, &u_size[0]));
  n = u_size[1];
  for (int32_T i{0}; i < n; i++) {
    int32_T i1;
    int32_T loopUpperBound;
    b_y = nullptr;
    iv[0] = u_data[i].f1->size[0];
    iv[1] = u_data[i].f1->size[1];
    m = emlrtCreateNumericArray(2, &iv[0], mxSINGLE_CLASS, mxREAL);
    pData = static_cast<real32_T *>(emlrtMxGetData(m));
    i1 = 0;
    loopUpperBound = u_data[i].f1->size[1];
    for (int32_T b_i{0}; b_i < loopUpperBound; b_i++) {
      int32_T b_loopUpperBound;
      b_loopUpperBound = u_data[i].f1->size[0];
      for (int32_T c_i{0}; c_i < b_loopUpperBound; c_i++) {
        pData[i1 + c_i] = u_data[i].f1->data[c_i + u_data[i].f1->size[0] * b_i];
      }

      if (u_data[i].f1->size[0] - 1 >= 0) {
        i1 += u_data[i].f1->size[0];
      }
    }

    emlrtAssign(&b_y, m);
    emlrtSetCell(y, i, b_y);
  }

  return y;
}

static void emxEnsureCapacity_cell_wrap_0(cell_wrap_0 data[65534], const int32_T
  size[2], int32_T oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T newNumel;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = size[0] * size[1];
  if (oldNumel > newNumel) {
    emxTrim_cell_wrap_0_1x65534(data, newNumel, oldNumel);
  } else if (oldNumel < newNumel) {
    emxExpand_cell_wrap_0_1x65534(data, oldNumel, newNumel, srcLocation);
  }
}

static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(char_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<char_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<char_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_creal32_T(emxArray_creal32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(creal32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<creal32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<creal32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(int32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<int32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<int32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(ptrdiff_t));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<ptrdiff_t *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<ptrdiff_t *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(real32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<real32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<real32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(real_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<real_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<real_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(uint32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<uint32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<uint32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxExpand_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex, const emlrtRTEInfo *srcLocation)
{
  int64_T b;
  b = b_computeEndIdx(static_cast<int64_T>(fromIndex), static_cast<int64_T>
                      (toIndex - 1), 1L);
  for (int64_T i{0L}; i <= b; i++) {
    emxInitStruct_cell_wrap_0(&data[static_cast<int32_T>(fromIndex + i)],
      srcLocation, false);
  }
}

static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct)
{
  emxFree_real32_T(&pStruct->f1);
}

static void emxFree_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray)
{
  int32_T numEl;
  numEl = pEmxArray->size[0] * pEmxArray->size[1];
  for (int32_T i{0}; i < numEl; i++) {
    emxFreeStruct_cell_wrap_0(&pEmxArray->data[i]);
  }
}

static void emxFree_char_T(emxArray_char_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_char_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_char_T *>(nullptr);
  }
}

static void emxFree_creal32_T(emxArray_creal32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_creal32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<creal32_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_creal32_T *>(nullptr);
  }
}

static void emxFree_int32_T(emxArray_int32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_int32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_int32_T *>(nullptr);
  }
}

static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_ptrdiff_t *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<ptrdiff_t *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_ptrdiff_t *>(nullptr);
  }
}

static void emxFree_real32_T(emxArray_real32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_real32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<real32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_real32_T *>(nullptr);
  }
}

static void emxFree_real_T(emxArray_real_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_real_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_real_T *>(nullptr);
  }
}

static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_uint32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<uint32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_uint32_T *>(nullptr);
  }
}

static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush)
{
  emxInit_real32_T(&pStruct->f1, 2, srcLocation, doPush);
}

static void emxInit_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray)
{
  pEmxArray->size[0] = 0;
  pEmxArray->size[1] = 0;
}

static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_char_T *emxArray;
  *pEmxArray = static_cast<emxArray_char_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_char_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_char_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<char_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_creal32_T(emxArray_creal32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_creal32_T *emxArray;
  *pEmxArray = static_cast<emxArray_creal32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_creal32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_creal32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<creal32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_int32_T *emxArray;
  *pEmxArray = static_cast<emxArray_int32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_int32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_int32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<int32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_ptrdiff_t *emxArray;
  *pEmxArray = static_cast<emxArray_ptrdiff_t *>(emlrtMallocEmxArray(sizeof
    (emxArray_ptrdiff_t)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_ptrdiff_t, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<ptrdiff_t *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_real32_T(emxArray_real32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_real32_T *emxArray;
  *pEmxArray = static_cast<emxArray_real32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_real32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_real32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<real32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_real_T *emxArray;
  *pEmxArray = static_cast<emxArray_real_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_real_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_real_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<real_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_uint32_T *emxArray;
  *pEmxArray = static_cast<emxArray_uint32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_uint32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_uint32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<uint32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxTrim_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex)
{
  int64_T b;
  b = b_computeEndIdx(static_cast<int64_T>(fromIndex), static_cast<int64_T>
                      (toIndex - 1), 1L);
  for (int64_T i{0L}; i <= b; i++) {
    emxFreeStruct_cell_wrap_0(&data[static_cast<int32_T>(fromIndex + i)]);
  }
}

static real32_T (*f_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2]
{
  static const int32_T dims[2]{ 1, 2 };

  int32_T iv[2];
  real32_T (*ret)[2];
  boolean_T bv[2]{ false, false };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret = (real32_T (*)[2])emlrtMxGetData(src);
  emlrtDestroyArray(&src);
  return ret;
}
static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
*location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "feval", true, location);
}

static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
  m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 3, &pArrays[0],
    "feval", true, location);
}

static void gpuEmxEnsureCapacity_creal32_T(const emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu, boolean_T needsCopy)
{
  creal32_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (creal32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(creal32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  int32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (int32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(int32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_real32_T(const emxArray_real32_T *cpu,
  emxArray_real32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  real32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (real32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(real32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy)
{
  real_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (real_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(real_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  uint32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (uint32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(uint32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxFree_creal32_T(emxArray_creal32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_int32_T(emxArray_int32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_real32_T(emxArray_real32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_real_T(emxArray_real_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxMemcpyCpuToGpu_creal32_T(emxArray_creal32_T *gpu, const
  emxArray_creal32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal32_T), cudaMemcpyHostToDevice), __FILE__,
                 __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_real32_T(emxArray_real32_T *gpu, const
  emxArray_real32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real32_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_creal32_T(emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal32_T), cudaMemcpyDeviceToHost), __FILE__,
                 __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_real32_T(emxArray_real32_T *cpu,
  emxArray_real32_T *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real32_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxReset_creal32_T(emxArray_creal32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_creal32_T));
}

static void gpuEmxReset_int32_T(emxArray_int32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_int32_T));
}

static void gpuEmxReset_real32_T(emxArray_real32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_real32_T));
}

static void gpuEmxReset_real_T(emxArray_real_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_real_T));
}

static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_uint32_T));
}

static const mxArray *length(const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 1, &pArray, "length",
    true, location);
}

static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  fn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else {
    real_T b;
    real_T c;
    b = std::abs(u0);
    c = std::abs(u1);
    if (std::isinf(u1)) {
      if (b == 1.0) {
        y = 1.0;
      } else if (b > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (c == 0.0) {
      y = 1.0;
    } else if (c == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }

  return y;
}

static real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
    y = rtNaN;
  } else if (std::isinf(u1)) {
    y = u0;
  } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {
    real_T q;
    q = std::abs(u0 / u1);
    if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {
      y = 0.0 * u0;
    } else {
      y = std::fmod(u0, u1);
    }
  } else {
    y = std::fmod(u0, u1);
  }

  return y;
}

void b_ec_wtcc_api(ec_wtccStackData *SD, const mxArray * const prhs[6], int32_T
                   nlhs, const mxArray *plhs[2])
{
  emxArray_real32_T *x;
  int32_T c_size[2];
  real32_T (*ds)[2];
  real32_T (*fLims)[2];
  real32_T fVoices;
  real32_T fs;
  uint16_T (*c_data)[131068];
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  // Marshall function inputs
  emxInit_real32_T(&x, 2, &df_emlrtRTEI, true);
  x->canFreeData = false;
  emlrt_marshallIn(emlrtAlias(prhs[0]), "x", x);
  *(uint16_T **)&c_data = emlrt_marshallIn(emlrtAlias(prhs[1]), "c", c_size);
  fs = b_emlrt_marshallIn(emlrtAliasP(prhs[2]), "fs");
  fLims = c_emlrt_marshallIn(emlrtAlias(prhs[3]), "fLims");
  fVoices = b_emlrt_marshallIn(emlrtAliasP(prhs[4]), "fVoices");
  ds = c_emlrt_marshallIn(emlrtAlias(prhs[5]), "ds");

  // Invoke the target function
  emxInit_cell_wrap_0_1x65534(&SD->f1.xx);
  emxInit_cell_wrap_0_1x65534(&SD->f1.yy);
  ec_wtcc(SD, x, *c_data, c_size, fs, *fLims, fVoices, *ds, SD->f1.xx.data,
          SD->f1.xx.size, SD->f1.yy.data, SD->f1.yy.size);
  emxFree_real32_T(&x);

  // Marshall function outputs
  plhs[0] = emlrt_marshallOut(SD->f1.xx.data, SD->f1.xx.size);
  emxFree_cell_wrap_0_1x65534(&SD->f1.xx);
  if (nlhs > 1) {
    plhs[1] = emlrt_marshallOut(SD->f1.yy.data, SD->f1.yy.size);
  }

  emxFree_cell_wrap_0_1x65534(&SD->f1.yy);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

//
// function [xx,yy] = ec_wtcc(x,c,fs,fLims,fVoices,ds)
void ec_wtcc(ec_wtccStackData *SD, const emxArray_real32_T *cpu_x, const
             uint16_T c_data[], const int32_T c_size[2], real32_T fs, const
             real32_T fLims[2], real32_T fVoices, const real32_T ds[2],
             cell_wrap_0 xx_data[], int32_T xx_size[2], cell_wrap_0 yy_data[],
             int32_T yy_size[2])
{
  static const creal_T dc7{ 1.0020841800044864E-289,// re
    0.0                                // im
  };

  static creal_T cpu_dc{ 0.0,          // re
    0.0                                // im
  };

  static creal_T cpu_dc6{ 0.0,         // re
    0.0                                // im
  };

  static const real_T cpu_table100[100]{ 0.0, 0.0, 0.69314718055994529,
    1.791759469228055, 3.1780538303479458, 4.7874917427820458,
    6.5792512120101012, 8.5251613610654147, 10.604602902745251,
    12.801827480081469, 15.104412573075516, 17.502307845873887,
    19.987214495661885, 22.552163853123425, 25.19122118273868, 27.89927138384089,
    30.671860106080672, 33.505073450136891, 36.395445208033053,
    39.339884187199495, 42.335616460753485, 45.380138898476908,
    48.471181351835227, 51.606675567764377, 54.784729398112319,
    58.003605222980518, 61.261701761002, 64.557538627006338, 67.88974313718154,
    71.257038967168015, 74.658236348830158, 78.0922235533153, 81.557959456115043,
    85.054467017581516, 88.580827542197682, 92.1361756036871, 95.7196945421432,
    99.330612454787428, 102.96819861451381, 106.63176026064346,
    110.32063971475739, 114.03421178146171, 117.77188139974507,
    121.53308151543864, 125.3172711493569, 129.12393363912722,
    132.95257503561632, 136.80272263732635, 140.67392364823425,
    144.5657439463449, 148.47776695177302, 152.40959258449735, 156.3608363030788,
    160.3311282166309, 164.32011226319517, 168.32744544842765,
    172.35279713916279, 176.39584840699735, 180.45629141754378,
    184.53382886144948, 188.6281734236716, 192.7390472878449, 196.86618167289,
    201.00931639928152, 205.1681994826412, 209.34258675253685,
    213.53224149456327, 217.73693411395422, 221.95644181913033,
    226.1905483237276, 230.43904356577696, 234.70172344281826,
    238.97838956183432, 243.26884900298271, 247.57291409618688,
    251.89040220972319, 256.22113555000954, 260.56494097186322,
    264.92164979855278, 269.29109765101981, 273.67312428569369,
    278.06757344036612, 282.4742926876304, 286.893133295427, 291.32395009427029,
    295.76660135076065, 300.22094864701415, 304.68685676566872,
    309.1641935801469, 313.65282994987905, 318.1526396202093, 322.66349912672615,
    327.1852877037752, 331.71788719692847, 336.26118197919845, 340.815058870799,
    345.37940706226686, 349.95411804077025, 354.53908551944079,
    359.1342053695754 };

  static const real_T NODES[15]{ -0.99145537112081261, -0.94910791234275849,
    -0.8648644233597691, -0.74153118559939435, -0.58608723546769115,
    -0.40584515137739718, -0.20778495500789851, 0.0, 0.20778495500789851,
    0.40584515137739718, 0.58608723546769115, 0.74153118559939435,
    0.8648644233597691, 0.94910791234275849, 0.99145537112081261 };

  static const real_T dv3[15]{ 0.022935322010529221, 0.063092092629978544,
    0.1047900103222502, 0.14065325971552589, 0.16900472663926791,
    0.19035057806478539, 0.20443294007529891, 0.20948214108472779,
    0.20443294007529891, 0.19035057806478539, 0.16900472663926791,
    0.14065325971552589, 0.1047900103222502, 0.063092092629978544,
    0.022935322010529221 };

  static const real_T dv4[15]{ 0.022935322010529221, -0.066392873538891159,
    0.1047900103222502, -0.13905213177375081, 0.16900472663926791,
    -0.19147947244033353, 0.20443294007529891, -0.20847704258874161,
    0.20443294007529891, -0.19147947244033353, 0.16900472663926791,
    -0.13905213177375081, 0.1047900103222502, -0.066392873538891159,
    0.022935322010529221 };

  static const real_T p1[8]{ 4.9452353592967269, 201.8112620856775,
    2290.8383738313464, 11319.672059033808, 28557.246356716354,
    38484.962284437934, 26377.487876241954, 7225.8139797002877 };

  static const real_T p2[8]{ 4.974607845568932, 542.4138599891071,
    15506.938649783649, 184793.29044456323, 1.0882047694688288E+6,
    3.33815296798703E+6, 5.1066616789273527E+6, 3.0741090548505397E+6 };

  static const real_T p4[8]{ 14745.0216605994, 2.4268133694867045E+6,
    1.2147555740450932E+8, 2.6634324496309772E+9, 2.9403789566345539E+10,
    1.7026657377653989E+11, 4.926125793377431E+11, 5.6062518562239514E+11 };

  static const real_T q1[8]{ 67.482125503037778, 1113.3323938571993,
    7738.7570569353984, 27639.870744033407, 54993.102062261576,
    61611.221800660023, 36351.2759150194, 8785.5363024310136 };

  static const real_T q2[8]{ 183.03283993705926, 7765.0493214450062,
    133190.38279660742, 1.1367058213219696E+6, 5.2679641174379466E+6,
    1.3467014543111017E+7, 1.7827365303532742E+7, 9.5330955918443538E+6 };

  static const real_T q4[8]{ 2690.5301758708993, 639388.56543000927,
    4.1355999302413881E+7, 1.120872109616148E+9, 1.4886137286788137E+10,
    1.0168035862724382E+11, 3.4174763455073773E+11, 4.4631581874197131E+11 };

  static const real_T d_c[7]{ -0.001910444077728, 0.00084171387781295,
    -0.00059523799130430121, 0.0007936507935003503, -0.0027777777777776816,
    0.083333333333333329, 0.0057083835261 };

  static const int32_T iv1[2]{ 1, 7 };

  static const int32_T iv117[2]{ 1, 7 };

  static const int32_T iv118[2]{ 1, 7 };

  static const int32_T iv119[2]{ 1, 7 };

  static const int32_T iv120[2]{ 1, 7 };

  static const int32_T iv122[2]{ 1, 7 };

  static const int32_T iv123[2]{ 1, 7 };

  static const int32_T iv124[2]{ 1, 7 };

  static const int32_T iv125[2]{ 1, 7 };

  static const int32_T iv126[2]{ 1, 7 };

  static const int32_T iv127[2]{ 1, 7 };

  static const int32_T iv129[2]{ 1, 7 };

  static const int32_T iv130[2]{ 1, 7 };

  static const int32_T iv131[2]{ 1, 7 };

  static const int32_T iv132[2]{ 1, 7 };

  static const int32_T iv133[2]{ 1, 7 };

  static const int32_T iv134[2]{ 1, 7 };

  static const int32_T iv135[2]{ 1, 7 };

  static const int32_T iv136[2]{ 1, 7 };

  static const int32_T iv137[2]{ 1, 7 };

  static const int32_T iv138[2]{ 1, 7 };

  static const int32_T iv2[2]{ 1, 7 };

  static const int32_T iv20[2]{ 1, 7 };

  static const int32_T iv21[2]{ 1, 7 };

  static const int32_T iv22[2]{ 1, 7 };

  static const int32_T iv23[2]{ 1, 7 };

  static const int32_T iv25[2]{ 1, 7 };

  static const int32_T iv26[2]{ 1, 7 };

  static const int32_T iv27[2]{ 1, 7 };

  static const int32_T iv28[2]{ 1, 7 };

  static const int32_T iv29[2]{ 1, 7 };

  static const int32_T iv3[2]{ 1, 2 };

  static const int32_T iv30[2]{ 1, 7 };

  static const int32_T iv32[2]{ 1, 7 };

  static const int32_T iv33[2]{ 1, 7 };

  static const int32_T iv34[2]{ 1, 7 };

  static const int32_T iv35[2]{ 1, 7 };

  static const int32_T iv36[2]{ 1, 7 };

  static const int32_T iv37[2]{ 1, 7 };

  static const int32_T iv38[2]{ 1, 7 };

  static const int32_T iv39[2]{ 1, 7 };

  static const int32_T iv4[2]{ 1, 7 };

  static const int32_T iv40[2]{ 1, 7 };

  static const int32_T iv41[2]{ 1, 7 };

  static const int32_T iv5[2]{ 1, 5 };

  static const int32_T iv8[2]{ 1, 7 };

  static const char_T cpu_cv[128]{ '\x00', '\x01', '\x02', '\x03', '\x04',
    '\x05', '\x06', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\x0e', '\x0f',
    '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18',
    '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '\"', '#',
    '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'a',
    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}',
    '~', '\x7f' };

  static const char_T b_b[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n'
  };

  static const char_T cv1[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n'
  };

  static const char_T rfmt[7]{ '%', '2', '3', '.', '1', '5', 'e' };

  static const char_T u[7]{ 's', 'p', 'r', 'i', 'n', 't', 'f' };

  static const char_T b_formatSpec[5]{ '%', '2', '.', '2', 'f' };

  static const char_T b_a[4]{ 'a', 'm', 'o', 'r' };

  static const char_T cv2[4]{ 'b', 'u', 'm', 'p' };

  static const char_T cv3[4]{ 'a', 'm', 'o', 'r' };

  static const char_T formatSpec[2]{ '%', 'f' };

  static const int8_T A[4]{ 1, 1, 0, 0 };

  dim3 block;
  dim3 grid;
  emxArray_char_T *b_tmpStr;
  emxArray_char_T *tmpStr;
  emxArray_creal32_T ab_gpu_expanded;
  emxArray_creal32_T ab_gpu_w;
  emxArray_creal32_T ae_gpu_expanded;
  emxArray_creal32_T b_gpu_cfsDFT;
  emxArray_creal32_T b_gpu_cfspos;
  emxArray_creal32_T b_gpu_cfsposdft;
  emxArray_creal32_T b_gpu_expanded;
  emxArray_creal32_T b_gpu_newIm;
  emxArray_creal32_T b_gpu_opts_x;
  emxArray_creal32_T b_gpu_result;
  emxArray_creal32_T b_gpu_w;
  emxArray_creal32_T b_gpu_xposdft;
  emxArray_creal32_T b_gpu_y1;
  emxArray_creal32_T b_gpu_yCol;
  emxArray_creal32_T bb_gpu_w;
  emxArray_creal32_T be_gpu_expanded;
  emxArray_creal32_T c_gpu_a;
  emxArray_creal32_T c_gpu_c;
  emxArray_creal32_T c_gpu_cfsDFT;
  emxArray_creal32_T c_gpu_expanded;
  emxArray_creal32_T c_gpu_newIm;
  emxArray_creal32_T c_gpu_result;
  emxArray_creal32_T c_gpu_smooth;
  emxArray_creal32_T c_gpu_w;
  emxArray_creal32_T c_gpu_yCol;
  emxArray_creal32_T cb_gpu_expanded;
  emxArray_creal32_T cb_gpu_w;
  emxArray_creal32_T d_gpu_c;
  emxArray_creal32_T d_gpu_newIm;
  emxArray_creal32_T d_gpu_result;
  emxArray_creal32_T d_gpu_smooth;
  emxArray_creal32_T d_gpu_w;
  emxArray_creal32_T d_gpu_yCol;
  emxArray_creal32_T e_gpu_c;
  emxArray_creal32_T e_gpu_expanded;
  emxArray_creal32_T e_gpu_newIm;
  emxArray_creal32_T e_gpu_result;
  emxArray_creal32_T e_gpu_w;
  emxArray_creal32_T e_gpu_x;
  emxArray_creal32_T e_gpu_y;
  emxArray_creal32_T e_gpu_yCol;
  emxArray_creal32_T eb_gpu_expanded;
  emxArray_creal32_T eb_gpu_y;
  emxArray_creal32_T ec_gpu_y;
  emxArray_creal32_T f_gpu_a;
  emxArray_creal32_T f_gpu_c;
  emxArray_creal32_T f_gpu_newIm;
  emxArray_creal32_T f_gpu_result;
  emxArray_creal32_T f_gpu_w;
  emxArray_creal32_T f_gpu_x;
  emxArray_creal32_T f_gpu_yCol;
  emxArray_creal32_T fb_gpu_y;
  emxArray_creal32_T fc_gpu_y;
  emxArray_creal32_T g_gpu_a;
  emxArray_creal32_T g_gpu_c;
  emxArray_creal32_T g_gpu_expanded;
  emxArray_creal32_T g_gpu_newIm;
  emxArray_creal32_T g_gpu_w;
  emxArray_creal32_T g_gpu_x;
  emxArray_creal32_T g_gpu_y;
  emxArray_creal32_T g_gpu_yCol;
  emxArray_creal32_T gb_gpu_expanded;
  emxArray_creal32_T gpu_cfsDFT;
  emxArray_creal32_T gpu_cfspos;
  emxArray_creal32_T gpu_cfsposdft;
  emxArray_creal32_T gpu_crossCFS;
  emxArray_creal32_T gpu_newIm;
  emxArray_creal32_T gpu_result;
  emxArray_creal32_T gpu_w;
  emxArray_creal32_T gpu_xCol;
  emxArray_creal32_T gpu_xposdft;
  emxArray_creal32_T gpu_yCol;
  emxArray_creal32_T h_gpu_a;
  emxArray_creal32_T h_gpu_c;
  emxArray_creal32_T h_gpu_newIm;
  emxArray_creal32_T h_gpu_w;
  emxArray_creal32_T h_gpu_yCol;
  emxArray_creal32_T i_gpu_a;
  emxArray_creal32_T i_gpu_c;
  emxArray_creal32_T i_gpu_expanded;
  emxArray_creal32_T i_gpu_newIm;
  emxArray_creal32_T i_gpu_w;
  emxArray_creal32_T i_gpu_yCol;
  emxArray_creal32_T ib_gpu_expanded;
  emxArray_creal32_T id_gpu_y;
  emxArray_creal32_T j_gpu_a;
  emxArray_creal32_T j_gpu_expanded;
  emxArray_creal32_T j_gpu_newIm;
  emxArray_creal32_T j_gpu_w;
  emxArray_creal32_T j_gpu_yCol;
  emxArray_creal32_T jd_gpu_y;
  emxArray_creal32_T k_gpu_a;
  emxArray_creal32_T k_gpu_newIm;
  emxArray_creal32_T k_gpu_w;
  emxArray_creal32_T k_gpu_yCol;
  emxArray_creal32_T kb_gpu_expanded;
  emxArray_creal32_T l_gpu_a;
  emxArray_creal32_T l_gpu_expanded;
  emxArray_creal32_T l_gpu_newIm;
  emxArray_creal32_T l_gpu_w;
  emxArray_creal32_T l_gpu_yCol;
  emxArray_creal32_T lb_gpu_expanded;
  emxArray_creal32_T m_gpu_a;
  emxArray_creal32_T m_gpu_newIm;
  emxArray_creal32_T m_gpu_w;
  emxArray_creal32_T m_gpu_yCol;
  emxArray_creal32_T n_gpu_expanded;
  emxArray_creal32_T n_gpu_newIm;
  emxArray_creal32_T n_gpu_w;
  emxArray_creal32_T n_gpu_yCol;
  emxArray_creal32_T nb_gpu_expanded;
  emxArray_creal32_T o_gpu_newIm;
  emxArray_creal32_T o_gpu_w;
  emxArray_creal32_T o_gpu_yCol;
  emxArray_creal32_T p_gpu_expanded;
  emxArray_creal32_T p_gpu_newIm;
  emxArray_creal32_T p_gpu_w;
  emxArray_creal32_T p_gpu_y;
  emxArray_creal32_T p_gpu_yCol;
  emxArray_creal32_T pb_gpu_expanded;
  emxArray_creal32_T pb_gpu_y;
  emxArray_creal32_T pc_gpu_y;
  emxArray_creal32_T q_gpu_newIm;
  emxArray_creal32_T q_gpu_w;
  emxArray_creal32_T q_gpu_y;
  emxArray_creal32_T q_gpu_yCol;
  emxArray_creal32_T qb_gpu_y;
  emxArray_creal32_T r_gpu_expanded;
  emxArray_creal32_T r_gpu_newIm;
  emxArray_creal32_T r_gpu_w;
  emxArray_creal32_T r_gpu_y;
  emxArray_creal32_T r_gpu_yCol;
  emxArray_creal32_T rb_gpu_expanded;
  emxArray_creal32_T rb_gpu_y;
  emxArray_creal32_T s_gpu_expanded;
  emxArray_creal32_T s_gpu_newIm;
  emxArray_creal32_T s_gpu_w;
  emxArray_creal32_T s_gpu_yCol;
  emxArray_creal32_T sb_gpu_expanded;
  emxArray_creal32_T t_gpu_newIm;
  emxArray_creal32_T t_gpu_w;
  emxArray_creal32_T tc_gpu_y;
  emxArray_creal32_T u_gpu_expanded;
  emxArray_creal32_T u_gpu_newIm;
  emxArray_creal32_T u_gpu_w;
  emxArray_creal32_T ub_gpu_expanded;
  emxArray_creal32_T uc_gpu_y;
  emxArray_creal32_T v_gpu_newIm;
  emxArray_creal32_T v_gpu_w;
  emxArray_creal32_T vc_gpu_y;
  emxArray_creal32_T w_gpu_expanded;
  emxArray_creal32_T w_gpu_newIm;
  emxArray_creal32_T w_gpu_w;
  emxArray_creal32_T wb_gpu_expanded;
  emxArray_creal32_T x_gpu_w;
  emxArray_creal32_T y_gpu_expanded;
  emxArray_creal32_T y_gpu_w;
  emxArray_creal32_T yb_gpu_expanded;
  emxArray_creal32_T *ab_cpu_c;
  emxArray_creal32_T *ab_cpu_yCol;
  emxArray_creal32_T *ac_cpu_w;
  emxArray_creal32_T *ae_cpu_expanded;
  emxArray_creal32_T *ae_cpu_y;
  emxArray_creal32_T *af_cpu_y;
  emxArray_creal32_T *b_c;
  emxArray_creal32_T *b_cpu_cfsDFT;
  emxArray_creal32_T *b_cpu_cfspos;
  emxArray_creal32_T *b_cpu_cfsposdft;
  emxArray_creal32_T *b_cpu_newIm;
  emxArray_creal32_T *b_cpu_opts_x;
  emxArray_creal32_T *b_cpu_xCol;
  emxArray_creal32_T *b_cpu_xposdft;
  emxArray_creal32_T *b_cpu_y1;
  emxArray_creal32_T *bb_cpu_yCol;
  emxArray_creal32_T *bc_cpu_w;
  emxArray_creal32_T *bd_cpu_expanded;
  emxArray_creal32_T *c;
  emxArray_creal32_T *c_cpu_a;
  emxArray_creal32_T *c_cpu_c;
  emxArray_creal32_T *c_cpu_cfsDFT;
  emxArray_creal32_T *c_cpu_newIm;
  emxArray_creal32_T *c_cpu_smooth;
  emxArray_creal32_T *cb_cpu_yCol;
  emxArray_creal32_T *cc_cpu_w;
  emxArray_creal32_T *ce_cpu_expanded;
  emxArray_creal32_T *cpu_cfsDFT;
  emxArray_creal32_T *cpu_cfspos;
  emxArray_creal32_T *cpu_cfsposdft;
  emxArray_creal32_T *cpu_crossCFS;
  emxArray_creal32_T *cpu_newIm;
  emxArray_creal32_T *cpu_xposdft;
  emxArray_creal32_T *d_cpu_newIm;
  emxArray_creal32_T *db_cpu_yCol;
  emxArray_creal32_T *dc_cpu_w;
  emxArray_creal32_T *dd_cpu_expanded;
  emxArray_creal32_T *e_cpu_expanded;
  emxArray_creal32_T *e_cpu_newIm;
  emxArray_creal32_T *e_cpu_x;
  emxArray_creal32_T *ec_cpu_w;
  emxArray_creal32_T *ee_cpu_expanded;
  emxArray_creal32_T *eh_cpu_y;
  emxArray_creal32_T *f_cpu_expanded;
  emxArray_creal32_T *f_cpu_newIm;
  emxArray_creal32_T *f_cpu_x;
  emxArray_creal32_T *fc_cpu_w;
  emxArray_creal32_T *fd_cpu_expanded;
  emxArray_creal32_T *fh_cpu_y;
  emxArray_creal32_T *g_cpu_newIm;
  emxArray_creal32_T *g_cpu_result;
  emxArray_creal32_T *g_cpu_x;
  emxArray_creal32_T *gc_cpu_expanded;
  emxArray_creal32_T *gc_cpu_w;
  emxArray_creal32_T *gh_cpu_y;
  emxArray_creal32_T *h_cpu_newIm;
  emxArray_creal32_T *h_cpu_result;
  emxArray_creal32_T *h_cpu_smooth;
  emxArray_creal32_T *h_cpu_y;
  emxArray_creal32_T *hd_cpu_expanded;
  emxArray_creal32_T *hh_cpu_y;
  emxArray_creal32_T *i_cpu_newIm;
  emxArray_creal32_T *i_cpu_result;
  emxArray_creal32_T *ic_cpu_expanded;
  emxArray_creal32_T *ih_cpu_y;
  emxArray_creal32_T *j_cpu_newIm;
  emxArray_creal32_T *j_cpu_result;
  emxArray_creal32_T *jc_cpu_expanded;
  emxArray_creal32_T *jd_cpu_expanded;
  emxArray_creal32_T *jh_cpu_y;
  emxArray_creal32_T *k_cpu_newIm;
  emxArray_creal32_T *k_cpu_result;
  emxArray_creal32_T *k_cpu_yCol;
  emxArray_creal32_T *kc_cpu_expanded;
  emxArray_creal32_T *kf_cpu_y;
  emxArray_creal32_T *l_cpu_newIm;
  emxArray_creal32_T *l_cpu_result;
  emxArray_creal32_T *l_cpu_w;
  emxArray_creal32_T *l_cpu_yCol;
  emxArray_creal32_T *ld_cpu_expanded;
  emxArray_creal32_T *m_cpu_newIm;
  emxArray_creal32_T *m_cpu_w;
  emxArray_creal32_T *m_cpu_y;
  emxArray_creal32_T *m_cpu_yCol;
  emxArray_creal32_T *mc_cpu_expanded;
  emxArray_creal32_T *n_cpu_a;
  emxArray_creal32_T *n_cpu_newIm;
  emxArray_creal32_T *n_cpu_w;
  emxArray_creal32_T *n_cpu_yCol;
  emxArray_creal32_T *nd_cpu_expanded;
  emxArray_creal32_T *o_cpu_a;
  emxArray_creal32_T *o_cpu_newIm;
  emxArray_creal32_T *o_cpu_w;
  emxArray_creal32_T *o_cpu_yCol;
  emxArray_creal32_T *ob_cpu_w;
  emxArray_creal32_T *oc_cpu_expanded;
  emxArray_creal32_T *of_cpu_y;
  emxArray_creal32_T *p_cpu_a;
  emxArray_creal32_T *p_cpu_newIm;
  emxArray_creal32_T *p_cpu_w;
  emxArray_creal32_T *p_cpu_yCol;
  emxArray_creal32_T *pb_cpu_w;
  emxArray_creal32_T *pc_cpu_expanded;
  emxArray_creal32_T *pd_cpu_expanded;
  emxArray_creal32_T *q_cpu_a;
  emxArray_creal32_T *q_cpu_newIm;
  emxArray_creal32_T *q_cpu_w;
  emxArray_creal32_T *q_cpu_yCol;
  emxArray_creal32_T *qb_cpu_w;
  emxArray_creal32_T *qc_cpu_expanded;
  emxArray_creal32_T *qf_cpu_y;
  emxArray_creal32_T *r_cpu_a;
  emxArray_creal32_T *r_cpu_newIm;
  emxArray_creal32_T *r_cpu_w;
  emxArray_creal32_T *r_cpu_yCol;
  emxArray_creal32_T *rb_cpu_w;
  emxArray_creal32_T *rc_cpu_expanded;
  emxArray_creal32_T *rd_cpu_expanded;
  emxArray_creal32_T *s_cpu_a;
  emxArray_creal32_T *s_cpu_newIm;
  emxArray_creal32_T *s_cpu_w;
  emxArray_creal32_T *s_cpu_yCol;
  emxArray_creal32_T *sb_cpu_w;
  emxArray_creal32_T *se_cpu_y;
  emxArray_creal32_T *smooth;
  emxArray_creal32_T *t_cpu_a;
  emxArray_creal32_T *t_cpu_newIm;
  emxArray_creal32_T *t_cpu_w;
  emxArray_creal32_T *t_cpu_yCol;
  emxArray_creal32_T *tb_cpu_w;
  emxArray_creal32_T *tc_cpu_expanded;
  emxArray_creal32_T *td_cpu_expanded;
  emxArray_creal32_T *u_cpu_a;
  emxArray_creal32_T *u_cpu_c;
  emxArray_creal32_T *u_cpu_newIm;
  emxArray_creal32_T *u_cpu_w;
  emxArray_creal32_T *u_cpu_yCol;
  emxArray_creal32_T *ub_cpu_w;
  emxArray_creal32_T *ue_cpu_y;
  emxArray_creal32_T *v_cpu_c;
  emxArray_creal32_T *v_cpu_newIm;
  emxArray_creal32_T *v_cpu_yCol;
  emxArray_creal32_T *vb_cpu_w;
  emxArray_creal32_T *vc_cpu_expanded;
  emxArray_creal32_T *vd_cpu_expanded;
  emxArray_creal32_T *w_cpu_c;
  emxArray_creal32_T *w_cpu_newIm;
  emxArray_creal32_T *w_cpu_yCol;
  emxArray_creal32_T *wb_cpu_w;
  emxArray_creal32_T *wf_cpu_y;
  emxArray_creal32_T *x_cpu_c;
  emxArray_creal32_T *x_cpu_yCol;
  emxArray_creal32_T *xb_cpu_w;
  emxArray_creal32_T *xc_cpu_expanded;
  emxArray_creal32_T *xd_cpu_expanded;
  emxArray_creal32_T *xe_cpu_y;
  emxArray_creal32_T *y_cpu_c;
  emxArray_creal32_T *y_cpu_yCol;
  emxArray_creal32_T *yb_cpu_w;
  emxArray_creal32_T *yc_cpu_expanded;
  emxArray_creal32_T *ye_cpu_y;
  emxArray_int32_T ab_gpu_rows;
  emxArray_int32_T ab_gpu_y;
  emxArray_int32_T ac_gpu_rows;
  emxArray_int32_T ac_gpu_y;
  emxArray_int32_T ad_gpu_rows;
  emxArray_int32_T ad_gpu_y;
  emxArray_int32_T ae_gpu_y;
  emxArray_int32_T af_gpu_y;
  emxArray_int32_T ah_gpu_y;
  emxArray_int32_T b_gpu_IPIV;
  emxArray_int32_T b_gpu_cols;
  emxArray_int32_T b_gpu_jpvt;
  emxArray_int32_T b_gpu_omega_tmp1;
  emxArray_int32_T b_gpu_rows;
  emxArray_int32_T bb_gpu_rows;
  emxArray_int32_T bb_gpu_y;
  emxArray_int32_T bc_gpu_rows;
  emxArray_int32_T bc_gpu_y;
  emxArray_int32_T bd_gpu_rows;
  emxArray_int32_T bd_gpu_y;
  emxArray_int32_T be_gpu_y;
  emxArray_int32_T bf_gpu_y;
  emxArray_int32_T bh_gpu_y;
  emxArray_int32_T c_gpu_cols;
  emxArray_int32_T c_gpu_omega_tmp1;
  emxArray_int32_T c_gpu_rows;
  emxArray_int32_T cb_gpu_rows;
  emxArray_int32_T cb_gpu_y;
  emxArray_int32_T cc_gpu_rows;
  emxArray_int32_T cc_gpu_y;
  emxArray_int32_T cd_gpu_rows;
  emxArray_int32_T cd_gpu_y;
  emxArray_int32_T ce_gpu_y;
  emxArray_int32_T cf_gpu_y;
  emxArray_int32_T cg_gpu_y;
  emxArray_int32_T ch_gpu_y;
  emxArray_int32_T d_gpu_cols;
  emxArray_int32_T d_gpu_omega_tmp1;
  emxArray_int32_T d_gpu_rows;
  emxArray_int32_T db_gpu_rows;
  emxArray_int32_T db_gpu_y;
  emxArray_int32_T dc_gpu_rows;
  emxArray_int32_T dc_gpu_y;
  emxArray_int32_T dd_gpu_rows;
  emxArray_int32_T dd_gpu_y;
  emxArray_int32_T de_gpu_y;
  emxArray_int32_T df_gpu_y;
  emxArray_int32_T dg_gpu_y;
  emxArray_int32_T dh_gpu_y;
  emxArray_int32_T e_gpu_cols;
  emxArray_int32_T e_gpu_rows;
  emxArray_int32_T eb_gpu_rows;
  emxArray_int32_T ec_gpu_rows;
  emxArray_int32_T ed_gpu_rows;
  emxArray_int32_T ed_gpu_y;
  emxArray_int32_T ee_gpu_y;
  emxArray_int32_T ef_gpu_y;
  emxArray_int32_T eg_gpu_y;
  emxArray_int32_T eh_gpu_y;
  emxArray_int32_T f_gpu_cols;
  emxArray_int32_T f_gpu_rows;
  emxArray_int32_T fb_gpu_rows;
  emxArray_int32_T fc_gpu_rows;
  emxArray_int32_T fd_gpu_rows;
  emxArray_int32_T fd_gpu_y;
  emxArray_int32_T fe_gpu_y;
  emxArray_int32_T ff_gpu_y;
  emxArray_int32_T fg_gpu_y;
  emxArray_int32_T fh_gpu_y;
  emxArray_int32_T g_gpu_cols;
  emxArray_int32_T g_gpu_rows;
  emxArray_int32_T gb_gpu_rows;
  emxArray_int32_T gc_gpu_rows;
  emxArray_int32_T gd_gpu_rows;
  emxArray_int32_T gd_gpu_y;
  emxArray_int32_T ge_gpu_y;
  emxArray_int32_T gf_gpu_y;
  emxArray_int32_T gg_gpu_y;
  emxArray_int32_T gh_gpu_y;
  emxArray_int32_T gpu_IPIV;
  emxArray_int32_T gpu_cols;
  emxArray_int32_T gpu_iv10;
  emxArray_int32_T gpu_iv100;
  emxArray_int32_T gpu_iv101;
  emxArray_int32_T gpu_iv103;
  emxArray_int32_T gpu_iv107;
  emxArray_int32_T gpu_iv108;
  emxArray_int32_T gpu_iv11;
  emxArray_int32_T gpu_iv12;
  emxArray_int32_T gpu_iv13;
  emxArray_int32_T gpu_iv139;
  emxArray_int32_T gpu_iv14;
  emxArray_int32_T gpu_iv140;
  emxArray_int32_T gpu_iv141;
  emxArray_int32_T gpu_iv142;
  emxArray_int32_T gpu_iv143;
  emxArray_int32_T gpu_iv144;
  emxArray_int32_T gpu_iv145;
  emxArray_int32_T gpu_iv146;
  emxArray_int32_T gpu_iv147;
  emxArray_int32_T gpu_iv148;
  emxArray_int32_T gpu_iv149;
  emxArray_int32_T gpu_iv150;
  emxArray_int32_T gpu_iv151;
  emxArray_int32_T gpu_iv152;
  emxArray_int32_T gpu_iv153;
  emxArray_int32_T gpu_iv154;
  emxArray_int32_T gpu_iv155;
  emxArray_int32_T gpu_iv156;
  emxArray_int32_T gpu_iv159;
  emxArray_int32_T gpu_iv16;
  emxArray_int32_T gpu_iv160;
  emxArray_int32_T gpu_iv161;
  emxArray_int32_T gpu_iv162;
  emxArray_int32_T gpu_iv163;
  emxArray_int32_T gpu_iv164;
  emxArray_int32_T gpu_iv166;
  emxArray_int32_T gpu_iv167;
  emxArray_int32_T gpu_iv168;
  emxArray_int32_T gpu_iv169;
  emxArray_int32_T gpu_iv17;
  emxArray_int32_T gpu_iv170;
  emxArray_int32_T gpu_iv171;
  emxArray_int32_T gpu_iv172;
  emxArray_int32_T gpu_iv173;
  emxArray_int32_T gpu_iv174;
  emxArray_int32_T gpu_iv175;
  emxArray_int32_T gpu_iv176;
  emxArray_int32_T gpu_iv177;
  emxArray_int32_T gpu_iv178;
  emxArray_int32_T gpu_iv179;
  emxArray_int32_T gpu_iv18;
  emxArray_int32_T gpu_iv181;
  emxArray_int32_T gpu_iv183;
  emxArray_int32_T gpu_iv184;
  emxArray_int32_T gpu_iv185;
  emxArray_int32_T gpu_iv186;
  emxArray_int32_T gpu_iv187;
  emxArray_int32_T gpu_iv188;
  emxArray_int32_T gpu_iv189;
  emxArray_int32_T gpu_iv19;
  emxArray_int32_T gpu_iv190;
  emxArray_int32_T gpu_iv191;
  emxArray_int32_T gpu_iv193;
  emxArray_int32_T gpu_iv194;
  emxArray_int32_T gpu_iv195;
  emxArray_int32_T gpu_iv196;
  emxArray_int32_T gpu_iv197;
  emxArray_int32_T gpu_iv199;
  emxArray_int32_T gpu_iv203;
  emxArray_int32_T gpu_iv204;
  emxArray_int32_T gpu_iv42;
  emxArray_int32_T gpu_iv43;
  emxArray_int32_T gpu_iv44;
  emxArray_int32_T gpu_iv45;
  emxArray_int32_T gpu_iv46;
  emxArray_int32_T gpu_iv47;
  emxArray_int32_T gpu_iv48;
  emxArray_int32_T gpu_iv49;
  emxArray_int32_T gpu_iv50;
  emxArray_int32_T gpu_iv51;
  emxArray_int32_T gpu_iv52;
  emxArray_int32_T gpu_iv53;
  emxArray_int32_T gpu_iv54;
  emxArray_int32_T gpu_iv55;
  emxArray_int32_T gpu_iv56;
  emxArray_int32_T gpu_iv57;
  emxArray_int32_T gpu_iv58;
  emxArray_int32_T gpu_iv59;
  emxArray_int32_T gpu_iv62;
  emxArray_int32_T gpu_iv63;
  emxArray_int32_T gpu_iv64;
  emxArray_int32_T gpu_iv65;
  emxArray_int32_T gpu_iv66;
  emxArray_int32_T gpu_iv67;
  emxArray_int32_T gpu_iv69;
  emxArray_int32_T gpu_iv70;
  emxArray_int32_T gpu_iv71;
  emxArray_int32_T gpu_iv72;
  emxArray_int32_T gpu_iv73;
  emxArray_int32_T gpu_iv74;
  emxArray_int32_T gpu_iv75;
  emxArray_int32_T gpu_iv76;
  emxArray_int32_T gpu_iv77;
  emxArray_int32_T gpu_iv78;
  emxArray_int32_T gpu_iv79;
  emxArray_int32_T gpu_iv80;
  emxArray_int32_T gpu_iv81;
  emxArray_int32_T gpu_iv82;
  emxArray_int32_T gpu_iv84;
  emxArray_int32_T gpu_iv86;
  emxArray_int32_T gpu_iv87;
  emxArray_int32_T gpu_iv88;
  emxArray_int32_T gpu_iv89;
  emxArray_int32_T gpu_iv9;
  emxArray_int32_T gpu_iv90;
  emxArray_int32_T gpu_iv91;
  emxArray_int32_T gpu_iv92;
  emxArray_int32_T gpu_iv93;
  emxArray_int32_T gpu_iv94;
  emxArray_int32_T gpu_iv95;
  emxArray_int32_T gpu_iv97;
  emxArray_int32_T gpu_iv98;
  emxArray_int32_T gpu_iv99;
  emxArray_int32_T gpu_jpvt;
  emxArray_int32_T gpu_omega_tmp1;
  emxArray_int32_T gpu_rows;
  emxArray_int32_T h_gpu_cols;
  emxArray_int32_T h_gpu_rows;
  emxArray_int32_T hb_gpu_rows;
  emxArray_int32_T hb_gpu_y;
  emxArray_int32_T hc_gpu_rows;
  emxArray_int32_T hc_gpu_y;
  emxArray_int32_T hd_gpu_rows;
  emxArray_int32_T hd_gpu_y;
  emxArray_int32_T he_gpu_y;
  emxArray_int32_T hf_gpu_y;
  emxArray_int32_T hg_gpu_y;
  emxArray_int32_T i_gpu_cols;
  emxArray_int32_T i_gpu_rows;
  emxArray_int32_T ib_gpu_rows;
  emxArray_int32_T ib_gpu_y;
  emxArray_int32_T ic_gpu_rows;
  emxArray_int32_T ic_gpu_y;
  emxArray_int32_T id_gpu_rows;
  emxArray_int32_T ig_gpu_y;
  emxArray_int32_T j_gpu_cols;
  emxArray_int32_T j_gpu_rows;
  emxArray_int32_T jb_gpu_rows;
  emxArray_int32_T jb_gpu_y;
  emxArray_int32_T jc_gpu_rows;
  emxArray_int32_T jc_gpu_y;
  emxArray_int32_T jd_gpu_rows;
  emxArray_int32_T jg_gpu_y;
  emxArray_int32_T k_gpu_cols;
  emxArray_int32_T k_gpu_rows;
  emxArray_int32_T kb_gpu_rows;
  emxArray_int32_T kb_gpu_y;
  emxArray_int32_T kc_gpu_rows;
  emxArray_int32_T kc_gpu_y;
  emxArray_int32_T kd_gpu_rows;
  emxArray_int32_T kg_gpu_y;
  emxArray_int32_T l_gpu_cols;
  emxArray_int32_T l_gpu_rows;
  emxArray_int32_T lb_gpu_rows;
  emxArray_int32_T lb_gpu_y;
  emxArray_int32_T lc_gpu_rows;
  emxArray_int32_T lc_gpu_y;
  emxArray_int32_T ld_gpu_rows;
  emxArray_int32_T ld_gpu_y;
  emxArray_int32_T le_gpu_y;
  emxArray_int32_T lf_gpu_y;
  emxArray_int32_T lg_gpu_y;
  emxArray_int32_T m_gpu_rows;
  emxArray_int32_T mb_gpu_rows;
  emxArray_int32_T mb_gpu_y;
  emxArray_int32_T mc_gpu_rows;
  emxArray_int32_T mc_gpu_y;
  emxArray_int32_T md_gpu_rows;
  emxArray_int32_T md_gpu_y;
  emxArray_int32_T me_gpu_y;
  emxArray_int32_T mf_gpu_y;
  emxArray_int32_T n_gpu_rows;
  emxArray_int32_T nb_gpu_rows;
  emxArray_int32_T nb_gpu_y;
  emxArray_int32_T nc_gpu_rows;
  emxArray_int32_T nc_gpu_y;
  emxArray_int32_T nd_gpu_rows;
  emxArray_int32_T nd_gpu_y;
  emxArray_int32_T ne_gpu_y;
  emxArray_int32_T nf_gpu_y;
  emxArray_int32_T o_gpu_rows;
  emxArray_int32_T ob_gpu_rows;
  emxArray_int32_T ob_gpu_y;
  emxArray_int32_T oc_gpu_rows;
  emxArray_int32_T oc_gpu_y;
  emxArray_int32_T od_gpu_rows;
  emxArray_int32_T od_gpu_y;
  emxArray_int32_T oe_gpu_y;
  emxArray_int32_T of_gpu_y;
  emxArray_int32_T p_gpu_rows;
  emxArray_int32_T pb_gpu_rows;
  emxArray_int32_T pc_gpu_rows;
  emxArray_int32_T pd_gpu_rows;
  emxArray_int32_T pd_gpu_y;
  emxArray_int32_T pe_gpu_y;
  emxArray_int32_T pf_gpu_y;
  emxArray_int32_T pg_gpu_y;
  emxArray_int32_T q_gpu_rows;
  emxArray_int32_T qb_gpu_rows;
  emxArray_int32_T qc_gpu_rows;
  emxArray_int32_T qd_gpu_y;
  emxArray_int32_T qe_gpu_y;
  emxArray_int32_T qf_gpu_y;
  emxArray_int32_T qg_gpu_y;
  emxArray_int32_T r_gpu_rows;
  emxArray_int32_T rb_gpu_rows;
  emxArray_int32_T rc_gpu_rows;
  emxArray_int32_T rc_gpu_y;
  emxArray_int32_T rd_gpu_y;
  emxArray_int32_T re_gpu_y;
  emxArray_int32_T rf_gpu_y;
  emxArray_int32_T rg_gpu_y;
  emxArray_int32_T s_gpu_rows;
  emxArray_int32_T sb_gpu_rows;
  emxArray_int32_T sc_gpu_rows;
  emxArray_int32_T sc_gpu_y;
  emxArray_int32_T sd_gpu_y;
  emxArray_int32_T se_gpu_y;
  emxArray_int32_T sf_gpu_y;
  emxArray_int32_T sg_gpu_y;
  emxArray_int32_T t_gpu_rows;
  emxArray_int32_T t_gpu_y;
  emxArray_int32_T tb_gpu_rows;
  emxArray_int32_T tb_gpu_y;
  emxArray_int32_T tc_gpu_rows;
  emxArray_int32_T tg_gpu_y;
  emxArray_int32_T u_gpu_rows;
  emxArray_int32_T u_gpu_y;
  emxArray_int32_T ub_gpu_rows;
  emxArray_int32_T ub_gpu_y;
  emxArray_int32_T uc_gpu_rows;
  emxArray_int32_T ug_gpu_y;
  emxArray_int32_T v_gpu_rows;
  emxArray_int32_T v_gpu_y;
  emxArray_int32_T vb_gpu_rows;
  emxArray_int32_T vb_gpu_y;
  emxArray_int32_T vc_gpu_rows;
  emxArray_int32_T vf_gpu_y;
  emxArray_int32_T vg_gpu_y;
  emxArray_int32_T w_gpu_rows;
  emxArray_int32_T w_gpu_y;
  emxArray_int32_T wb_gpu_rows;
  emxArray_int32_T wb_gpu_y;
  emxArray_int32_T wc_gpu_rows;
  emxArray_int32_T wf_gpu_y;
  emxArray_int32_T wg_gpu_y;
  emxArray_int32_T x_gpu_rows;
  emxArray_int32_T x_gpu_y;
  emxArray_int32_T xb_gpu_rows;
  emxArray_int32_T xb_gpu_y;
  emxArray_int32_T xc_gpu_rows;
  emxArray_int32_T xc_gpu_y;
  emxArray_int32_T xd_gpu_y;
  emxArray_int32_T xe_gpu_y;
  emxArray_int32_T xg_gpu_y;
  emxArray_int32_T y_gpu_rows;
  emxArray_int32_T y_gpu_y;
  emxArray_int32_T yb_gpu_rows;
  emxArray_int32_T yb_gpu_y;
  emxArray_int32_T yc_gpu_rows;
  emxArray_int32_T yc_gpu_y;
  emxArray_int32_T yd_gpu_y;
  emxArray_int32_T ye_gpu_y;
  emxArray_int32_T yg_gpu_y;
  emxArray_int32_T *ab_cpu_rows;
  emxArray_int32_T *ab_cpu_y;
  emxArray_int32_T *ac_cpu_rows;
  emxArray_int32_T *ac_cpu_y;
  emxArray_int32_T *ad_cpu_rows;
  emxArray_int32_T *ad_cpu_y;
  emxArray_int32_T *ag_cpu_y;
  emxArray_int32_T *b_cpu_IPIV;
  emxArray_int32_T *b_cpu_cols;
  emxArray_int32_T *b_cpu_jpvt;
  emxArray_int32_T *b_cpu_omega_tmp1;
  emxArray_int32_T *b_cpu_rows;
  emxArray_int32_T *bb_cpu_rows;
  emxArray_int32_T *bb_cpu_y;
  emxArray_int32_T *bc_cpu_rows;
  emxArray_int32_T *bc_cpu_y;
  emxArray_int32_T *bd_cpu_rows;
  emxArray_int32_T *be_cpu_y;
  emxArray_int32_T *bf_cpu_y;
  emxArray_int32_T *bg_cpu_y;
  emxArray_int32_T *c_cpu_cols;
  emxArray_int32_T *c_cpu_omega_tmp1;
  emxArray_int32_T *c_cpu_rows;
  emxArray_int32_T *cb_cpu_rows;
  emxArray_int32_T *cc_cpu_rows;
  emxArray_int32_T *cc_cpu_y;
  emxArray_int32_T *cd_cpu_rows;
  emxArray_int32_T *cd_cpu_y;
  emxArray_int32_T *ce_cpu_y;
  emxArray_int32_T *cf_cpu_y;
  emxArray_int32_T *cpu_IPIV;
  emxArray_int32_T *cpu_cols;
  emxArray_int32_T *cpu_iv10;
  emxArray_int32_T *cpu_iv100;
  emxArray_int32_T *cpu_iv101;
  emxArray_int32_T *cpu_iv103;
  emxArray_int32_T *cpu_iv107;
  emxArray_int32_T *cpu_iv108;
  emxArray_int32_T *cpu_iv11;
  emxArray_int32_T *cpu_iv12;
  emxArray_int32_T *cpu_iv13;
  emxArray_int32_T *cpu_iv139;
  emxArray_int32_T *cpu_iv14;
  emxArray_int32_T *cpu_iv140;
  emxArray_int32_T *cpu_iv141;
  emxArray_int32_T *cpu_iv142;
  emxArray_int32_T *cpu_iv143;
  emxArray_int32_T *cpu_iv144;
  emxArray_int32_T *cpu_iv145;
  emxArray_int32_T *cpu_iv146;
  emxArray_int32_T *cpu_iv147;
  emxArray_int32_T *cpu_iv148;
  emxArray_int32_T *cpu_iv149;
  emxArray_int32_T *cpu_iv150;
  emxArray_int32_T *cpu_iv151;
  emxArray_int32_T *cpu_iv152;
  emxArray_int32_T *cpu_iv153;
  emxArray_int32_T *cpu_iv154;
  emxArray_int32_T *cpu_iv155;
  emxArray_int32_T *cpu_iv156;
  emxArray_int32_T *cpu_iv159;
  emxArray_int32_T *cpu_iv16;
  emxArray_int32_T *cpu_iv160;
  emxArray_int32_T *cpu_iv161;
  emxArray_int32_T *cpu_iv162;
  emxArray_int32_T *cpu_iv163;
  emxArray_int32_T *cpu_iv164;
  emxArray_int32_T *cpu_iv166;
  emxArray_int32_T *cpu_iv167;
  emxArray_int32_T *cpu_iv168;
  emxArray_int32_T *cpu_iv169;
  emxArray_int32_T *cpu_iv17;
  emxArray_int32_T *cpu_iv170;
  emxArray_int32_T *cpu_iv171;
  emxArray_int32_T *cpu_iv172;
  emxArray_int32_T *cpu_iv173;
  emxArray_int32_T *cpu_iv174;
  emxArray_int32_T *cpu_iv175;
  emxArray_int32_T *cpu_iv176;
  emxArray_int32_T *cpu_iv177;
  emxArray_int32_T *cpu_iv178;
  emxArray_int32_T *cpu_iv179;
  emxArray_int32_T *cpu_iv18;
  emxArray_int32_T *cpu_iv181;
  emxArray_int32_T *cpu_iv183;
  emxArray_int32_T *cpu_iv184;
  emxArray_int32_T *cpu_iv185;
  emxArray_int32_T *cpu_iv186;
  emxArray_int32_T *cpu_iv187;
  emxArray_int32_T *cpu_iv188;
  emxArray_int32_T *cpu_iv189;
  emxArray_int32_T *cpu_iv19;
  emxArray_int32_T *cpu_iv190;
  emxArray_int32_T *cpu_iv191;
  emxArray_int32_T *cpu_iv193;
  emxArray_int32_T *cpu_iv194;
  emxArray_int32_T *cpu_iv195;
  emxArray_int32_T *cpu_iv196;
  emxArray_int32_T *cpu_iv197;
  emxArray_int32_T *cpu_iv199;
  emxArray_int32_T *cpu_iv203;
  emxArray_int32_T *cpu_iv204;
  emxArray_int32_T *cpu_iv42;
  emxArray_int32_T *cpu_iv43;
  emxArray_int32_T *cpu_iv44;
  emxArray_int32_T *cpu_iv45;
  emxArray_int32_T *cpu_iv46;
  emxArray_int32_T *cpu_iv47;
  emxArray_int32_T *cpu_iv48;
  emxArray_int32_T *cpu_iv49;
  emxArray_int32_T *cpu_iv50;
  emxArray_int32_T *cpu_iv51;
  emxArray_int32_T *cpu_iv52;
  emxArray_int32_T *cpu_iv53;
  emxArray_int32_T *cpu_iv54;
  emxArray_int32_T *cpu_iv55;
  emxArray_int32_T *cpu_iv56;
  emxArray_int32_T *cpu_iv57;
  emxArray_int32_T *cpu_iv58;
  emxArray_int32_T *cpu_iv59;
  emxArray_int32_T *cpu_iv62;
  emxArray_int32_T *cpu_iv63;
  emxArray_int32_T *cpu_iv64;
  emxArray_int32_T *cpu_iv65;
  emxArray_int32_T *cpu_iv66;
  emxArray_int32_T *cpu_iv67;
  emxArray_int32_T *cpu_iv69;
  emxArray_int32_T *cpu_iv70;
  emxArray_int32_T *cpu_iv71;
  emxArray_int32_T *cpu_iv72;
  emxArray_int32_T *cpu_iv73;
  emxArray_int32_T *cpu_iv74;
  emxArray_int32_T *cpu_iv75;
  emxArray_int32_T *cpu_iv76;
  emxArray_int32_T *cpu_iv77;
  emxArray_int32_T *cpu_iv78;
  emxArray_int32_T *cpu_iv79;
  emxArray_int32_T *cpu_iv80;
  emxArray_int32_T *cpu_iv81;
  emxArray_int32_T *cpu_iv82;
  emxArray_int32_T *cpu_iv84;
  emxArray_int32_T *cpu_iv86;
  emxArray_int32_T *cpu_iv87;
  emxArray_int32_T *cpu_iv88;
  emxArray_int32_T *cpu_iv89;
  emxArray_int32_T *cpu_iv9;
  emxArray_int32_T *cpu_iv90;
  emxArray_int32_T *cpu_iv91;
  emxArray_int32_T *cpu_iv92;
  emxArray_int32_T *cpu_iv93;
  emxArray_int32_T *cpu_iv94;
  emxArray_int32_T *cpu_iv95;
  emxArray_int32_T *cpu_iv97;
  emxArray_int32_T *cpu_iv98;
  emxArray_int32_T *cpu_iv99;
  emxArray_int32_T *cpu_jpvt;
  emxArray_int32_T *cpu_omega_tmp1;
  emxArray_int32_T *cpu_rows;
  emxArray_int32_T *d_cpu_cols;
  emxArray_int32_T *d_cpu_omega_tmp1;
  emxArray_int32_T *d_cpu_rows;
  emxArray_int32_T *db_cpu_rows;
  emxArray_int32_T *db_cpu_y;
  emxArray_int32_T *dc_cpu_rows;
  emxArray_int32_T *dc_cpu_y;
  emxArray_int32_T *dd_cpu_rows;
  emxArray_int32_T *dd_cpu_y;
  emxArray_int32_T *df_cpu_y;
  emxArray_int32_T *dg_cpu_y;
  emxArray_int32_T *e_cpu_cols;
  emxArray_int32_T *e_cpu_rows;
  emxArray_int32_T *eb_cpu_rows;
  emxArray_int32_T *eb_cpu_y;
  emxArray_int32_T *ec_cpu_rows;
  emxArray_int32_T *ec_cpu_y;
  emxArray_int32_T *ed_cpu_rows;
  emxArray_int32_T *ed_cpu_y;
  emxArray_int32_T *ee_cpu_y;
  emxArray_int32_T *ef_cpu_y;
  emxArray_int32_T *eg_cpu_y;
  emxArray_int32_T *f_cpu_cols;
  emxArray_int32_T *f_cpu_rows;
  emxArray_int32_T *fb_cpu_rows;
  emxArray_int32_T *fb_cpu_y;
  emxArray_int32_T *fc_cpu_rows;
  emxArray_int32_T *fc_cpu_y;
  emxArray_int32_T *fd_cpu_rows;
  emxArray_int32_T *fd_cpu_y;
  emxArray_int32_T *fe_cpu_y;
  emxArray_int32_T *ff_cpu_y;
  emxArray_int32_T *fg_cpu_y;
  emxArray_int32_T *g_cpu_cols;
  emxArray_int32_T *g_cpu_rows;
  emxArray_int32_T *gb_cpu_rows;
  emxArray_int32_T *gb_cpu_y;
  emxArray_int32_T *gc_cpu_rows;
  emxArray_int32_T *gc_cpu_y;
  emxArray_int32_T *gd_cpu_rows;
  emxArray_int32_T *gd_cpu_y;
  emxArray_int32_T *ge_cpu_y;
  emxArray_int32_T *gf_cpu_y;
  emxArray_int32_T *gg_cpu_y;
  emxArray_int32_T *h_cpu_cols;
  emxArray_int32_T *h_cpu_rows;
  emxArray_int32_T *hb_cpu_rows;
  emxArray_int32_T *hb_cpu_y;
  emxArray_int32_T *hc_cpu_rows;
  emxArray_int32_T *hd_cpu_rows;
  emxArray_int32_T *hd_cpu_y;
  emxArray_int32_T *he_cpu_y;
  emxArray_int32_T *hf_cpu_y;
  emxArray_int32_T *hg_cpu_y;
  emxArray_int32_T *i_cpu_cols;
  emxArray_int32_T *i_cpu_rows;
  emxArray_int32_T *ib_cpu_rows;
  emxArray_int32_T *ib_cpu_y;
  emxArray_int32_T *ic_cpu_rows;
  emxArray_int32_T *id_cpu_rows;
  emxArray_int32_T *id_cpu_y;
  emxArray_int32_T *ie_cpu_y;
  emxArray_int32_T *ig_cpu_y;
  emxArray_int32_T *j_cpu_cols;
  emxArray_int32_T *j_cpu_rows;
  emxArray_int32_T *j_cpu_y;
  emxArray_int32_T *jb_cpu_rows;
  emxArray_int32_T *jb_cpu_y;
  emxArray_int32_T *jc_cpu_rows;
  emxArray_int32_T *jd_cpu_rows;
  emxArray_int32_T *jd_cpu_y;
  emxArray_int32_T *je_cpu_y;
  emxArray_int32_T *jg_cpu_y;
  emxArray_int32_T *k_cpu_cols;
  emxArray_int32_T *k_cpu_rows;
  emxArray_int32_T *k_cpu_y;
  emxArray_int32_T *kb_cpu_rows;
  emxArray_int32_T *kb_cpu_y;
  emxArray_int32_T *kc_cpu_rows;
  emxArray_int32_T *kc_cpu_y;
  emxArray_int32_T *kd_cpu_rows;
  emxArray_int32_T *kd_cpu_y;
  emxArray_int32_T *ke_cpu_y;
  emxArray_int32_T *kg_cpu_y;
  emxArray_int32_T *l_cpu_cols;
  emxArray_int32_T *l_cpu_rows;
  emxArray_int32_T *l_cpu_y;
  emxArray_int32_T *lb_cpu_rows;
  emxArray_int32_T *lb_cpu_y;
  emxArray_int32_T *lc_cpu_rows;
  emxArray_int32_T *lc_cpu_y;
  emxArray_int32_T *ld_cpu_rows;
  emxArray_int32_T *ld_cpu_y;
  emxArray_int32_T *le_cpu_y;
  emxArray_int32_T *lf_cpu_y;
  emxArray_int32_T *lg_cpu_y;
  emxArray_int32_T *m_cpu_rows;
  emxArray_int32_T *mb_cpu_rows;
  emxArray_int32_T *mb_cpu_y;
  emxArray_int32_T *mc_cpu_rows;
  emxArray_int32_T *mc_cpu_y;
  emxArray_int32_T *md_cpu_rows;
  emxArray_int32_T *md_cpu_y;
  emxArray_int32_T *me_cpu_y;
  emxArray_int32_T *mf_cpu_y;
  emxArray_int32_T *mg_cpu_y;
  emxArray_int32_T *n_cpu_rows;
  emxArray_int32_T *n_cpu_y;
  emxArray_int32_T *nb_cpu_rows;
  emxArray_int32_T *nb_cpu_y;
  emxArray_int32_T *nc_cpu_rows;
  emxArray_int32_T *nd_cpu_rows;
  emxArray_int32_T *nd_cpu_y;
  emxArray_int32_T *ne_cpu_y;
  emxArray_int32_T *nf_cpu_y;
  emxArray_int32_T *ng_cpu_y;
  emxArray_int32_T *o_cpu_rows;
  emxArray_int32_T *o_cpu_y;
  emxArray_int32_T *ob_cpu_rows;
  emxArray_int32_T *ob_cpu_y;
  emxArray_int32_T *oc_cpu_rows;
  emxArray_int32_T *oc_cpu_y;
  emxArray_int32_T *od_cpu_rows;
  emxArray_int32_T *od_cpu_y;
  emxArray_int32_T *oe_cpu_y;
  emxArray_int32_T *og_cpu_y;
  emxArray_int32_T *p_cpu_rows;
  emxArray_int32_T *p_cpu_y;
  emxArray_int32_T *pb_cpu_rows;
  emxArray_int32_T *pb_cpu_y;
  emxArray_int32_T *pc_cpu_rows;
  emxArray_int32_T *pd_cpu_rows;
  emxArray_int32_T *pd_cpu_y;
  emxArray_int32_T *pe_cpu_y;
  emxArray_int32_T *pf_cpu_y;
  emxArray_int32_T *pg_cpu_y;
  emxArray_int32_T *q_cpu_rows;
  emxArray_int32_T *qb_cpu_rows;
  emxArray_int32_T *qb_cpu_y;
  emxArray_int32_T *qc_cpu_rows;
  emxArray_int32_T *qd_cpu_y;
  emxArray_int32_T *qe_cpu_y;
  emxArray_int32_T *qg_cpu_y;
  emxArray_int32_T *r_cpu_rows;
  emxArray_int32_T *rb_cpu_rows;
  emxArray_int32_T *rc_cpu_rows;
  emxArray_int32_T *rc_cpu_y;
  emxArray_int32_T *rd_cpu_y;
  emxArray_int32_T *re_cpu_y;
  emxArray_int32_T *rg_cpu_y;
  emxArray_int32_T *s_cpu_rows;
  emxArray_int32_T *s_cpu_y;
  emxArray_int32_T *sb_cpu_rows;
  emxArray_int32_T *sb_cpu_y;
  emxArray_int32_T *sc_cpu_rows;
  emxArray_int32_T *sd_cpu_y;
  emxArray_int32_T *sf_cpu_y;
  emxArray_int32_T *sg_cpu_y;
  emxArray_int32_T *t_cpu_rows;
  emxArray_int32_T *t_cpu_y;
  emxArray_int32_T *tb_cpu_rows;
  emxArray_int32_T *tc_cpu_rows;
  emxArray_int32_T *te_cpu_y;
  emxArray_int32_T *tg_cpu_y;
  emxArray_int32_T *u_cpu_rows;
  emxArray_int32_T *u_cpu_y;
  emxArray_int32_T *ub_cpu_rows;
  emxArray_int32_T *ub_cpu_y;
  emxArray_int32_T *uc_cpu_rows;
  emxArray_int32_T *uc_cpu_y;
  emxArray_int32_T *ud_cpu_y;
  emxArray_int32_T *ug_cpu_y;
  emxArray_int32_T *v_cpu_rows;
  emxArray_int32_T *vb_cpu_rows;
  emxArray_int32_T *vb_cpu_y;
  emxArray_int32_T *vc_cpu_rows;
  emxArray_int32_T *vd_cpu_y;
  emxArray_int32_T *ve_cpu_y;
  emxArray_int32_T *vf_cpu_y;
  emxArray_int32_T *vg_cpu_y;
  emxArray_int32_T *w_cpu_rows;
  emxArray_int32_T *wb_cpu_rows;
  emxArray_int32_T *wc_cpu_rows;
  emxArray_int32_T *wc_cpu_y;
  emxArray_int32_T *wd_cpu_y;
  emxArray_int32_T *we_cpu_y;
  emxArray_int32_T *wg_cpu_y;
  emxArray_int32_T *x_cpu_rows;
  emxArray_int32_T *xb_cpu_rows;
  emxArray_int32_T *xc_cpu_rows;
  emxArray_int32_T *xc_cpu_y;
  emxArray_int32_T *xf_cpu_y;
  emxArray_int32_T *y_cpu_rows;
  emxArray_int32_T *yb_cpu_rows;
  emxArray_int32_T *yc_cpu_rows;
  emxArray_int32_T *yc_cpu_y;
  emxArray_int32_T *yf_cpu_y;
  emxArray_ptrdiff_t *b_jpvt_t;
  emxArray_ptrdiff_t *jpvt_t;
  emxArray_real32_T ab_gpu_c;
  emxArray_real32_T ab_gpu_yCol;
  emxArray_real32_T ac_gpu_expanded;
  emxArray_real32_T ac_gpu_w;
  emxArray_real32_T ad_gpu_expanded;
  emxArray_real32_T ag_gpu_y;
  emxArray_real32_T b_gpu_a;
  emxArray_real32_T b_gpu_c;
  emxArray_real32_T b_gpu_h;
  emxArray_real32_T b_gpu_opts_filter;
  emxArray_real32_T b_gpu_psihat;
  emxArray_real32_T b_gpu_smooth;
  emxArray_real32_T b_gpu_x;
  emxArray_real32_T b_gpu_xCol;
  emxArray_real32_T b_gpu_xv;
  emxArray_real32_T bb_gpu_expanded;
  emxArray_real32_T bb_gpu_yCol;
  emxArray_real32_T bc_gpu_expanded;
  emxArray_real32_T bc_gpu_w;
  emxArray_real32_T bd_gpu_expanded;
  emxArray_real32_T c_gpu_x;
  emxArray_real32_T cb_gpu_yCol;
  emxArray_real32_T cc_gpu_expanded;
  emxArray_real32_T cc_gpu_w;
  emxArray_real32_T cd_gpu_expanded;
  emxArray_real32_T ce_gpu_expanded;
  emxArray_real32_T d_gpu_expanded;
  emxArray_real32_T d_gpu_h;
  emxArray_real32_T d_gpu_x;
  emxArray_real32_T d_gpu_y;
  emxArray_real32_T db_gpu_expanded;
  emxArray_real32_T db_gpu_w;
  emxArray_real32_T db_gpu_yCol;
  emxArray_real32_T dc_gpu_expanded;
  emxArray_real32_T dc_gpu_w;
  emxArray_real32_T dd_gpu_expanded;
  emxArray_real32_T de_gpu_expanded;
  emxArray_real32_T e_gpu_smooth;
  emxArray_real32_T eb_gpu_w;
  emxArray_real32_T ec_gpu_expanded;
  emxArray_real32_T ec_gpu_w;
  emxArray_real32_T ed_gpu_expanded;
  emxArray_real32_T ee_gpu_expanded;
  emxArray_real32_T f_gpu_expanded;
  emxArray_real32_T f_gpu_smooth;
  emxArray_real32_T f_gpu_y;
  emxArray_real32_T fb_gpu_expanded;
  emxArray_real32_T fb_gpu_w;
  emxArray_real32_T fc_gpu_expanded;
  emxArray_real32_T fc_gpu_w;
  emxArray_real32_T fd_gpu_expanded;
  emxArray_real32_T fe_gpu_expanded;
  emxArray_real32_T g_gpu_result;
  emxArray_real32_T g_gpu_smooth;
  emxArray_real32_T gb_gpu_w;
  emxArray_real32_T gc_gpu_expanded;
  emxArray_real32_T gd_gpu_expanded;
  emxArray_real32_T gpu_a;
  emxArray_real32_T gpu_c;
  emxArray_real32_T gpu_cfs1;
  emxArray_real32_T gpu_cfs2;
  emxArray_real32_T gpu_expanded;
  emxArray_real32_T gpu_fv;
  emxArray_real32_T gpu_opts_filter;
  emxArray_real32_T gpu_opts_x;
  emxArray_real32_T gpu_psihat;
  emxArray_real32_T gpu_smooth;
  emxArray_real32_T gpu_wtc;
  emxArray_real32_T gpu_x;
  emxArray_real32_T gpu_xv;
  emxArray_real32_T gpu_y;
  emxArray_real32_T gpu_y1;
  emxArray_real32_T h_gpu_expanded;
  emxArray_real32_T h_gpu_result;
  emxArray_real32_T h_gpu_smooth;
  emxArray_real32_T h_gpu_y;
  emxArray_real32_T hb_gpu_expanded;
  emxArray_real32_T hb_gpu_w;
  emxArray_real32_T hc_gpu_expanded;
  emxArray_real32_T hd_gpu_expanded;
  emxArray_real32_T i_gpu_result;
  emxArray_real32_T i_gpu_x;
  emxArray_real32_T i_gpu_y;
  emxArray_real32_T ib_gpu_w;
  emxArray_real32_T ic_gpu_expanded;
  emxArray_real32_T id_gpu_expanded;
  emxArray_real32_T ie_gpu_y;
  emxArray_real32_T if_gpu_y;
  emxArray_real32_T j_gpu_c;
  emxArray_real32_T j_gpu_result;
  emxArray_real32_T j_gpu_x;
  emxArray_real32_T jb_gpu_expanded;
  emxArray_real32_T jb_gpu_w;
  emxArray_real32_T jc_gpu_expanded;
  emxArray_real32_T jd_gpu_expanded;
  emxArray_real32_T je_gpu_y;
  emxArray_real32_T jf_gpu_y;
  emxArray_real32_T k_gpu_c;
  emxArray_real32_T k_gpu_expanded;
  emxArray_real32_T k_gpu_result;
  emxArray_real32_T k_gpu_x;
  emxArray_real32_T kb_gpu_w;
  emxArray_real32_T kc_gpu_expanded;
  emxArray_real32_T kd_gpu_expanded;
  emxArray_real32_T l_gpu_c;
  emxArray_real32_T l_gpu_result;
  emxArray_real32_T l_gpu_x;
  emxArray_real32_T lb_gpu_w;
  emxArray_real32_T lc_gpu_expanded;
  emxArray_real32_T ld_gpu_expanded;
  emxArray_real32_T m_gpu_c;
  emxArray_real32_T m_gpu_expanded;
  emxArray_real32_T m_gpu_x;
  emxArray_real32_T mb_gpu_expanded;
  emxArray_real32_T mb_gpu_w;
  emxArray_real32_T mc_gpu_expanded;
  emxArray_real32_T md_gpu_expanded;
  emxArray_real32_T mg_gpu_y;
  emxArray_real32_T n_gpu_a;
  emxArray_real32_T n_gpu_c;
  emxArray_real32_T n_gpu_x;
  emxArray_real32_T nb_gpu_w;
  emxArray_real32_T nc_gpu_expanded;
  emxArray_real32_T nd_gpu_expanded;
  emxArray_real32_T ng_gpu_y;
  emxArray_real32_T o_gpu_a;
  emxArray_real32_T o_gpu_c;
  emxArray_real32_T o_gpu_expanded;
  emxArray_real32_T o_gpu_x;
  emxArray_real32_T ob_gpu_expanded;
  emxArray_real32_T ob_gpu_w;
  emxArray_real32_T oc_gpu_expanded;
  emxArray_real32_T od_gpu_expanded;
  emxArray_real32_T p_gpu_a;
  emxArray_real32_T p_gpu_c;
  emxArray_real32_T p_gpu_x;
  emxArray_real32_T pb_gpu_w;
  emxArray_real32_T pc_gpu_expanded;
  emxArray_real32_T pd_gpu_expanded;
  emxArray_real32_T q_gpu_a;
  emxArray_real32_T q_gpu_c;
  emxArray_real32_T q_gpu_expanded;
  emxArray_real32_T q_gpu_x;
  emxArray_real32_T qb_gpu_expanded;
  emxArray_real32_T qb_gpu_w;
  emxArray_real32_T qc_gpu_expanded;
  emxArray_real32_T qd_gpu_expanded;
  emxArray_real32_T r_gpu_a;
  emxArray_real32_T r_gpu_c;
  emxArray_real32_T rb_gpu_w;
  emxArray_real32_T rc_gpu_expanded;
  emxArray_real32_T rd_gpu_expanded;
  emxArray_real32_T s_gpu_a;
  emxArray_real32_T s_gpu_c;
  emxArray_real32_T sb_gpu_w;
  emxArray_real32_T sc_gpu_expanded;
  emxArray_real32_T sd_gpu_expanded;
  emxArray_real32_T t_gpu_a;
  emxArray_real32_T t_gpu_c;
  emxArray_real32_T t_gpu_expanded;
  emxArray_real32_T t_gpu_yCol;
  emxArray_real32_T tb_gpu_expanded;
  emxArray_real32_T tb_gpu_w;
  emxArray_real32_T tc_gpu_expanded;
  emxArray_real32_T td_gpu_expanded;
  emxArray_real32_T td_gpu_y;
  emxArray_real32_T te_gpu_y;
  emxArray_real32_T tf_gpu_y;
  emxArray_real32_T u_gpu_a;
  emxArray_real32_T u_gpu_c;
  emxArray_real32_T u_gpu_yCol;
  emxArray_real32_T ub_gpu_w;
  emxArray_real32_T uc_gpu_expanded;
  emxArray_real32_T ud_gpu_expanded;
  emxArray_real32_T ud_gpu_y;
  emxArray_real32_T ue_gpu_y;
  emxArray_real32_T v_gpu_c;
  emxArray_real32_T v_gpu_expanded;
  emxArray_real32_T v_gpu_yCol;
  emxArray_real32_T vb_gpu_expanded;
  emxArray_real32_T vb_gpu_w;
  emxArray_real32_T vc_gpu_expanded;
  emxArray_real32_T vd_gpu_expanded;
  emxArray_real32_T vd_gpu_y;
  emxArray_real32_T ve_gpu_y;
  emxArray_real32_T w_gpu_c;
  emxArray_real32_T w_gpu_yCol;
  emxArray_real32_T wb_gpu_w;
  emxArray_real32_T wc_gpu_expanded;
  emxArray_real32_T wd_gpu_expanded;
  emxArray_real32_T x_gpu_c;
  emxArray_real32_T x_gpu_expanded;
  emxArray_real32_T x_gpu_yCol;
  emxArray_real32_T xb_gpu_expanded;
  emxArray_real32_T xb_gpu_w;
  emxArray_real32_T xc_gpu_expanded;
  emxArray_real32_T xd_gpu_expanded;
  emxArray_real32_T xf_gpu_y;
  emxArray_real32_T y_gpu_c;
  emxArray_real32_T y_gpu_yCol;
  emxArray_real32_T yb_gpu_w;
  emxArray_real32_T yc_gpu_expanded;
  emxArray_real32_T yd_gpu_expanded;
  emxArray_real32_T yf_gpu_y;
  emxArray_real32_T *ab_cpu_expanded;
  emxArray_real32_T *ab_cpu_w;
  emxArray_real32_T *ac_cpu_expanded;
  emxArray_real32_T *ad_cpu_expanded;
  emxArray_real32_T *ah_cpu_y;
  emxArray_real32_T *b_cpu_a;
  emxArray_real32_T *b_cpu_c;
  emxArray_real32_T *b_cpu_expanded;
  emxArray_real32_T *b_cpu_h;
  emxArray_real32_T *b_cpu_opts_filter;
  emxArray_real32_T *b_cpu_psihat;
  emxArray_real32_T *b_cpu_result;
  emxArray_real32_T *b_cpu_smooth;
  emxArray_real32_T *b_cpu_w;
  emxArray_real32_T *b_cpu_x;
  emxArray_real32_T *b_cpu_xv;
  emxArray_real32_T *b_cpu_yCol;
  emxArray_real32_T *bb_cpu_expanded;
  emxArray_real32_T *bb_cpu_w;
  emxArray_real32_T *bc_cpu_expanded;
  emxArray_real32_T *be_cpu_expanded;
  emxArray_real32_T *bh_cpu_y;
  emxArray_real32_T *c_cpu_expanded;
  emxArray_real32_T *c_cpu_result;
  emxArray_real32_T *c_cpu_w;
  emxArray_real32_T *c_cpu_x;
  emxArray_real32_T *c_cpu_yCol;
  emxArray_real32_T *cb_cpu_expanded;
  emxArray_real32_T *cb_cpu_w;
  emxArray_real32_T *cc_cpu_expanded;
  emxArray_real32_T *cd_cpu_expanded;
  emxArray_real32_T *ch_cpu_y;
  emxArray_real32_T *cpu_a;
  emxArray_real32_T *cpu_c;
  emxArray_real32_T *cpu_cfs1;
  emxArray_real32_T *cpu_cfs2;
  emxArray_real32_T *cpu_expanded;
  emxArray_real32_T *cpu_fv;
  emxArray_real32_T *cpu_opts_filter;
  emxArray_real32_T *cpu_opts_x;
  emxArray_real32_T *cpu_psihat;
  emxArray_real32_T *cpu_result;
  emxArray_real32_T *cpu_smooth;
  emxArray_real32_T *cpu_wtc;
  emxArray_real32_T *cpu_xCol;
  emxArray_real32_T *cpu_xv;
  emxArray_real32_T *cpu_y;
  emxArray_real32_T *cpu_y1;
  emxArray_real32_T *cpu_yCol;
  emxArray_real32_T *d_cpu_c;
  emxArray_real32_T *d_cpu_expanded;
  emxArray_real32_T *d_cpu_h;
  emxArray_real32_T *d_cpu_result;
  emxArray_real32_T *d_cpu_smooth;
  emxArray_real32_T *d_cpu_w;
  emxArray_real32_T *d_cpu_x;
  emxArray_real32_T *d_cpu_yCol;
  emxArray_real32_T *db_cpu_expanded;
  emxArray_real32_T *db_cpu_w;
  emxArray_real32_T *dc_cpu_expanded;
  emxArray_real32_T *de_cpu_expanded;
  emxArray_real32_T *dh_cpu_y;
  emxArray_real32_T *e_cpu_a;
  emxArray_real32_T *e_cpu_c;
  emxArray_real32_T *e_cpu_result;
  emxArray_real32_T *e_cpu_smooth;
  emxArray_real32_T *e_cpu_w;
  emxArray_real32_T *e_cpu_yCol;
  emxArray_real32_T *eb_cpu_expanded;
  emxArray_real32_T *eb_cpu_w;
  emxArray_real32_T *ec_cpu_expanded;
  emxArray_real32_T *ed_cpu_expanded;
  emxArray_real32_T *f_cpu_a;
  emxArray_real32_T *f_cpu_c;
  emxArray_real32_T *f_cpu_result;
  emxArray_real32_T *f_cpu_smooth;
  emxArray_real32_T *f_cpu_w;
  emxArray_real32_T *f_cpu_yCol;
  emxArray_real32_T *fb_cpu_expanded;
  emxArray_real32_T *fb_cpu_w;
  emxArray_real32_T *fc_cpu_expanded;
  emxArray_real32_T *fe_cpu_expanded;
  emxArray_real32_T *g_cpu_a;
  emxArray_real32_T *g_cpu_c;
  emxArray_real32_T *g_cpu_expanded;
  emxArray_real32_T *g_cpu_smooth;
  emxArray_real32_T *g_cpu_w;
  emxArray_real32_T *g_cpu_y;
  emxArray_real32_T *g_cpu_yCol;
  emxArray_real32_T *gb_cpu_expanded;
  emxArray_real32_T *gb_cpu_w;
  emxArray_real32_T *gd_cpu_expanded;
  emxArray_real32_T *h_cpu_a;
  emxArray_real32_T *h_cpu_c;
  emxArray_real32_T *h_cpu_expanded;
  emxArray_real32_T *h_cpu_w;
  emxArray_real32_T *h_cpu_yCol;
  emxArray_real32_T *hb_cpu_expanded;
  emxArray_real32_T *hb_cpu_w;
  emxArray_real32_T *hc_cpu_expanded;
  emxArray_real32_T *i_cpu_a;
  emxArray_real32_T *i_cpu_c;
  emxArray_real32_T *i_cpu_expanded;
  emxArray_real32_T *i_cpu_w;
  emxArray_real32_T *i_cpu_x;
  emxArray_real32_T *i_cpu_y;
  emxArray_real32_T *i_cpu_yCol;
  emxArray_real32_T *ib_cpu_expanded;
  emxArray_real32_T *ib_cpu_w;
  emxArray_real32_T *id_cpu_expanded;
  emxArray_real32_T *j_cpu_a;
  emxArray_real32_T *j_cpu_c;
  emxArray_real32_T *j_cpu_expanded;
  emxArray_real32_T *j_cpu_w;
  emxArray_real32_T *j_cpu_x;
  emxArray_real32_T *j_cpu_yCol;
  emxArray_real32_T *jb_cpu_expanded;
  emxArray_real32_T *jb_cpu_w;
  emxArray_real32_T *jc_cpu_y;
  emxArray_real32_T *k_cpu_a;
  emxArray_real32_T *k_cpu_c;
  emxArray_real32_T *k_cpu_expanded;
  emxArray_real32_T *k_cpu_w;
  emxArray_real32_T *k_cpu_x;
  emxArray_real32_T *kb_cpu_expanded;
  emxArray_real32_T *kb_cpu_w;
  emxArray_real32_T *kd_cpu_expanded;
  emxArray_real32_T *l_cpu_a;
  emxArray_real32_T *l_cpu_c;
  emxArray_real32_T *l_cpu_expanded;
  emxArray_real32_T *l_cpu_x;
  emxArray_real32_T *lb_cpu_expanded;
  emxArray_real32_T *lb_cpu_w;
  emxArray_real32_T *lc_cpu_expanded;
  emxArray_real32_T *m_cpu_c;
  emxArray_real32_T *m_cpu_expanded;
  emxArray_real32_T *m_cpu_x;
  emxArray_real32_T *mb_cpu_expanded;
  emxArray_real32_T *mb_cpu_w;
  emxArray_real32_T *md_cpu_expanded;
  emxArray_real32_T *n_cpu_c;
  emxArray_real32_T *n_cpu_expanded;
  emxArray_real32_T *n_cpu_x;
  emxArray_real32_T *nb_cpu_expanded;
  emxArray_real32_T *nb_cpu_w;
  emxArray_real32_T *nc_cpu_expanded;
  emxArray_real32_T *nc_cpu_y;
  emxArray_real32_T *o_cpu_c;
  emxArray_real32_T *o_cpu_expanded;
  emxArray_real32_T *o_cpu_x;
  emxArray_real32_T *ob_cpu_expanded;
  emxArray_real32_T *od_cpu_expanded;
  emxArray_real32_T *p_cpu_c;
  emxArray_real32_T *p_cpu_expanded;
  emxArray_real32_T *p_cpu_x;
  emxArray_real32_T *pb_cpu_expanded;
  emxArray_real32_T *pc_cpu_y;
  emxArray_real32_T *q_cpu_c;
  emxArray_real32_T *q_cpu_expanded;
  emxArray_real32_T *q_cpu_x;
  emxArray_real32_T *q_cpu_y;
  emxArray_real32_T *qb_cpu_expanded;
  emxArray_real32_T *qd_cpu_expanded;
  emxArray_real32_T *r_cpu_c;
  emxArray_real32_T *r_cpu_expanded;
  emxArray_real32_T *r_cpu_y;
  emxArray_real32_T *rb_cpu_expanded;
  emxArray_real32_T *rb_cpu_y;
  emxArray_real32_T *s_cpu_c;
  emxArray_real32_T *s_cpu_expanded;
  emxArray_real32_T *sb_cpu_expanded;
  emxArray_real32_T *sc_cpu_expanded;
  emxArray_real32_T *sd_cpu_expanded;
  emxArray_real32_T *t_cpu_c;
  emxArray_real32_T *t_cpu_expanded;
  emxArray_real32_T *tb_cpu_expanded;
  emxArray_real32_T *tb_cpu_y;
  emxArray_real32_T *u_cpu_expanded;
  emxArray_real32_T *ub_cpu_expanded;
  emxArray_real32_T *uc_cpu_expanded;
  emxArray_real32_T *ud_cpu_expanded;
  emxArray_real32_T *v_cpu_expanded;
  emxArray_real32_T *v_cpu_w;
  emxArray_real32_T *vb_cpu_expanded;
  emxArray_real32_T *vc_cpu_y;
  emxArray_real32_T *w_cpu_expanded;
  emxArray_real32_T *w_cpu_w;
  emxArray_real32_T *wb_cpu_expanded;
  emxArray_real32_T *wb_cpu_y;
  emxArray_real32_T *wc_cpu_expanded;
  emxArray_real32_T *wd_cpu_expanded;
  emxArray_real32_T *x_cpu_expanded;
  emxArray_real32_T *x_cpu_w;
  emxArray_real32_T *xb_cpu_expanded;
  emxArray_real32_T *xb_cpu_y;
  emxArray_real32_T *xg_cpu_y;
  emxArray_real32_T *y_cpu_expanded;
  emxArray_real32_T *y_cpu_w;
  emxArray_real32_T *y_cpu_y;
  emxArray_real32_T *yb_cpu_expanded;
  emxArray_real32_T *yb_cpu_y;
  emxArray_real32_T *yd_cpu_expanded;
  emxArray_real32_T *yg_cpu_y;
  emxArray_real_T b_gpu_Fmat;
  emxArray_real_T b_gpu_G;
  emxArray_real_T b_gpu_b;
  emxArray_real_T b_gpu_b0;
  emxArray_real_T b_gpu_h1;
  emxArray_real_T b_gpu_k;
  emxArray_real_T b_gpu_m;
  emxArray_real_T b_gpu_omega;
  emxArray_real_T b_gpu_omega_tmp2;
  emxArray_real_T b_gpu_sinc1A;
  emxArray_real_T b_gpu_sinc2A;
  emxArray_real_T b_gpu_sinc3A;
  emxArray_real_T b_gpu_sinc4A;
  emxArray_real_T b_gpu_tau;
  emxArray_real_T b_gpu_y;
  emxArray_real_T bg_gpu_y;
  emxArray_real_T c_gpu_Fmat;
  emxArray_real_T c_gpu_h;
  emxArray_real_T c_gpu_omega;
  emxArray_real_T c_gpu_omega_tmp2;
  emxArray_real_T c_gpu_y;
  emxArray_real_T d_gpu_a;
  emxArray_real_T d_gpu_omega_tmp2;
  emxArray_real_T e_gpu_a;
  emxArray_real_T gb_gpu_y;
  emxArray_real_T gc_gpu_w;
  emxArray_real_T gc_gpu_y;
  emxArray_real_T gpu_Fmat;
  emxArray_real_T gpu_G;
  emxArray_real_T gpu_b;
  emxArray_real_T gpu_b0;
  emxArray_real_T gpu_daughter;
  emxArray_real_T gpu_dv23;
  emxArray_real_T gpu_dv25;
  emxArray_real_T gpu_dv26;
  emxArray_real_T gpu_dv27;
  emxArray_real_T gpu_dv29;
  emxArray_real_T gpu_dv31;
  emxArray_real_T gpu_expnt;
  emxArray_real_T gpu_fb_Omega;
  emxArray_real_T gpu_fb_Scales;
  emxArray_real_T gpu_h;
  emxArray_real_T gpu_h1;
  emxArray_real_T gpu_k;
  emxArray_real_T gpu_m;
  emxArray_real_T gpu_omega;
  emxArray_real_T gpu_omega_tmp2;
  emxArray_real_T gpu_sinc1A;
  emxArray_real_T gpu_sinc2A;
  emxArray_real_T gpu_sinc3A;
  emxArray_real_T gpu_sinc4A;
  emxArray_real_T gpu_somega;
  emxArray_real_T gpu_tau;
  emxArray_real_T h_gpu_x;
  emxArray_real_T hh_gpu_y;
  emxArray_real_T ih_gpu_y;
  emxArray_real_T j_gpu_y;
  emxArray_real_T jh_gpu_y;
  emxArray_real_T k_gpu_y;
  emxArray_real_T kd_gpu_y;
  emxArray_real_T ke_gpu_y;
  emxArray_real_T kf_gpu_y;
  emxArray_real_T m_gpu_y;
  emxArray_real_T n_gpu_y;
  emxArray_real_T og_gpu_y;
  emxArray_real_T qc_gpu_y;
  emxArray_real_T r_gpu_x;
  emxArray_real_T s_gpu_y;
  emxArray_real_T sb_gpu_y;
  emxArray_real_T uf_gpu_y;
  emxArray_real_T wc_gpu_y;
  emxArray_real_T wd_gpu_y;
  emxArray_real_T we_gpu_y;
  emxArray_real_T *b_cpu_Fmat;
  emxArray_real_T *b_cpu_G;
  emxArray_real_T *b_cpu_b;
  emxArray_real_T *b_cpu_b0;
  emxArray_real_T *b_cpu_h1;
  emxArray_real_T *b_cpu_k;
  emxArray_real_T *b_cpu_m;
  emxArray_real_T *b_cpu_omega;
  emxArray_real_T *b_cpu_omega_tmp2;
  emxArray_real_T *b_cpu_sinc1A;
  emxArray_real_T *b_cpu_sinc2A;
  emxArray_real_T *b_cpu_sinc3A;
  emxArray_real_T *b_cpu_sinc4A;
  emxArray_real_T *b_cpu_tau;
  emxArray_real_T *b_cpu_y;
  emxArray_real_T *bd_cpu_y;
  emxArray_real_T *c_cpu_Fmat;
  emxArray_real_T *c_cpu_h;
  emxArray_real_T *c_cpu_omega;
  emxArray_real_T *c_cpu_omega_tmp2;
  emxArray_real_T *c_cpu_y;
  emxArray_real_T *cb_cpu_y;
  emxArray_real_T *cg_cpu_y;
  emxArray_real_T *cpu_Fmat;
  emxArray_real_T *cpu_G;
  emxArray_real_T *cpu_b;
  emxArray_real_T *cpu_b0;
  emxArray_real_T *cpu_daughter;
  emxArray_real_T *cpu_dv23;
  emxArray_real_T *cpu_dv25;
  emxArray_real_T *cpu_dv26;
  emxArray_real_T *cpu_dv27;
  emxArray_real_T *cpu_dv29;
  emxArray_real_T *cpu_dv31;
  emxArray_real_T *cpu_expnt;
  emxArray_real_T *cpu_fb_Omega;
  emxArray_real_T *cpu_fb_Scales;
  emxArray_real_T *cpu_h;
  emxArray_real_T *cpu_h1;
  emxArray_real_T *cpu_k;
  emxArray_real_T *cpu_m;
  emxArray_real_T *cpu_omega;
  emxArray_real_T *cpu_omega_tmp2;
  emxArray_real_T *cpu_sinc1A;
  emxArray_real_T *cpu_sinc2A;
  emxArray_real_T *cpu_sinc3A;
  emxArray_real_T *cpu_sinc4A;
  emxArray_real_T *cpu_somega;
  emxArray_real_T *cpu_tau;
  emxArray_real_T *cpu_w;
  emxArray_real_T *d_cpu_a;
  emxArray_real_T *d_cpu_omega_tmp2;
  emxArray_real_T *d_cpu_y;
  emxArray_real_T *de_cpu_y;
  emxArray_real_T *e_cpu_y;
  emxArray_real_T *f_cpu_y;
  emxArray_real_T *h_cpu_x;
  emxArray_real_T *hc_cpu_y;
  emxArray_real_T *ic_cpu_y;
  emxArray_real_T *if_cpu_y;
  emxArray_real_T *jf_cpu_y;
  emxArray_real_T *m_cpu_a;
  emxArray_real_T *qc_cpu_y;
  emxArray_real_T *r_cpu_x;
  emxArray_real_T *rf_cpu_y;
  emxArray_real_T *sc_cpu_y;
  emxArray_real_T *tc_cpu_y;
  emxArray_real_T *tf_cpu_y;
  emxArray_real_T *uf_cpu_y;
  emxArray_real_T *w_cpu_y;
  emxArray_real_T *x_cpu_y;
  emxArray_real_T *xd_cpu_y;
  emxArray_real_T *yd_cpu_y;
  emxArray_uint32_T l_gpu_y;
  emxArray_uint32_T o_gpu_y;
  emxArray_uint32_T *td_cpu_y;
  emxArray_uint32_T *v_cpu_y;
  const mxArray *ab_y;
  const mxArray *ac_y;
  const mxArray *ad_y;
  const mxArray *b_y;
  const mxArray *bb_y;
  const mxArray *bc_y;
  const mxArray *bd_y;
  const mxArray *c_tmpStr;
  const mxArray *c_y;
  const mxArray *cb_y;
  const mxArray *cc_y;
  const mxArray *cd_y;
  const mxArray *d_tmpStr;
  const mxArray *d_y;
  const mxArray *db_y;
  const mxArray *dc_y;
  const mxArray *dd_y;
  const mxArray *e_y;
  const mxArray *eb_y;
  const mxArray *ec_y;
  const mxArray *ed_y;
  const mxArray *f_y;
  const mxArray *fb_y;
  const mxArray *fc_y;
  const mxArray *fd_y;
  const mxArray *g_y;
  const mxArray *gb_y;
  const mxArray *gc_y;
  const mxArray *gd_y;
  const mxArray *h_y;
  const mxArray *hb_y;
  const mxArray *hc_y;
  const mxArray *hd_y;
  const mxArray *i_y;
  const mxArray *ib_y;
  const mxArray *ic_y;
  const mxArray *id_y;
  const mxArray *j_y;
  const mxArray *jb_y;
  const mxArray *jc_y;
  const mxArray *jd_y;
  const mxArray *k_y;
  const mxArray *kb_y;
  const mxArray *kc_y;
  const mxArray *kd_y;
  const mxArray *l_y;
  const mxArray *lb_y;
  const mxArray *lc_y;
  const mxArray *ld_y;
  const mxArray *m;
  const mxArray *m1;
  const mxArray *m10;
  const mxArray *m11;
  const mxArray *m12;
  const mxArray *m13;
  const mxArray *m15;
  const mxArray *m16;
  const mxArray *m17;
  const mxArray *m18;
  const mxArray *m19;
  const mxArray *m2;
  const mxArray *m20;
  const mxArray *m21;
  const mxArray *m22;
  const mxArray *m23;
  const mxArray *m24;
  const mxArray *m25;
  const mxArray *m26;
  const mxArray *m27;
  const mxArray *m28;
  const mxArray *m29;
  const mxArray *m3;
  const mxArray *m31;
  const mxArray *m32;
  const mxArray *m33;
  const mxArray *m34;
  const mxArray *m35;
  const mxArray *m36;
  const mxArray *m37;
  const mxArray *m38;
  const mxArray *m39;
  const mxArray *m4;
  const mxArray *m40;
  const mxArray *m41;
  const mxArray *m42;
  const mxArray *m43;
  const mxArray *m44;
  const mxArray *m45;
  const mxArray *m46;
  const mxArray *m47;
  const mxArray *m48;
  const mxArray *m49;
  const mxArray *m5;
  const mxArray *m50;
  const mxArray *m51;
  const mxArray *m52;
  const mxArray *m53;
  const mxArray *m54;
  const mxArray *m55;
  const mxArray *m57;
  const mxArray *m58;
  const mxArray *m59;
  const mxArray *m6;
  const mxArray *m60;
  const mxArray *m61;
  const mxArray *m62;
  const mxArray *m63;
  const mxArray *m64;
  const mxArray *m65;
  const mxArray *m66;
  const mxArray *m67;
  const mxArray *m68;
  const mxArray *m69;
  const mxArray *m7;
  const mxArray *m70;
  const mxArray *m71;
  const mxArray *m73;
  const mxArray *m74;
  const mxArray *m75;
  const mxArray *m76;
  const mxArray *m77;
  const mxArray *m78;
  const mxArray *m79;
  const mxArray *m8;
  const mxArray *m80;
  const mxArray *m81;
  const mxArray *m82;
  const mxArray *m83;
  const mxArray *m84;
  const mxArray *m85;
  const mxArray *m86;
  const mxArray *m87;
  const mxArray *m88;
  const mxArray *m89;
  const mxArray *m9;
  const mxArray *m90;
  const mxArray *m91;
  const mxArray *m92;
  const mxArray *m93;
  const mxArray *m_y;
  const mxArray *mb_y;
  const mxArray *mc_y;
  const mxArray *md_y;
  const mxArray *n_y;
  const mxArray *nb_y;
  const mxArray *nc_y;
  const mxArray *nd_y;
  const mxArray *o_y;
  const mxArray *ob_y;
  const mxArray *oc_y;
  const mxArray *od_y;
  const mxArray *p_y;
  const mxArray *pb_y;
  const mxArray *pc_y;
  const mxArray *q_y;
  const mxArray *qb_y;
  const mxArray *qc_y;
  const mxArray *r_y;
  const mxArray *rb_y;
  const mxArray *rc_y;
  const mxArray *s_y;
  const mxArray *sb_y;
  const mxArray *sc_y;
  const mxArray *t_y;
  const mxArray *tb_y;
  const mxArray *tc_y;
  const mxArray *u_y;
  const mxArray *ub_y;
  const mxArray *uc_y;
  const mxArray *v_y;
  const mxArray *vb_y;
  const mxArray *vc_y;
  const mxArray *w_y;
  const mxArray *wb_y;
  const mxArray *wc_y;
  const mxArray *x_y;
  const mxArray *xb_y;
  const mxArray *xc_y;
  const mxArray *y;
  const mxArray *y_y;
  const mxArray *yb_y;
  const mxArray *yc_y;
  creal_T *gpu_dc;
  creal_T *gpu_dc6;
  creal32_T (*gpu_a_data)[1];
  creal32_T *c_gpu_cfsposdft;
  real_T cpu_dv9_data[9735];
  real_T (*b_gpu_a_data)[9735];
  real_T (*b_gpu_fx_data)[9735];
  real_T (*b_gpu_x_data)[9735];
  real_T (*c_gpu_a_data)[9735];
  real_T (*c_gpu_fx_data)[9735];
  real_T (*d_gpu_fx_data)[9735];
  real_T (*gpu_dv15_data)[9735];
  real_T (*gpu_dv2_data)[9735];
  real_T (*gpu_dv8_data)[9735];
  real_T (*gpu_dv9_data)[9735];
  real_T (*gpu_fx_data)[9735];
  real_T (*gpu_x_data)[9735];
  real_T (*gpu_xt_data)[9735];
  real_T (*gpu_y_data)[9735];
  real_T (*gpu_subs)[1298];
  real_T (*gpu_interval)[650];
  real_T Ly;
  real_T b_Ly;
  int32_T a_size[2];
  int32_T b_a_size[2];
  int32_T b_xt_size[2];
  int32_T dv13_size[2];
  int32_T dv2_size[2];
  int32_T dv6_size[2];
  int32_T dv9_size[2];
  int32_T fx_size[2];
  int32_T xt_size[2];
  int32_T (*gpu_lshift)[2];
  int32_T (*gpu_origSiz)[2];
  int32_T b_eint;
  int32_T b_exponent;
  int32_T c_eint;
  int32_T cpu_lidx;
  int32_T d_eint;
  int32_T e_eint;
  int32_T eint;
  int32_T exponent;
  int32_T f_eint;
  int32_T g_eint;
  int32_T h_eint;
  int32_T i;
  int32_T i1;
  int32_T i269;
  int32_T i275;
  int32_T i392;
  int32_T i71;
  int32_T i74;
  int32_T i_eint;
  int32_T j_eint;
  int32_T *gpu_lidx;
  real32_T cpu_cv_re;
  real32_T *gpu_cv_re;
  real32_T *gpu_f;
  real32_T *gpu_f1;
  real32_T *gpu_f10;
  real32_T *gpu_f11;
  real32_T *gpu_f12;
  real32_T *gpu_f13;
  real32_T *gpu_f14;
  real32_T *gpu_f15;
  real32_T *gpu_f16;
  real32_T *gpu_f17;
  real32_T *gpu_f18;
  real32_T *gpu_f19;
  real32_T *gpu_f20;
  real32_T *gpu_f21;
  real32_T *gpu_f22;
  real32_T *gpu_f23;
  real32_T *gpu_f24;
  real32_T *gpu_f25;
  real32_T *gpu_f26;
  real32_T *gpu_f27;
  real32_T *gpu_f28;
  real32_T *gpu_f29;
  real32_T *gpu_f30;
  real32_T *gpu_f31;
  real32_T *gpu_f32;
  real32_T *gpu_f33;
  real32_T *gpu_f34;
  real32_T *gpu_f35;
  real32_T *gpu_f36;
  real32_T *gpu_f37;
  real32_T *gpu_f6;
  real32_T *gpu_f7;
  real32_T *gpu_f8;
  real32_T *gpu_f9;
  char_T unusedExpr[23];
  char_T (*gpu_wav)[4];
  char_T (*gpu_wname)[4];
  boolean_T G_needsGpuEnsureCapacity;
  boolean_T b;
  boolean_T b_G_needsGpuEnsureCapacity;
  boolean_T b_fx_data_outdatedOnCpu;
  boolean_T b_h_needsGpuEnsureCapacity;
  boolean_T b_h_outdatedOnGpu;
  boolean_T b_x_outdatedOnCpu;
  boolean_T b_y_needsGpuEnsureCapacity;
  boolean_T c_omega_tmp1_needsGpuEnsureCapa;
  boolean_T c_p;
  boolean_T c_x_outdatedOnCpu;
  boolean_T c_y_needsGpuEnsureCapacity;
  boolean_T crossCFS_outdatedOnCpu;
  boolean_T d_omega_tmp1_needsGpuEnsureCapa;
  boolean_T d_p;
  boolean_T d_x_outdatedOnCpu;
  boolean_T d_y_needsGpuEnsureCapacity;
  boolean_T daughter_outdatedOnCpu;
  boolean_T e_omega_tmp1_needsGpuEnsureCapa;
  boolean_T e_y_needsGpuEnsureCapacity;
  boolean_T f_omega_tmp1_needsGpuEnsureCapa;
  boolean_T f_y_needsGpuEnsureCapacity;
  boolean_T fx_data_outdatedOnCpu;
  boolean_T g_y_needsGpuEnsureCapacity;
  boolean_T h_needsGpuEnsureCapacity;
  boolean_T h_outdatedOnGpu;
  boolean_T h_y_needsGpuEnsureCapacity;
  boolean_T i_y_needsGpuEnsureCapacity;
  boolean_T j_y_needsGpuEnsureCapacity;
  boolean_T k_y_needsGpuEnsureCapacity;
  boolean_T l_y_needsGpuEnsureCapacity;
  boolean_T m_y_needsGpuEnsureCapacity;
  boolean_T n_y_needsGpuEnsureCapacity;
  boolean_T o_y_needsGpuEnsureCapacity;
  boolean_T p_y_needsGpuEnsureCapacity;
  boolean_T q_y_needsGpuEnsureCapacity;
  boolean_T r_y_needsGpuEnsureCapacity;
  boolean_T wtc_outdatedOnCpu;
  boolean_T x_needsGpuEnsureCapacity;
  boolean_T x_outdatedOnGpu;
  boolean_T y_needsGpuEnsureCapacity;
  if (!gpuConstsCopied_ec_wtcc) {
    gpuConstsCopied_ec_wtcc = true;
    checkCudaError(cudaMemcpy(*global_gpu_cv, cpu_cv, sizeof(char_T [128]),
      cudaMemcpyHostToDevice), __FILE__, __LINE__);
    checkCudaError(cudaMemcpy(*global_gpu_table100, cpu_table100, sizeof(real_T
      [100]), cudaMemcpyHostToDevice), __FILE__, __LINE__);
  }

  checkCudaError(mwCudaMalloc(&gpu_f37, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f36, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f35, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f34, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f33, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f32, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f31, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f30, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f29, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f28, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f27, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f26, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f25, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f24, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f23, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f22, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f21, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f20, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f19, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f18, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f17, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f16, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f15, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f14, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f13, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f12, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f11, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f10, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f9, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f8, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f7, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f6, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_lshift, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_origSiz, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f1, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_cv_re, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_a_data, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&c_gpu_cfsposdft, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv9_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv15_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_a_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&c_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv2_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv8_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&c_gpu_a_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&d_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_y_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_xt_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_x_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_x_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_subs, 10384UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_interval, 5200UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_wname, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_wav, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_lidx, 4UL), __FILE__, __LINE__);
  gpuEmxReset_creal32_T(&cb_gpu_w);
  gpuEmxReset_creal32_T(&jd_gpu_y);
  gpuEmxReset_creal32_T(&bb_gpu_w);
  gpuEmxReset_creal32_T(&i_gpu_w);
  gpuEmxReset_creal32_T(&r_gpu_w);
  gpuEmxReset_creal32_T(&y_gpu_w);
  gpuEmxReset_creal32_T(&q_gpu_y);
  gpuEmxReset_creal32_T(&fb_gpu_y);
  gpuEmxReset_creal32_T(&qb_gpu_y);
  gpuEmxReset_creal32_T(&fc_gpu_y);
  gpuEmxReset_creal32_T(&c_gpu_w);
  gpuEmxReset_creal32_T(&l_gpu_w);
  gpuEmxReset_creal32_T(&uc_gpu_y);
  gpuEmxReset_creal32_T(&f_gpu_w);
  gpuEmxReset_creal32_T(&o_gpu_w);
  gpuEmxReset_creal32_T(&v_gpu_w);
  gpuEmxReset_creal32_T(&h_gpu_w);
  gpuEmxReset_creal32_T(&q_gpu_w);
  gpuEmxReset_creal32_T(&x_gpu_w);
  gpuEmxReset_creal32_T(&b_gpu_w);
  gpuEmxReset_creal32_T(&k_gpu_w);
  gpuEmxReset_creal32_T(&e_gpu_w);
  gpuEmxReset_creal32_T(&n_gpu_w);
  gpuEmxReset_creal32_T(&u_gpu_w);
  gpuEmxReset_creal32_T(&s_gpu_yCol);
  gpuEmxReset_creal32_T(&f_gpu_yCol);
  gpuEmxReset_creal32_T(&l_gpu_yCol);
  gpuEmxReset_creal32_T(&q_gpu_yCol);
  gpuEmxReset_creal32_T(&d_gpu_yCol);
  gpuEmxReset_creal32_T(&j_gpu_yCol);
  gpuEmxReset_creal32_T(&o_gpu_yCol);
  gpuEmxReset_creal32_T(&b_gpu_yCol);
  gpuEmxReset_creal32_T(&h_gpu_yCol);
  gpuEmxReset_real_T(&b_gpu_b0);
  gpuEmxReset_real32_T(&fc_gpu_w);
  gpuEmxReset_real32_T(&ng_gpu_y);
  gpuEmxReset_real32_T(&ec_gpu_w);
  gpuEmxReset_real32_T(&lb_gpu_w);
  gpuEmxReset_real32_T(&ub_gpu_w);
  gpuEmxReset_real32_T(&cc_gpu_w);
  gpuEmxReset_real32_T(&ud_gpu_y);
  gpuEmxReset_real32_T(&je_gpu_y);
  gpuEmxReset_real32_T(&ue_gpu_y);
  gpuEmxReset_real32_T(&jf_gpu_y);
  gpuEmxReset_real32_T(&fb_gpu_w);
  gpuEmxReset_real32_T(&ob_gpu_w);
  gpuEmxReset_real32_T(&yf_gpu_y);
  gpuEmxReset_real32_T(&ib_gpu_w);
  gpuEmxReset_real32_T(&rb_gpu_w);
  gpuEmxReset_real32_T(&yb_gpu_w);
  gpuEmxReset_real32_T(&kb_gpu_w);
  gpuEmxReset_real32_T(&tb_gpu_w);
  gpuEmxReset_real32_T(&bc_gpu_w);
  gpuEmxReset_real32_T(&eb_gpu_w);
  gpuEmxReset_real32_T(&nb_gpu_w);
  gpuEmxReset_real32_T(&hb_gpu_w);
  gpuEmxReset_real32_T(&qb_gpu_w);
  gpuEmxReset_real32_T(&xb_gpu_w);
  gpuEmxReset_real_T(&gpu_b0);
  gpuEmxReset_creal32_T(&d_gpu_smooth);
  gpuEmxReset_real32_T(&f_gpu_smooth);
  gpuEmxReset_real32_T(&e_gpu_smooth);
  gpuEmxReset_real32_T(&h_gpu_smooth);
  gpuEmxReset_real32_T(&g_gpu_smooth);
  gpuEmxReset_creal32_T(&p_gpu_newIm);
  gpuEmxReset_creal32_T(&v_gpu_newIm);
  gpuEmxReset_creal32_T(&gpu_newIm);
  gpuEmxReset_creal32_T(&g_gpu_newIm);
  gpuEmxReset_creal32_T(&h_gpu_newIm);
  gpuEmxReset_creal32_T(&n_gpu_newIm);
  gpuEmxReset_creal32_T(&s_gpu_newIm);
  gpuEmxReset_creal32_T(&u_gpu_newIm);
  gpuEmxReset_creal32_T(&t_gpu_newIm);
  gpuEmxReset_creal32_T(&d_gpu_newIm);
  gpuEmxReset_creal32_T(&k_gpu_newIm);
  gpuEmxReset_creal32_T(&f_gpu_newIm);
  gpuEmxReset_creal32_T(&m_gpu_newIm);
  gpuEmxReset_creal32_T(&r_gpu_newIm);
  gpuEmxReset_creal32_T(&e_gpu_newIm);
  gpuEmxReset_creal32_T(&l_gpu_newIm);
  gpuEmxReset_creal32_T(&q_gpu_newIm);
  gpuEmxReset_creal32_T(&c_gpu_newIm);
  gpuEmxReset_creal32_T(&j_gpu_newIm);
  gpuEmxReset_creal32_T(&b_gpu_newIm);
  gpuEmxReset_creal32_T(&i_gpu_newIm);
  gpuEmxReset_int32_T(&rb_gpu_rows);
  gpuEmxReset_int32_T(&sb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv204);
  gpuEmxReset_int32_T(&m_gpu_rows);
  gpuEmxReset_int32_T(&bb_gpu_rows);
  gpuEmxReset_int32_T(&lb_gpu_rows);
  gpuEmxReset_int32_T(&pb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv203);
  gpuEmxReset_int32_T(&n_gpu_rows);
  gpuEmxReset_int32_T(&cb_gpu_rows);
  gpuEmxReset_int32_T(&gb_gpu_rows);
  gpuEmxReset_int32_T(&mb_gpu_rows);
  gpuEmxReset_int32_T(&qb_gpu_rows);
  gpuEmxReset_int32_T(&g_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv199);
  gpuEmxReset_int32_T(&u_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv197);
  gpuEmxReset_int32_T(&gpu_iv196);
  gpuEmxReset_int32_T(&gpu_iv195);
  gpuEmxReset_int32_T(&h_gpu_rows);
  gpuEmxReset_int32_T(&k_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv194);
  gpuEmxReset_int32_T(&v_gpu_rows);
  gpuEmxReset_int32_T(&y_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv193);
  gpuEmxReset_int32_T(&jb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv191);
  gpuEmxReset_int32_T(&f_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv190);
  gpuEmxReset_int32_T(&b_gpu_rows);
  gpuEmxReset_int32_T(&l_gpu_rows);
  gpuEmxReset_int32_T(&p_gpu_rows);
  gpuEmxReset_int32_T(&ab_gpu_rows);
  gpuEmxReset_int32_T(&kb_gpu_rows);
  gpuEmxReset_int32_T(&rd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv189);
  gpuEmxReset_int32_T(&gpu_iv188);
  gpuEmxReset_int32_T(&ob_gpu_rows);
  gpuEmxReset_int32_T(&sd_gpu_y);
  gpuEmxReset_int32_T(&e_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv187);
  gpuEmxReset_int32_T(&gpu_iv186);
  gpuEmxReset_int32_T(&s_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv185);
  gpuEmxReset_int32_T(&gpu_iv184);
  gpuEmxReset_int32_T(&fb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv183);
  gpuEmxReset_real32_T(&xb_gpu_expanded);
  gpuEmxReset_creal32_T(&yb_gpu_expanded);
  gpuEmxReset_int32_T(&f_gpu_rows);
  gpuEmxReset_int32_T(&b_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv181);
  gpuEmxReset_int32_T(&t_gpu_rows);
  gpuEmxReset_int32_T(&d_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv179);
  gpuEmxReset_int32_T(&e_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv178);
  gpuEmxReset_int32_T(&nb_gpu_y);
  gpuEmxReset_int32_T(&nc_gpu_y);
  gpuEmxReset_int32_T(&gd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv177);
  gpuEmxReset_int32_T(&pd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv176);
  gpuEmxReset_int32_T(&j_gpu_rows);
  gpuEmxReset_int32_T(&ob_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv175);
  gpuEmxReset_int32_T(&x_gpu_rows);
  gpuEmxReset_int32_T(&oc_gpu_y);
  gpuEmxReset_int32_T(&ib_gpu_rows);
  gpuEmxReset_int32_T(&hd_gpu_y);
  gpuEmxReset_int32_T(&qd_gpu_y);
  gpuEmxReset_int32_T(&gpu_rows);
  gpuEmxReset_int32_T(&gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv174);
  gpuEmxReset_real32_T(&o_gpu_expanded);
  gpuEmxReset_creal32_T(&p_gpu_expanded);
  gpuEmxReset_int32_T(&o_gpu_rows);
  gpuEmxReset_int32_T(&c_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv173);
  gpuEmxReset_real32_T(&fb_gpu_expanded);
  gpuEmxReset_creal32_T(&gb_gpu_expanded);
  gpuEmxReset_real32_T(&qb_gpu_expanded);
  gpuEmxReset_creal32_T(&rb_gpu_expanded);
  gpuEmxReset_real32_T(&vb_gpu_expanded);
  gpuEmxReset_creal32_T(&wb_gpu_expanded);
  gpuEmxReset_int32_T(&cb_gpu_y);
  gpuEmxReset_int32_T(&cc_gpu_y);
  gpuEmxReset_int32_T(&nb_gpu_rows);
  gpuEmxReset_int32_T(&d_gpu_rows);
  gpuEmxReset_int32_T(&db_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv172);
  gpuEmxReset_int32_T(&lb_gpu_y);
  gpuEmxReset_int32_T(&r_gpu_rows);
  gpuEmxReset_int32_T(&dc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv171);
  gpuEmxReset_int32_T(&lc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv170);
  gpuEmxReset_int32_T(&gpu_iv169);
  gpuEmxReset_int32_T(&ed_gpu_y);
  gpuEmxReset_real32_T(&h_gpu_expanded);
  gpuEmxReset_creal32_T(&i_gpu_expanded);
  gpuEmxReset_int32_T(&mb_gpu_y);
  gpuEmxReset_real32_T(&x_gpu_expanded);
  gpuEmxReset_creal32_T(&y_gpu_expanded);
  gpuEmxReset_int32_T(&mc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv168);
  gpuEmxReset_int32_T(&fd_gpu_y);
  gpuEmxReset_real_T(&kd_gpu_y);
  gpuEmxReset_real32_T(&m_gpu_expanded);
  gpuEmxReset_creal32_T(&n_gpu_expanded);
  gpuEmxReset_real32_T(&db_gpu_expanded);
  gpuEmxReset_creal32_T(&eb_gpu_expanded);
  gpuEmxReset_real32_T(&ob_gpu_expanded);
  gpuEmxReset_creal32_T(&pb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv167);
  gpuEmxReset_int32_T(&ab_gpu_y);
  gpuEmxReset_int32_T(&i_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv166);
  gpuEmxReset_int32_T(&ac_gpu_y);
  gpuEmxReset_int32_T(&w_gpu_rows);
  gpuEmxReset_int32_T(&hb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv164);
  gpuEmxReset_int32_T(&bb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv163);
  gpuEmxReset_int32_T(&bc_gpu_y);
  gpuEmxReset_creal32_T(&tc_gpu_y);
  gpuEmxReset_int32_T(&od_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv162);
  gpuEmxReset_real32_T(&f_gpu_expanded);
  gpuEmxReset_creal32_T(&g_gpu_expanded);
  gpuEmxReset_real_T(&gb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv161);
  gpuEmxReset_real32_T(&v_gpu_expanded);
  gpuEmxReset_creal32_T(&w_gpu_expanded);
  gpuEmxReset_real_T(&gc_gpu_y);
  gpuEmxReset_creal32_T(&o_gpu_newIm);
  gpuEmxReset_int32_T(&gpu_iv160);
  gpuEmxReset_int32_T(&c_gpu_rows);
  gpuEmxReset_int32_T(&q_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv159);
  gpuEmxReset_int32_T(&xc_gpu_y);
  gpuEmxReset_real_T(&wc_gpu_y);
  gpuEmxReset_creal32_T(&p_gpu_y);
  gpuEmxReset_int32_T(&kb_gpu_y);
  gpuEmxReset_creal32_T(&pb_gpu_y);
  gpuEmxReset_int32_T(&kc_gpu_y);
  gpuEmxReset_int32_T(&yc_gpu_y);
  gpuEmxReset_int32_T(&dd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv156);
  gpuEmxReset_int32_T(&gpu_iv155);
  gpuEmxReset_int32_T(&gpu_iv154);
  gpuEmxReset_real32_T(&jb_gpu_expanded);
  gpuEmxReset_creal32_T(&kb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv153);
  gpuEmxReset_creal32_T(&id_gpu_y);
  gpuEmxReset_real_T(&s_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv152);
  gpuEmxReset_real_T(&sb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv151);
  gpuEmxReset_int32_T(&gpu_iv150);
  gpuEmxReset_creal32_T(&f_gpu_result);
  gpuEmxReset_int32_T(&t_gpu_y);
  gpuEmxReset_int32_T(&y_gpu_y);
  gpuEmxReset_int32_T(&tb_gpu_y);
  gpuEmxReset_int32_T(&yb_gpu_y);
  gpuEmxReset_int32_T(&u_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv149);
  gpuEmxReset_int32_T(&gpu_iv148);
  gpuEmxReset_int32_T(&ub_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv147);
  gpuEmxReset_int32_T(&gpu_iv146);
  gpuEmxReset_int32_T(&gpu_iv145);
  gpuEmxReset_int32_T(&md_gpu_y);
  gpuEmxReset_real32_T(&gpu_expanded);
  gpuEmxReset_creal32_T(&b_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv144);
  gpuEmxReset_creal32_T(&eb_gpu_y);
  gpuEmxReset_real32_T(&q_gpu_expanded);
  gpuEmxReset_creal32_T(&r_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv143);
  gpuEmxReset_creal32_T(&ec_gpu_y);
  gpuEmxReset_creal32_T(&vc_gpu_y);
  gpuEmxReset_int32_T(&nd_gpu_y);
  gpuEmxReset_creal32_T(&b_gpu_result);
  gpuEmxReset_creal32_T(&d_gpu_result);
  gpuEmxReset_creal32_T(&e_gpu_result);
  gpuEmxReset_int32_T(&ld_gpu_y);
  gpuEmxReset_real32_T(&tb_gpu_expanded);
  gpuEmxReset_creal32_T(&ub_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv142);
  gpuEmxReset_int32_T(&gpu_iv141);
  gpuEmxReset_creal32_T(&r_gpu_y);
  gpuEmxReset_int32_T(&ib_gpu_y);
  gpuEmxReset_creal32_T(&rb_gpu_y);
  gpuEmxReset_int32_T(&ic_gpu_y);
  gpuEmxReset_int32_T(&bd_gpu_y);
  gpuEmxReset_creal32_T(&sb_gpu_expanded);
  gpuEmxReset_creal32_T(&gpu_result);
  gpuEmxReset_int32_T(&jb_gpu_y);
  gpuEmxReset_creal32_T(&c_gpu_result);
  gpuEmxReset_int32_T(&jc_gpu_y);
  gpuEmxReset_int32_T(&cd_gpu_y);
  gpuEmxReset_int32_T(&hb_gpu_y);
  gpuEmxReset_real32_T(&k_gpu_expanded);
  gpuEmxReset_creal32_T(&l_gpu_expanded);
  gpuEmxReset_int32_T(&hc_gpu_y);
  gpuEmxReset_real32_T(&bb_gpu_expanded);
  gpuEmxReset_creal32_T(&cb_gpu_expanded);
  gpuEmxReset_int32_T(&db_gpu_rows);
  gpuEmxReset_int32_T(&eb_gpu_rows);
  gpuEmxReset_int32_T(&ad_gpu_y);
  gpuEmxReset_real32_T(&mb_gpu_expanded);
  gpuEmxReset_creal32_T(&nb_gpu_expanded);
  gpuEmxReset_int32_T(&w_gpu_y);
  gpuEmxReset_int32_T(&wb_gpu_y);
  gpuEmxReset_int32_T(&x_gpu_y);
  gpuEmxReset_creal32_T(&j_gpu_expanded);
  gpuEmxReset_int32_T(&xb_gpu_y);
  gpuEmxReset_creal32_T(&ab_gpu_expanded);
  gpuEmxReset_creal32_T(&lb_gpu_expanded);
  gpuEmxReset_int32_T(&v_gpu_y);
  gpuEmxReset_real32_T(&d_gpu_expanded);
  gpuEmxReset_creal32_T(&e_gpu_expanded);
  gpuEmxReset_int32_T(&vb_gpu_y);
  gpuEmxReset_real32_T(&t_gpu_expanded);
  gpuEmxReset_creal32_T(&u_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv140);
  gpuEmxReset_int32_T(&gpu_iv139);
  gpuEmxReset_creal32_T(&c_gpu_expanded);
  gpuEmxReset_creal32_T(&s_gpu_expanded);
  gpuEmxReset_real_T(&qc_gpu_y);
  gpuEmxReset_int32_T(&rc_gpu_y);
  gpuEmxReset_int32_T(&sc_gpu_y);
  gpuEmxReset_creal32_T(&f_gpu_a);
  gpuEmxReset_creal32_T(&i_gpu_a);
  gpuEmxReset_real32_T(&hb_gpu_expanded);
  gpuEmxReset_creal32_T(&ib_gpu_expanded);
  gpuEmxReset_creal32_T(&m_gpu_a);
  gpuEmxReset_creal32_T(&pc_gpu_y);
  gpuEmxReset_creal32_T(&i_gpu_c);
  gpuEmxReset_creal32_T(&h_gpu_a);
  gpuEmxReset_creal32_T(&k_gpu_a);
  gpuEmxReset_creal32_T(&l_gpu_a);
  gpuEmxReset_creal32_T(&e_gpu_c);
  gpuEmxReset_creal32_T(&g_gpu_c);
  gpuEmxReset_creal32_T(&t_gpu_w);
  gpuEmxReset_creal32_T(&h_gpu_c);
  gpuEmxReset_creal32_T(&g_gpu_a);
  gpuEmxReset_creal32_T(&j_gpu_a);
  gpuEmxReset_creal32_T(&d_gpu_c);
  gpuEmxReset_creal32_T(&f_gpu_c);
  gpuEmxReset_creal32_T(&gpu_w);
  gpuEmxReset_creal32_T(&j_gpu_w);
  gpuEmxReset_creal32_T(&ab_gpu_w);
  gpuEmxReset_creal32_T(&s_gpu_w);
  gpuEmxReset_creal32_T(&g_gpu_w);
  gpuEmxReset_creal32_T(&p_gpu_w);
  gpuEmxReset_creal32_T(&n_gpu_yCol);
  gpuEmxReset_creal32_T(&w_gpu_w);
  gpuEmxReset_creal32_T(&d_gpu_w);
  gpuEmxReset_creal32_T(&m_gpu_w);
  gpuEmxReset_creal32_T(&gpu_yCol);
  gpuEmxReset_creal32_T(&g_gpu_yCol);
  gpuEmxReset_creal32_T(&r_gpu_yCol);
  gpuEmxReset_real_T(&n_gpu_y);
  gpuEmxReset_creal32_T(&e_gpu_yCol);
  gpuEmxReset_creal32_T(&k_gpu_yCol);
  gpuEmxReset_creal32_T(&p_gpu_yCol);
  gpuEmxReset_creal32_T(&c_gpu_yCol);
  gpuEmxReset_creal32_T(&i_gpu_yCol);
  gpuEmxReset_creal32_T(&m_gpu_yCol);
  gpuEmxReset_int32_T(&gpu_IPIV);
  gpuEmxReset_real_T(&m_gpu_y);
  gpuEmxReset_real_T(&gpu_tau);
  gpuEmxReset_creal32_T(&gpu_xCol);
  gpuEmxReset_real_T(&gpu_dv31);
  gpuEmxReset_real32_T(&gpu_fv);
  gpuEmxReset_int32_T(&gpu_jpvt);
  gpuEmxReset_real_T(&h_gpu_x);
  gpuEmxReset_real_T(&gpu_dv29);
  gpuEmxReset_real_T(&e_gpu_a);
  gpuEmxReset_int32_T(&ld_gpu_rows);
  gpuEmxReset_int32_T(&md_gpu_rows);
  gpuEmxReset_creal32_T(&b_gpu_y1);
  gpuEmxReset_int32_T(&gpu_iv108);
  gpuEmxReset_int32_T(&gc_gpu_rows);
  gpuEmxReset_int32_T(&uc_gpu_rows);
  gpuEmxReset_int32_T(&fd_gpu_rows);
  gpuEmxReset_int32_T(&jd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv107);
  gpuEmxReset_int32_T(&hc_gpu_rows);
  gpuEmxReset_int32_T(&vc_gpu_rows);
  gpuEmxReset_int32_T(&ad_gpu_rows);
  gpuEmxReset_int32_T(&gd_gpu_rows);
  gpuEmxReset_int32_T(&kd_gpu_rows);
  gpuEmxReset_real_T(&b_gpu_b);
  gpuEmxReset_int32_T(&ac_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv103);
  gpuEmxReset_int32_T(&oc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv101);
  gpuEmxReset_int32_T(&gpu_iv100);
  gpuEmxReset_int32_T(&gpu_iv99);
  gpuEmxReset_int32_T(&bc_gpu_rows);
  gpuEmxReset_int32_T(&ec_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv98);
  gpuEmxReset_int32_T(&pc_gpu_rows);
  gpuEmxReset_int32_T(&sc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv97);
  gpuEmxReset_int32_T(&dd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv95);
  gpuEmxReset_int32_T(&l_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv94);
  gpuEmxReset_int32_T(&ub_gpu_rows);
  gpuEmxReset_int32_T(&fc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv93);
  gpuEmxReset_int32_T(&jc_gpu_rows);
  gpuEmxReset_int32_T(&tc_gpu_rows);
  gpuEmxReset_int32_T(&ed_gpu_rows);
  gpuEmxReset_int32_T(&vg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv92);
  gpuEmxReset_int32_T(&gpu_iv91);
  gpuEmxReset_int32_T(&id_gpu_rows);
  gpuEmxReset_int32_T(&wg_gpu_y);
  gpuEmxReset_int32_T(&xb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv90);
  gpuEmxReset_int32_T(&gpu_iv89);
  gpuEmxReset_real_T(&b_gpu_sinc4A);
  gpuEmxReset_int32_T(&mc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv88);
  gpuEmxReset_int32_T(&gpu_iv87);
  gpuEmxReset_int32_T(&yc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv86);
  gpuEmxReset_real32_T(&xd_gpu_expanded);
  gpuEmxReset_real32_T(&yd_gpu_expanded);
  gpuEmxReset_int32_T(&yb_gpu_rows);
  gpuEmxReset_int32_T(&h_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv84);
  gpuEmxReset_int32_T(&nc_gpu_rows);
  gpuEmxReset_int32_T(&j_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv82);
  gpuEmxReset_int32_T(&k_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv81);
  gpuEmxReset_int32_T(&re_gpu_y);
  gpuEmxReset_uint32_T(&o_gpu_y);
  gpuEmxReset_real_T(&b_gpu_sinc3A);
  gpuEmxReset_int32_T(&rf_gpu_y);
  gpuEmxReset_int32_T(&kg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv80);
  gpuEmxReset_int32_T(&tg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv79);
  gpuEmxReset_int32_T(&dc_gpu_rows);
  gpuEmxReset_int32_T(&se_gpu_y);
  gpuEmxReset_real32_T(&d_gpu_h);
  gpuEmxReset_int32_T(&gpu_iv78);
  gpuEmxReset_int32_T(&rc_gpu_rows);
  gpuEmxReset_int32_T(&sf_gpu_y);
  gpuEmxReset_int32_T(&cd_gpu_rows);
  gpuEmxReset_int32_T(&lg_gpu_y);
  gpuEmxReset_int32_T(&ug_gpu_y);
  gpuEmxReset_int32_T(&tb_gpu_rows);
  gpuEmxReset_int32_T(&g_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv77);
  gpuEmxReset_real32_T(&oc_gpu_expanded);
  gpuEmxReset_real32_T(&pc_gpu_expanded);
  gpuEmxReset_real_T(&b_gpu_sinc2A);
  gpuEmxReset_int32_T(&ic_gpu_rows);
  gpuEmxReset_int32_T(&i_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv76);
  gpuEmxReset_real32_T(&fd_gpu_expanded);
  gpuEmxReset_real32_T(&gd_gpu_expanded);
  gpuEmxReset_real32_T(&qd_gpu_expanded);
  gpuEmxReset_real32_T(&rd_gpu_expanded);
  gpuEmxReset_real32_T(&vd_gpu_expanded);
  gpuEmxReset_real32_T(&wd_gpu_expanded);
  gpuEmxReset_int32_T(&ge_gpu_y);
  gpuEmxReset_int32_T(&gf_gpu_y);
  gpuEmxReset_int32_T(&hd_gpu_rows);
  gpuEmxReset_int32_T(&wb_gpu_rows);
  gpuEmxReset_int32_T(&he_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv75);
  gpuEmxReset_int32_T(&pe_gpu_y);
  gpuEmxReset_real_T(&b_gpu_sinc1A);
  gpuEmxReset_int32_T(&lc_gpu_rows);
  gpuEmxReset_int32_T(&hf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv74);
  gpuEmxReset_int32_T(&pf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv73);
  gpuEmxReset_int32_T(&gpu_iv72);
  gpuEmxReset_int32_T(&ig_gpu_y);
  gpuEmxReset_real32_T(&hc_gpu_expanded);
  gpuEmxReset_real32_T(&ic_gpu_expanded);
  gpuEmxReset_int32_T(&qe_gpu_y);
  gpuEmxReset_real32_T(&xc_gpu_expanded);
  gpuEmxReset_real32_T(&yc_gpu_expanded);
  gpuEmxReset_int32_T(&qf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv71);
  gpuEmxReset_int32_T(&jg_gpu_y);
  gpuEmxReset_real_T(&og_gpu_y);
  gpuEmxReset_real32_T(&mc_gpu_expanded);
  gpuEmxReset_real32_T(&nc_gpu_expanded);
  gpuEmxReset_real32_T(&dd_gpu_expanded);
  gpuEmxReset_real32_T(&ed_gpu_expanded);
  gpuEmxReset_real32_T(&od_gpu_expanded);
  gpuEmxReset_real32_T(&pd_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv70);
  gpuEmxReset_int32_T(&ee_gpu_y);
  gpuEmxReset_int32_T(&cc_gpu_rows);
  gpuEmxReset_real_T(&b_gpu_G);
  gpuEmxReset_int32_T(&gpu_iv69);
  gpuEmxReset_int32_T(&ef_gpu_y);
  gpuEmxReset_int32_T(&qc_gpu_rows);
  gpuEmxReset_int32_T(&bd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv67);
  gpuEmxReset_int32_T(&fe_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv66);
  gpuEmxReset_int32_T(&ff_gpu_y);
  gpuEmxReset_real32_T(&xf_gpu_y);
  gpuEmxReset_int32_T(&sg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv65);
  gpuEmxReset_real32_T(&fc_gpu_expanded);
  gpuEmxReset_real32_T(&gc_gpu_expanded);
  gpuEmxReset_real_T(&ke_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv64);
  gpuEmxReset_real32_T(&vc_gpu_expanded);
  gpuEmxReset_real32_T(&wc_gpu_expanded);
  gpuEmxReset_real_T(&kf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv63);
  gpuEmxReset_int32_T(&vb_gpu_rows);
  gpuEmxReset_int32_T(&kc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv62);
  gpuEmxReset_int32_T(&cg_gpu_y);
  gpuEmxReset_real_T(&bg_gpu_y);
  gpuEmxReset_real32_T(&td_gpu_y);
  gpuEmxReset_int32_T(&oe_gpu_y);
  gpuEmxReset_real32_T(&te_gpu_y);
  gpuEmxReset_int32_T(&of_gpu_y);
  gpuEmxReset_int32_T(&dg_gpu_y);
  gpuEmxReset_int32_T(&hg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv59);
  gpuEmxReset_int32_T(&gpu_iv58);
  gpuEmxReset_real_T(&b_gpu_k);
  gpuEmxReset_int32_T(&gpu_iv57);
  gpuEmxReset_real32_T(&jd_gpu_expanded);
  gpuEmxReset_real32_T(&kd_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv56);
  gpuEmxReset_real32_T(&mg_gpu_y);
  gpuEmxReset_real_T(&wd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv55);
  gpuEmxReset_real_T(&we_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv54);
  gpuEmxReset_int32_T(&gpu_iv53);
  gpuEmxReset_real32_T(&l_gpu_result);
  gpuEmxReset_int32_T(&xd_gpu_y);
  gpuEmxReset_int32_T(&de_gpu_y);
  gpuEmxReset_real_T(&b_gpu_m);
  gpuEmxReset_int32_T(&xe_gpu_y);
  gpuEmxReset_int32_T(&df_gpu_y);
  gpuEmxReset_int32_T(&yd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv52);
  gpuEmxReset_int32_T(&gpu_iv51);
  gpuEmxReset_int32_T(&ye_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv50);
  gpuEmxReset_int32_T(&gpu_iv49);
  gpuEmxReset_int32_T(&gpu_iv48);
  gpuEmxReset_int32_T(&qg_gpu_y);
  gpuEmxReset_real32_T(&ac_gpu_expanded);
  gpuEmxReset_real32_T(&bc_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv47);
  gpuEmxReset_real32_T(&ie_gpu_y);
  gpuEmxReset_real32_T(&qc_gpu_expanded);
  gpuEmxReset_real32_T(&rc_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv46);
  gpuEmxReset_real32_T(&if_gpu_y);
  gpuEmxReset_real32_T(&ag_gpu_y);
  gpuEmxReset_int32_T(&rg_gpu_y);
  gpuEmxReset_real32_T(&h_gpu_result);
  gpuEmxReset_real32_T(&j_gpu_result);
  gpuEmxReset_real32_T(&v_gpu_c);
  gpuEmxReset_real32_T(&k_gpu_result);
  gpuEmxReset_int32_T(&pg_gpu_y);
  gpuEmxReset_real32_T(&td_gpu_expanded);
  gpuEmxReset_real32_T(&ud_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv45);
  gpuEmxReset_int32_T(&gpu_iv44);
  gpuEmxReset_real32_T(&vd_gpu_y);
  gpuEmxReset_int32_T(&me_gpu_y);
  gpuEmxReset_real32_T(&ve_gpu_y);
  gpuEmxReset_int32_T(&mf_gpu_y);
  gpuEmxReset_int32_T(&fg_gpu_y);
  gpuEmxReset_real32_T(&sd_gpu_expanded);
  gpuEmxReset_real32_T(&g_gpu_result);
  gpuEmxReset_int32_T(&ne_gpu_y);
  gpuEmxReset_real_T(&c_gpu_h);
  gpuEmxReset_real_T(&b_gpu_h1);
  gpuEmxReset_real32_T(&i_gpu_result);
  gpuEmxReset_int32_T(&nf_gpu_y);
  gpuEmxReset_int32_T(&gg_gpu_y);
  gpuEmxReset_real32_T(&k_gpu_c);
  gpuEmxReset_int32_T(&le_gpu_y);
  gpuEmxReset_real32_T(&kc_gpu_expanded);
  gpuEmxReset_real32_T(&lc_gpu_expanded);
  gpuEmxReset_real32_T(&q_gpu_c);
  gpuEmxReset_int32_T(&lf_gpu_y);
  gpuEmxReset_real32_T(&bd_gpu_expanded);
  gpuEmxReset_real32_T(&cd_gpu_expanded);
  gpuEmxReset_int32_T(&eg_gpu_y);
  gpuEmxReset_real32_T(&md_gpu_expanded);
  gpuEmxReset_real32_T(&nd_gpu_expanded);
  gpuEmxReset_int32_T(&be_gpu_y);
  gpuEmxReset_int32_T(&bf_gpu_y);
  gpuEmxReset_int32_T(&wc_gpu_rows);
  gpuEmxReset_int32_T(&xc_gpu_rows);
  gpuEmxReset_real32_T(&ab_gpu_c);
  gpuEmxReset_int32_T(&ce_gpu_y);
  gpuEmxReset_real32_T(&jc_gpu_expanded);
  gpuEmxReset_int32_T(&cf_gpu_y);
  gpuEmxReset_real32_T(&ad_gpu_expanded);
  gpuEmxReset_real32_T(&ld_gpu_expanded);
  gpuEmxReset_int32_T(&ae_gpu_y);
  gpuEmxReset_real32_T(&dc_gpu_expanded);
  gpuEmxReset_real32_T(&ec_gpu_expanded);
  gpuEmxReset_int32_T(&af_gpu_y);
  gpuEmxReset_real32_T(&tc_gpu_expanded);
  gpuEmxReset_real32_T(&uc_gpu_expanded);
  gpuEmxReset_real_T(&gpu_dv27);
  gpuEmxReset_int32_T(&gpu_iv43);
  gpuEmxReset_int32_T(&gpu_iv42);
  gpuEmxReset_real32_T(&cc_gpu_expanded);
  gpuEmxReset_real32_T(&o_gpu_c);
  gpuEmxReset_real32_T(&sc_gpu_expanded);
  gpuEmxReset_real32_T(&u_gpu_c);
  gpuEmxReset_real32_T(&x_gpu_c);
  gpuEmxReset_real32_T(&m_gpu_c);
  gpuEmxReset_real32_T(&s_gpu_c);
  gpuEmxReset_real_T(&uf_gpu_y);
  gpuEmxReset_real32_T(&n_gpu_a);
  gpuEmxReset_real32_T(&q_gpu_a);
  gpuEmxReset_int32_T(&vf_gpu_y);
  gpuEmxReset_int32_T(&wf_gpu_y);
  gpuEmxReset_real32_T(&j_gpu_c);
  gpuEmxReset_real32_T(&p_gpu_c);
  gpuEmxReset_real32_T(&u_gpu_a);
  gpuEmxReset_real32_T(&hd_gpu_expanded);
  gpuEmxReset_real32_T(&id_gpu_expanded);
  gpuEmxReset_real32_T(&y_gpu_c);
  gpuEmxReset_real32_T(&tf_gpu_y);
  gpuEmxReset_real32_T(&p_gpu_a);
  gpuEmxReset_real32_T(&s_gpu_a);
  gpuEmxReset_real32_T(&t_gpu_a);
  gpuEmxReset_real32_T(&n_gpu_c);
  gpuEmxReset_real32_T(&t_gpu_c);
  gpuEmxReset_real32_T(&wb_gpu_w);
  gpuEmxReset_real32_T(&w_gpu_c);
  gpuEmxReset_real32_T(&o_gpu_a);
  gpuEmxReset_real32_T(&r_gpu_a);
  gpuEmxReset_real32_T(&l_gpu_c);
  gpuEmxReset_real32_T(&r_gpu_c);
  gpuEmxReset_real32_T(&o_gpu_x);
  gpuEmxReset_real32_T(&db_gpu_w);
  gpuEmxReset_real32_T(&mb_gpu_w);
  gpuEmxReset_real32_T(&dc_gpu_w);
  gpuEmxReset_real32_T(&i_gpu_x);
  gpuEmxReset_real32_T(&l_gpu_x);
  gpuEmxReset_real32_T(&vb_gpu_w);
  gpuEmxReset_real32_T(&q_gpu_x);
  gpuEmxReset_real32_T(&jb_gpu_w);
  gpuEmxReset_real32_T(&sb_gpu_w);
  gpuEmxReset_real32_T(&ac_gpu_w);
  gpuEmxReset_real32_T(&bb_gpu_yCol);
  gpuEmxReset_real32_T(&gb_gpu_w);
  gpuEmxReset_real32_T(&k_gpu_x);
  gpuEmxReset_real32_T(&pb_gpu_w);
  gpuEmxReset_real32_T(&n_gpu_x);
  gpuEmxReset_real32_T(&p_gpu_x);
  gpuEmxReset_real32_T(&t_gpu_yCol);
  gpuEmxReset_real32_T(&w_gpu_yCol);
  gpuEmxReset_real32_T(&j_gpu_x);
  gpuEmxReset_real32_T(&m_gpu_x);
  gpuEmxReset_real32_T(&db_gpu_yCol);
  gpuEmxReset_real_T(&k_gpu_y);
  gpuEmxReset_real32_T(&v_gpu_yCol);
  gpuEmxReset_real32_T(&y_gpu_yCol);
  gpuEmxReset_real32_T(&cb_gpu_yCol);
  gpuEmxReset_real32_T(&u_gpu_yCol);
  gpuEmxReset_real32_T(&x_gpu_yCol);
  gpuEmxReset_real32_T(&ab_gpu_yCol);
  gpuEmxReset_int32_T(&b_gpu_IPIV);
  gpuEmxReset_real_T(&j_gpu_y);
  gpuEmxReset_real_T(&b_gpu_tau);
  gpuEmxReset_creal32_T(&b_gpu_opts_x);
  gpuEmxReset_real32_T(&b_gpu_xCol);
  gpuEmxReset_real32_T(&b_gpu_opts_filter);
  gpuEmxReset_real_T(&gpu_dv26);
  gpuEmxReset_int32_T(&b_gpu_jpvt);
  gpuEmxReset_real_T(&r_gpu_x);
  gpuEmxReset_real_T(&gpu_dv25);
  gpuEmxReset_real_T(&d_gpu_a);
  gpuEmxReset_real32_T(&gpu_y1);
  gpuEmxReset_real_T(&gpu_b);
  gpuEmxReset_int32_T(&gpu_iv19);
  gpuEmxReset_real_T(&gpu_sinc4A);
  gpuEmxReset_uint32_T(&l_gpu_y);
  gpuEmxReset_real_T(&gpu_sinc3A);
  gpuEmxReset_real32_T(&b_gpu_h);
  gpuEmxReset_real_T(&gpu_sinc2A);
  gpuEmxReset_real_T(&gpu_sinc1A);
  gpuEmxReset_real_T(&gpu_G);
  gpuEmxReset_real_T(&gpu_k);
  gpuEmxReset_real_T(&gpu_m);
  gpuEmxReset_real_T(&gpu_h);
  gpuEmxReset_real_T(&gpu_h1);
  gpuEmxReset_real_T(&gpu_dv23);
  gpuEmxReset_creal32_T(&w_gpu_newIm);
  gpuEmxReset_int32_T(&nd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv18);
  gpuEmxReset_real32_T(&gpu_opts_x);
  gpuEmxReset_real32_T(&gpu_opts_filter);
  gpuEmxReset_int32_T(&ah_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv17);
  gpuEmxReset_int32_T(&gpu_iv16);
  gpuEmxReset_real32_T(&gpu_wtc);
  gpuEmxReset_int32_T(&xg_gpu_y);
  gpuEmxReset_creal32_T(&ae_gpu_expanded);
  gpuEmxReset_int32_T(&yg_gpu_y);
  gpuEmxReset_real32_T(&i_gpu_y);
  gpuEmxReset_creal32_T(&be_gpu_expanded);
  gpuEmxReset_creal32_T(&c_gpu_c);
  gpuEmxReset_real32_T(&h_gpu_y);
  gpuEmxReset_creal32_T(&c_gpu_a);
  gpuEmxReset_creal32_T(&c_gpu_smooth);
  gpuEmxReset_int32_T(&od_gpu_rows);
  gpuEmxReset_creal32_T(&g_gpu_x);
  gpuEmxReset_int32_T(&gpu_iv14);
  gpuEmxReset_real_T(&c_gpu_Fmat);
  gpuEmxReset_creal32_T(&c_gpu_cfsDFT);
  gpuEmxReset_int32_T(&dh_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv13);
  gpuEmxReset_int32_T(&gpu_iv12);
  gpuEmxReset_real_T(&c_gpu_omega);
  gpuEmxReset_int32_T(&bh_gpu_y);
  gpuEmxReset_real32_T(&ce_gpu_expanded);
  gpuEmxReset_real_T(&d_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&ch_gpu_y);
  gpuEmxReset_real32_T(&de_gpu_expanded);
  gpuEmxReset_int32_T(&d_gpu_omega_tmp1);
  gpuEmxReset_real32_T(&b_gpu_c);
  gpuEmxReset_real32_T(&b_gpu_a);
  gpuEmxReset_creal32_T(&gpu_crossCFS);
  gpuEmxReset_real32_T(&b_gpu_smooth);
  gpuEmxReset_creal32_T(&f_gpu_x);
  gpuEmxReset_creal32_T(&g_gpu_y);
  gpuEmxReset_real_T(&b_gpu_Fmat);
  gpuEmxReset_creal32_T(&b_gpu_cfsDFT);
  gpuEmxReset_int32_T(&pd_gpu_rows);
  gpuEmxReset_real_T(&b_gpu_omega);
  gpuEmxReset_int32_T(&gpu_iv11);
  gpuEmxReset_real_T(&c_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&c_gpu_omega_tmp1);
  gpuEmxReset_int32_T(&gh_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv10);
  gpuEmxReset_int32_T(&gpu_iv9);
  gpuEmxReset_int32_T(&eh_gpu_y);
  gpuEmxReset_real32_T(&ee_gpu_expanded);
  gpuEmxReset_int32_T(&fh_gpu_y);
  gpuEmxReset_real32_T(&gpu_cfs2);
  gpuEmxReset_real32_T(&fe_gpu_expanded);
  gpuEmxReset_real32_T(&gpu_c);
  gpuEmxReset_real32_T(&f_gpu_y);
  gpuEmxReset_real32_T(&gpu_a);
  gpuEmxReset_real32_T(&gpu_smooth);
  gpuEmxReset_creal32_T(&e_gpu_x);
  gpuEmxReset_creal32_T(&e_gpu_y);
  gpuEmxReset_real_T(&gpu_Fmat);
  gpuEmxReset_creal32_T(&gpu_cfsDFT);
  gpuEmxReset_real_T(&gpu_omega);
  gpuEmxReset_real_T(&b_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&b_gpu_omega_tmp1);
  gpuEmxReset_real32_T(&gpu_cfs1);
  gpuEmxReset_real32_T(&d_gpu_y);
  gpuEmxReset_creal32_T(&b_gpu_cfspos);
  gpuEmxReset_creal32_T(&b_gpu_cfsposdft);
  gpuEmxReset_real32_T(&d_gpu_x);
  gpuEmxReset_creal32_T(&b_gpu_xposdft);
  gpuEmxReset_real32_T(&b_gpu_xv);
  gpuEmxReset_real32_T(&b_gpu_psihat);
  gpuEmxReset_creal32_T(&gpu_cfspos);
  gpuEmxReset_creal32_T(&gpu_cfsposdft);
  gpuEmxReset_real32_T(&c_gpu_x);
  gpuEmxReset_creal32_T(&gpu_xposdft);
  gpuEmxReset_real32_T(&gpu_xv);
  gpuEmxReset_real32_T(&gpu_psihat);
  gpuEmxReset_real_T(&jh_gpu_y);
  gpuEmxReset_real_T(&hh_gpu_y);
  gpuEmxReset_real_T(&gpu_daughter);
  gpuEmxReset_real_T(&ih_gpu_y);
  gpuEmxReset_real_T(&gpu_expnt);
  gpuEmxReset_real_T(&gc_gpu_w);
  gpuEmxReset_real_T(&gpu_somega);
  gpuEmxReset_real_T(&c_gpu_y);
  gpuEmxReset_real_T(&b_gpu_y);
  gpuEmxReset_real_T(&gpu_omega_tmp2);
  gpuEmxReset_int32_T(&gpu_omega_tmp1);
  gpuEmxReset_real_T(&gpu_fb_Omega);
  gpuEmxReset_real_T(&gpu_fb_Scales);
  gpuEmxReset_real32_T(&gpu_y);
  gpuEmxReset_real32_T(&b_gpu_x);
  checkCudaError(mwCudaMalloc(&gpu_dc, 16UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dc6, 16UL), __FILE__, __LINE__);
  gpuEmxReset_real32_T(&gpu_x);
  b_fx_data_outdatedOnCpu = false;
  fx_data_outdatedOnCpu = false;
  b_h_outdatedOnGpu = false;
  h_outdatedOnGpu = false;
  wtc_outdatedOnCpu = false;
  d_x_outdatedOnCpu = false;
  crossCFS_outdatedOnCpu = false;
  c_x_outdatedOnCpu = false;
  b_x_outdatedOnCpu = false;
  daughter_outdatedOnCpu = false;
  x_outdatedOnGpu = true;
  r_y_needsGpuEnsureCapacity = true;
  q_y_needsGpuEnsureCapacity = true;
  p_y_needsGpuEnsureCapacity = true;
  o_y_needsGpuEnsureCapacity = true;
  n_y_needsGpuEnsureCapacity = true;
  m_y_needsGpuEnsureCapacity = true;
  l_y_needsGpuEnsureCapacity = true;
  k_y_needsGpuEnsureCapacity = true;
  j_y_needsGpuEnsureCapacity = true;
  b_G_needsGpuEnsureCapacity = true;
  i_y_needsGpuEnsureCapacity = true;
  h_y_needsGpuEnsureCapacity = true;
  g_y_needsGpuEnsureCapacity = true;
  f_y_needsGpuEnsureCapacity = true;
  e_y_needsGpuEnsureCapacity = true;
  b_h_needsGpuEnsureCapacity = true;
  d_y_needsGpuEnsureCapacity = true;
  c_y_needsGpuEnsureCapacity = true;
  G_needsGpuEnsureCapacity = true;
  h_needsGpuEnsureCapacity = true;
  f_omega_tmp1_needsGpuEnsureCapa = true;
  e_omega_tmp1_needsGpuEnsureCapa = true;
  d_omega_tmp1_needsGpuEnsureCapa = true;
  b_y_needsGpuEnsureCapacity = true;
  y_needsGpuEnsureCapacity = true;
  c_omega_tmp1_needsGpuEnsureCapa = true;
  x_needsGpuEnsureCapacity = true;
  checkCudaError(cudaMemcpy(gpu_dc, &cpu_dc, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  checkCudaError(cudaMemcpy(gpu_dc6, &cpu_dc6, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  ec_wtcc_kernel1<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_dc, gpu_dc6);
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  //  Wavelet coherence & resample
  // 'ec_wtcc:4' x (:,:){mustBeFloat}
  // 'ec_wtcc:5' c (:,2){uint16}
  // 'ec_wtcc:6' fs (1,1){mustBeFloat}
  // 'ec_wtcc:7' fLims (1,2){mustBeFloat}
  // 'ec_wtcc:8' fVoices (1,1){mustBeFloat} = 12
  // 'ec_wtcc:9' ds (1,2){mustBeFloat} = [1,1]
  //  Trigger kernel creation
  // 'ec_wtcc:13' coder.gpu.kernelfun;
  //  Make vars
  // 'ec_wtcc:16' nPairs = height(c);
  // 'ec_wtcc:17' tmp = cell(1,nPairs);
  i = xx_size[0] * xx_size[1];
  xx_size[0] = 1;
  xx_size[1] = c_size[0];
  emxEnsureCapacity_cell_wrap_0(xx_data, xx_size, i, &emlrtRTEI);

  // 'ec_wtcc:18' xx = coder.nullcopy(tmp);
  //  Fix define array error
  // 'ec_wtcc:19' yy = coder.nullcopy(tmp);
  i = yy_size[0] * yy_size[1];
  yy_size[0] = 1;
  yy_size[1] = c_size[0];
  emxEnsureCapacity_cell_wrap_0(yy_data, yy_size, i, &b_emlrtRTEI);

  //  Loop across pairs
  // 'ec_wtcc:22' for p = 1:nPairs
  i1 = c_size[0];
  if (c_size[0] - 1 >= 0) {
    if ((fs == 0.0F) || std::isnan(static_cast<real_T>(fs))) {
      b = true;
    } else {
      b = false;
    }
  }

  emxInit_real32_T(&b_cpu_x, 1, &c_emlrtRTEI, true);
  emxInit_real32_T(&cpu_y, 1, &d_emlrtRTEI, true);
  emxInit_real_T(&cpu_fb_Scales, 2, &ud_emlrtRTEI, true);
  emxInit_real_T(&cpu_fb_Omega, 2, &ud_emlrtRTEI, true);
  emxInit_int32_T(&cpu_omega_tmp1, 2, &e_emlrtRTEI, true);
  emxInit_real_T(&cpu_omega_tmp2, 2, &f_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_y, 2, &vd_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_y, 2, &wd_emlrtRTEI, true);
  emxInit_real_T(&cpu_somega, 2, &xd_emlrtRTEI, true);
  emxInit_real_T(&cpu_w, 2, &m_emlrtRTEI, true);
  emxInit_real_T(&cpu_expnt, 2, &n_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_y, 2, &yd_emlrtRTEI, true);
  emxInit_real_T(&cpu_daughter, 2, &t_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_y, 2, &ae_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_y, 2, &be_emlrtRTEI, true);
  emxInit_real32_T(&cpu_psihat, 2, &q_emlrtRTEI, true);
  emxInit_real32_T(&cpu_xv, 2, &s_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_xposdft, 2, &u_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_x, 2, &w_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_cfsposdft, 2, &ce_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_cfspos, 2, &y_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_psihat, 2, &q_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_xv, 2, &s_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_xposdft, 2, &u_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_x, 2, &w_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_cfsposdft, 2, &ce_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_cfspos, 2, &y_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_y, 2, &de_emlrtRTEI, true);
  emxInit_real32_T(&cpu_cfs1, 2, &kb_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_omega_tmp1, 2, &bb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_omega_tmp2, 2, &cb_emlrtRTEI, true);
  emxInit_real_T(&cpu_omega, 2, &db_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_cfsDFT, 2, &eb_emlrtRTEI, true);
  emxInit_real_T(&cpu_Fmat, 2, &ee_emlrtRTEI, true);
  emxInit_creal32_T(&h_cpu_y, 2, &fe_emlrtRTEI, true);
  emxInit_creal32_T(&e_cpu_x, 2, &gb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_smooth, 2, &ge_emlrtRTEI, true);
  emxInit_real32_T(&cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_y, 2, &he_emlrtRTEI, true);
  emxInit_real32_T(&cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_cfs2, 2, &qb_emlrtRTEI, true);
  emxInit_int32_T(&j_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&k_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv9, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv10, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&l_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_omega_tmp1, 2, &bb_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_omega_tmp2, 2, &cb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv11, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_omega, 2, &db_emlrtRTEI, true);
  emxInit_int32_T(&cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_cfsDFT, 2, &eb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_Fmat, 2, &ee_emlrtRTEI, true);
  emxInit_creal32_T(&m_cpu_y, 2, &fe_emlrtRTEI, true);
  emxInit_creal32_T(&f_cpu_x, 2, &gb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_smooth, 2, &ge_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_crossCFS, 2, &rb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_int32_T(&d_cpu_omega_tmp1, 2, &bb_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&n_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_omega_tmp2, 2, &cb_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&o_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_omega, 2, &db_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv12, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv13, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&p_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_cfsDFT, 2, &eb_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_Fmat, 2, &ee_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv14, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&g_cpu_x, 2, &sb_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_smooth, 2, &ge_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&q_cpu_y, 2, &je_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&e_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&r_cpu_y, 2, &je_emlrtRTEI, true);
  emxInit_int32_T(&s_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&f_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&t_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_wtc, 2, &vb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv16, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv17, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&u_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_opts_filter, 1, &wb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_opts_x, 2, &wb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv18, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&cpu_dv23, 1, &ke_emlrtRTEI, true);
  emxInit_real_T(&cpu_h1, 1, &cc_emlrtRTEI, true);
  emxInit_real_T(&cpu_h, 2, &emlrtRTEI, true);
  emxInit_real_T(&cpu_m, 2, &bc_emlrtRTEI, true);
  emxInit_real_T(&cpu_k, 1, &dc_emlrtRTEI, true);
  emxInit_real_T(&cpu_G, 2, &le_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc1A, 2, &me_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc2A, 2, &ne_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_h, 1, &ic_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc3A, 2, &oe_emlrtRTEI, true);
  emxInit_uint32_T(&v_cpu_y, 2, &pe_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc4A, 2, &qe_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv19, 2, &re_emlrtRTEI, true);
  emxInit_real_T(&cpu_b, 1, &kc_emlrtRTEI, true);
  emxInit_real32_T(&cpu_y1, 2, &se_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_a, 1, &emlrtRTEI, true);
  emxInit_real_T(&cpu_dv25, 1, &te_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_x, 1, &ue_emlrtRTEI, true);
  emxInit_int32_T(&cpu_jpvt, 2, &emlrtRTEI, true);
  emxInit_real_T(&cpu_dv26, 1, &te_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_opts_filter, 1, &wb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_xCol, 2, &yc_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_opts_x, 2, &wb_emlrtRTEI, true);
  emxInit_real_T(&cpu_tau, 1, &emlrtRTEI, true);
  emxInit_real_T(&w_cpu_y, 1, &ve_emlrtRTEI, true);
  emxInit_ptrdiff_t(&jpvt_t, 1, &dd_emlrtRTEI, true);
  emxInit_int32_T(&cpu_IPIV, 1, &we_emlrtRTEI, true);
  emxInit_real32_T(&cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real_T(&x_cpu_y, 1, &ye_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&h_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&k_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&l_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&m_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&n_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_w, 1, &id_emlrtRTEI, true);
  emxInit_real32_T(&o_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&p_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&h_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&q_cpu_x, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&k_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&h_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&h_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&y_cpu_y, 1, &id_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&h_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_real32_T(&k_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_int32_T(&ab_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&k_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real32_T(&l_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_real_T(&cb_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_real32_T(&l_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&m_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&n_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&o_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&i_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&p_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&j_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv42, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv43, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&cpu_dv27, 1, &ke_emlrtRTEI, true);
  emxInit_real32_T(&k_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&l_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&db_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&m_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&n_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&eb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&o_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&p_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&q_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&q_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_int32_T(&d_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&e_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ib_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&r_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&s_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&t_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&u_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&r_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&v_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&w_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&lb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&s_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_int32_T(&mb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_h1, 1, &cc_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_h, 2, &emlrtRTEI, true);
  emxInit_int32_T(&ob_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_real32_T(&x_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&pb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&rb_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&sb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&tb_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv44, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv45, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&y_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ab_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ub_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_real32_T(&t_cpu_c, 1, &bf_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_int32_T(&vb_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&wb_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_real32_T(&xb_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv46, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&bb_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cb_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&yb_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv47, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&db_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&eb_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ac_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv48, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv49, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv50, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv51, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv52, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&dc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ec_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_m, 2, &bc_emlrtRTEI, true);
  emxInit_int32_T(&fc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv53, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv54, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&hc_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv55, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&ic_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_real32_T(&jc_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv56, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&fb_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&gb_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv57, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_k, 1, &dc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv58, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv59, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&lc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&mc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&nc_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&oc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&pc_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_real_T(&qc_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_int32_T(&rc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv62, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&f_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&g_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv63, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&sc_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_real32_T(&hb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ib_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv64, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&tc_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_real32_T(&jb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&kb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv65, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&uc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&vc_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&wc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv66, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&xc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv67, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&h_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&i_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&yc_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv69, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_G, 2, &le_emlrtRTEI, true);
  emxInit_int32_T(&j_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ad_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv70, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&lb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&mb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&nb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ob_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&pb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&qb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&bd_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_int32_T(&cd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv71, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&dd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&rb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&sb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ed_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&tb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ub_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv72, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv73, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv74, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&k_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_sinc1A, 2, &me_emlrtRTEI, true);
  emxInit_int32_T(&id_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv75, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&l_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&m_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ld_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&vb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&wb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&xb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&yb_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ac_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&bc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv76, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&n_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_sinc2A, 2, &ne_emlrtRTEI, true);
  emxInit_real32_T(&cc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&dc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv77, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&o_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&md_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&p_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&od_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&q_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv78, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_h, 1, &ic_emlrtRTEI, true);
  emxInit_int32_T(&pd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&r_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv79, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv80, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&rd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&sd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_sinc3A, 2, &oe_emlrtRTEI, true);
  emxInit_uint32_T(&td_cpu_y, 2, &pe_emlrtRTEI, true);
  emxInit_int32_T(&ud_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv81, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv82, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&d_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&s_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv84, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&e_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&t_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ec_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&fc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv86, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&u_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv87, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv88, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&v_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_sinc4A, 2, &qe_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv89, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv90, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&w_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&vd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&x_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv91, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv92, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&wd_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&y_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ab_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv93, 2, &re_emlrtRTEI, true);
  emxInit_int32_T(&cb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&db_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv94, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&f_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv95, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&eb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv97, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv98, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ib_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv99, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv100, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv101, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv103, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_b, 1, &kc_emlrtRTEI, true);
  emxInit_int32_T(&lb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&mb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ob_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&pb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv107, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&rb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&sb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&tb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv108, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_y1, 2, &se_emlrtRTEI, true);
  emxInit_int32_T(&ub_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&vb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_a, 1, &emlrtRTEI, true);
  emxInit_real_T(&cpu_dv29, 1, &te_emlrtRTEI, true);
  emxInit_real_T(&r_cpu_x, 1, &ue_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_jpvt, 2, &emlrtRTEI, true);
  emxInit_real32_T(&cpu_fv, 2, &emlrtRTEI, true);
  emxInit_real_T(&cpu_dv31, 1, &te_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_xCol, 2, &yc_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_tau, 1, &emlrtRTEI, true);
  emxInit_real_T(&xd_cpu_y, 1, &ve_emlrtRTEI, true);
  emxInit_ptrdiff_t(&b_jpvt_t, 1, &dd_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_IPIV, 1, &we_emlrtRTEI, true);
  emxInit_creal32_T(&k_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&l_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&m_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&n_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&o_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&p_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_real_T(&yd_cpu_y, 1, &ye_emlrtRTEI, true);
  emxInit_creal32_T(&q_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&r_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&s_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&l_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&m_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&n_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&t_cpu_yCol, 1, &xe_emlrtRTEI, true);
  emxInit_creal32_T(&o_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&p_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&q_cpu_w, 1, &id_emlrtRTEI, true);
  emxInit_creal32_T(&r_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&s_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&t_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&u_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&v_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&n_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&o_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&w_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&u_cpu_w, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&x_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&y_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&p_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&q_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&r_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&ab_cpu_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&ae_cpu_y, 1, &id_emlrtRTEI, true);
  emxInit_creal32_T(&s_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&gc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&hc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&b_c, 1, &ie_emlrtRTEI, true);
  emxInit_creal32_T(&t_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&u_cpu_a, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&be_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ce_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_real_T(&de_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_creal32_T(&ic_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&jc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv139, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv140, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&kc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&lc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ee_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&mc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&nc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fe_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&oc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&pc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ge_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&qc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&he_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ie_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&je_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&rc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&sc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ke_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&wb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&xb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&tc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&uc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&le_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&vc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&wc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&me_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ne_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&oe_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&g_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_int32_T(&pe_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&h_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_creal32_T(&xc_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qe_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&re_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&se_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&te_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&ue_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv141, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv142, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&yc_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ad_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ve_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&i_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_creal32_T(&j_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_creal32_T(&k_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_int32_T(&we_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&xe_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_creal32_T(&ye_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv143, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&bd_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&cd_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&af_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv144, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&dd_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ed_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv145, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv146, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv147, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv148, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv149, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&df_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ef_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ff_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&l_cpu_result, 1, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv150, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv151, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&if_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv152, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&jf_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_creal32_T(&kf_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv153, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&fd_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_real32_T(&gd_cpu_expanded, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv154, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv155, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv156, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&lf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&mf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&of_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&pf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&qf_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_real_T(&rf_cpu_y, 2, &af_emlrtRTEI, true);
  emxInit_int32_T(&sf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv159, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&yb_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ac_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv160, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&b_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&tf_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_creal32_T(&hd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&id_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv161, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&uf_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_creal32_T(&jd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&kd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv162, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&vf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&wf_cpu_y, 2, &id_emlrtRTEI, true);
  emxInit_int32_T(&xf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv163, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&yf_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv164, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ag_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv166, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&dc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv167, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&ld_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&md_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&nd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&od_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&pd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&qd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real_T(&cg_cpu_y, 2, &cf_emlrtRTEI, true);
  emxInit_int32_T(&dg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv168, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&eg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&rd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&sd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&td_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&ud_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv169, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv170, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv171, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ig_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ec_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv172, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&lg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&mg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&vd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&wd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&xd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&yd_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&ae_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&be_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv173, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&g_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&ce_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&de_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv174, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&h_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ic_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ng_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&og_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&pg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv175, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&lc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv176, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&rg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv177, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&sg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&tg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ug_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv178, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&i_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv179, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&j_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&mc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv181, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&k_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&ee_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&fe_cpu_expanded, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv183, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&oc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv184, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv185, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&pc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv186, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv187, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&qc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&vg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&rc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv188, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv189, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&wg_cpu_y, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&sc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&tc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&uc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&vc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&wc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv190, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&l_cpu_cols, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv191, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&xc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv193, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&yc_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ad_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv194, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&bd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv195, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv196, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv197, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&dd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv199, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ed_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&fd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&gd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&hd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&id_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&jd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv203, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&kd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&ld_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&md_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&nd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv204, 1, &nb_emlrtRTEI, true);
  emxInit_int32_T(&od_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_int32_T(&pd_cpu_rows, 2, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&d_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&e_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&f_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&g_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&h_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&i_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&j_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&k_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&l_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&m_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&n_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&o_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&p_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&q_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&r_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&s_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&t_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&u_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&v_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_creal32_T(&w_cpu_newIm, 1, &nb_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_smooth, 1, &mb_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_smooth, 2, &pb_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_smooth, 1, &mb_emlrtRTEI, true);
  emxInit_real32_T(&g_cpu_smooth, 2, &pb_emlrtRTEI, true);
  emxInit_creal32_T(&smooth, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&h_cpu_smooth, 2, &pb_emlrtRTEI, true);
  emxInit_real_T(&cpu_b0, 1, &nc_emlrtRTEI, true);
  emxInit_real32_T(&v_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&w_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&x_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&y_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&ab_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&bb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&cb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&db_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&eb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&fb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&gb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&xg_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&hb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&ib_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&yg_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&ah_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&bh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&ch_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&jb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&kb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&lb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&mb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real32_T(&dh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_real32_T(&nb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_b0, 1, &nc_emlrtRTEI, true);
  emxInit_creal32_T(&u_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&v_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&w_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&x_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&y_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&ab_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&bb_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&cb_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&db_cpu_yCol, 1, &mb_emlrtRTEI, true);
  emxInit_creal32_T(&ob_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&pb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&qb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&rb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&sb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&tb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&ub_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&vb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&wb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&xb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&yb_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&eh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&ac_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&bc_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&fh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&gh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&hh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&ih_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&cc_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&dc_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&ec_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&fc_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_creal32_T(&jh_cpu_y, 2, &od_emlrtRTEI, true);
  emxInit_creal32_T(&gc_cpu_w, 2, &nd_emlrtRTEI, true);
  emxInit_char_T(&tmpStr, 2, &emlrtRTEI, true);
  emxInit_char_T(&b_tmpStr, 2, &emlrtRTEI, true);
  for (int32_T p{0}; p < i1; p++) {
    int64_T f;
    real_T cpu_subs[1298];
    real_T cpu_interval[650];
    real_T errsub[649];
    real_T qsub[649];
    real_T F[4];
    real_T varargin_2[4];
    real_T c_blockDims[3];
    real_T FreqLimits[2];
    real_T NyquistRange[2];
    real_T T;
    real_T a;
    real_T b_m;
    real_T b_p;
    real_T b_r;
    real_T c_a;
    real_T c_c;
    real_T d;
    real_T e;
    real_T fa;
    real_T fb;
    real_T fc;
    real_T halfh;
    real_T omegac;
    real_T r;
    real_T s;
    real_T tol;
    real_T toler;
    int32_T b_blockDims[3];
    int32_T cpu_lshift[2];
    int32_T cpu_origSiz[2];
    int32_T omega_tmp2[1];
    int32_T OH;
    int32_T bcoef;
    int32_T exitg2;
    int32_T fb_SignalPad;
    int32_T i1Start;
    int32_T itime;
    int32_T ix;
    int32_T n;
    int32_T nsubs;
    int32_T offsetH;
    real32_T cv_im;
    uint32_T blockDims[3];
    uint32_T xSize[2];
    uint32_T N;
    uint32_T b_u;
    char_T cpu_wav[4];
    char_T cpu_wname[4];
    int8_T n_idx_0;
    boolean_T c_b[2];
    boolean_T G_outdatedOnCpu;
    boolean_T Nodd;
    boolean_T b_guard1;
    boolean_T c_fb_Scales_needsGpuEnsureCapac;
    boolean_T exitg1;
    boolean_T exitg3;
    boolean_T exitg4;
    boolean_T fb_Omega_needsGpuEnsureCapacity;
    boolean_T fb_Omega_outdatedOnCpu;
    boolean_T fb_Omega_outdatedOnGpu;
    boolean_T first_iteration;
    boolean_T guard1;
    boolean_T interval_outdatedOnGpu;
    boolean_T omega_tmp2_outdatedOnCpu;
    boolean_T opts_isRowVectorInput;
    boolean_T opts_x_needsGpuEnsureCapacity;
    boolean_T opts_x_outdatedOnCpu;
    boolean_T subs_outdatedOnCpu;
    boolean_T validLaunchParams;
    boolean_T wav_outdatedOnCpu;
    boolean_T x_outdatedOnCpu;
    boolean_T y_outdatedOnCpu;

    // 'ec_wtcc:23' [xx{p},yy{p}] = wtc_lfn(x(:,c(p,1)),x(:,c(p,2)),fs,fLims,fVoices,ds);
    i = b_cpu_x->size[0];
    b_cpu_x->size[0] = cpu_x->size[0];
    emxEnsureCapacity_real32_T(b_cpu_x, i, &c_emlrtRTEI);
    i = cpu_y->size[0];
    cpu_y->size[0] = cpu_x->size[0];
    emxEnsureCapacity_real32_T(cpu_y, i, &d_emlrtRTEI);
    n = cpu_x->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (x_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real32_T(cpu_x, &gpu_x, !x_outdatedOnGpu);
    }

    x_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_real32_T(cpu_y, &gpu_y, true);
    gpuEmxEnsureCapacity_real32_T(b_cpu_x, &b_gpu_x, true);
    if (x_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real32_T(&gpu_x, cpu_x);
    }

    x_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel2<<<grid, block>>>(static_cast<int32_T>(c_data[p + c_size[0]]),
        static_cast<int32_T>(c_data[p]), gpu_x, n, gpu_y, b_gpu_x, cpu_x->size
        [0U]);
    }

    x_outdatedOnCpu = true;
    y_outdatedOnCpu = true;

    //  Wavelet coherence - local function
    //  Calculate wavelet coherence
    // 'ec_wtcc:33' [x,y] = wcoherence(x,y,fs,FrequencyLimits=fLims,VoicesPerOctave=fVoices);
    i = cpu_x->size[0];
    r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &eint);
    if (r == 0.5) {
      halfh = static_cast<real_T>(eint) - 1.0;
    } else {
      halfh = std::log(r) / 0.69314718055994529 + static_cast<real_T>(eint);
    }

    halfh = std::trunc(halfh);
    for (itime = 0; itime < 2; itime++) {
      FreqLimits[itime] = fLims[itime];
    }

    r = std::frexp(static_cast<real_T>(i), &b_eint);
    if (r == 0.5) {
      r = static_cast<real_T>(b_eint) - 1.0;
    } else {
      r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(b_eint);
    }

    r = std::trunc(r);
    if (!(halfh - 1.0 <= r - 1.0)) {
      y = nullptr;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &rfmt[0]);
      emlrtAssign(&y, m);
      b_y = nullptr;
      m1 = emlrtCreateDoubleScalar(r - 1.0);
      emlrtAssign(&b_y, m1);
      emlrt_marshallIn(b_sprintf(y, b_y, &emlrtMCI), "<output of sprintf>",
                       unusedExpr);
    }

    guard1 = false;
    if (b) {
      Nodd = true;
      itime = 0;
      exitg1 = false;
      while ((!exitg1) && (itime < 2)) {
        if (!(FreqLimits[itime] == 0.0)) {
          Nodd = false;
          exitg1 = true;
        } else {
          itime++;
        }
      }

      if (Nodd) {
        a = 6.0;
        omegac = 44.729833462074168;
        fa = -1.8;
        fb = 0.2;
        fc = 0.2;
        c_c = 44.729833462074168;
        e = 0.0;
        d = 0.0;
        exitg1 = false;
        while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
          if ((fb > 0.0) == (fc > 0.0)) {
            c_c = a;
            fc = fa;
            d = omegac - a;
            e = d;
          }

          if (std::abs(fc) < std::abs(fb)) {
            a = omegac;
            omegac = c_c;
            c_c = a;
            fa = fb;
            fb = fc;
            fc = fa;
          }

          b_m = 0.5 * (c_c - omegac);
          toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
          if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
            exitg1 = true;
          } else {
            if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
              d = b_m;
              e = b_m;
            } else {
              s = fb / fa;
              if (a == c_c) {
                b_p = 2.0 * b_m * s;
                fa = 1.0 - s;
              } else {
                fa /= fc;
                b_r = fb / fc;
                b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r -
                            1.0));
                fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
              }

              if (b_p > 0.0) {
                fa = -fa;
              } else {
                b_p = -b_p;
              }

              if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) && (b_p <
                   std::abs(0.5 * e * fa))) {
                e = d;
                d = b_p / fa;
              } else {
                d = b_m;
                e = b_m;
              }
            }

            a = omegac;
            fa = fb;
            if (std::abs(d) > toler) {
              omegac += d;
            } else if (omegac > c_c) {
              omegac -= toler;
            } else {
              omegac += toler;
            }

            fb = 0.2 - 2.0 * std::exp(-((omegac - 6.0) * (omegac - 6.0)) / 2.0);
          }
        }

        r = omegac / 3.1415926535897931;
        fa = 1.0 / (r * 1.0471975511965976);
        if ((fa > 0.5) || (r * 1.0471975511965976 < 2.0)) {
          fa = 0.5;
        }

        FreqLimits[0] = rt_powd_snf(2.0, -(halfh - 1.0)) * fa;
        FreqLimits[1] = fa;
      } else {
        guard1 = true;
      }
    } else {
      guard1 = true;
    }

    if (guard1 && ((!(fs == 0.0F)) && (!std::isnan(static_cast<real_T>(fs))))) {
      Nodd = true;
      itime = 0;
      exitg1 = false;
      while ((!exitg1) && (itime < 2)) {
        if (!(FreqLimits[itime] == 0.0)) {
          Nodd = false;
          exitg1 = true;
        } else {
          itime++;
        }
      }

      if (Nodd) {
        T = 1.0 / fs;
        a = 6.0;
        omegac = 44.729833462074168;
        fa = -1.8;
        fb = 0.2;
        fc = 0.2;
        c_c = 44.729833462074168;
        e = 0.0;
        d = 0.0;
        exitg1 = false;
        while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
          if ((fb > 0.0) == (fc > 0.0)) {
            c_c = a;
            fc = fa;
            d = omegac - a;
            e = d;
          }

          if (std::abs(fc) < std::abs(fb)) {
            a = omegac;
            omegac = c_c;
            c_c = a;
            fa = fb;
            fb = fc;
            fc = fa;
          }

          b_m = 0.5 * (c_c - omegac);
          toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
          if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
            exitg1 = true;
          } else {
            if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
              d = b_m;
              e = b_m;
            } else {
              s = fb / fa;
              if (a == c_c) {
                b_p = 2.0 * b_m * s;
                fa = 1.0 - s;
              } else {
                fa /= fc;
                b_r = fb / fc;
                b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r -
                            1.0));
                fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
              }

              if (b_p > 0.0) {
                fa = -fa;
              } else {
                b_p = -b_p;
              }

              if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) && (b_p <
                   std::abs(0.5 * e * fa))) {
                e = d;
                d = b_p / fa;
              } else {
                d = b_m;
                e = b_m;
              }
            }

            a = omegac;
            fa = fb;
            if (std::abs(d) > toler) {
              omegac += d;
            } else if (omegac > c_c) {
              omegac -= toler;
            } else {
              omegac += toler;
            }

            fb = 0.2 - 2.0 * std::exp(-((omegac - 6.0) * (omegac - 6.0)) / 2.0);
          }
        }

        r = omegac / 3.1415926535897931;
        fa = 1.0 / (r * 1.0471975511965976) * fs;
        if ((fa > fs / 2.0) || (r * 1.0471975511965976 * T < 2.0 * T)) {
          fa = fs / 2.0;
        }

        FreqLimits[0] = rt_powd_snf(2.0, -(halfh - 1.0)) * fa;
        FreqLimits[1] = fa;
      }
    }

    first_iteration = false;
    cpu_lidx = 0;
    do {
      exitg2 = 0;
      if (cpu_lidx + 1 < 11) {
        if (cpu_cv[static_cast<int32_T>(b_b[cpu_lidx])] != cpu_cv
            [static_cast<int32_T>(cv1[cpu_lidx])]) {
          exitg2 = 1;
        } else {
          cpu_lidx++;
        }
      } else {
        first_iteration = true;
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    if (first_iteration) {
      if (cpu_x->size[0] <= 100000) {
        fb_SignalPad = static_cast<int32_T>(std::floor(static_cast<real_T>
          (cpu_x->size[0]) / 2.0));
      } else {
        r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &c_eint);
        if (r == 0.5) {
          halfh = static_cast<real_T>(c_eint) - 1.0;
        } else {
          halfh = std::log(r) / 0.69314718055994529 + static_cast<real_T>(c_eint);
        }

        halfh = std::ceil(halfh);
        fb_SignalPad = static_cast<int32_T>(halfh);
      }
    } else {
      fb_SignalPad = 0;
    }

    for (itime = 0; itime < 2; itime++) {
      c_b[itime] = std::isnan(FreqLimits[itime]);
    }

    first_iteration = true;
    itime = 0;
    exitg1 = false;
    while ((!exitg1) && (itime < 2)) {
      if (!c_b[itime]) {
        first_iteration = false;
        exitg1 = true;
      } else {
        itime++;
      }
    }

    if (!first_iteration) {
      real_T freqrange[2];
      real_T cf;
      for (itime = 0; itime < 2; itime++) {
        freqrange[itime] = FreqLimits[itime];
      }

      NyquistRange[1] = fs / 2.0;
      if ((FreqLimits[1] <= 0.0) || (FreqLimits[0] >= NyquistRange[1])) {
        c_tmpStr = nullptr;
        c_y = nullptr;
        m2 = emlrtCreateCharArray(2, &iv2[0]);
        emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m2, &u[0]);
        emlrtAssign(&c_y, m2);
        d_y = nullptr;
        m3 = emlrtCreateCharArray(2, &iv3[0]);
        emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 2, m3, &formatSpec[0]);
        emlrtAssign(&d_y, m3);
        e_y = nullptr;
        m4 = emlrtCreateDoubleScalar(NyquistRange[1]);
        emlrtAssign(&e_y, m4);
        emlrtAssign(&c_tmpStr, feval(c_y, d_y, e_y, &b_emlrtMCI));
        emlrt_marshallIn(length(emlrtAlias(c_tmpStr), &c_emlrtMCI),
                         "<output of length>");
        emlrt_marshallIn(emlrtAlias(c_tmpStr), "tmpStr", tmpStr);
        emlrtDestroyArray(&c_tmpStr);
      }

      omegac = 3.1415926535897931;
      ec_wtcc_kernel3<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv,
        *gpu_wname, *gpu_wav, b_a[0], b_a[1], b_a[2], b_a[3]);
      wav_outdatedOnCpu = true;
      checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL,
        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
      if (cpu_wname[0] == 'm') {
        cf = 1.8820720577620569;
        b_r = 0.0057083835261;
        r = 0.0057083835261;
        fa = 0.0057083835261;
        for (ix = 0; ix < 6; ix++) {
          s = d_c[ix];
          b_r = b_r * 0.005353955978584176 + s;
          r = r * 0.005353955978584176 + s;
          fa = fa * 0.005353955978584176 + s;
        }

        b_r /= 13.666666666666666;
        r /= 13.666666666666666;
        fa /= 13.666666666666666;
        r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((b_r
          + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) +
                       std::exp((cpu_table100[14] + 2.5377749931802178) - (((r +
          0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) -
                      std::exp((cpu_table100[13] + 5.8211893391859881) - (((fa +
          0.91893853320467278) - 1.307479889018099) + 22.071116966494703)));
        if (std::isinf(r) || std::isnan(r)) {
          ec_wtcc_kernel4<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
          ec_wtcc_kernel5<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
            (*gpu_interval);
          interval_outdatedOnGpu = false;
          toler = 0.0;
          offsetH = 1;
          checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          ix = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
            (cpu_interval[0]);
          if (ix > 0) {
            n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
              (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
            nsubs = n_idx_0 + 1;
            if (n_idx_0 + 2 > 2) {
              cpu_lidx = n_idx_0;
              cpu_interval[n_idx_0 + 1] = cpu_interval[1];
              interval_outdatedOnGpu = true;
              r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
                (n_idx_0) + 1.0);
              for (bcoef = 0; bcoef < cpu_lidx; bcoef++) {
                cpu_interval[n_idx_0 - bcoef] = cpu_interval[0] +
                  static_cast<real_T>(n_idx_0 - bcoef) * r;
              }
            }

            offsetH = n_idx_0 + 1;
          } else {
            nsubs = 1;
          }

          cpu_lidx = 0;
          for (bcoef = 0; bcoef < offsetH; bcoef++) {
            if (std::abs(cpu_interval[bcoef + 1] - cpu_interval[cpu_lidx]) > 0.0)
            {
              cpu_lidx++;
              cpu_interval[cpu_lidx] = cpu_interval[bcoef + 1];
              interval_outdatedOnGpu = true;
            } else {
              nsubs--;
            }
          }

          if (nsubs + 1 < 2) {
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel6<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(offsetH,
              *gpu_interval);
            interval_outdatedOnGpu = false;
            nsubs = 1;
          }

          if (ix <= 0) {
            toler = rtNaN;
          } else {
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1346<<<grid, block>>>(*gpu_interval, nsubs - 1,
                *gpu_subs);
            }

            subs_outdatedOnCpu = true;
            T = 0.0;
            b_p = 0.0;
            first_iteration = true;
            do {
              exitg2 = 0;
              interval_outdatedOnGpu = false;
              n = 15 * nsubs;
              ix = -1;
              for (itime = 0; itime < nsubs; itime++) {
                if (subs_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                s = cpu_subs[itime << 1];
                subs_outdatedOnCpu = false;
                fa = cpu_subs[(itime << 1) + 1];
                r = (s + fa) / 2.0;
                halfh = (fa - s) / 2.0;
                for (bcoef = 0; bcoef < 15; bcoef++) {
                  SD->f0.cpu_x_data[(ix + bcoef) + 1] = NODES[bcoef] * halfh + r;
                  interval_outdatedOnGpu = true;
                }

                ix += 15;
              }

              xt_size[0] = 1;
              xt_size[1] = n;
              mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data,
                  77880UL, cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1347<<<grid, block>>>(*gpu_x_data, n - 1,
                  *gpu_xt_data, *b_gpu_x_data);
              }

              b_guard1 = false;
              if (!first_iteration) {
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                halfh = std::abs(SD->f0.cpu_x_data[0]);
                Nodd = false;
                itime = 0;
                exitg1 = false;
                while ((!exitg1) && (itime <= n - 2)) {
                  s = halfh;
                  halfh = std::abs(SD->f0.cpu_x_data[itime + 1]);
                  if (std::abs(SD->f0.cpu_x_data[itime + 1] - SD->
                               f0.cpu_x_data[itime]) <= 2.2204460492503131E-14 *
                      std::fmax(s, halfh)) {
                    Nodd = true;
                    exitg1 = true;
                  } else {
                    itime++;
                  }
                }

                if (Nodd) {
                  fx_size[0] = 1;
                  fx_size[1] = n;
                  mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>(n)
                    - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1348<<<grid, block>>>(static_cast<int16_T>(n)
                      - 1, *d_gpu_fx_data);
                  }

                  fx_data_outdatedOnCpu = true;
                  exitg2 = 1;
                } else {
                  b_guard1 = true;
                }
              } else {
                b_guard1 = true;
              }

              if (b_guard1) {
                first_iteration = false;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1349<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1350<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_x_data);
                }

                a_size[1] = n;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1351<<<grid, block>>>(*gpu_x_data, *gpu_y_data,
                    n - 1, *c_gpu_a_data);
                }

                dv2_size[0] = 1;
                dv2_size[1] = a_size[1];
                mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1352<<<grid, block>>>(*c_gpu_a_data, a_size[1] -
                    1, *gpu_dv2_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1353<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                dv6_size[0] = 1;
                dv6_size[1] = n;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1354<<<grid, block>>>(*gpu_y_data, n - 1,
                    *gpu_x_data);
                }

                if (a_size[1] == n) {
                  fx_size[0] = 1;
                  fx_size[1] = a_size[1];
                  mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                    &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1355<<<grid, block>>>(*gpu_xt_data,
                      *gpu_x_data, *gpu_dv2_data, a_size[1] - 1, *d_gpu_fx_data);
                  }

                  fx_data_outdatedOnCpu = true;
                } else {
                  if (fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *d_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  checkCudaError(cudaMemcpy(SD->f0.cpu_dv2_data, *gpu_dv2_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  binary_expand_op_10(SD->f0.cpu_fx_data, fx_size,
                                      SD->f0.cpu_dv2_data, dv2_size,
                                      SD->f0.cpu_x_data, dv6_size,
                                      SD->f0.cpu_xt_data, xt_size);
                  fx_data_outdatedOnCpu = false;
                }

                r = 0.0;
                ix = -1;
                for (itime = 0; itime < nsubs; itime++) {
                  s = 0.0;
                  fa = 0.0;
                  for (bcoef = 0; bcoef < 15; bcoef++) {
                    if (fx_data_outdatedOnCpu) {
                      checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data,
                        *d_gpu_fx_data, 77880UL, cudaMemcpyDeviceToHost),
                                     __FILE__, __LINE__);
                    }

                    s += dv3[bcoef] * SD->f0.cpu_fx_data[(ix + bcoef) + 1];
                    fx_data_outdatedOnCpu = false;
                    fa += dv4[bcoef] * SD->f0.cpu_fx_data[(ix + bcoef) + 1];
                  }

                  ix += 15;
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  halfh = (cpu_subs[(itime << 1) + 1] - cpu_subs[itime << 1]) /
                    2.0;
                  s *= halfh;
                  qsub[itime] = s;
                  r += s;
                  errsub[itime] = fa * halfh;
                }

                toler = r + T;
                tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(toler));
                fb = 2.0 * tol;
                r = 0.0;
                cpu_lidx = 0;
                for (itime = 0; itime < nsubs; itime++) {
                  s = errsub[itime];
                  fa = std::abs(s);
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  if (fa <= fb * ((cpu_subs[(itime << 1) + 1] - cpu_subs[itime <<
                                   1]) / 2.0)) {
                    b_p += s;
                    T += qsub[itime];
                  } else {
                    r += fa;
                    cpu_lidx++;
                    cpu_subs[(cpu_lidx - 1) << 1] = cpu_subs[itime << 1];
                    cpu_subs[((cpu_lidx - 1) << 1) + 1] = cpu_subs[(itime << 1)
                      + 1];
                  }
                }

                r += std::abs(b_p);
                if ((!std::isinf(toler)) && (!std::isnan(toler)) && ((!std::
                      isinf(r)) && (!std::isnan(r))) && (cpu_lidx != 0) && (!(r <=
                      tol))) {
                  nsubs = cpu_lidx << 1;
                  if (nsubs > 650) {
                    exitg2 = 1;
                  } else {
                    for (itime = 0; itime < cpu_lidx; itime++) {
                      if (subs_outdatedOnCpu) {
                        checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                      }

                      cpu_subs[((((cpu_lidx - itime) << 1) - 1) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) - 1) << 1) + 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1] =
                        (cpu_subs[((cpu_lidx - itime) - 1) << 1] + cpu_subs
                         [(((cpu_lidx - itime) - 1) << 1) + 1]) / 2.0;
                      cpu_subs[((((cpu_lidx - itime) << 1) - 2) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 2) << 1] = cpu_subs
                        [((cpu_lidx - itime) - 1) << 1];
                      subs_outdatedOnCpu = false;
                    }
                  }
                } else {
                  exitg2 = 1;
                }
              }
            } while (exitg2 == 0);
          }

          ec_wtcc_kernel7<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
          ec_wtcc_kernel8<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
            (*gpu_interval);
          interval_outdatedOnGpu = false;
          b_m = 0.0;
          offsetH = 1;
          checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          ix = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
            (cpu_interval[0]);
          if (ix > 0) {
            n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
              (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
            nsubs = n_idx_0 + 1;
            if (n_idx_0 + 2 > 2) {
              cpu_lidx = n_idx_0;
              cpu_interval[n_idx_0 + 1] = cpu_interval[1];
              interval_outdatedOnGpu = true;
              r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
                (n_idx_0) + 1.0);
              for (bcoef = 0; bcoef < cpu_lidx; bcoef++) {
                cpu_interval[n_idx_0 - bcoef] = cpu_interval[0] +
                  static_cast<real_T>(n_idx_0 - bcoef) * r;
              }
            }

            offsetH = n_idx_0 + 1;
          } else {
            nsubs = 1;
          }

          cpu_lidx = 0;
          for (bcoef = 0; bcoef < offsetH; bcoef++) {
            if (std::abs(cpu_interval[bcoef + 1] - cpu_interval[cpu_lidx]) > 0.0)
            {
              cpu_lidx++;
              cpu_interval[cpu_lidx] = cpu_interval[bcoef + 1];
              interval_outdatedOnGpu = true;
            } else {
              nsubs--;
            }
          }

          if (nsubs + 1 < 2) {
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel9<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(offsetH,
              *gpu_interval);
            interval_outdatedOnGpu = false;
            nsubs = 1;
          }

          if (ix <= 0) {
            b_m = rtNaN;
          } else {
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1339<<<grid, block>>>(*gpu_interval, nsubs - 1,
                *gpu_subs);
            }

            subs_outdatedOnCpu = true;
            T = 0.0;
            b_p = 0.0;
            first_iteration = true;
            do {
              exitg2 = 0;
              interval_outdatedOnGpu = false;
              n = 15 * nsubs;
              ix = -1;
              for (itime = 0; itime < nsubs; itime++) {
                if (subs_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                s = cpu_subs[itime << 1];
                subs_outdatedOnCpu = false;
                fa = cpu_subs[(itime << 1) + 1];
                r = (s + fa) / 2.0;
                halfh = (fa - s) / 2.0;
                for (bcoef = 0; bcoef < 15; bcoef++) {
                  SD->f0.cpu_x_data[(ix + bcoef) + 1] = NODES[bcoef] * halfh + r;
                  interval_outdatedOnGpu = true;
                }

                ix += 15;
              }

              mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data,
                  77880UL, cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1340<<<grid, block>>>(*gpu_x_data, n - 1,
                  *gpu_xt_data, *b_gpu_x_data);
              }

              b_guard1 = false;
              if (!first_iteration) {
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                halfh = std::abs(SD->f0.cpu_x_data[0]);
                Nodd = false;
                itime = 0;
                exitg1 = false;
                while ((!exitg1) && (itime <= n - 2)) {
                  s = halfh;
                  halfh = std::abs(SD->f0.cpu_x_data[itime + 1]);
                  if (std::abs(SD->f0.cpu_x_data[itime + 1] - SD->
                               f0.cpu_x_data[itime]) <= 2.2204460492503131E-14 *
                      std::fmax(s, halfh)) {
                    Nodd = true;
                    exitg1 = true;
                  } else {
                    itime++;
                  }
                }

                if (Nodd) {
                  mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>(n)
                    - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1341<<<grid, block>>>(static_cast<int16_T>(n)
                      - 1, *c_gpu_fx_data);
                  }

                  exitg2 = 1;
                } else {
                  b_guard1 = true;
                }
              } else {
                b_guard1 = true;
              }

              if (b_guard1) {
                first_iteration = false;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1342<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_dv8_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1343<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1344<<<grid, block>>>(*gpu_y_data, n - 1,
                    *gpu_x_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1345<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv8_data, n - 1, *c_gpu_fx_data);
                }

                interval_outdatedOnGpu = true;
                r = 0.0;
                ix = -1;
                for (itime = 0; itime < nsubs; itime++) {
                  s = 0.0;
                  fa = 0.0;
                  for (bcoef = 0; bcoef < 15; bcoef++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(SD->f0.cpu_x_data,
                        *c_gpu_fx_data, 77880UL, cudaMemcpyDeviceToHost),
                                     __FILE__, __LINE__);
                    }

                    s += dv3[bcoef] * SD->f0.cpu_x_data[(ix + bcoef) + 1];
                    interval_outdatedOnGpu = false;
                    fa += dv4[bcoef] * SD->f0.cpu_x_data[(ix + bcoef) + 1];
                  }

                  ix += 15;
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  halfh = (cpu_subs[(itime << 1) + 1] - cpu_subs[itime << 1]) /
                    2.0;
                  s *= halfh;
                  qsub[itime] = s;
                  r += s;
                  errsub[itime] = fa * halfh;
                }

                b_m = r + T;
                tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(b_m));
                fb = 2.0 * tol;
                r = 0.0;
                cpu_lidx = 0;
                for (itime = 0; itime < nsubs; itime++) {
                  s = errsub[itime];
                  fa = std::abs(s);
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  if (fa <= fb * ((cpu_subs[(itime << 1) + 1] - cpu_subs[itime <<
                                   1]) / 2.0)) {
                    b_p += s;
                    T += qsub[itime];
                  } else {
                    r += fa;
                    cpu_lidx++;
                    cpu_subs[(cpu_lidx - 1) << 1] = cpu_subs[itime << 1];
                    cpu_subs[((cpu_lidx - 1) << 1) + 1] = cpu_subs[(itime << 1)
                      + 1];
                  }
                }

                r += std::abs(b_p);
                if ((!std::isinf(b_m)) && (!std::isnan(b_m)) && ((!std::isinf(r))
                     && (!std::isnan(r))) && (cpu_lidx != 0) && (!(r <= tol))) {
                  nsubs = cpu_lidx << 1;
                  if (nsubs > 650) {
                    exitg2 = 1;
                  } else {
                    for (itime = 0; itime < cpu_lidx; itime++) {
                      if (subs_outdatedOnCpu) {
                        checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                      }

                      cpu_subs[((((cpu_lidx - itime) << 1) - 1) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) - 1) << 1) + 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1] =
                        (cpu_subs[((cpu_lidx - itime) - 1) << 1] + cpu_subs
                         [(((cpu_lidx - itime) - 1) << 1) + 1]) / 2.0;
                      cpu_subs[((((cpu_lidx - itime) << 1) - 2) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 2) << 1] = cpu_subs
                        [((cpu_lidx - itime) - 1) << 1];
                      subs_outdatedOnCpu = false;
                    }
                  }
                } else {
                  exitg2 = 1;
                }
              }
            } while (exitg2 == 0);
          }

          r = std::sqrt(3.5421952306087032 * (toler / b_m));
        }
      } else if (cpu_wname[0] == 'a') {
        cf = 6.0;
        r = 1.4142135623730951;
      } else {
        cf = 5.0;
        r = 5.847705;
      }

      halfh = static_cast<real_T>(cpu_x->size[0]) / (r * 2.0);
      first_iteration = false;
      cpu_lidx = 0;
      do {
        exitg2 = 0;
        if (cpu_lidx + 1 < 5) {
          if (wav_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          wav_outdatedOnCpu = false;
          if (cv2[cpu_lidx] != cpu_wav[cpu_lidx]) {
            exitg2 = 1;
          } else {
            cpu_lidx++;
          }
        } else {
          first_iteration = true;
          exitg2 = 1;
        }
      } while (exitg2 == 0);

      if (first_iteration) {
        cpu_lidx = 1;
      } else {
        cpu_lidx = 0;
        do {
          exitg2 = 0;
          if (cpu_lidx + 1 < 5) {
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            wav_outdatedOnCpu = false;
            if (cv3[cpu_lidx] != cpu_wav[cpu_lidx]) {
              exitg2 = 1;
            } else {
              cpu_lidx++;
            }
          } else {
            first_iteration = true;
            exitg2 = 1;
          }
        } while (exitg2 == 0);

        if (first_iteration) {
          cpu_lidx = 2;
        } else {
          cpu_lidx = -1;
        }
      }

      switch (cpu_lidx) {
       case 0:
        if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
            (-rt_powd_snf(cf, 3.0)) >= 0.0) {
          if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
              (-rt_powd_snf(cf, 3.0)) == 1.0) {
            omegac = 9.0856029641606977;
          } else {
            omegac = cf;
          }
        } else {
          a = cf;
          omegac = 9.0856029641606977;
          fa = 1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
            (-rt_powd_snf(cf, 3.0));
          fb = 1.0;
          if (fa == 0.0) {
            omegac = cf;
          } else {
            fc = 1.0;
            c_c = 9.0856029641606977;
            e = 0.0;
            d = 0.0;
            exitg1 = false;
            while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
              if ((fb > 0.0) == (fc > 0.0)) {
                c_c = a;
                fc = fa;
                d = omegac - a;
                e = d;
              }

              if (std::abs(fc) < std::abs(fb)) {
                a = omegac;
                omegac = c_c;
                c_c = a;
                fa = fb;
                fb = fc;
                fc = fa;
              }

              b_m = 0.5 * (c_c - omegac);
              toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
              if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
                exitg1 = true;
              } else {
                if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                  d = b_m;
                  e = b_m;
                } else {
                  s = fb / fa;
                  if (a == c_c) {
                    b_p = 2.0 * b_m * s;
                    fa = 1.0 - s;
                  } else {
                    fa /= fc;
                    b_r = fb / fc;
                    b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r
                                - 1.0));
                    fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                  }

                  if (b_p > 0.0) {
                    fa = -fa;
                  } else {
                    b_p = -b_p;
                  }

                  if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) &&
                      (b_p < std::abs(0.5 * e * fa))) {
                    e = d;
                    d = b_p / fa;
                  } else {
                    d = b_m;
                    e = b_m;
                  }
                }

                a = omegac;
                fa = fb;
                if (std::abs(d) > toler) {
                  omegac += d;
                } else if (omegac > c_c) {
                  omegac -= toler;
                } else {
                  omegac += toler;
                }

                fb = 1.0 - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0) *
                  std::exp(-rt_powd_snf(omegac, 3.0));
              }
            }
          }
        }
        break;

       case 1:
        a = 4.94065645841247E-324;
        r = 0.99999999999999978;
        fa = -0.69314718055994529;
        fb = 2.2517998136852462E+15;
        fc = 2.2517998136852462E+15;
        c_c = 0.99999999999999978;
        e = 0.0;
        d = 0.0;
        exitg4 = false;
        while ((!exitg4) && ((fb != 0.0) && (a != r))) {
          if ((fb > 0.0) == (fc > 0.0)) {
            c_c = a;
            fc = fa;
            d = r - a;
            e = d;
          }

          if (std::abs(fc) < std::abs(fb)) {
            a = r;
            r = c_c;
            c_c = a;
            fa = fb;
            fb = fc;
            fc = fa;
          }

          b_m = 0.5 * (c_c - r);
          toler = 4.4408920985006262E-16 * std::fmax(std::abs(r), 1.0);
          if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
            exitg4 = true;
          } else {
            if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
              d = b_m;
              e = b_m;
            } else {
              s = fb / fa;
              if (a == c_c) {
                b_p = 2.0 * b_m * s;
                fa = 1.0 - s;
              } else {
                fa /= fc;
                b_r = fb / fc;
                b_p = s * (2.0 * b_m * fa * (fa - b_r) - (r - a) * (b_r - 1.0));
                fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
              }

              if (b_p > 0.0) {
                fa = -fa;
              } else {
                b_p = -b_p;
              }

              if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) && (b_p <
                   std::abs(0.5 * e * fa))) {
                e = d;
                d = b_p / fa;
              } else {
                d = b_m;
                e = b_m;
              }
            }

            a = r;
            fa = fb;
            if (std::abs(d) > toler) {
              r += d;
            } else if (r > c_c) {
              r -= toler;
            } else {
              r += toler;
            }

            fb = (1.0 / (1.0 - r * r) - 0.69314718055994529) - 1.0;
          }
        }

        omegac = 0.6 * r + cf;
        break;

       case 2:
        a = cf - cf;
        if (1.0 - 2.0 * std::exp(-(a * a) / 2.0) > 0.0) {
          omegac = cf + 38.729833462074168;
        } else {
          a = cf;
          omegac = cf + 38.729833462074168;
          c_a = cf - cf;
          fa = 1.0 - 2.0 * std::exp(-(c_a * c_a) / 2.0);
          fb = 1.0;
          if (fa == 0.0) {
            omegac = cf;
          } else {
            fc = 1.0;
            c_c = cf + 38.729833462074168;
            e = 0.0;
            d = 0.0;
            exitg3 = false;
            while ((!exitg3) && ((fb != 0.0) && (a != omegac))) {
              if ((fb > 0.0) == (fc > 0.0)) {
                c_c = a;
                fc = fa;
                d = omegac - a;
                e = d;
              }

              if (std::abs(fc) < std::abs(fb)) {
                a = omegac;
                omegac = c_c;
                c_c = a;
                fa = fb;
                fb = fc;
                fc = fa;
              }

              b_m = 0.5 * (c_c - omegac);
              toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
              if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
                exitg3 = true;
              } else {
                if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                  d = b_m;
                  e = b_m;
                } else {
                  s = fb / fa;
                  if (a == c_c) {
                    b_p = 2.0 * b_m * s;
                    fa = 1.0 - s;
                  } else {
                    fa /= fc;
                    b_r = fb / fc;
                    b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r
                                - 1.0));
                    fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                  }

                  if (b_p > 0.0) {
                    fa = -fa;
                  } else {
                    b_p = -b_p;
                  }

                  if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) &&
                      (b_p < std::abs(0.5 * e * fa))) {
                    e = d;
                    d = b_p / fa;
                  } else {
                    d = b_m;
                    e = b_m;
                  }
                }

                a = omegac;
                fa = fb;
                if (std::abs(d) > toler) {
                  omegac += d;
                } else if (omegac > c_c) {
                  omegac -= toler;
                } else {
                  omegac += toler;
                }

                c_a = omegac - cf;
                fb = 1.0 - 2.0 * std::exp(-(c_a * c_a) / 2.0);
              }
            }
          }
        }
        break;
      }

      r = omegac / 3.1415926535897931;
      if (halfh < r * rt_powd_snf(2.0, 1.0 / fVoices)) {
        halfh = r * rt_powd_snf(2.0, 1.0 / fVoices);
      }

      r = 1.0 / (halfh * (6.2831853071795862 / cf)) * fs;
      if (FreqLimits[0] < r) {
        FreqLimits[0] = r;
        freqrange[0] = r;
      }

      if (FreqLimits[1] > fs / 2.0) {
        FreqLimits[1] = fs / 2.0;
        freqrange[1] = FreqLimits[1];
      }

      if (freqrange[1] == 0.0) {
        fa = rtMinusInf;
      } else if (freqrange[1] < 0.0) {
        fa = rtNaN;
      } else if ((!std::isinf(freqrange[1])) && (!std::isnan(freqrange[1]))) {
        r = std::frexp(freqrange[1], &d_eint);
        if (r == 0.5) {
          fa = static_cast<real_T>(d_eint) - 1.0;
        } else if ((d_eint == 1) && (r < 0.75)) {
          fa = std::log(2.0 * r) / 0.69314718055994529;
        } else {
          fa = std::log(r) / 0.69314718055994529 + static_cast<real_T>(d_eint);
        }
      } else {
        fa = freqrange[1];
      }

      if (freqrange[0] == 0.0) {
        r = rtMinusInf;
      } else if (freqrange[0] < 0.0) {
        r = rtNaN;
      } else if ((!std::isinf(freqrange[0])) && (!std::isnan(freqrange[0]))) {
        r = std::frexp(freqrange[0], &e_eint);
        if (r == 0.5) {
          r = static_cast<real_T>(e_eint) - 1.0;
        } else if ((e_eint == 1) && (r < 0.75)) {
          r = std::log(2.0 * r) / 0.69314718055994529;
        } else {
          r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(e_eint);
        }
      } else {
        r = freqrange[0];
      }

      if (!(fa - r >= 1.0 / fVoices)) {
        d_tmpStr = nullptr;
        f_y = nullptr;
        m5 = emlrtCreateCharArray(2, &iv4[0]);
        emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m5, &u[0]);
        emlrtAssign(&f_y, m5);
        g_y = nullptr;
        m6 = emlrtCreateCharArray(2, &iv5[0]);
        emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 5, m6, &b_formatSpec[0]);
        emlrtAssign(&g_y, m6);
        h_y = nullptr;
        m7 = emlrtCreateDoubleScalar(1.0 / fVoices);
        emlrtAssign(&h_y, m7);
        emlrtAssign(&d_tmpStr, feval(f_y, g_y, h_y, &b_emlrtMCI));
        emlrt_marshallIn(length(emlrtAlias(d_tmpStr), &c_emlrtMCI),
                         "<output of length>");
        emlrt_marshallIn(emlrtAlias(d_tmpStr), "tmpStr", b_tmpStr);
        emlrtDestroyArray(&d_tmpStr);
      }
    }

    N = static_cast<uint32_T>(cpu_x->size[0]) + static_cast<uint32_T>
      (fb_SignalPad << 1);
    ix = static_cast<int32_T>(std::trunc(static_cast<real_T>(N) / 2.0));
    if (ix < 1) {
      cpu_omega_tmp1->size[0] = 1;
      cpu_omega_tmp1->size[1] = 0;
    } else {
      i = cpu_omega_tmp1->size[0] * cpu_omega_tmp1->size[1];
      cpu_omega_tmp1->size[0] = 1;
      cpu_omega_tmp1->size[1] = ix;
      emxEnsureCapacity_int32_T(cpu_omega_tmp1, i, &e_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
      c_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1338<<<grid, block>>>(ix - 1, gpu_omega_tmp1);
      }
    }

    i = cpu_omega_tmp2->size[0] * cpu_omega_tmp2->size[1];
    cpu_omega_tmp2->size[0] = 1;
    cpu_omega_tmp2->size[1] = cpu_omega_tmp1->size[1];
    emxEnsureCapacity_real_T(cpu_omega_tmp2, i, &f_emlrtRTEI);
    n = cpu_omega_tmp1->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (c_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
    }

    c_omega_tmp1_needsGpuEnsureCapa = false;
    gpuEmxEnsureCapacity_real_T(cpu_omega_tmp2, &gpu_omega_tmp2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel10<<<grid, block>>>(6.2831853071795862 / static_cast<real_T>
        (N), gpu_omega_tmp1, n, gpu_omega_tmp2);
    }

    omega_tmp2_outdatedOnCpu = true;
    cpu_lidx = static_cast<int32_T>(std::trunc((static_cast<real_T>(N) - 1.0) /
      2.0));
    if (cpu_lidx < 1) {
      ix = 1;
      bcoef = -1;
    } else {
      cpu_lidx--;
      ix = -1;
      bcoef = 0;
    }

    i = cpu_fb_Omega->size[0] * cpu_fb_Omega->size[1];
    cpu_fb_Omega->size[0] = 1;
    cpu_fb_Omega->size[1] = (cpu_omega_tmp2->size[1] + div_s32(bcoef - cpu_lidx,
      ix)) + 2;
    emxEnsureCapacity_real_T(cpu_fb_Omega, i, &g_emlrtRTEI);
    gpuEmxEnsureCapacity_real_T(cpu_fb_Omega, &gpu_fb_Omega, true);
    ec_wtcc_kernel11<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_fb_Omega);
    offsetH = cpu_omega_tmp2->size[1];
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    fb_Omega_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel12<<<grid, block>>>(gpu_omega_tmp2, offsetH - 1,
        gpu_fb_Omega);
    }

    fb_Omega_outdatedOnGpu = false;
    fb_Omega_outdatedOnCpu = true;
    offsetH = div_s32(bcoef - cpu_lidx, ix);
    for (i = 0; i <= offsetH; i++) {
      if (fb_Omega_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Omega, &gpu_fb_Omega);
      }

      if (omega_tmp2_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_omega_tmp2, &gpu_omega_tmp2);
      }

      omega_tmp2_outdatedOnCpu = false;
      cpu_fb_Omega->data[(i + cpu_omega_tmp2->size[1]) + 1] =
        -cpu_omega_tmp2->data[cpu_lidx + ix * i];
      fb_Omega_outdatedOnCpu = false;
      fb_Omega_outdatedOnGpu = true;
      fb_Omega_needsGpuEnsureCapacity = true;
    }

    for (itime = 0; itime < 2; itime++) {
      c_b[itime] = std::isnan(FreqLimits[itime]);
    }

    first_iteration = true;
    itime = 0;
    exitg1 = false;
    while ((!exitg1) && (itime < 2)) {
      if (!c_b[itime]) {
        first_iteration = false;
        exitg1 = true;
      } else {
        itime++;
      }
    }

    if (!first_iteration) {
      for (itime = 0; itime < 2; itime++) {
        NyquistRange[itime] = FreqLimits[itime] / fs * 2.0 * 3.1415926535897931;
      }

      for (itime = 0; itime < 4; itime++) {
        cpu_wname[itime] = cpu_cv[static_cast<int32_T>(b_a[itime])];
      }

      if (cpu_wname[0] == 'm') {
        r = 1.8820720577620569;
      } else {
        bcoef = 1;
        if (cpu_wname[0] == 'a') {
          bcoef = 2;
        }

        if (bcoef > 1) {
          r = 6.0;
        } else {
          r = 5.0;
        }
      }

      halfh = r / NyquistRange[1];
      r = r / NyquistRange[0] / halfh;
      if (r == 0.0) {
        r = rtMinusInf;
      } else if (r < 0.0) {
        r = rtNaN;
      } else if ((!std::isinf(r)) && (!std::isnan(r))) {
        r = std::frexp(r, &f_eint);
        if (r == 0.5) {
          r = static_cast<real_T>(f_eint) - 1.0;
        } else if ((f_eint == 1) && (r < 0.75)) {
          r = std::log(2.0 * r) / 0.69314718055994529;
        } else {
          r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(f_eint);
        }
      }

      tol = fVoices * r;
      if (std::isnan(tol)) {
        i = b_cpu_y->size[0] * b_cpu_y->size[1];
        b_cpu_y->size[0] = 1;
        b_cpu_y->size[1] = 1;
        emxEnsureCapacity_real_T(b_cpu_y, i, &h_emlrtRTEI);
        gpuEmxEnsureCapacity_real_T(b_cpu_y, &b_gpu_y, true);
        y_needsGpuEnsureCapacity = false;
        ec_wtcc_kernel13<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_y);
      } else if (tol < 0.0) {
        b_cpu_y->size[0] = 1;
        b_cpu_y->size[1] = 0;
      } else {
        i = b_cpu_y->size[0] * b_cpu_y->size[1];
        b_cpu_y->size[0] = 1;
        b_cpu_y->size[1] = static_cast<int32_T>(tol) + 1;
        emxEnsureCapacity_real_T(b_cpu_y, i, &h_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(b_cpu_y, &b_gpu_y, true);
        y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1309<<<grid, block>>>(static_cast<int32_T>(tol), b_gpu_y);
        }
      }

      i = c_cpu_y->size[0] * c_cpu_y->size[1];
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = b_cpu_y->size[1];
      emxEnsureCapacity_real_T(c_cpu_y, i, &i_emlrtRTEI);
      offsetH = b_cpu_y->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      if (y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(b_cpu_y, &b_gpu_y, true);
      }

      y_needsGpuEnsureCapacity = false;
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &c_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel14<<<grid, block>>>(b_gpu_y, rt_powd_snf(2.0, 1.0 /
          fVoices), offsetH - 1, c_gpu_y);
      }

      i = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
      cpu_fb_Scales->size[0] = 1;
      cpu_fb_Scales->size[1] = c_cpu_y->size[1];
      emxEnsureCapacity_real_T(cpu_fb_Scales, i, &j_emlrtRTEI);
      n = c_cpu_y->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
      c_fb_Scales_needsGpuEnsureCapac = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel15<<<grid, block>>>(c_gpu_y, halfh, n, gpu_fb_Scales);
      }

      subs_outdatedOnCpu = true;
    } else {
      omegac = 3.1415926535897931;
      ec_wtcc_kernel1310<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv,
        *gpu_wav, *gpu_wname, b_a[0], b_a[1], b_a[2], b_a[3]);
      wav_outdatedOnCpu = true;
      checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL, cudaMemcpyDeviceToHost),
                     __FILE__, __LINE__);
      if (cpu_wav[0] == 'm') {
        a = 1.8820720577620569;
        b_r = 0.0057083835261;
        r = 0.0057083835261;
        fa = 0.0057083835261;
        for (ix = 0; ix < 6; ix++) {
          s = d_c[ix];
          b_r = b_r * 0.005353955978584176 + s;
          r = r * 0.005353955978584176 + s;
          fa = fa * 0.005353955978584176 + s;
        }

        b_r /= 13.666666666666666;
        r /= 13.666666666666666;
        fa /= 13.666666666666666;
        r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((b_r
          + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) +
                       std::exp((cpu_table100[14] + 2.5377749931802178) - (((r +
          0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) -
                      std::exp((cpu_table100[13] + 5.8211893391859881) - (((fa +
          0.91893853320467278) - 1.307479889018099) + 22.071116966494703)));
        if (std::isinf(r) || std::isnan(r)) {
          ec_wtcc_kernel1311<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
            (*gpu_interval);
          ec_wtcc_kernel1312<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
            (*gpu_interval);
          interval_outdatedOnGpu = false;
          toler = 0.0;
          offsetH = 1;
          checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          ix = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
            (cpu_interval[0]);
          if (ix > 0) {
            n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
              (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
            nsubs = n_idx_0 + 1;
            if (n_idx_0 + 2 > 2) {
              cpu_lidx = n_idx_0;
              cpu_interval[n_idx_0 + 1] = cpu_interval[1];
              interval_outdatedOnGpu = true;
              r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
                (n_idx_0) + 1.0);
              for (bcoef = 0; bcoef < cpu_lidx; bcoef++) {
                cpu_interval[n_idx_0 - bcoef] = cpu_interval[0] +
                  static_cast<real_T>(n_idx_0 - bcoef) * r;
              }
            }

            offsetH = n_idx_0 + 1;
          } else {
            nsubs = 1;
          }

          cpu_lidx = 0;
          for (bcoef = 0; bcoef < offsetH; bcoef++) {
            if (std::abs(cpu_interval[bcoef + 1] - cpu_interval[cpu_lidx]) > 0.0)
            {
              cpu_lidx++;
              cpu_interval[cpu_lidx] = cpu_interval[bcoef + 1];
              interval_outdatedOnGpu = true;
            } else {
              nsubs--;
            }
          }

          if (nsubs + 1 < 2) {
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel1313<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(offsetH,
              *gpu_interval);
            interval_outdatedOnGpu = false;
            nsubs = 1;
          }

          if (ix <= 0) {
            toler = rtNaN;
          } else {
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1328<<<grid, block>>>(*gpu_interval, nsubs - 1,
                *gpu_subs);
            }

            subs_outdatedOnCpu = true;
            T = 0.0;
            b_p = 0.0;
            do {
              exitg2 = 0;
              interval_outdatedOnGpu = false;
              n = 15 * nsubs;
              ix = -1;
              for (itime = 0; itime < nsubs; itime++) {
                if (subs_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                s = cpu_subs[itime << 1];
                subs_outdatedOnCpu = false;
                fa = cpu_subs[(itime << 1) + 1];
                r = (s + fa) / 2.0;
                halfh = (fa - s) / 2.0;
                for (bcoef = 0; bcoef < 15; bcoef++) {
                  SD->f0.cpu_x_data[(ix + bcoef) + 1] = NODES[bcoef] * halfh + r;
                  interval_outdatedOnGpu = true;
                }

                ix += 15;
              }

              b_xt_size[0] = 1;
              b_xt_size[1] = n;
              mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data,
                  77880UL, cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1329<<<grid, block>>>(*gpu_x_data, n - 1,
                  *gpu_xt_data, *b_gpu_x_data);
              }

              b_guard1 = false;
              if (!first_iteration) {
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                halfh = std::abs(SD->f0.cpu_x_data[0]);
                Nodd = false;
                itime = 0;
                exitg1 = false;
                while ((!exitg1) && (itime <= n - 2)) {
                  s = halfh;
                  halfh = std::abs(SD->f0.cpu_x_data[itime + 1]);
                  if (std::abs(SD->f0.cpu_x_data[itime + 1] - SD->
                               f0.cpu_x_data[itime]) <= 2.2204460492503131E-14 *
                      std::fmax(s, halfh)) {
                    Nodd = true;
                    exitg1 = true;
                  } else {
                    itime++;
                  }
                }

                if (Nodd) {
                  fx_size[0] = 1;
                  fx_size[1] = n;
                  mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>(n)
                    - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1330<<<grid, block>>>(static_cast<int16_T>(n)
                      - 1, *b_gpu_fx_data);
                  }

                  b_fx_data_outdatedOnCpu = true;
                  exitg2 = 1;
                } else {
                  b_guard1 = true;
                }
              } else {
                b_guard1 = true;
              }

              if (b_guard1) {
                first_iteration = false;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1331<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1332<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_x_data);
                }

                b_a_size[1] = n;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1333<<<grid, block>>>(*gpu_x_data, *gpu_y_data,
                    n - 1, *b_gpu_a_data);
                }

                dv9_size[0] = 1;
                dv9_size[1] = b_a_size[1];
                mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1334<<<grid, block>>>(*b_gpu_a_data, b_a_size[1]
                    - 1, *gpu_dv9_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1335<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                dv13_size[0] = 1;
                dv13_size[1] = n;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1336<<<grid, block>>>(*gpu_y_data, n - 1,
                    *gpu_x_data);
                }

                if (b_a_size[1] == n) {
                  fx_size[0] = 1;
                  fx_size[1] = b_a_size[1];
                  mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1337<<<grid, block>>>(*gpu_xt_data,
                      *gpu_x_data, *gpu_dv9_data, b_a_size[1] - 1,
                      *b_gpu_fx_data);
                  }

                  b_fx_data_outdatedOnCpu = true;
                } else {
                  if (b_fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.b_cpu_fx_data,
                      *b_gpu_fx_data, 77880UL, cudaMemcpyDeviceToHost), __FILE__,
                                   __LINE__);
                  }

                  checkCudaError(cudaMemcpy(cpu_dv9_data, *gpu_dv9_data, 77880UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  binary_expand_op_10(SD->f0.b_cpu_fx_data, fx_size,
                                      cpu_dv9_data, dv9_size, SD->f0.cpu_x_data,
                                      dv13_size, SD->f0.cpu_xt_data, b_xt_size);
                  b_fx_data_outdatedOnCpu = false;
                }

                r = 0.0;
                ix = -1;
                for (itime = 0; itime < nsubs; itime++) {
                  s = 0.0;
                  fa = 0.0;
                  for (bcoef = 0; bcoef < 15; bcoef++) {
                    if (b_fx_data_outdatedOnCpu) {
                      checkCudaError(cudaMemcpy(SD->f0.b_cpu_fx_data,
                        *b_gpu_fx_data, 77880UL, cudaMemcpyDeviceToHost),
                                     __FILE__, __LINE__);
                    }

                    s += dv3[bcoef] * SD->f0.b_cpu_fx_data[(ix + bcoef) + 1];
                    b_fx_data_outdatedOnCpu = false;
                    fa += dv4[bcoef] * SD->f0.b_cpu_fx_data[(ix + bcoef) + 1];
                  }

                  ix += 15;
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  halfh = (cpu_subs[(itime << 1) + 1] - cpu_subs[itime << 1]) /
                    2.0;
                  s *= halfh;
                  qsub[itime] = s;
                  r += s;
                  errsub[itime] = fa * halfh;
                }

                toler = r + T;
                tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(toler));
                fb = 2.0 * tol;
                r = 0.0;
                cpu_lidx = 0;
                for (itime = 0; itime < nsubs; itime++) {
                  s = errsub[itime];
                  fa = std::abs(s);
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  if (fa <= fb * ((cpu_subs[(itime << 1) + 1] - cpu_subs[itime <<
                                   1]) / 2.0)) {
                    b_p += s;
                    T += qsub[itime];
                  } else {
                    r += fa;
                    cpu_lidx++;
                    cpu_subs[(cpu_lidx - 1) << 1] = cpu_subs[itime << 1];
                    cpu_subs[((cpu_lidx - 1) << 1) + 1] = cpu_subs[(itime << 1)
                      + 1];
                  }
                }

                r += std::abs(b_p);
                if ((!std::isinf(toler)) && (!std::isnan(toler)) && ((!std::
                      isinf(r)) && (!std::isnan(r))) && (cpu_lidx != 0) && (!(r <=
                      tol))) {
                  nsubs = cpu_lidx << 1;
                  if (nsubs > 650) {
                    exitg2 = 1;
                  } else {
                    for (itime = 0; itime < cpu_lidx; itime++) {
                      if (subs_outdatedOnCpu) {
                        checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                      }

                      cpu_subs[((((cpu_lidx - itime) << 1) - 1) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) - 1) << 1) + 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1] =
                        (cpu_subs[((cpu_lidx - itime) - 1) << 1] + cpu_subs
                         [(((cpu_lidx - itime) - 1) << 1) + 1]) / 2.0;
                      cpu_subs[((((cpu_lidx - itime) << 1) - 2) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 2) << 1] = cpu_subs
                        [((cpu_lidx - itime) - 1) << 1];
                      subs_outdatedOnCpu = false;
                    }
                  }
                } else {
                  exitg2 = 1;
                }
              }
            } while (exitg2 == 0);
          }

          ec_wtcc_kernel1314<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
            (*gpu_interval);
          ec_wtcc_kernel1315<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
            (*gpu_interval);
          interval_outdatedOnGpu = false;
          b_m = 0.0;
          offsetH = 1;
          checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          ix = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
            (cpu_interval[0]);
          if (ix > 0) {
            n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
              (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
            nsubs = n_idx_0 + 1;
            if (n_idx_0 + 2 > 2) {
              cpu_lidx = n_idx_0;
              cpu_interval[n_idx_0 + 1] = cpu_interval[1];
              interval_outdatedOnGpu = true;
              r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
                (n_idx_0) + 1.0);
              for (bcoef = 0; bcoef < cpu_lidx; bcoef++) {
                cpu_interval[n_idx_0 - bcoef] = cpu_interval[0] +
                  static_cast<real_T>(n_idx_0 - bcoef) * r;
              }
            }

            offsetH = n_idx_0 + 1;
          } else {
            nsubs = 1;
          }

          cpu_lidx = 0;
          for (bcoef = 0; bcoef < offsetH; bcoef++) {
            if (std::abs(cpu_interval[bcoef + 1] - cpu_interval[cpu_lidx]) > 0.0)
            {
              cpu_lidx++;
              cpu_interval[cpu_lidx] = cpu_interval[bcoef + 1];
              interval_outdatedOnGpu = true;
            } else {
              nsubs--;
            }
          }

          if (nsubs + 1 < 2) {
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel1316<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(offsetH,
              *gpu_interval);
            interval_outdatedOnGpu = false;
            nsubs = 1;
          }

          if (ix <= 0) {
            b_m = rtNaN;
          } else {
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1321<<<grid, block>>>(*gpu_interval, nsubs - 1,
                *gpu_subs);
            }

            subs_outdatedOnCpu = true;
            T = 0.0;
            b_p = 0.0;
            first_iteration = true;
            do {
              exitg2 = 0;
              interval_outdatedOnGpu = false;
              n = 15 * nsubs;
              ix = -1;
              for (itime = 0; itime < nsubs; itime++) {
                if (subs_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                s = cpu_subs[itime << 1];
                subs_outdatedOnCpu = false;
                fa = cpu_subs[(itime << 1) + 1];
                r = (s + fa) / 2.0;
                halfh = (fa - s) / 2.0;
                for (bcoef = 0; bcoef < 15; bcoef++) {
                  SD->f0.cpu_x_data[(ix + bcoef) + 1] = NODES[bcoef] * halfh + r;
                  interval_outdatedOnGpu = true;
                }

                ix += 15;
              }

              mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data,
                  77880UL, cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1322<<<grid, block>>>(*gpu_x_data, n - 1,
                  *gpu_xt_data, *b_gpu_x_data);
              }

              b_guard1 = false;
              if (!first_iteration) {
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                halfh = std::abs(SD->f0.cpu_x_data[0]);
                Nodd = false;
                itime = 0;
                exitg1 = false;
                while ((!exitg1) && (itime <= n - 2)) {
                  s = halfh;
                  halfh = std::abs(SD->f0.cpu_x_data[itime + 1]);
                  if (std::abs(SD->f0.cpu_x_data[itime + 1] - SD->
                               f0.cpu_x_data[itime]) <= 2.2204460492503131E-14 *
                      std::fmax(s, halfh)) {
                    Nodd = true;
                    exitg1 = true;
                  } else {
                    itime++;
                  }
                }

                if (Nodd) {
                  mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>(n)
                    - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel1323<<<grid, block>>>(static_cast<int16_T>(n)
                      - 1, *gpu_fx_data);
                  }

                  exitg2 = 1;
                } else {
                  b_guard1 = true;
                }
              } else {
                b_guard1 = true;
              }

              if (b_guard1) {
                first_iteration = false;
                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1324<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_dv15_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1325<<<grid, block>>>(*b_gpu_x_data, n - 1,
                    *gpu_y_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1326<<<grid, block>>>(*gpu_y_data, n - 1,
                    *gpu_x_data);
                }

                mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
                  2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1327<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv15_data, n - 1, *gpu_fx_data);
                }

                interval_outdatedOnGpu = true;
                r = 0.0;
                ix = -1;
                for (itime = 0; itime < nsubs; itime++) {
                  s = 0.0;
                  fa = 0.0;
                  for (bcoef = 0; bcoef < 15; bcoef++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_fx_data,
                        77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    s += dv3[bcoef] * SD->f0.cpu_x_data[(ix + bcoef) + 1];
                    interval_outdatedOnGpu = false;
                    fa += dv4[bcoef] * SD->f0.cpu_x_data[(ix + bcoef) + 1];
                  }

                  ix += 15;
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  halfh = (cpu_subs[(itime << 1) + 1] - cpu_subs[itime << 1]) /
                    2.0;
                  s *= halfh;
                  qsub[itime] = s;
                  r += s;
                  errsub[itime] = fa * halfh;
                }

                b_m = r + T;
                tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(b_m));
                fb = 2.0 * tol;
                r = 0.0;
                cpu_lidx = 0;
                for (itime = 0; itime < nsubs; itime++) {
                  s = errsub[itime];
                  fa = std::abs(s);
                  if (subs_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                      cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  subs_outdatedOnCpu = false;
                  if (fa <= fb * ((cpu_subs[(itime << 1) + 1] - cpu_subs[itime <<
                                   1]) / 2.0)) {
                    b_p += s;
                    T += qsub[itime];
                  } else {
                    r += fa;
                    cpu_lidx++;
                    cpu_subs[(cpu_lidx - 1) << 1] = cpu_subs[itime << 1];
                    cpu_subs[((cpu_lidx - 1) << 1) + 1] = cpu_subs[(itime << 1)
                      + 1];
                  }
                }

                r += std::abs(b_p);
                if ((!std::isinf(b_m)) && (!std::isnan(b_m)) && ((!std::isinf(r))
                     && (!std::isnan(r))) && (cpu_lidx != 0) && (!(r <= tol))) {
                  nsubs = cpu_lidx << 1;
                  if (nsubs > 650) {
                    exitg2 = 1;
                  } else {
                    for (itime = 0; itime < cpu_lidx; itime++) {
                      if (subs_outdatedOnCpu) {
                        checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                      }

                      cpu_subs[((((cpu_lidx - itime) << 1) - 1) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) - 1) << 1) + 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1] =
                        (cpu_subs[((cpu_lidx - itime) - 1) << 1] + cpu_subs
                         [(((cpu_lidx - itime) - 1) << 1) + 1]) / 2.0;
                      cpu_subs[((((cpu_lidx - itime) << 1) - 2) << 1) + 1] =
                        cpu_subs[(((cpu_lidx - itime) << 1) - 1) << 1];
                      cpu_subs[(((cpu_lidx - itime) << 1) - 2) << 1] = cpu_subs
                        [((cpu_lidx - itime) - 1) << 1];
                      subs_outdatedOnCpu = false;
                    }
                  }
                } else {
                  exitg2 = 1;
                }
              }
            } while (exitg2 == 0);
          }

          r = std::sqrt(3.5421952306087032 * (toler / b_m));
        }
      } else if (cpu_wav[0] == 'a') {
        a = 6.0;
        r = 1.4142135623730951;
      } else {
        a = 5.0;
        r = 5.847705;
      }

      tol = static_cast<real_T>(cpu_x->size[0]) / (r * 2.0);
      first_iteration = false;
      cpu_lidx = 0;
      do {
        exitg2 = 0;
        if (cpu_lidx + 1 < 5) {
          if (wav_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          wav_outdatedOnCpu = false;
          if (cv2[cpu_lidx] != cpu_wname[cpu_lidx]) {
            exitg2 = 1;
          } else {
            cpu_lidx++;
          }
        } else {
          first_iteration = true;
          exitg2 = 1;
        }
      } while (exitg2 == 0);

      if (first_iteration) {
        cpu_lidx = 1;
      } else {
        cpu_lidx = 0;
        do {
          exitg2 = 0;
          if (cpu_lidx + 1 < 5) {
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            wav_outdatedOnCpu = false;
            if (cv3[cpu_lidx] != cpu_wname[cpu_lidx]) {
              exitg2 = 1;
            } else {
              cpu_lidx++;
            }
          } else {
            first_iteration = true;
            exitg2 = 1;
          }
        } while (exitg2 == 0);

        if (first_iteration) {
          cpu_lidx = 2;
        } else {
          cpu_lidx = -1;
        }
      }

      switch (cpu_lidx) {
       case 0:
        if (0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
            (-rt_powd_snf(a, 3.0)) >= 0.0) {
          if (0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
              (-rt_powd_snf(a, 3.0)) == 0.2) {
            omegac = 9.0856029641606977;
          } else {
            omegac = a;
          }
        } else {
          omegac = 9.0856029641606977;
          fa = 0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
            (-rt_powd_snf(a, 3.0));
          fb = 0.2;
          if (fa == 0.0) {
            omegac = a;
          } else {
            fc = 0.2;
            c_c = 9.0856029641606977;
            e = 0.0;
            d = 0.0;
            exitg1 = false;
            while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
              if ((fb > 0.0) == (fc > 0.0)) {
                c_c = a;
                fc = fa;
                d = omegac - a;
                e = d;
              }

              if (std::abs(fc) < std::abs(fb)) {
                a = omegac;
                omegac = c_c;
                c_c = a;
                fa = fb;
                fb = fc;
                fc = fa;
              }

              b_m = 0.5 * (c_c - omegac);
              toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
              if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
                exitg1 = true;
              } else {
                if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                  d = b_m;
                  e = b_m;
                } else {
                  s = fb / fa;
                  if (a == c_c) {
                    b_p = 2.0 * b_m * s;
                    fa = 1.0 - s;
                  } else {
                    fa /= fc;
                    b_r = fb / fc;
                    b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r
                                - 1.0));
                    fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                  }

                  if (b_p > 0.0) {
                    fa = -fa;
                  } else {
                    b_p = -b_p;
                  }

                  if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) &&
                      (b_p < std::abs(0.5 * e * fa))) {
                    e = d;
                    d = b_p / fa;
                  } else {
                    d = b_m;
                    e = b_m;
                  }
                }

                a = omegac;
                fa = fb;
                if (std::abs(d) > toler) {
                  omegac += d;
                } else if (omegac > c_c) {
                  omegac -= toler;
                } else {
                  omegac += toler;
                }

                fb = 0.2 - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0) *
                  std::exp(-rt_powd_snf(omegac, 3.0));
              }
            }
          }
        }
        break;

       case 1:
        c_a = 4.94065645841247E-324;
        r = 0.99999999999999978;
        fa = -2.3025850929940455;
        fb = 2.2517998136852448E+15;
        fc = 2.2517998136852448E+15;
        c_c = 0.99999999999999978;
        e = 0.0;
        d = 0.0;
        exitg4 = false;
        while ((!exitg4) && ((fb != 0.0) && (c_a != r))) {
          if ((fb > 0.0) == (fc > 0.0)) {
            c_c = c_a;
            fc = fa;
            d = r - c_a;
            e = d;
          }

          if (std::abs(fc) < std::abs(fb)) {
            c_a = r;
            r = c_c;
            c_c = c_a;
            fa = fb;
            fb = fc;
            fc = fa;
          }

          b_m = 0.5 * (c_c - r);
          toler = 4.4408920985006262E-16 * std::fmax(std::abs(r), 1.0);
          if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
            exitg4 = true;
          } else {
            if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
              d = b_m;
              e = b_m;
            } else {
              s = fb / fa;
              if (c_a == c_c) {
                b_p = 2.0 * b_m * s;
                fa = 1.0 - s;
              } else {
                fa /= fc;
                b_r = fb / fc;
                b_p = s * (2.0 * b_m * fa * (fa - b_r) - (r - c_a) * (b_r - 1.0));
                fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
              }

              if (b_p > 0.0) {
                fa = -fa;
              } else {
                b_p = -b_p;
              }

              if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) && (b_p <
                   std::abs(0.5 * e * fa))) {
                e = d;
                d = b_p / fa;
              } else {
                d = b_m;
                e = b_m;
              }
            }

            c_a = r;
            fa = fb;
            if (std::abs(d) > toler) {
              r += d;
            } else if (r > c_c) {
              r -= toler;
            } else {
              r += toler;
            }

            fb = ((1.0 / (1.0 - r * r) - 1.6094379124341003) -
                  0.69314718055994529) - 1.0;
          }
        }

        omegac = 0.6 * r + a;
        break;

       case 2:
        c_a = a - a;
        if (0.2 - 2.0 * std::exp(-(c_a * c_a) / 2.0) > 0.0) {
          omegac = a + 38.729833462074168;
        } else {
          c_a = a;
          omegac = a + 38.729833462074168;
          r = a - a;
          fa = 0.2 - 2.0 * std::exp(-(r * r) / 2.0);
          fb = 0.2;
          if (fa == 0.0) {
            omegac = a;
          } else {
            fc = 0.2;
            c_c = a + 38.729833462074168;
            e = 0.0;
            d = 0.0;
            exitg3 = false;
            while ((!exitg3) && ((fb != 0.0) && (c_a != omegac))) {
              if ((fb > 0.0) == (fc > 0.0)) {
                c_c = c_a;
                fc = fa;
                d = omegac - c_a;
                e = d;
              }

              if (std::abs(fc) < std::abs(fb)) {
                c_a = omegac;
                omegac = c_c;
                c_c = c_a;
                fa = fb;
                fb = fc;
                fc = fa;
              }

              b_m = 0.5 * (c_c - omegac);
              toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
              if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
                exitg3 = true;
              } else {
                if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                  d = b_m;
                  e = b_m;
                } else {
                  s = fb / fa;
                  if (c_a == c_c) {
                    b_p = 2.0 * b_m * s;
                    fa = 1.0 - s;
                  } else {
                    fa /= fc;
                    b_r = fb / fc;
                    b_p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - c_a) *
                               (b_r - 1.0));
                    fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                  }

                  if (b_p > 0.0) {
                    fa = -fa;
                  } else {
                    b_p = -b_p;
                  }

                  if ((2.0 * b_p < 3.0 * b_m * fa - std::abs(toler * fa)) &&
                      (b_p < std::abs(0.5 * e * fa))) {
                    e = d;
                    d = b_p / fa;
                  } else {
                    d = b_m;
                    e = b_m;
                  }
                }

                c_a = omegac;
                fa = fb;
                if (std::abs(d) > toler) {
                  omegac += d;
                } else if (omegac > c_c) {
                  omegac -= toler;
                } else {
                  omegac += toler;
                }

                r = omegac - a;
                fb = 0.2 - 2.0 * std::exp(-(r * r) / 2.0);
              }
            }
          }
        }
        break;
      }

      halfh = omegac / 3.1415926535897931;
      if (tol < halfh * rt_powd_snf(2.0, 1.0 / fVoices)) {
        tol = halfh * rt_powd_snf(2.0, 1.0 / fVoices);
      }

      s = tol / halfh;
      if (s == 0.0) {
        s = rtMinusInf;
      } else if (s < 0.0) {
        s = rtNaN;
      } else if ((!std::isinf(s)) && (!std::isnan(s))) {
        s = std::frexp(s, &g_eint);
        if (s == 0.5) {
          s = static_cast<real_T>(g_eint) - 1.0;
        } else if ((g_eint == 1) && (s < 0.75)) {
          s = std::log(2.0 * s) / 0.69314718055994529;
        } else {
          s = std::log(s) / 0.69314718055994529 + static_cast<real_T>(g_eint);
        }
      }

      tol = std::fmax(s, 1.0 / fVoices) * fVoices;
      if (std::isnan(tol)) {
        i = d_cpu_y->size[0] * d_cpu_y->size[1];
        d_cpu_y->size[0] = 1;
        d_cpu_y->size[1] = 1;
        emxEnsureCapacity_real_T(d_cpu_y, i, &h_emlrtRTEI);
        gpuEmxEnsureCapacity_real_T(d_cpu_y, &ih_gpu_y, true);
        b_y_needsGpuEnsureCapacity = false;
        ec_wtcc_kernel1317<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ih_gpu_y);
      } else if (tol < 0.0) {
        d_cpu_y->size[0] = 1;
        d_cpu_y->size[1] = 0;
      } else {
        i = d_cpu_y->size[0] * d_cpu_y->size[1];
        d_cpu_y->size[0] = 1;
        d_cpu_y->size[1] = static_cast<int32_T>(tol) + 1;
        emxEnsureCapacity_real_T(d_cpu_y, i, &h_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(d_cpu_y, &ih_gpu_y, true);
        b_y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1320<<<grid, block>>>(static_cast<int32_T>(tol),
            ih_gpu_y);
        }
      }

      i = f_cpu_y->size[0] * f_cpu_y->size[1];
      f_cpu_y->size[0] = 1;
      f_cpu_y->size[1] = d_cpu_y->size[1];
      emxEnsureCapacity_real_T(f_cpu_y, i, &i_emlrtRTEI);
      offsetH = d_cpu_y->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      if (b_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(d_cpu_y, &ih_gpu_y, true);
      }

      b_y_needsGpuEnsureCapacity = false;
      gpuEmxEnsureCapacity_real_T(f_cpu_y, &jh_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1318<<<grid, block>>>(ih_gpu_y, rt_powd_snf(2.0, 1.0 /
          fVoices), offsetH - 1, jh_gpu_y);
      }

      i = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
      cpu_fb_Scales->size[0] = 1;
      cpu_fb_Scales->size[1] = f_cpu_y->size[1];
      emxEnsureCapacity_real_T(cpu_fb_Scales, i, &j_emlrtRTEI);
      n = f_cpu_y->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
      c_fb_Scales_needsGpuEnsureCapac = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1319<<<grid, block>>>(jh_gpu_y, halfh, n, gpu_fb_Scales);
      }

      subs_outdatedOnCpu = true;
    }

    if (cpu_fb_Scales->size[1] == 1) {
      wav_outdatedOnCpu = false;
      i = cpu_somega->size[0] * cpu_somega->size[1];
      cpu_somega->size[0] = 1;
      if (cpu_fb_Omega->size[1] == 1) {
        cpu_somega->size[1] = 1;
      } else {
        cpu_somega->size[1] = cpu_fb_Omega->size[1];
      }

      emxEnsureCapacity_real_T(cpu_somega, i, &l_emlrtRTEI);
      interval_outdatedOnGpu = true;
      bcoef = (cpu_fb_Omega->size[1] != 1);
      ix = cpu_somega->size[1] - 1;
      for (itime = 0; itime <= ix; itime++) {
        if (subs_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Scales, &gpu_fb_Scales);
        }

        subs_outdatedOnCpu = false;
        if (fb_Omega_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Omega, &gpu_fb_Omega);
        }

        fb_Omega_outdatedOnCpu = false;
        cpu_somega->data[itime] = cpu_fb_Scales->data[0] * cpu_fb_Omega->
          data[bcoef * itime];
        wav_outdatedOnCpu = true;
        c_fb_Scales_needsGpuEnsureCapac = true;
      }
    } else {
      i = cpu_somega->size[0] * cpu_somega->size[1];
      cpu_somega->size[0] = cpu_fb_Scales->size[1];
      cpu_somega->size[1] = cpu_fb_Omega->size[1];
      emxEnsureCapacity_real_T(cpu_somega, i, &k_emlrtRTEI);
      offsetH = cpu_fb_Omega->size[1];
      n = cpu_fb_Scales->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1, n), &grid, &block,
        2147483647U);
      if (fb_Omega_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(cpu_fb_Omega, &gpu_fb_Omega,
          !fb_Omega_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, true);
      interval_outdatedOnGpu = false;
      if (fb_Omega_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_fb_Omega, cpu_fb_Omega);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1308<<<grid, block>>>(gpu_fb_Omega, gpu_fb_Scales, n,
          offsetH - 1, gpu_somega, cpu_somega->size[0U]);
      }

      wav_outdatedOnCpu = false;
    }

    first_iteration = false;
    cpu_lidx = 0;
    do {
      exitg2 = 0;
      if (cpu_lidx + 1 < 5) {
        if (cv3[cpu_lidx] != b_a[cpu_lidx]) {
          exitg2 = 1;
        } else {
          cpu_lidx++;
        }
      } else {
        first_iteration = true;
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    if (first_iteration) {
      itime = 0;
    } else {
      itime = -1;
    }

    if (itime == 0) {
      i = cpu_expnt->size[0] * cpu_expnt->size[1];
      cpu_expnt->size[0] = cpu_somega->size[0];
      cpu_expnt->size[1] = cpu_somega->size[1];
      emxEnsureCapacity_real_T(cpu_expnt, i, &n_emlrtRTEI);
      n = cpu_somega->size[0] * cpu_somega->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, !wav_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_expnt, &gpu_expnt, true);
      if (wav_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_somega, cpu_somega);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel16<<<grid, block>>>(gpu_somega, n, gpu_expnt);
      }

      offsetH = cpu_expnt->size[0] * cpu_expnt->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel17<<<grid, block>>>(offsetH - 1, gpu_expnt);
      }

      i = cpu_daughter->size[0] * cpu_daughter->size[1];
      cpu_daughter->size[0] = cpu_expnt->size[0];
      cpu_daughter->size[1] = cpu_expnt->size[1];
      emxEnsureCapacity_real_T(cpu_daughter, i, &p_emlrtRTEI);
      n = cpu_expnt->size[0] * cpu_expnt->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel18<<<grid, block>>>(gpu_somega, gpu_expnt, n, gpu_daughter);
      }

      daughter_outdatedOnCpu = true;
    } else {
      i = cpu_w->size[0] * cpu_w->size[1];
      cpu_w->size[0] = cpu_somega->size[0];
      cpu_w->size[1] = cpu_somega->size[1];
      emxEnsureCapacity_real_T(cpu_w, i, &m_emlrtRTEI);
      n = cpu_somega->size[0] * cpu_somega->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, !wav_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_w, &gc_gpu_w, true);
      if (wav_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_somega, cpu_somega);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1302<<<grid, block>>>(gpu_somega, n, gc_gpu_w);
      }

      i = cpu_expnt->size[0] * cpu_expnt->size[1];
      cpu_expnt->size[0] = cpu_w->size[0];
      cpu_expnt->size[1] = cpu_w->size[1];
      emxEnsureCapacity_real_T(cpu_expnt, i, &o_emlrtRTEI);
      n = cpu_w->size[0] * cpu_w->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_expnt, &gpu_expnt, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1303<<<grid, block>>>(gc_gpu_w, n, gpu_expnt);
      }

      offsetH = cpu_expnt->size[0] * cpu_expnt->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1304<<<grid, block>>>(offsetH - 1, gpu_expnt);
      }

      offsetH = cpu_w->size[0] * cpu_w->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_w->size[itime]);
      }

      i = e_cpu_y->size[0] * e_cpu_y->size[1];
      e_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
      e_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_real_T(e_cpu_y, i, &r_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(e_cpu_y, &hh_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1305<<<grid, block>>>(gc_gpu_w, offsetH - 1, hh_gpu_y);
      }

      if ((cpu_expnt->size[0] == e_cpu_y->size[0]) && (cpu_expnt->size[1] ==
           e_cpu_y->size[1])) {
        i = cpu_daughter->size[0] * cpu_daughter->size[1];
        cpu_daughter->size[0] = cpu_expnt->size[0];
        cpu_daughter->size[1] = cpu_expnt->size[1];
        emxEnsureCapacity_real_T(cpu_daughter, i, &t_emlrtRTEI);
        n = cpu_expnt->size[0] * cpu_expnt->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1306<<<grid, block>>>(hh_gpu_y, gpu_expnt, n,
            gpu_daughter);
        }

        wav_outdatedOnCpu = false;
      } else {
        if (daughter_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_daughter, &gpu_daughter);
        }

        gpuEmxMemcpyGpuToCpu_real_T(cpu_expnt, &gpu_expnt);
        gpuEmxMemcpyGpuToCpu_real_T(e_cpu_y, &hh_gpu_y);
        binary_expand_op_9(cpu_daughter, cpu_expnt, e_cpu_y);
        wav_outdatedOnCpu = true;
        interval_outdatedOnGpu = true;
      }

      cpu_lidx = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
        2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter,
          !wav_outdatedOnCpu);
      }

      if (wav_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_daughter, cpu_daughter);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1307<<<grid, block>>>(cpu_lidx, gpu_daughter);
      }

      daughter_outdatedOnCpu = true;
    }

    halfh = std::fmin(std::floor(static_cast<real_T>(cpu_fb_Scales->size[1]) /
      2.0), static_cast<real_T>(fVoices));
    i = cpu_psihat->size[0] * cpu_psihat->size[1];
    cpu_psihat->size[0] = cpu_daughter->size[0];
    cpu_psihat->size[1] = cpu_daughter->size[1];
    emxEnsureCapacity_real32_T(cpu_psihat, i, &q_emlrtRTEI);
    n = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_psihat, &gpu_psihat, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel19<<<grid, block>>>(gpu_daughter, n, gpu_psihat);
    }

    i = cpu_xv->size[0] * cpu_xv->size[1];
    cpu_xv->size[0] = 1;
    cpu_xv->size[1] = b_cpu_x->size[0];
    emxEnsureCapacity_real32_T(cpu_xv, i, &s_emlrtRTEI);
    n = b_cpu_x->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, true);
    wav_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel20<<<grid, block>>>(b_gpu_x, n, gpu_xv);
    }

    interval_outdatedOnGpu = false;
    if (fb_SignalPad > 0) {
      cpu_lidx = cpu_x->size[0] - fb_SignalPad;
      if (cpu_lidx + 1 > cpu_x->size[0]) {
        ix = 0;
        bcoef = 1;
        cpu_lidx = -1;
      } else {
        ix = cpu_x->size[0] - 1;
        bcoef = -1;
      }

      i = c_cpu_x->size[0] * c_cpu_x->size[1];
      c_cpu_x->size[0] = 1;
      c_cpu_x->size[1] = fb_SignalPad;
      emxEnsureCapacity_real32_T(c_cpu_x, i, &w_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(fb_SignalPad - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(c_cpu_x, &c_gpu_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel21<<<grid, block>>>(b_gpu_x, fb_SignalPad - 1, c_gpu_x);
      }

      mwGetLaunchParameters1D(computeNumIters((fb_SignalPad >> 1) - 1), &grid,
        &block, 2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel22<<<grid, block>>>(fb_SignalPad, (fb_SignalPad >> 1) - 1,
          c_gpu_x);
      }

      i = cpu_xv->size[0] * cpu_xv->size[1];
      cpu_xv->size[0] = 1;
      cpu_xv->size[1] = ((b_cpu_x->size[0] + c_cpu_x->size[1]) + div_s32
                         (cpu_lidx - ix, bcoef)) + 1;
      emxEnsureCapacity_real32_T(cpu_xv, i, &x_emlrtRTEI);
      offsetH = c_cpu_x->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel23<<<grid, block>>>(c_gpu_x, offsetH - 1, gpu_xv);
      }

      subs_outdatedOnCpu = true;
      offsetH = b_cpu_x->size[0];
      for (i = 0; i < offsetH; i++) {
        if (subs_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_xv, &gpu_xv);
        }

        if (x_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_x, &b_gpu_x);
        }

        x_outdatedOnCpu = false;
        cpu_xv->data[i + c_cpu_x->size[1]] = b_cpu_x->data[i];
        subs_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        wav_outdatedOnCpu = true;
      }

      offsetH = div_s32(cpu_lidx - ix, bcoef);
      for (i = 0; i <= offsetH; i++) {
        if (subs_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_xv, &gpu_xv);
        }

        if (x_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_x, &b_gpu_x);
        }

        x_outdatedOnCpu = false;
        cpu_xv->data[(i + b_cpu_x->size[0]) + c_cpu_x->size[1]] = b_cpu_x->
          data[ix + bcoef * i];
        subs_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        wav_outdatedOnCpu = true;
      }
    }

    if (cpu_xv->size[1] - (static_cast<int32_T>(static_cast<uint32_T>
          (cpu_xv->size[1]) >> 1) << 1) == 1) {
      cufftHandle fftPlanHandle;
      i = cpu_xposdft->size[0] * cpu_xposdft->size[1];
      cpu_xposdft->size[0] = 1;
      cpu_xposdft->size[1] = cpu_xv->size[1];
      emxEnsureCapacity_creal32_T(cpu_xposdft, i, &u_emlrtRTEI);
      n = cpu_xv->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, !interval_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_creal32_T(cpu_xposdft, &gpu_xposdft, true);
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real32_T(&gpu_xv, cpu_xv);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel24<<<grid, block>>>(gpu_xv, n, gpu_xposdft);
      }

      ix = cpu_xposdft->size[1];
      fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, 1, 1, CUFFT_C2C, 1);
      cufftExecC2C(fftPlanHandle, (cufftComplex *)&gpu_xposdft.data[0],
                   (cufftComplex *)&gpu_xposdft.data[0], CUFFT_FORWARD);
    } else {
      cufftHandle b_fftPlanHandle;
      ix = cpu_xv->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_xv->size[itime]);
      }

      i = cpu_xposdft->size[0] * cpu_xposdft->size[1];
      cpu_xposdft->size[0] = 1;
      cpu_xposdft->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_creal32_T(cpu_xposdft, i, &v_emlrtRTEI);
      b_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, 1, 1, CUFFT_R2C, 1);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, !interval_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_creal32_T(cpu_xposdft, &gpu_xposdft, true);
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real32_T(&gpu_xv, cpu_xv);
      }

      cufftExecR2C(b_fftPlanHandle, (cufftReal *)&gpu_xv.data[0], (cufftComplex *)
                   &gpu_xposdft.data[0]);
      cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
        (xSize[1]) + 1) / 2.0);
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 2), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1301<<<grid, block>>>(cpu_lidx - 2, gpu_xposdft, xSize[1]);
      }
    }

    i1Start = cpu_psihat->size[1];
    ix = cpu_xposdft->size[1];
    if (i1Start <= ix) {
      ix = i1Start;
    }

    if (cpu_psihat->size[1] == 1) {
      i = cpu_xposdft->size[1];
    } else if (cpu_xposdft->size[1] == cpu_psihat->size[1]) {
      i = cpu_xposdft->size[1];
    } else {
      i = ix;
    }

    nsubs = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1];
    cpu_cfsposdft->size[0] = cpu_psihat->size[0];
    i1Start = cpu_psihat->size[1];
    ix = cpu_xposdft->size[1];
    if (i1Start <= ix) {
      ix = i1Start;
    }

    if (cpu_psihat->size[1] == 1) {
      cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
    } else if (cpu_xposdft->size[1] == cpu_psihat->size[1]) {
      cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
    } else {
      cpu_cfsposdft->size[1] = ix;
    }

    emxEnsureCapacity_creal32_T(cpu_cfsposdft, nsubs, &l_emlrtRTEI);
    wav_outdatedOnCpu = true;
    if ((cpu_psihat->size[0] != 0) && (i != 0)) {
      bcoef = (cpu_psihat->size[1] != 1);
      n = cpu_cfsposdft->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(i - 1, n), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsposdft, &gpu_cfsposdft, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel25<<<grid, block>>>(gpu_xposdft, gpu_psihat, bcoef, n, i -
          1, gpu_cfsposdft, cpu_psihat->size[0U], cpu_cfsposdft->size[0U]);
      }
    }

    if ((cpu_cfsposdft->size[0] == 0) || (cpu_cfsposdft->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_cfsposdft->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(cpu_cfsposdft->size[1]);
      i = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[0] = static_cast<int32_T>(xSize[0]);
      cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal32_T(cpu_cfspos, i, &y_emlrtRTEI);
      n = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos, true);
      fb_Omega_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel26<<<grid, block>>>(n, gpu_cfspos);
      }

      fb_Omega_outdatedOnGpu = false;
      x_outdatedOnCpu = true;
    } else {
      cufftHandle c_fftPlanHandle;
      ix = cpu_cfsposdft->size[1];
      c_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_cfsposdft->size[0], 1,
        CUFFT_C2C, cpu_cfsposdft->size[0]);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(cpu_cfsposdft, &gpu_cfsposdft, true);
      }

      cufftExecC2C(c_fftPlanHandle, (cufftComplex *)&gpu_cfsposdft.data[0],
                   (cufftComplex *)&gpu_cfsposdft.data[0], CUFFT_INVERSE);
      i = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[0] = cpu_cfsposdft->size[0];
      cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal32_T(cpu_cfspos, i, &y_emlrtRTEI);
      ec_wtcc_kernel1299<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
        (c_gpu_cfsposdft, cpu_cfsposdft->size[1U]);
      n = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos, true);
      fb_Omega_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1300<<<grid, block>>>(c_gpu_cfsposdft, gpu_cfsposdft, n,
          gpu_cfspos);
      }

      fb_Omega_outdatedOnGpu = false;
      x_outdatedOnCpu = true;
    }

    if (fb_SignalPad > 0) {
      N = static_cast<uint32_T>(fb_SignalPad) + static_cast<uint32_T>
        (cpu_x->size[0]);
      if (static_cast<uint32_T>(fb_SignalPad + 1) > N) {
        cpu_lidx = 0;
        ix = 0;
      } else {
        cpu_lidx = fb_SignalPad;
        ix = static_cast<int32_T>(N);
      }

      bcoef = cpu_cfspos->size[0];
      offsetH = ix - cpu_lidx;
      for (i = 0; i < offsetH; i++) {
        for (nsubs = 0; nsubs < bcoef; nsubs++) {
          if (x_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfspos, &gpu_cfspos);
          }

          cpu_cfspos->data[nsubs + bcoef * i] = cpu_cfspos->data[nsubs +
            cpu_cfspos->size[0] * (cpu_lidx + i)];
          x_outdatedOnCpu = false;
          fb_Omega_outdatedOnGpu = true;
        }
      }

      i = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[1] = ix - cpu_lidx;
      emxEnsureCapacity_creal32_T(cpu_cfspos, i, &ab_emlrtRTEI);
      fb_Omega_needsGpuEnsureCapacity = true;
    }

    i = b_cpu_psihat->size[0] * b_cpu_psihat->size[1];
    b_cpu_psihat->size[0] = cpu_daughter->size[0];
    b_cpu_psihat->size[1] = cpu_daughter->size[1];
    emxEnsureCapacity_real32_T(b_cpu_psihat, i, &q_emlrtRTEI);
    n = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_psihat, &b_gpu_psihat, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel27<<<grid, block>>>(gpu_daughter, n, b_gpu_psihat);
    }

    i = b_cpu_xv->size[0] * b_cpu_xv->size[1];
    b_cpu_xv->size[0] = 1;
    b_cpu_xv->size[1] = cpu_y->size[0];
    emxEnsureCapacity_real32_T(b_cpu_xv, i, &s_emlrtRTEI);
    n = cpu_y->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv, true);
    wav_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel28<<<grid, block>>>(gpu_y, n, b_gpu_xv);
    }

    interval_outdatedOnGpu = false;
    if (fb_SignalPad > 0) {
      cpu_lidx = cpu_x->size[0] - fb_SignalPad;
      if (cpu_lidx + 1 > cpu_x->size[0]) {
        ix = 0;
        bcoef = 1;
        cpu_lidx = -1;
      } else {
        ix = cpu_x->size[0] - 1;
        bcoef = -1;
      }

      i = d_cpu_x->size[0] * d_cpu_x->size[1];
      d_cpu_x->size[0] = 1;
      d_cpu_x->size[1] = fb_SignalPad;
      emxEnsureCapacity_real32_T(d_cpu_x, i, &w_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(fb_SignalPad - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(d_cpu_x, &d_gpu_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel29<<<grid, block>>>(gpu_y, fb_SignalPad - 1, d_gpu_x);
      }

      mwGetLaunchParameters1D(computeNumIters((fb_SignalPad >> 1) - 1), &grid,
        &block, 2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel30<<<grid, block>>>(fb_SignalPad, (fb_SignalPad >> 1) - 1,
          d_gpu_x);
      }

      i = b_cpu_xv->size[0] * b_cpu_xv->size[1];
      b_cpu_xv->size[0] = 1;
      b_cpu_xv->size[1] = ((cpu_y->size[0] + d_cpu_x->size[1]) + div_s32
                           (cpu_lidx - ix, bcoef)) + 1;
      emxEnsureCapacity_real32_T(b_cpu_xv, i, &x_emlrtRTEI);
      offsetH = d_cpu_x->size[1];
      mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel31<<<grid, block>>>(d_gpu_x, offsetH - 1, b_gpu_xv);
      }

      subs_outdatedOnCpu = true;
      offsetH = cpu_y->size[0];
      for (i = 0; i < offsetH; i++) {
        if (subs_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_xv, &b_gpu_xv);
        }

        if (y_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_y, &gpu_y);
        }

        y_outdatedOnCpu = false;
        b_cpu_xv->data[i + d_cpu_x->size[1]] = cpu_y->data[i];
        subs_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        wav_outdatedOnCpu = true;
      }

      offsetH = div_s32(cpu_lidx - ix, bcoef);
      for (i = 0; i <= offsetH; i++) {
        if (subs_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_xv, &b_gpu_xv);
        }

        if (y_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_y, &gpu_y);
        }

        y_outdatedOnCpu = false;
        b_cpu_xv->data[(i + cpu_y->size[0]) + d_cpu_x->size[1]] = cpu_y->data[ix
          + bcoef * i];
        subs_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        wav_outdatedOnCpu = true;
      }
    }

    if (b_cpu_xv->size[1] - (static_cast<int32_T>(static_cast<uint32_T>
          (b_cpu_xv->size[1]) >> 1) << 1) == 1) {
      cufftHandle d_fftPlanHandle;
      i = b_cpu_xposdft->size[0] * b_cpu_xposdft->size[1];
      b_cpu_xposdft->size[0] = 1;
      b_cpu_xposdft->size[1] = b_cpu_xv->size[1];
      emxEnsureCapacity_creal32_T(b_cpu_xposdft, i, &u_emlrtRTEI);
      n = b_cpu_xv->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv,
          !interval_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_creal32_T(b_cpu_xposdft, &b_gpu_xposdft, true);
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real32_T(&b_gpu_xv, b_cpu_xv);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel32<<<grid, block>>>(b_gpu_xv, n, b_gpu_xposdft);
      }

      ix = b_cpu_xposdft->size[1];
      d_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, 1, 1, CUFFT_C2C, 1);
      cufftExecC2C(d_fftPlanHandle, (cufftComplex *)&b_gpu_xposdft.data[0],
                   (cufftComplex *)&b_gpu_xposdft.data[0], CUFFT_FORWARD);
    } else {
      cufftHandle e_fftPlanHandle;
      ix = b_cpu_xv->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(b_cpu_xv->size[itime]);
      }

      i = b_cpu_xposdft->size[0] * b_cpu_xposdft->size[1];
      b_cpu_xposdft->size[0] = 1;
      b_cpu_xposdft->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_creal32_T(b_cpu_xposdft, i, &v_emlrtRTEI);
      e_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, 1, 1, CUFFT_R2C, 1);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv,
          !interval_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_creal32_T(b_cpu_xposdft, &b_gpu_xposdft, true);
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real32_T(&b_gpu_xv, b_cpu_xv);
      }

      cufftExecR2C(e_fftPlanHandle, (cufftReal *)&b_gpu_xv.data[0],
                   (cufftComplex *)&b_gpu_xposdft.data[0]);
      cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
        (xSize[1]) + 1) / 2.0);
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 2), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1298<<<grid, block>>>(cpu_lidx - 2, b_gpu_xposdft, xSize[1]);
      }
    }

    i1Start = b_cpu_psihat->size[1];
    ix = b_cpu_xposdft->size[1];
    if (i1Start <= ix) {
      ix = i1Start;
    }

    if (b_cpu_psihat->size[1] == 1) {
      i = b_cpu_xposdft->size[1];
    } else if (b_cpu_xposdft->size[1] == b_cpu_psihat->size[1]) {
      i = b_cpu_xposdft->size[1];
    } else {
      i = ix;
    }

    nsubs = b_cpu_cfsposdft->size[0] * b_cpu_cfsposdft->size[1];
    b_cpu_cfsposdft->size[0] = b_cpu_psihat->size[0];
    i1Start = b_cpu_psihat->size[1];
    ix = b_cpu_xposdft->size[1];
    if (i1Start <= ix) {
      ix = i1Start;
    }

    if (b_cpu_psihat->size[1] == 1) {
      b_cpu_cfsposdft->size[1] = b_cpu_xposdft->size[1];
    } else if (b_cpu_xposdft->size[1] == b_cpu_psihat->size[1]) {
      b_cpu_cfsposdft->size[1] = b_cpu_xposdft->size[1];
    } else {
      b_cpu_cfsposdft->size[1] = ix;
    }

    emxEnsureCapacity_creal32_T(b_cpu_cfsposdft, nsubs, &l_emlrtRTEI);
    wav_outdatedOnCpu = true;
    if ((b_cpu_psihat->size[0] != 0) && (i != 0)) {
      bcoef = (b_cpu_psihat->size[1] != 1);
      n = b_cpu_cfsposdft->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(i - 1, n), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsposdft, &b_gpu_cfsposdft, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel33<<<grid, block>>>(b_gpu_xposdft, b_gpu_psihat, bcoef, n,
          i - 1, b_gpu_cfsposdft, b_cpu_psihat->size[0U], b_cpu_cfsposdft->size
          [0U]);
      }
    }

    if ((b_cpu_cfsposdft->size[0] == 0) || (b_cpu_cfsposdft->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(b_cpu_cfsposdft->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(b_cpu_cfsposdft->size[1]);
      i = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
      b_cpu_cfspos->size[0] = static_cast<int32_T>(xSize[0]);
      b_cpu_cfspos->size[1] = b_cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal32_T(b_cpu_cfspos, i, &y_emlrtRTEI);
      n = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel34<<<grid, block>>>(n, b_gpu_cfspos);
      }

      fb_Omega_outdatedOnCpu = false;
      y_outdatedOnCpu = true;
    } else {
      cufftHandle f_fftPlanHandle;
      ix = b_cpu_cfsposdft->size[1];
      f_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, b_cpu_cfsposdft->size[0],
        1, CUFFT_C2C, b_cpu_cfsposdft->size[0]);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsposdft, &b_gpu_cfsposdft, true);
      }

      cufftExecC2C(f_fftPlanHandle, (cufftComplex *)&b_gpu_cfsposdft.data[0],
                   (cufftComplex *)&b_gpu_cfsposdft.data[0], CUFFT_INVERSE);
      i = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
      b_cpu_cfspos->size[0] = b_cpu_cfsposdft->size[0];
      b_cpu_cfspos->size[1] = b_cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal32_T(b_cpu_cfspos, i, &y_emlrtRTEI);
      ec_wtcc_kernel1296<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
        (c_gpu_cfsposdft, b_cpu_cfsposdft->size[1U]);
      n = b_cpu_cfsposdft->size[0] * b_cpu_cfsposdft->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1297<<<grid, block>>>(c_gpu_cfsposdft, b_gpu_cfsposdft, n,
          b_gpu_cfspos);
      }

      fb_Omega_outdatedOnCpu = false;
      y_outdatedOnCpu = true;
    }

    if (fb_SignalPad > 0) {
      N = static_cast<uint32_T>(fb_SignalPad) + static_cast<uint32_T>
        (cpu_x->size[0]);
      if (static_cast<uint32_T>(fb_SignalPad + 1) > N) {
        fb_SignalPad = 0;
        cpu_lidx = 0;
      } else {
        cpu_lidx = static_cast<int32_T>(N);
      }

      bcoef = b_cpu_cfspos->size[0];
      offsetH = cpu_lidx - fb_SignalPad;
      for (i = 0; i < offsetH; i++) {
        for (nsubs = 0; nsubs < bcoef; nsubs++) {
          if (y_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfspos, &b_gpu_cfspos);
          }

          b_cpu_cfspos->data[nsubs + bcoef * i] = b_cpu_cfspos->data[nsubs +
            b_cpu_cfspos->size[0] * (fb_SignalPad + i)];
          y_outdatedOnCpu = false;
          fb_Omega_outdatedOnCpu = true;
        }
      }

      i = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
      b_cpu_cfspos->size[1] = cpu_lidx - fb_SignalPad;
      emxEnsureCapacity_creal32_T(b_cpu_cfspos, i, &ab_emlrtRTEI);
      wav_outdatedOnCpu = true;
    }

    cpu_lidx = static_cast<int32_T>(std::trunc(static_cast<real_T>
      (cpu_cfspos->size[0]) / 2.0));
    if (!(halfh <= cpu_lidx)) {
      i_y = nullptr;
      m8 = emlrtCreateCharArray(2, &iv8[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m8, &rfmt[0]);
      emlrtAssign(&i_y, m8);
      j_y = nullptr;
      m9 = emlrtCreateDoubleScalar(static_cast<real_T>(cpu_lidx));
      emlrtAssign(&j_y, m9);
      emlrt_marshallIn(b_sprintf(i_y, j_y, &emlrtMCI), "<output of sprintf>",
                       unusedExpr);
    }

    offsetH = cpu_cfspos->size[0] * cpu_cfspos->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_cfspos->size[itime]);
    }

    i = g_cpu_y->size[0] * g_cpu_y->size[1];
    g_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    g_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(g_cpu_y, i, &r_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    if (fb_Omega_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos,
        !fb_Omega_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real32_T(g_cpu_y, &d_gpu_y, true);
    if (fb_Omega_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_cfspos, cpu_cfspos);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel35<<<grid, block>>>(gpu_cfspos, offsetH - 1, d_gpu_y);
    }

    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(g_cpu_y->size[itime]);
    }

    i = cpu_cfs1->size[0] * cpu_cfs1->size[1];
    cpu_cfs1->size[0] = static_cast<int32_T>(xSize[0]);
    cpu_cfs1->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(cpu_cfs1, i, &i_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel36<<<grid, block>>>(d_gpu_y, static_cast<int32_T>(xSize[0]) *
        static_cast<int32_T>(xSize[1]) - 1, gpu_cfs1);
    }

    fa = std::frexp(static_cast<real_T>(cpu_cfs1->size[1]), &h_eint);
    ix = h_eint;
    if (fa == 0.5) {
      ix = h_eint - 1;
    }

    r = rt_powd_snf(2.0, static_cast<real_T>(ix));
    ix = static_cast<int32_T>(std::trunc(r / 2.0));
    if (ix < 1) {
      b_cpu_omega_tmp1->size[0] = 1;
      b_cpu_omega_tmp1->size[1] = 0;
    } else {
      i = b_cpu_omega_tmp1->size[0] * b_cpu_omega_tmp1->size[1];
      b_cpu_omega_tmp1->size[0] = 1;
      b_cpu_omega_tmp1->size[1] = ix;
      emxEnsureCapacity_int32_T(b_cpu_omega_tmp1, i, &bb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_int32_T(b_cpu_omega_tmp1, &b_gpu_omega_tmp1, true);
      d_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1295<<<grid, block>>>(ix - 1, b_gpu_omega_tmp1);
      }
    }

    i = b_cpu_omega_tmp2->size[0] * b_cpu_omega_tmp2->size[1];
    b_cpu_omega_tmp2->size[0] = 1;
    b_cpu_omega_tmp2->size[1] = b_cpu_omega_tmp1->size[1];
    emxEnsureCapacity_real_T(b_cpu_omega_tmp2, i, &cb_emlrtRTEI);
    n = b_cpu_omega_tmp1->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (d_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_int32_T(b_cpu_omega_tmp1, &b_gpu_omega_tmp1, true);
    }

    d_omega_tmp1_needsGpuEnsureCapa = false;
    gpuEmxEnsureCapacity_real_T(b_cpu_omega_tmp2, &b_gpu_omega_tmp2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel37<<<grid, block>>>(6.2831853071795862 / r, b_gpu_omega_tmp1,
        n, b_gpu_omega_tmp2);
    }

    omega_tmp2_outdatedOnCpu = true;
    cpu_lidx = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
    if (cpu_lidx < 1) {
      ix = 1;
      bcoef = -1;
    } else {
      cpu_lidx--;
      ix = -1;
      bcoef = 0;
    }

    i = cpu_omega->size[0] * cpu_omega->size[1];
    cpu_omega->size[0] = 1;
    cpu_omega->size[1] = (b_cpu_omega_tmp2->size[1] + div_s32(bcoef - cpu_lidx,
      ix)) + 2;
    emxEnsureCapacity_real_T(cpu_omega, i, &db_emlrtRTEI);
    gpuEmxEnsureCapacity_real_T(cpu_omega, &gpu_omega, true);
    ec_wtcc_kernel38<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_omega);
    offsetH = b_cpu_omega_tmp2->size[1];
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    fb_Omega_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel39<<<grid, block>>>(b_gpu_omega_tmp2, offsetH - 1, gpu_omega);
    }

    fb_Omega_outdatedOnGpu = false;
    interval_outdatedOnGpu = true;
    offsetH = div_s32(bcoef - cpu_lidx, ix);
    for (i = 0; i <= offsetH; i++) {
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_omega, &gpu_omega);
      }

      if (omega_tmp2_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(b_cpu_omega_tmp2, &b_gpu_omega_tmp2);
      }

      omega_tmp2_outdatedOnCpu = false;
      cpu_omega->data[(i + b_cpu_omega_tmp2->size[1]) + 1] =
        -b_cpu_omega_tmp2->data[cpu_lidx + ix * i];
      interval_outdatedOnGpu = false;
      fb_Omega_outdatedOnGpu = true;
      fb_Omega_needsGpuEnsureCapacity = true;
    }

    if ((cpu_cfs1->size[0] == 0) || (cpu_cfs1->size[1] == 0) ||
        (static_cast<int32_T>(r) == 0)) {
      i = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
      cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
      cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(cpu_cfsDFT, i, &eb_emlrtRTEI);
      n = cpu_cfs1->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel40<<<grid, block>>>(n, gpu_cfsDFT);
      }
    } else if (cpu_cfs1->size[1] != static_cast<int32_T>(r)) {
      cufftHandle i_fftPlanHandle;
      if (cpu_cfs1->size[1] < static_cast<int32_T>(r)) {
        i = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
        cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
        cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(cpu_cfsDFT, i, &eb_emlrtRTEI);
        n = cpu_cfs1->size[0] * static_cast<int32_T>(r) - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1290<<<grid, block>>>(n, gpu_cfsDFT);
        }
      } else {
        i = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
        cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
        cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(cpu_cfsDFT, i, &v_emlrtRTEI);
        interval_outdatedOnGpu = true;
      }

      cpu_lidx = cpu_cfs1->size[0];
      if (cpu_cfs1->size[1] > static_cast<int32_T>(r)) {
        ix = static_cast<int32_T>(r);
      } else {
        ix = cpu_cfs1->size[1];
      }

      mwGetLaunchParameters1D(computeNumIters(ix - 1, cpu_lidx - 1), &grid,
        &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1291<<<grid, block>>>(gpu_cfs1, cpu_lidx - 1, ix - 1,
          gpu_cfsDFT, cpu_cfsDFT->size[0U], cpu_cfs1->size[0U]);
      }

      ix = cpu_cfsDFT->size[1];
      i_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_cfsDFT->size[0], 1,
        CUFFT_C2C, cpu_cfsDFT->size[0]);
      cufftExecC2C(i_fftPlanHandle, (cufftComplex *)&gpu_cfsDFT.data[0],
                   (cufftComplex *)&gpu_cfsDFT.data[0], CUFFT_FORWARD);
    } else {
      bcoef = cpu_cfs1->size[0] * cpu_cfs1->size[1];
      if (bcoef - (static_cast<int32_T>(static_cast<uint32_T>(bcoef) >> 1) << 1)
          == 1) {
        cufftHandle g_fftPlanHandle;
        i = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
        cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
        cpu_cfsDFT->size[1] = cpu_cfs1->size[1];
        emxEnsureCapacity_creal32_T(cpu_cfsDFT, i, &eb_emlrtRTEI);
        n = cpu_cfs1->size[0] * cpu_cfs1->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1292<<<grid, block>>>(gpu_cfs1, n, gpu_cfsDFT);
        }

        ix = cpu_cfsDFT->size[1];
        g_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_cfsDFT->size[0], 1,
          CUFFT_C2C, cpu_cfsDFT->size[0]);
        cufftExecC2C(g_fftPlanHandle, (cufftComplex *)&gpu_cfsDFT.data[0],
                     (cufftComplex *)&gpu_cfsDFT.data[0], CUFFT_FORWARD);
      } else {
        ix = cpu_cfs1->size[1];
        for (itime = 0; itime < 2; itime++) {
          xSize[itime] = static_cast<uint32_T>(cpu_cfs1->size[itime]);
        }

        cufftHandle h_fftPlanHandle;
        i = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
        cpu_cfsDFT->size[0] = static_cast<int32_T>(xSize[0]);
        cpu_cfsDFT->size[1] = static_cast<int32_T>(xSize[1]);
        emxEnsureCapacity_creal32_T(cpu_cfsDFT, i, &v_emlrtRTEI);
        h_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_cfs1->size[0], 1,
          CUFFT_R2C, cpu_cfs1->size[0]);
        gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
        cufftExecR2C(h_fftPlanHandle, (cufftReal *)&gpu_cfs1.data[0],
                     (cufftComplex *)&gpu_cfsDFT.data[0]);
        cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
          (xSize[1]) + 1) / 2.0) - 2;
        if ((cpu_cfsDFT->size[0] == 1) || (cpu_cfsDFT->size[1] == 1)) {
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1293<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
              cpu_lidx, gpu_cfsDFT);
          }
        } else {
          n = cpu_cfsDFT->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx, n), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1294<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
              n, cpu_lidx, gpu_cfsDFT, cpu_cfsDFT->size[0U]);
          }
        }
      }
    }

    i = cpu_Fmat->size[0] * cpu_Fmat->size[1];
    cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
    cpu_Fmat->size[1] = cpu_omega->size[1];
    emxEnsureCapacity_real_T(cpu_Fmat, i, &fb_emlrtRTEI);
    cpu_lidx = cpu_omega->size[1];
    n = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid, &block,
      2147483647U);
    if (c_fb_Scales_needsGpuEnsureCapac) {
      gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    }

    if (fb_Omega_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_omega, &gpu_omega, !fb_Omega_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real_T(cpu_Fmat, &gpu_Fmat, true);
    if (fb_Omega_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_omega, cpu_omega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel41<<<grid, block>>>(gpu_fb_Scales, gpu_omega, n, cpu_lidx -
        1, gpu_Fmat, cpu_Fmat->size[0U]);
    }

    if ((cpu_Fmat->size[0] == cpu_cfsDFT->size[0]) && (cpu_Fmat->size[1] ==
         cpu_cfsDFT->size[1])) {
      i = e_cpu_x->size[0] * e_cpu_x->size[1];
      e_cpu_x->size[0] = cpu_Fmat->size[0];
      e_cpu_x->size[1] = cpu_Fmat->size[1];
      emxEnsureCapacity_creal32_T(e_cpu_x, i, &gb_emlrtRTEI);
      n = cpu_Fmat->size[0] * cpu_Fmat->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(e_cpu_x, &e_gpu_x, true);
      subs_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel42<<<grid, block>>>(gpu_cfsDFT, gpu_Fmat, n, e_gpu_x);
      }

      interval_outdatedOnGpu = false;
      b_x_outdatedOnCpu = true;
    } else {
      if (b_x_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(e_cpu_x, &e_gpu_x);
      }

      gpuEmxMemcpyGpuToCpu_real_T(cpu_Fmat, &gpu_Fmat);
      gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfsDFT, &gpu_cfsDFT);
      binary_expand_op_5(e_cpu_x, cpu_Fmat, cpu_cfsDFT);
      b_x_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      subs_outdatedOnCpu = true;
    }

    if ((e_cpu_x->size[0] == 0) || (e_cpu_x->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(e_cpu_x->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(e_cpu_x->size[1]);
      i = h_cpu_y->size[0] * h_cpu_y->size[1];
      h_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
      h_cpu_y->size[1] = e_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(h_cpu_y, i, &hb_emlrtRTEI);
      n = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(h_cpu_y, &e_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel43<<<grid, block>>>(n, e_gpu_y);
      }
    } else {
      cufftHandle j_fftPlanHandle;
      ix = e_cpu_x->size[1];
      j_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, e_cpu_x->size[0], 1,
        CUFFT_C2C, e_cpu_x->size[0]);
      if (subs_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(e_cpu_x, &e_gpu_x,
          !interval_outdatedOnGpu);
      }

      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_creal32_T(&e_gpu_x, e_cpu_x);
      }

      cufftExecC2C(j_fftPlanHandle, (cufftComplex *)&e_gpu_x.data[0],
                   (cufftComplex *)&e_gpu_x.data[0], CUFFT_INVERSE);
      b_x_outdatedOnCpu = true;
      i = h_cpu_y->size[0] * h_cpu_y->size[1];
      h_cpu_y->size[0] = e_cpu_x->size[0];
      h_cpu_y->size[1] = e_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(h_cpu_y, i, &hb_emlrtRTEI);
      ec_wtcc_kernel1288<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
        (c_gpu_cfsposdft, e_cpu_x->size[1U]);
      n = e_cpu_x->size[0] * e_cpu_x->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(h_cpu_y, &e_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1289<<<grid, block>>>(c_gpu_cfsposdft, e_gpu_x, n, e_gpu_y);
      }
    }

    i = cpu_smooth->size[0] * cpu_smooth->size[1];
    cpu_smooth->size[0] = h_cpu_y->size[0];
    cpu_smooth->size[1] = h_cpu_y->size[1];
    emxEnsureCapacity_real32_T(cpu_smooth, i, &ib_emlrtRTEI);
    n = h_cpu_y->size[0] * h_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_smooth, &gpu_smooth, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel44<<<grid, block>>>(e_gpu_y, n, gpu_smooth);
    }

    ix = cpu_cfs1->size[1];
    a = 1.0 / halfh;
    if ((cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
      i = cpu_a->size[0];
      cpu_a->size[0] = cpu_cfs1->size[1];
      emxEnsureCapacity_real32_T(cpu_a, i, &jb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_a, &gpu_a, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel45<<<grid, block>>>(gpu_smooth, ix - 1, gpu_a,
          cpu_smooth->size[0U]);
      }

      i = cpu_c->size[0];
      cpu_c->size[0] = cpu_a->size[0];
      emxEnsureCapacity_real32_T(cpu_c, i, &lb_emlrtRTEI);
      n = cpu_a->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel46<<<grid, block>>>(n, gpu_c);
      }

      if (cpu_a->size[0] != 0) {
        if (cpu_a->size[0] == 1) {
          i = cpu_c->size[0];
          cpu_c->size[0] = 1;
          emxEnsureCapacity_real32_T(cpu_c, i, &lb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
          ec_wtcc_kernel47<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a, gpu_a,
            gpu_c);
        } else {
          bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
            (cpu_a->size[0])));
          b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(cpu_a->size[0]) + static_cast<uint32_T>(bcoef))
            - 1.0) / static_cast<real_T>(bcoef)));
          OH = cpu_a->size[0];
          if (cpu_a->size[0] > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = cpu_a->size[0] + 1;
          }

          i = b_cpu_expanded->size[0];
          b_cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_real32_T(b_cpu_expanded, i, &nb_emlrtRTEI);
          n = cpu_a->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(b_cpu_expanded, &ee_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1275<<<grid, block>>>(n, ee_gpu_expanded);
          }

          n = cpu_a->size[0];
          i = k_cpu_y->size[0] * k_cpu_y->size[1];
          k_cpu_y->size[0] = 1;
          k_cpu_y->size[1] = cpu_a->size[0];
          emxEnsureCapacity_int32_T(k_cpu_y, i, &ob_emlrtRTEI);
          k_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            k_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv10->size[0];
          cpu_iv10->size[0] = k_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv10, i, &nb_emlrtRTEI);
          n = k_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(k_cpu_y, &eh_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv10, &gpu_iv10, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&eh_gpu_y, k_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1276<<<grid, block>>>(eh_gpu_y, n, gpu_iv10);
          }

          omega_tmp2[0] = cpu_iv10->size[0];
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1277<<<grid, block>>>(gpu_a, gpu_iv10, omega_tmp2[0] -
              1, ee_gpu_expanded);
          }

          i = cpu_c->size[0];
          cpu_c->size[0] = cpu_a->size[0];
          emxEnsureCapacity_real32_T(cpu_c, i, &nb_emlrtRTEI);
          mwApplyLaunchParameters(computeNumIters(OH - 1), dim3
            (static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
            (static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U), &grid,
            &block);
          gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1278<<<grid, block>>>(a, ee_gpu_expanded, OH - 1,
              gpu_c);
          }
        }
      }

      i = cpu_cfs1->size[0] * cpu_cfs1->size[1];
      cpu_cfs1->size[0] = 1;
      cpu_cfs1->size[1] = cpu_c->size[0];
      emxEnsureCapacity_real32_T(cpu_cfs1, i, &kb_emlrtRTEI);
      n = cpu_c->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel48<<<grid, block>>>(gpu_c, n, gpu_cfs1, cpu_cfs1->size[0U]);
      }
    } else {
      i = cpu_cfs1->size[0] * cpu_cfs1->size[1];
      cpu_cfs1->size[0] = cpu_smooth->size[0];
      cpu_cfs1->size[1] = ix;
      emxEnsureCapacity_real32_T(cpu_cfs1, i, &kb_emlrtRTEI);
      n = cpu_smooth->size[0] * ix - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1279<<<grid, block>>>(n, gpu_cfs1);
      }

      if ((cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
        if ((cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
          i = d_cpu_smooth->size[0];
          d_cpu_smooth->size[0] = 1;
          emxEnsureCapacity_real32_T(d_cpu_smooth, i, &mb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(d_cpu_smooth, &g_gpu_smooth, true);
          ec_wtcc_kernel1280<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a,
            gpu_smooth, g_gpu_smooth);
          i = cpu_cfs1->size[0] * cpu_cfs1->size[1];
          cpu_cfs1->size[0] = 1;
          cpu_cfs1->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_cfs1, i, &kb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
          ec_wtcc_kernel1281<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
            (g_gpu_smooth, gpu_cfs1);
        } else {
          bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
            (cpu_smooth->size[0])));
          cpu_lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(ix)));
          blockDims[0] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(cpu_smooth->size[0]) + static_cast<uint32_T>
            (bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
          blockDims[1] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(ix) + static_cast<uint32_T>(cpu_lidx)) - 1.0) /
            static_cast<real_T>(cpu_lidx)));
          OH = cpu_smooth->size[0];
          if (static_cast<int32_T>(halfh) > MAX_int32_T - cpu_smooth->size[0]) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = cpu_smooth->size[0] + static_cast<int32_T>(halfh);
          }

          i = cpu_expanded->size[0] * cpu_expanded->size[1];
          cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_real32_T(cpu_expanded, i, &nb_emlrtRTEI);
          if (ix > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = ix + 1;
          }

          i = cpu_expanded->size[0] * cpu_expanded->size[1];
          cpu_expanded->size[1] = i1Start - 1;
          emxEnsureCapacity_real32_T(cpu_expanded, i, &nb_emlrtRTEI);
          n = ((cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) * ix - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(cpu_expanded, &fe_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1282<<<grid, block>>>(n, fe_gpu_expanded);
          }

          n = cpu_smooth->size[0];
          i = j_cpu_y->size[0] * j_cpu_y->size[1];
          j_cpu_y->size[0] = 1;
          j_cpu_y->size[1] = cpu_smooth->size[0];
          emxEnsureCapacity_int32_T(j_cpu_y, i, &ob_emlrtRTEI);
          j_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            j_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv9->size[0];
          cpu_iv9->size[0] = j_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv9, i, &nb_emlrtRTEI);
          n = j_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(j_cpu_y, &fh_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv9, &gpu_iv9, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&fh_gpu_y, j_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1283<<<grid, block>>>(static_cast<int32_T>(std::floor
              ((halfh - 1.0) / 2.0)), fh_gpu_y, n, gpu_iv9);
          }

          i = l_cpu_y->size[0] * l_cpu_y->size[1];
          l_cpu_y->size[0] = 1;
          l_cpu_y->size[1] = ix;
          emxEnsureCapacity_int32_T(l_cpu_y, i, &ob_emlrtRTEI);
          l_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= ix - 2; itime++) {
            nsubs++;
            l_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv11->size[0];
          cpu_iv11->size[0] = l_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv11, i, &nb_emlrtRTEI);
          n = l_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(l_cpu_y, &gh_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv11, &gpu_iv11, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&gh_gpu_y, l_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1284<<<grid, block>>>(gh_gpu_y, n, gpu_iv11);
          }

          i = e_cpu_smooth->size[0] * e_cpu_smooth->size[1];
          e_cpu_smooth->size[0] = cpu_smooth->size[0];
          e_cpu_smooth->size[1] = ix;
          emxEnsureCapacity_real32_T(e_cpu_smooth, i, &pb_emlrtRTEI);
          n = cpu_smooth->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(ix - 1, n), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(e_cpu_smooth, &h_gpu_smooth, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1285<<<grid, block>>>(gpu_smooth, n, ix - 1,
              h_gpu_smooth, e_cpu_smooth->size[0U], cpu_smooth->size[0U]);
          }

          fx_size[0] = cpu_iv9->size[0];
          fx_size[1] = cpu_iv11->size[0];
          mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0] - 1),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1286<<<grid, block>>>(h_gpu_smooth, fx_size[0],
              gpu_iv11, gpu_iv9, fx_size[0] - 1, fx_size[1] - 1, fe_gpu_expanded,
              cpu_expanded->size[0U]);
          }

          n = static_cast<int32_T>(halfh);
          i = cpu_rows->size[0] * cpu_rows->size[1];
          cpu_rows->size[0] = 1;
          cpu_rows->size[1] = static_cast<int32_T>(halfh);
          emxEnsureCapacity_int32_T(cpu_rows, i, &ob_emlrtRTEI);
          cpu_rows->data[0] = 0;
          nsubs = 0;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            cpu_rows->data[itime + 1] = nsubs;
          }

          i = cpu_cfs1->size[0] * cpu_cfs1->size[1];
          cpu_cfs1->size[0] = cpu_smooth->size[0];
          cpu_cfs1->size[1] = ix;
          emxEnsureCapacity_real32_T(cpu_cfs1, i, &nb_emlrtRTEI);
          mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
            (blockDims[0], blockDims[1], 1U), dim3(static_cast<uint32_T>(
            static_cast<int8_T>(bcoef)), static_cast<uint32_T>
            (static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
          gpuEmxEnsureCapacity_int32_T(cpu_rows, &pd_gpu_rows, false);
          gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&pd_gpu_rows, cpu_rows);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1287<<<grid, block>>>(a, fe_gpu_expanded, pd_gpu_rows,
              halfh, OH - 1, ix - 1, gpu_cfs1, cpu_expanded->size[0U],
              cpu_cfs1->size[0U]);
          }
        }
      }
    }

    offsetH = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(b_cpu_cfspos->size[itime]);
    }

    i = i_cpu_y->size[0] * i_cpu_y->size[1];
    i_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    i_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(i_cpu_y, i, &r_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos,
        !fb_Omega_outdatedOnCpu);
    }

    gpuEmxEnsureCapacity_real32_T(i_cpu_y, &f_gpu_y, true);
    if (fb_Omega_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&b_gpu_cfspos, b_cpu_cfspos);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel49<<<grid, block>>>(b_gpu_cfspos, offsetH - 1, f_gpu_y);
    }

    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(i_cpu_y->size[itime]);
    }

    i = cpu_cfs2->size[0] * cpu_cfs2->size[1];
    cpu_cfs2->size[0] = static_cast<int32_T>(xSize[0]);
    cpu_cfs2->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(cpu_cfs2, i, &i_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel50<<<grid, block>>>(f_gpu_y, static_cast<int32_T>(xSize[0]) *
        static_cast<int32_T>(xSize[1]) - 1, gpu_cfs2);
    }

    fa = std::frexp(static_cast<real_T>(cpu_cfs2->size[1]), &i_eint);
    ix = i_eint;
    if (fa == 0.5) {
      ix = i_eint - 1;
    }

    r = rt_powd_snf(2.0, static_cast<real_T>(ix));
    ix = static_cast<int32_T>(std::trunc(r / 2.0));
    if (ix < 1) {
      c_cpu_omega_tmp1->size[0] = 1;
      c_cpu_omega_tmp1->size[1] = 0;
    } else {
      i = c_cpu_omega_tmp1->size[0] * c_cpu_omega_tmp1->size[1];
      c_cpu_omega_tmp1->size[0] = 1;
      c_cpu_omega_tmp1->size[1] = ix;
      emxEnsureCapacity_int32_T(c_cpu_omega_tmp1, i, &bb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_int32_T(c_cpu_omega_tmp1, &c_gpu_omega_tmp1, true);
      e_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1274<<<grid, block>>>(ix - 1, c_gpu_omega_tmp1);
      }
    }

    i = c_cpu_omega_tmp2->size[0] * c_cpu_omega_tmp2->size[1];
    c_cpu_omega_tmp2->size[0] = 1;
    c_cpu_omega_tmp2->size[1] = c_cpu_omega_tmp1->size[1];
    emxEnsureCapacity_real_T(c_cpu_omega_tmp2, i, &cb_emlrtRTEI);
    n = c_cpu_omega_tmp1->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (e_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_int32_T(c_cpu_omega_tmp1, &c_gpu_omega_tmp1, true);
    }

    e_omega_tmp1_needsGpuEnsureCapa = false;
    gpuEmxEnsureCapacity_real_T(c_cpu_omega_tmp2, &c_gpu_omega_tmp2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel51<<<grid, block>>>(6.2831853071795862 / r, c_gpu_omega_tmp1,
        n, c_gpu_omega_tmp2);
    }

    omega_tmp2_outdatedOnCpu = true;
    cpu_lidx = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
    if (cpu_lidx < 1) {
      ix = 1;
      bcoef = -1;
    } else {
      cpu_lidx--;
      ix = -1;
      bcoef = 0;
    }

    i = b_cpu_omega->size[0] * b_cpu_omega->size[1];
    b_cpu_omega->size[0] = 1;
    b_cpu_omega->size[1] = (c_cpu_omega_tmp2->size[1] + div_s32(bcoef - cpu_lidx,
      ix)) + 2;
    emxEnsureCapacity_real_T(b_cpu_omega, i, &db_emlrtRTEI);
    gpuEmxEnsureCapacity_real_T(b_cpu_omega, &b_gpu_omega, true);
    ec_wtcc_kernel52<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_omega);
    offsetH = c_cpu_omega_tmp2->size[1];
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    fb_Omega_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel53<<<grid, block>>>(c_gpu_omega_tmp2, offsetH - 1,
        b_gpu_omega);
    }

    fb_Omega_outdatedOnGpu = false;
    interval_outdatedOnGpu = true;
    offsetH = div_s32(bcoef - cpu_lidx, ix);
    for (i = 0; i <= offsetH; i++) {
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(b_cpu_omega, &b_gpu_omega);
      }

      if (omega_tmp2_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(c_cpu_omega_tmp2, &c_gpu_omega_tmp2);
      }

      omega_tmp2_outdatedOnCpu = false;
      b_cpu_omega->data[(i + c_cpu_omega_tmp2->size[1]) + 1] =
        -c_cpu_omega_tmp2->data[cpu_lidx + ix * i];
      interval_outdatedOnGpu = false;
      fb_Omega_outdatedOnGpu = true;
      fb_Omega_needsGpuEnsureCapacity = true;
    }

    if ((cpu_cfs2->size[0] == 0) || (cpu_cfs2->size[1] == 0) ||
        (static_cast<int32_T>(r) == 0)) {
      i = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
      b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
      b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, i, &eb_emlrtRTEI);
      n = cpu_cfs2->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel54<<<grid, block>>>(n, b_gpu_cfsDFT);
      }
    } else if (cpu_cfs2->size[1] != static_cast<int32_T>(r)) {
      cufftHandle m_fftPlanHandle;
      if (cpu_cfs2->size[1] < static_cast<int32_T>(r)) {
        i = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
        b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
        b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, i, &eb_emlrtRTEI);
        n = cpu_cfs2->size[0] * static_cast<int32_T>(r) - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1269<<<grid, block>>>(n, b_gpu_cfsDFT);
        }
      } else {
        i = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
        b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
        b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, i, &v_emlrtRTEI);
        interval_outdatedOnGpu = true;
      }

      cpu_lidx = cpu_cfs2->size[0];
      if (cpu_cfs2->size[1] > static_cast<int32_T>(r)) {
        ix = static_cast<int32_T>(r);
      } else {
        ix = cpu_cfs2->size[1];
      }

      mwGetLaunchParameters1D(computeNumIters(ix - 1, cpu_lidx - 1), &grid,
        &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1270<<<grid, block>>>(gpu_cfs2, cpu_lidx - 1, ix - 1,
          b_gpu_cfsDFT, b_cpu_cfsDFT->size[0U], cpu_cfs2->size[0U]);
      }

      ix = b_cpu_cfsDFT->size[1];
      m_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, b_cpu_cfsDFT->size[0], 1,
        CUFFT_C2C, b_cpu_cfsDFT->size[0]);
      cufftExecC2C(m_fftPlanHandle, (cufftComplex *)&b_gpu_cfsDFT.data[0],
                   (cufftComplex *)&b_gpu_cfsDFT.data[0], CUFFT_FORWARD);
    } else {
      bcoef = cpu_cfs2->size[0] * cpu_cfs2->size[1];
      if (bcoef - (static_cast<int32_T>(static_cast<uint32_T>(bcoef) >> 1) << 1)
          == 1) {
        cufftHandle k_fftPlanHandle;
        i = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
        b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
        b_cpu_cfsDFT->size[1] = cpu_cfs2->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, i, &eb_emlrtRTEI);
        n = cpu_cfs2->size[0] * cpu_cfs2->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1271<<<grid, block>>>(gpu_cfs2, n, b_gpu_cfsDFT);
        }

        ix = b_cpu_cfsDFT->size[1];
        k_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, b_cpu_cfsDFT->size[0], 1,
          CUFFT_C2C, b_cpu_cfsDFT->size[0]);
        cufftExecC2C(k_fftPlanHandle, (cufftComplex *)&b_gpu_cfsDFT.data[0],
                     (cufftComplex *)&b_gpu_cfsDFT.data[0], CUFFT_FORWARD);
      } else {
        ix = cpu_cfs2->size[1];
        for (itime = 0; itime < 2; itime++) {
          xSize[itime] = static_cast<uint32_T>(cpu_cfs2->size[itime]);
        }

        cufftHandle l_fftPlanHandle;
        i = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
        b_cpu_cfsDFT->size[0] = static_cast<int32_T>(xSize[0]);
        b_cpu_cfsDFT->size[1] = static_cast<int32_T>(xSize[1]);
        emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, i, &v_emlrtRTEI);
        l_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_cfs2->size[0], 1,
          CUFFT_R2C, cpu_cfs2->size[0]);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
        cufftExecR2C(l_fftPlanHandle, (cufftReal *)&gpu_cfs2.data[0],
                     (cufftComplex *)&b_gpu_cfsDFT.data[0]);
        cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
          (xSize[1]) + 1) / 2.0) - 2;
        if ((b_cpu_cfsDFT->size[0] == 1) || (b_cpu_cfsDFT->size[1] == 1)) {
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1272<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
              cpu_lidx, b_gpu_cfsDFT);
          }
        } else {
          n = b_cpu_cfsDFT->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx, n), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1273<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
              n, cpu_lidx, b_gpu_cfsDFT, b_cpu_cfsDFT->size[0U]);
          }
        }
      }
    }

    i = b_cpu_Fmat->size[0] * b_cpu_Fmat->size[1];
    b_cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
    b_cpu_Fmat->size[1] = b_cpu_omega->size[1];
    emxEnsureCapacity_real_T(b_cpu_Fmat, i, &fb_emlrtRTEI);
    cpu_lidx = b_cpu_omega->size[1];
    n = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid, &block,
      2147483647U);
    if (fb_Omega_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(b_cpu_omega, &b_gpu_omega,
        !fb_Omega_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real_T(b_cpu_Fmat, &b_gpu_Fmat, true);
    if (fb_Omega_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_omega, b_cpu_omega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel55<<<grid, block>>>(gpu_fb_Scales, b_gpu_omega, n, cpu_lidx
        - 1, b_gpu_Fmat, b_cpu_Fmat->size[0U]);
    }

    if ((b_cpu_Fmat->size[0] == b_cpu_cfsDFT->size[0]) && (b_cpu_Fmat->size[1] ==
         b_cpu_cfsDFT->size[1])) {
      i = f_cpu_x->size[0] * f_cpu_x->size[1];
      f_cpu_x->size[0] = b_cpu_Fmat->size[0];
      f_cpu_x->size[1] = b_cpu_Fmat->size[1];
      emxEnsureCapacity_creal32_T(f_cpu_x, i, &gb_emlrtRTEI);
      n = b_cpu_Fmat->size[0] * b_cpu_Fmat->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(f_cpu_x, &f_gpu_x, true);
      subs_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel56<<<grid, block>>>(b_gpu_cfsDFT, b_gpu_Fmat, n, f_gpu_x);
      }

      interval_outdatedOnGpu = false;
      c_x_outdatedOnCpu = true;
    } else {
      if (c_x_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(f_cpu_x, &f_gpu_x);
      }

      gpuEmxMemcpyGpuToCpu_real_T(b_cpu_Fmat, &b_gpu_Fmat);
      gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT);
      binary_expand_op_5(f_cpu_x, b_cpu_Fmat, b_cpu_cfsDFT);
      c_x_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      subs_outdatedOnCpu = true;
    }

    if ((f_cpu_x->size[0] == 0) || (f_cpu_x->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(f_cpu_x->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(f_cpu_x->size[1]);
      i = m_cpu_y->size[0] * m_cpu_y->size[1];
      m_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
      m_cpu_y->size[1] = f_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(m_cpu_y, i, &hb_emlrtRTEI);
      n = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(m_cpu_y, &g_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel57<<<grid, block>>>(n, g_gpu_y);
      }
    } else {
      cufftHandle n_fftPlanHandle;
      ix = f_cpu_x->size[1];
      n_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, f_cpu_x->size[0], 1,
        CUFFT_C2C, f_cpu_x->size[0]);
      if (subs_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(f_cpu_x, &f_gpu_x,
          !interval_outdatedOnGpu);
      }

      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_creal32_T(&f_gpu_x, f_cpu_x);
      }

      cufftExecC2C(n_fftPlanHandle, (cufftComplex *)&f_gpu_x.data[0],
                   (cufftComplex *)&f_gpu_x.data[0], CUFFT_INVERSE);
      c_x_outdatedOnCpu = true;
      i = m_cpu_y->size[0] * m_cpu_y->size[1];
      m_cpu_y->size[0] = f_cpu_x->size[0];
      m_cpu_y->size[1] = f_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(m_cpu_y, i, &hb_emlrtRTEI);
      ec_wtcc_kernel1267<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
        (c_gpu_cfsposdft, f_cpu_x->size[1U]);
      n = f_cpu_x->size[0] * f_cpu_x->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(m_cpu_y, &g_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1268<<<grid, block>>>(c_gpu_cfsposdft, f_gpu_x, n, g_gpu_y);
      }
    }

    i = b_cpu_smooth->size[0] * b_cpu_smooth->size[1];
    b_cpu_smooth->size[0] = m_cpu_y->size[0];
    b_cpu_smooth->size[1] = m_cpu_y->size[1];
    emxEnsureCapacity_real32_T(b_cpu_smooth, i, &ib_emlrtRTEI);
    n = m_cpu_y->size[0] * m_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_smooth, &b_gpu_smooth, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel58<<<grid, block>>>(g_gpu_y, n, b_gpu_smooth);
    }

    ix = cpu_cfs2->size[1];
    a = 1.0 / halfh;
    if ((b_cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
      i = b_cpu_a->size[0];
      b_cpu_a->size[0] = cpu_cfs2->size[1];
      emxEnsureCapacity_real32_T(b_cpu_a, i, &jb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(b_cpu_a, &b_gpu_a, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel59<<<grid, block>>>(b_gpu_smooth, ix - 1, b_gpu_a,
          b_cpu_smooth->size[0U]);
      }

      i = b_cpu_c->size[0];
      b_cpu_c->size[0] = b_cpu_a->size[0];
      emxEnsureCapacity_real32_T(b_cpu_c, i, &lb_emlrtRTEI);
      n = b_cpu_a->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel60<<<grid, block>>>(n, b_gpu_c);
      }

      if (b_cpu_a->size[0] != 0) {
        if (b_cpu_a->size[0] == 1) {
          i = b_cpu_c->size[0];
          b_cpu_c->size[0] = 1;
          emxEnsureCapacity_real32_T(b_cpu_c, i, &lb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
          ec_wtcc_kernel61<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a, b_gpu_a,
            b_gpu_c);
        } else {
          bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
            (b_cpu_a->size[0])));
          b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(b_cpu_a->size[0]) + static_cast<uint32_T>
            (bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
          OH = b_cpu_a->size[0];
          if (b_cpu_a->size[0] > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = b_cpu_a->size[0] + 1;
          }

          i = d_cpu_expanded->size[0];
          d_cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_real32_T(d_cpu_expanded, i, &nb_emlrtRTEI);
          n = b_cpu_a->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(d_cpu_expanded, &ce_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1254<<<grid, block>>>(n, ce_gpu_expanded);
          }

          n = b_cpu_a->size[0];
          i = o_cpu_y->size[0] * o_cpu_y->size[1];
          o_cpu_y->size[0] = 1;
          o_cpu_y->size[1] = b_cpu_a->size[0];
          emxEnsureCapacity_int32_T(o_cpu_y, i, &ob_emlrtRTEI);
          o_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            o_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv13->size[0];
          cpu_iv13->size[0] = o_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv13, i, &nb_emlrtRTEI);
          n = o_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(o_cpu_y, &bh_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv13, &gpu_iv13, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&bh_gpu_y, o_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1255<<<grid, block>>>(bh_gpu_y, n, gpu_iv13);
          }

          omega_tmp2[0] = cpu_iv13->size[0];
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1256<<<grid, block>>>(b_gpu_a, gpu_iv13, omega_tmp2[0]
              - 1, ce_gpu_expanded);
          }

          i = b_cpu_c->size[0];
          b_cpu_c->size[0] = b_cpu_a->size[0];
          emxEnsureCapacity_real32_T(b_cpu_c, i, &nb_emlrtRTEI);
          mwApplyLaunchParameters(computeNumIters(OH - 1), dim3
            (static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
            (static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U), &grid,
            &block);
          gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1257<<<grid, block>>>(a, ce_gpu_expanded, OH - 1,
              b_gpu_c);
          }
        }
      }

      i = cpu_cfs2->size[0] * cpu_cfs2->size[1];
      cpu_cfs2->size[0] = 1;
      cpu_cfs2->size[1] = b_cpu_c->size[0];
      emxEnsureCapacity_real32_T(cpu_cfs2, i, &qb_emlrtRTEI);
      n = b_cpu_c->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel62<<<grid, block>>>(b_gpu_c, n, gpu_cfs2, cpu_cfs2->size
          [0U]);
      }
    } else {
      i = cpu_cfs2->size[0] * cpu_cfs2->size[1];
      cpu_cfs2->size[0] = b_cpu_smooth->size[0];
      cpu_cfs2->size[1] = ix;
      emxEnsureCapacity_real32_T(cpu_cfs2, i, &qb_emlrtRTEI);
      n = b_cpu_smooth->size[0] * ix - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1258<<<grid, block>>>(n, gpu_cfs2);
      }

      if ((b_cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
        if ((b_cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
          i = f_cpu_smooth->size[0];
          f_cpu_smooth->size[0] = 1;
          emxEnsureCapacity_real32_T(f_cpu_smooth, i, &mb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(f_cpu_smooth, &e_gpu_smooth, true);
          ec_wtcc_kernel1259<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a,
            b_gpu_smooth, e_gpu_smooth);
          i = cpu_cfs2->size[0] * cpu_cfs2->size[1];
          cpu_cfs2->size[0] = 1;
          cpu_cfs2->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_cfs2, i, &qb_emlrtRTEI);
          gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
          ec_wtcc_kernel1260<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
            (e_gpu_smooth, gpu_cfs2);
        } else {
          bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
            (b_cpu_smooth->size[0])));
          cpu_lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(ix)));
          blockDims[0] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(b_cpu_smooth->size[0]) + static_cast<uint32_T>
            (bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
          blockDims[1] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(ix) + static_cast<uint32_T>(cpu_lidx)) - 1.0) /
            static_cast<real_T>(cpu_lidx)));
          OH = b_cpu_smooth->size[0];
          if (static_cast<int32_T>(halfh) > MAX_int32_T - b_cpu_smooth->size[0])
          {
            i1Start = MAX_int32_T;
          } else {
            i1Start = b_cpu_smooth->size[0] + static_cast<int32_T>(halfh);
          }

          i = c_cpu_expanded->size[0] * c_cpu_expanded->size[1];
          c_cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_real32_T(c_cpu_expanded, i, &nb_emlrtRTEI);
          if (ix > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = ix + 1;
          }

          i = c_cpu_expanded->size[0] * c_cpu_expanded->size[1];
          c_cpu_expanded->size[1] = i1Start - 1;
          emxEnsureCapacity_real32_T(c_cpu_expanded, i, &nb_emlrtRTEI);
          n = ((b_cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) * ix -
            1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(c_cpu_expanded, &de_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1261<<<grid, block>>>(n, de_gpu_expanded);
          }

          n = b_cpu_smooth->size[0];
          i = n_cpu_y->size[0] * n_cpu_y->size[1];
          n_cpu_y->size[0] = 1;
          n_cpu_y->size[1] = b_cpu_smooth->size[0];
          emxEnsureCapacity_int32_T(n_cpu_y, i, &ob_emlrtRTEI);
          n_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            n_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv12->size[0];
          cpu_iv12->size[0] = n_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv12, i, &nb_emlrtRTEI);
          n = n_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(n_cpu_y, &ch_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv12, &gpu_iv12, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&ch_gpu_y, n_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1262<<<grid, block>>>(static_cast<int32_T>(std::floor
              ((halfh - 1.0) / 2.0)), ch_gpu_y, n, gpu_iv12);
          }

          i = p_cpu_y->size[0] * p_cpu_y->size[1];
          p_cpu_y->size[0] = 1;
          p_cpu_y->size[1] = ix;
          emxEnsureCapacity_int32_T(p_cpu_y, i, &ob_emlrtRTEI);
          p_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= ix - 2; itime++) {
            nsubs++;
            p_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv14->size[0];
          cpu_iv14->size[0] = p_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv14, i, &nb_emlrtRTEI);
          n = p_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(p_cpu_y, &dh_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv14, &gpu_iv14, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&dh_gpu_y, p_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1263<<<grid, block>>>(dh_gpu_y, n, gpu_iv14);
          }

          i = g_cpu_smooth->size[0] * g_cpu_smooth->size[1];
          g_cpu_smooth->size[0] = b_cpu_smooth->size[0];
          g_cpu_smooth->size[1] = ix;
          emxEnsureCapacity_real32_T(g_cpu_smooth, i, &pb_emlrtRTEI);
          n = b_cpu_smooth->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(ix - 1, n), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(g_cpu_smooth, &f_gpu_smooth, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1264<<<grid, block>>>(b_gpu_smooth, n, ix - 1,
              f_gpu_smooth, g_cpu_smooth->size[0U], b_cpu_smooth->size[0U]);
          }

          fx_size[0] = cpu_iv12->size[0];
          fx_size[1] = cpu_iv14->size[0];
          mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0] - 1),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1265<<<grid, block>>>(f_gpu_smooth, fx_size[0],
              gpu_iv14, gpu_iv12, fx_size[0] - 1, fx_size[1] - 1,
              de_gpu_expanded, c_cpu_expanded->size[0U]);
          }

          n = static_cast<int32_T>(halfh);
          i = b_cpu_rows->size[0] * b_cpu_rows->size[1];
          b_cpu_rows->size[0] = 1;
          b_cpu_rows->size[1] = static_cast<int32_T>(halfh);
          emxEnsureCapacity_int32_T(b_cpu_rows, i, &ob_emlrtRTEI);
          b_cpu_rows->data[0] = 0;
          nsubs = 0;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            b_cpu_rows->data[itime + 1] = nsubs;
          }

          i = cpu_cfs2->size[0] * cpu_cfs2->size[1];
          cpu_cfs2->size[0] = b_cpu_smooth->size[0];
          cpu_cfs2->size[1] = ix;
          emxEnsureCapacity_real32_T(cpu_cfs2, i, &nb_emlrtRTEI);
          mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
            (blockDims[0], blockDims[1], 1U), dim3(static_cast<uint32_T>(
            static_cast<int8_T>(bcoef)), static_cast<uint32_T>
            (static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
          gpuEmxEnsureCapacity_int32_T(b_cpu_rows, &od_gpu_rows, false);
          gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&od_gpu_rows, b_cpu_rows);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1266<<<grid, block>>>(a, de_gpu_expanded, od_gpu_rows,
              halfh, OH - 1, ix - 1, gpu_cfs2, c_cpu_expanded->size[0U],
              cpu_cfs2->size[0U]);
          }
        }
      }
    }

    if ((cpu_cfspos->size[0] == b_cpu_cfspos->size[0]) && (cpu_cfspos->size[1] ==
         b_cpu_cfspos->size[1])) {
      i = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
      cpu_crossCFS->size[0] = cpu_cfspos->size[0];
      cpu_crossCFS->size[1] = cpu_cfspos->size[1];
      emxEnsureCapacity_creal32_T(cpu_crossCFS, i, &rb_emlrtRTEI);
      n = cpu_cfspos->size[0] * cpu_cfspos->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel63<<<grid, block>>>(gpu_cfspos, b_gpu_cfspos, n,
          gpu_crossCFS);
      }

      subs_outdatedOnCpu = false;
    } else {
      if (crossCFS_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(cpu_crossCFS, &gpu_crossCFS);
      }

      if (x_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfspos, &gpu_cfspos);
      }

      if (y_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfspos, &b_gpu_cfspos);
      }

      binary_expand_op_6(cpu_crossCFS, cpu_cfspos, b_cpu_cfspos);
      subs_outdatedOnCpu = true;
      wav_outdatedOnCpu = true;
    }

    fa = std::frexp(static_cast<real_T>(cpu_crossCFS->size[1]), &j_eint);
    ix = j_eint;
    if (fa == 0.5) {
      ix = j_eint - 1;
    }

    r = rt_powd_snf(2.0, static_cast<real_T>(ix));
    ix = static_cast<int32_T>(std::trunc(r / 2.0));
    if (ix < 1) {
      d_cpu_omega_tmp1->size[0] = 1;
      d_cpu_omega_tmp1->size[1] = 0;
    } else {
      i = d_cpu_omega_tmp1->size[0] * d_cpu_omega_tmp1->size[1];
      d_cpu_omega_tmp1->size[0] = 1;
      d_cpu_omega_tmp1->size[1] = ix;
      emxEnsureCapacity_int32_T(d_cpu_omega_tmp1, i, &bb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_int32_T(d_cpu_omega_tmp1, &d_gpu_omega_tmp1, true);
      f_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1253<<<grid, block>>>(ix - 1, d_gpu_omega_tmp1);
      }
    }

    i = d_cpu_omega_tmp2->size[0] * d_cpu_omega_tmp2->size[1];
    d_cpu_omega_tmp2->size[0] = 1;
    d_cpu_omega_tmp2->size[1] = d_cpu_omega_tmp1->size[1];
    emxEnsureCapacity_real_T(d_cpu_omega_tmp2, i, &cb_emlrtRTEI);
    n = d_cpu_omega_tmp1->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (f_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_int32_T(d_cpu_omega_tmp1, &d_gpu_omega_tmp1, true);
    }

    f_omega_tmp1_needsGpuEnsureCapa = false;
    gpuEmxEnsureCapacity_real_T(d_cpu_omega_tmp2, &d_gpu_omega_tmp2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel64<<<grid, block>>>(6.2831853071795862 / r, d_gpu_omega_tmp1,
        n, d_gpu_omega_tmp2);
    }

    omega_tmp2_outdatedOnCpu = true;
    cpu_lidx = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
    if (cpu_lidx < 1) {
      ix = 1;
      bcoef = -1;
    } else {
      cpu_lidx--;
      ix = -1;
      bcoef = 0;
    }

    i = c_cpu_omega->size[0] * c_cpu_omega->size[1];
    c_cpu_omega->size[0] = 1;
    c_cpu_omega->size[1] = (d_cpu_omega_tmp2->size[1] + div_s32(bcoef - cpu_lidx,
      ix)) + 2;
    emxEnsureCapacity_real_T(c_cpu_omega, i, &db_emlrtRTEI);
    gpuEmxEnsureCapacity_real_T(c_cpu_omega, &c_gpu_omega, true);
    ec_wtcc_kernel65<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_omega);
    offsetH = d_cpu_omega_tmp2->size[1];
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    fb_Omega_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel66<<<grid, block>>>(d_gpu_omega_tmp2, offsetH - 1,
        c_gpu_omega);
    }

    fb_Omega_outdatedOnGpu = false;
    interval_outdatedOnGpu = true;
    offsetH = div_s32(bcoef - cpu_lidx, ix);
    for (i = 0; i <= offsetH; i++) {
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(c_cpu_omega, &c_gpu_omega);
      }

      if (omega_tmp2_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(d_cpu_omega_tmp2, &d_gpu_omega_tmp2);
      }

      omega_tmp2_outdatedOnCpu = false;
      c_cpu_omega->data[(i + d_cpu_omega_tmp2->size[1]) + 1] =
        -d_cpu_omega_tmp2->data[cpu_lidx + ix * i];
      interval_outdatedOnGpu = false;
      fb_Omega_outdatedOnGpu = true;
      fb_Omega_needsGpuEnsureCapacity = true;
    }

    if ((cpu_crossCFS->size[0] == 0) || (cpu_crossCFS->size[1] == 0) || (
         static_cast<int32_T>(r) == 0)) {
      i = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
      c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
      c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, i, &eb_emlrtRTEI);
      n = cpu_crossCFS->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel67<<<grid, block>>>(n, c_gpu_cfsDFT);
      }
    } else if (cpu_crossCFS->size[1] != static_cast<int32_T>(r)) {
      cufftHandle p_fftPlanHandle;
      if (cpu_crossCFS->size[1] < static_cast<int32_T>(r)) {
        i = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
        c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
        c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, i, &eb_emlrtRTEI);
        n = cpu_crossCFS->size[0] * static_cast<int32_T>(r) - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1250<<<grid, block>>>(n, c_gpu_cfsDFT);
        }
      } else {
        i = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
        c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
        c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
        emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, i, &v_emlrtRTEI);
        interval_outdatedOnGpu = true;
      }

      cpu_lidx = cpu_crossCFS->size[0];
      if (cpu_crossCFS->size[1] > static_cast<int32_T>(r)) {
        ix = static_cast<int32_T>(r);
      } else {
        ix = cpu_crossCFS->size[1];
      }

      mwGetLaunchParameters1D(computeNumIters(ix - 1, cpu_lidx - 1), &grid,
        &block, 2147483647U);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
          !subs_outdatedOnCpu);
      }

      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
      }

      if (subs_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1251<<<grid, block>>>(gpu_crossCFS, cpu_lidx - 1, ix - 1,
          c_gpu_cfsDFT, c_cpu_cfsDFT->size[0U], cpu_crossCFS->size[0U]);
      }

      ix = c_cpu_cfsDFT->size[1];
      p_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, c_cpu_cfsDFT->size[0], 1,
        CUFFT_C2C, c_cpu_cfsDFT->size[0]);
      cufftExecC2C(p_fftPlanHandle, (cufftComplex *)&c_gpu_cfsDFT.data[0],
                   (cufftComplex *)&c_gpu_cfsDFT.data[0], CUFFT_FORWARD);
    } else {
      cufftHandle o_fftPlanHandle;
      ix = cpu_crossCFS->size[1];
      o_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, cpu_crossCFS->size[0], 1,
        CUFFT_C2C, cpu_crossCFS->size[0]);
      if (wav_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
          !subs_outdatedOnCpu);
      }

      if (subs_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
      }

      cufftExecC2C(o_fftPlanHandle, (cufftComplex *)&gpu_crossCFS.data[0],
                   (cufftComplex *)&gpu_crossCFS.data[0], CUFFT_FORWARD);
      i = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
      c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
      c_cpu_cfsDFT->size[1] = cpu_crossCFS->size[1];
      emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, i, &eb_emlrtRTEI);
      n = cpu_crossCFS->size[0] * cpu_crossCFS->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1252<<<grid, block>>>(gpu_crossCFS, n, c_gpu_cfsDFT);
      }
    }

    i = c_cpu_Fmat->size[0] * c_cpu_Fmat->size[1];
    c_cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
    c_cpu_Fmat->size[1] = c_cpu_omega->size[1];
    emxEnsureCapacity_real_T(c_cpu_Fmat, i, &fb_emlrtRTEI);
    cpu_lidx = c_cpu_omega->size[1];
    n = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid, &block,
      2147483647U);
    if (fb_Omega_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(c_cpu_omega, &c_gpu_omega,
        !fb_Omega_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real_T(c_cpu_Fmat, &c_gpu_Fmat, true);
    if (fb_Omega_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&c_gpu_omega, c_cpu_omega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel68<<<grid, block>>>(gpu_fb_Scales, c_gpu_omega, n, cpu_lidx
        - 1, c_gpu_Fmat, c_cpu_Fmat->size[0U]);
    }

    if ((c_cpu_Fmat->size[0] == c_cpu_cfsDFT->size[0]) && (c_cpu_Fmat->size[1] ==
         c_cpu_cfsDFT->size[1])) {
      i = g_cpu_x->size[0] * g_cpu_x->size[1];
      g_cpu_x->size[0] = c_cpu_Fmat->size[0];
      g_cpu_x->size[1] = c_cpu_Fmat->size[1];
      emxEnsureCapacity_creal32_T(g_cpu_x, i, &sb_emlrtRTEI);
      n = c_cpu_Fmat->size[0] * c_cpu_Fmat->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(g_cpu_x, &g_gpu_x, true);
      subs_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel69<<<grid, block>>>(c_gpu_cfsDFT, c_gpu_Fmat, n, g_gpu_x);
      }

      interval_outdatedOnGpu = false;
      d_x_outdatedOnCpu = true;
    } else {
      if (d_x_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_creal32_T(g_cpu_x, &g_gpu_x);
      }

      gpuEmxMemcpyGpuToCpu_real_T(c_cpu_Fmat, &c_gpu_Fmat);
      gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT);
      binary_expand_op_5(g_cpu_x, c_cpu_Fmat, c_cpu_cfsDFT);
      d_x_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      subs_outdatedOnCpu = true;
    }

    if ((g_cpu_x->size[0] == 0) || (g_cpu_x->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(g_cpu_x->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(g_cpu_x->size[1]);
      i = c_cpu_smooth->size[0] * c_cpu_smooth->size[1];
      c_cpu_smooth->size[0] = static_cast<int32_T>(xSize[0]);
      c_cpu_smooth->size[1] = g_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(c_cpu_smooth, i, &tb_emlrtRTEI);
      n = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_smooth, &c_gpu_smooth, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel70<<<grid, block>>>(n, c_gpu_smooth);
      }
    } else {
      cufftHandle q_fftPlanHandle;
      ix = g_cpu_x->size[1];
      q_fftPlanHandle = acquireCUFFTPlan(1, &ix, &ix, g_cpu_x->size[0], 1,
        CUFFT_C2C, g_cpu_x->size[0]);
      if (subs_outdatedOnCpu) {
        gpuEmxEnsureCapacity_creal32_T(g_cpu_x, &g_gpu_x,
          !interval_outdatedOnGpu);
      }

      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_creal32_T(&g_gpu_x, g_cpu_x);
      }

      cufftExecC2C(q_fftPlanHandle, (cufftComplex *)&g_gpu_x.data[0],
                   (cufftComplex *)&g_gpu_x.data[0], CUFFT_INVERSE);
      d_x_outdatedOnCpu = true;
      i = c_cpu_smooth->size[0] * c_cpu_smooth->size[1];
      c_cpu_smooth->size[0] = g_cpu_x->size[0];
      c_cpu_smooth->size[1] = g_cpu_x->size[1];
      emxEnsureCapacity_creal32_T(c_cpu_smooth, i, &tb_emlrtRTEI);
      ec_wtcc_kernel1248<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
        (c_gpu_cfsposdft, g_cpu_x->size[1U]);
      n = g_cpu_x->size[0] * g_cpu_x->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_smooth, &c_gpu_smooth, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1249<<<grid, block>>>(c_gpu_cfsposdft, g_gpu_x, n,
          c_gpu_smooth);
      }
    }

    ix = cpu_crossCFS->size[1];
    a = 1.0 / halfh;
    if ((c_cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
      i = c_cpu_a->size[0];
      c_cpu_a->size[0] = cpu_crossCFS->size[1];
      emxEnsureCapacity_creal32_T(c_cpu_a, i, &jb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_a, &c_gpu_a, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel71<<<grid, block>>>(c_gpu_smooth, ix - 1, c_gpu_a,
          c_cpu_smooth->size[0U]);
      }

      i = c_cpu_c->size[0];
      c_cpu_c->size[0] = c_cpu_a->size[0];
      emxEnsureCapacity_creal32_T(c_cpu_c, i, &lb_emlrtRTEI);
      n = c_cpu_a->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel72<<<grid, block>>>(n, c_gpu_c);
      }

      if (c_cpu_a->size[0] != 0) {
        if (c_cpu_a->size[0] == 1) {
          i = c_cpu_c->size[0];
          c_cpu_c->size[0] = 1;
          emxEnsureCapacity_creal32_T(c_cpu_c, i, &lb_emlrtRTEI);
          ec_wtcc_kernel73<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_a, a,
            gpu_f, gpu_f1);
          gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
          ec_wtcc_kernel74<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
            gpu_f, c_gpu_c);
        } else {
          bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
            (c_cpu_a->size[0])));
          b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
            static_cast<uint32_T>(c_cpu_a->size[0]) + static_cast<uint32_T>
            (bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
          OH = c_cpu_a->size[0];
          if (c_cpu_a->size[0] > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = c_cpu_a->size[0] + 1;
          }

          i = f_cpu_expanded->size[0];
          f_cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_creal32_T(f_cpu_expanded, i, &nb_emlrtRTEI);
          n = c_cpu_a->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(f_cpu_expanded, &ae_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1236<<<grid, block>>>(n, ae_gpu_expanded);
          }

          n = c_cpu_a->size[0];
          i = t_cpu_y->size[0] * t_cpu_y->size[1];
          t_cpu_y->size[0] = 1;
          t_cpu_y->size[1] = c_cpu_a->size[0];
          emxEnsureCapacity_int32_T(t_cpu_y, i, &ob_emlrtRTEI);
          t_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            t_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv17->size[0];
          cpu_iv17->size[0] = t_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv17, i, &nb_emlrtRTEI);
          n = t_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(t_cpu_y, &xg_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv17, &gpu_iv17, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&xg_gpu_y, t_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1237<<<grid, block>>>(xg_gpu_y, n, gpu_iv17);
          }

          omega_tmp2[0] = cpu_iv17->size[0];
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1238<<<grid, block>>>(c_gpu_a, gpu_iv17, omega_tmp2[0]
              - 1, ae_gpu_expanded);
          }

          i = c_cpu_c->size[0];
          c_cpu_c->size[0] = c_cpu_a->size[0];
          emxEnsureCapacity_creal32_T(c_cpu_c, i, &nb_emlrtRTEI);
          mwApplyLaunchParameters(computeNumIters(OH - 1), dim3
            (static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
            (static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U), &grid,
            &block);
          gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1239<<<grid, block>>>(ae_gpu_expanded, a, OH - 1,
              c_gpu_c);
          }
        }
      }

      i = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
      cpu_crossCFS->size[0] = 1;
      cpu_crossCFS->size[1] = c_cpu_c->size[0];
      emxEnsureCapacity_creal32_T(cpu_crossCFS, i, &ub_emlrtRTEI);
      n = c_cpu_c->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel75<<<grid, block>>>(c_gpu_c, n, gpu_crossCFS,
          cpu_crossCFS->size[0U]);
      }

      subs_outdatedOnCpu = false;
      crossCFS_outdatedOnCpu = true;
    } else {
      i = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
      cpu_crossCFS->size[0] = c_cpu_smooth->size[0];
      cpu_crossCFS->size[1] = ix;
      emxEnsureCapacity_creal32_T(cpu_crossCFS, i, &ub_emlrtRTEI);
      n = c_cpu_smooth->size[0] * ix - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1240<<<grid, block>>>(n, gpu_crossCFS);
      }

      subs_outdatedOnCpu = false;
      crossCFS_outdatedOnCpu = true;
      if ((c_cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
        if ((c_cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
          i = smooth->size[0];
          smooth->size[0] = 1;
          emxEnsureCapacity_creal32_T(smooth, i, &mb_emlrtRTEI);
          gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_smooth, &c_gpu_smooth);
          smooth->data[0].re = c_cpu_smooth->data[0].re * static_cast<real32_T>
            (a) - c_cpu_smooth->data[0].im * 0.0F;
          smooth->data[0].im = c_cpu_smooth->data[0].re * 0.0F +
            c_cpu_smooth->data[0].im * static_cast<real32_T>(a);
          i = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
          cpu_crossCFS->size[0] = 1;
          cpu_crossCFS->size[1] = 1;
          emxEnsureCapacity_creal32_T(cpu_crossCFS, i, &ub_emlrtRTEI);
          cpu_crossCFS->data[0] = smooth->data[0];
          crossCFS_outdatedOnCpu = false;
          subs_outdatedOnCpu = true;
          wav_outdatedOnCpu = true;
        } else {
          OH = c_cpu_smooth->size[0];
          if (static_cast<int32_T>(halfh) > MAX_int32_T - c_cpu_smooth->size[0])
          {
            i1Start = MAX_int32_T;
          } else {
            i1Start = c_cpu_smooth->size[0] + static_cast<int32_T>(halfh);
          }

          i = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
          e_cpu_expanded->size[0] = i1Start - 1;
          emxEnsureCapacity_creal32_T(e_cpu_expanded, i, &nb_emlrtRTEI);
          if (ix > 2147483646) {
            i1Start = MAX_int32_T;
          } else {
            i1Start = ix + 1;
          }

          i = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
          e_cpu_expanded->size[1] = i1Start - 1;
          emxEnsureCapacity_creal32_T(e_cpu_expanded, i, &nb_emlrtRTEI);
          n = ((c_cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) * ix -
            1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(e_cpu_expanded, &be_gpu_expanded, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1241<<<grid, block>>>(n, be_gpu_expanded);
          }

          n = c_cpu_smooth->size[0];
          i = s_cpu_y->size[0] * s_cpu_y->size[1];
          s_cpu_y->size[0] = 1;
          s_cpu_y->size[1] = c_cpu_smooth->size[0];
          emxEnsureCapacity_int32_T(s_cpu_y, i, &ob_emlrtRTEI);
          s_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            s_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv16->size[0];
          cpu_iv16->size[0] = s_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv16, i, &nb_emlrtRTEI);
          n = s_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(s_cpu_y, &yg_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv16, &gpu_iv16, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&yg_gpu_y, s_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1242<<<grid, block>>>(static_cast<int32_T>(std::floor
              ((halfh - 1.0) / 2.0)), yg_gpu_y, n, gpu_iv16);
          }

          i = u_cpu_y->size[0] * u_cpu_y->size[1];
          u_cpu_y->size[0] = 1;
          u_cpu_y->size[1] = ix;
          emxEnsureCapacity_int32_T(u_cpu_y, i, &ob_emlrtRTEI);
          u_cpu_y->data[0] = 1;
          nsubs = 1;
          for (itime = 0; itime <= ix - 2; itime++) {
            nsubs++;
            u_cpu_y->data[itime + 1] = nsubs;
          }

          i = cpu_iv18->size[0];
          cpu_iv18->size[0] = u_cpu_y->size[1];
          emxEnsureCapacity_int32_T(cpu_iv18, i, &nb_emlrtRTEI);
          n = u_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(u_cpu_y, &ah_gpu_y, false);
          gpuEmxEnsureCapacity_int32_T(cpu_iv18, &gpu_iv18, true);
          gpuEmxMemcpyCpuToGpu_int32_T(&ah_gpu_y, u_cpu_y);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1243<<<grid, block>>>(ah_gpu_y, n, gpu_iv18);
          }

          i = h_cpu_smooth->size[0] * h_cpu_smooth->size[1];
          h_cpu_smooth->size[0] = c_cpu_smooth->size[0];
          h_cpu_smooth->size[1] = ix;
          emxEnsureCapacity_creal32_T(h_cpu_smooth, i, &pb_emlrtRTEI);
          n = c_cpu_smooth->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(ix - 1, n), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(h_cpu_smooth, &d_gpu_smooth, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1244<<<grid, block>>>(c_gpu_smooth, n, ix - 1,
              d_gpu_smooth, h_cpu_smooth->size[0U], c_cpu_smooth->size[0U]);
          }

          fx_size[0] = cpu_iv16->size[0];
          fx_size[1] = cpu_iv18->size[0];
          mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0] - 1),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1245<<<grid, block>>>(d_gpu_smooth, fx_size[0],
              gpu_iv18, gpu_iv16, fx_size[0] - 1, fx_size[1] - 1,
              be_gpu_expanded, e_cpu_expanded->size[0U]);
          }

          n = static_cast<int32_T>(halfh);
          i = c_cpu_rows->size[0] * c_cpu_rows->size[1];
          c_cpu_rows->size[0] = 1;
          c_cpu_rows->size[1] = static_cast<int32_T>(halfh);
          emxEnsureCapacity_int32_T(c_cpu_rows, i, &ob_emlrtRTEI);
          c_cpu_rows->data[0] = 0;
          y_outdatedOnCpu = true;
          fb_Omega_needsGpuEnsureCapacity = true;
          nsubs = 0;
          for (itime = 0; itime <= n - 2; itime++) {
            nsubs++;
            c_cpu_rows->data[itime + 1] = nsubs;
          }

          i = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
          cpu_crossCFS->size[0] = c_cpu_smooth->size[0];
          cpu_crossCFS->size[1] = ix;
          emxEnsureCapacity_creal32_T(cpu_crossCFS, i, &nb_emlrtRTEI);
          wav_outdatedOnCpu = true;
          cpu_lidx = static_cast<int32_T>(halfh);
          for (bcoef = 0; bcoef < ix; bcoef++) {
            for (nsubs = 0; nsubs < OH; nsubs++) {
              i = cpu_newIm->size[0];
              cpu_newIm->size[0] = c_cpu_rows->size[1];
              emxEnsureCapacity_creal32_T(cpu_newIm, i, &nb_emlrtRTEI);
              n = c_cpu_rows->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              if (fb_Omega_needsGpuEnsureCapacity) {
                gpuEmxEnsureCapacity_int32_T(c_cpu_rows, &nd_gpu_rows,
                  !y_outdatedOnCpu);
              }

              fb_Omega_needsGpuEnsureCapacity = false;
              gpuEmxEnsureCapacity_creal32_T(cpu_newIm, &w_gpu_newIm, true);
              if (y_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&nd_gpu_rows, c_cpu_rows);
              }

              y_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1246<<<grid, block>>>(bcoef, be_gpu_expanded,
                  nsubs, nd_gpu_rows, n, w_gpu_newIm, e_cpu_expanded->size[0U]);
              }

              fb_Omega_outdatedOnGpu = true;
              cpu_cv_re = 0.0F;
              cv_im = 0.0F;
              for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                if (fb_Omega_outdatedOnGpu) {
                  gpuEmxMemcpyGpuToCpu_creal32_T(cpu_newIm, &w_gpu_newIm);
                }

                cpu_cv_re += cpu_newIm->data[offsetH].re * static_cast<real32_T>
                  (a);
                fb_Omega_outdatedOnGpu = false;
                cv_im += cpu_newIm->data[offsetH].im * static_cast<real32_T>(a);
              }

              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
              }

              wav_outdatedOnCpu = false;
              ec_wtcc_kernel1247<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cv_im,
                cpu_cv_re, bcoef, nsubs, gpu_crossCFS, cpu_crossCFS->size[0U]);
            }
          }
        }
      }
    }

    offsetH = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_crossCFS->size[itime]);
    }

    i = q_cpu_y->size[0] * q_cpu_y->size[1];
    q_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    q_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(q_cpu_y, i, &r_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
        !subs_outdatedOnCpu);
    }

    gpuEmxEnsureCapacity_real32_T(q_cpu_y, &h_gpu_y, true);
    if (subs_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel76<<<grid, block>>>(gpu_crossCFS, offsetH - 1, h_gpu_y);
    }

    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(q_cpu_y->size[itime]);
    }

    i = r_cpu_y->size[0] * r_cpu_y->size[1];
    r_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    r_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(r_cpu_y, i, &i_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(r_cpu_y, &i_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel77<<<grid, block>>>(h_gpu_y, static_cast<int32_T>(xSize[0]) *
        static_cast<int32_T>(xSize[1]) - 1, i_gpu_y);
    }

    if (cpu_cfs1->size[0] == 1) {
      itime = cpu_cfs2->size[0];
    } else {
      itime = cpu_cfs1->size[0];
    }

    if (cpu_cfs1->size[1] == 1) {
      n = cpu_cfs2->size[1];
    } else {
      n = cpu_cfs1->size[1];
    }

    if ((cpu_cfs1->size[0] == cpu_cfs2->size[0]) && (cpu_cfs1->size[1] ==
         cpu_cfs2->size[1]) && (r_cpu_y->size[0] == itime) && (r_cpu_y->size[1] ==
         n)) {
      i = cpu_wtc->size[0] * cpu_wtc->size[1];
      cpu_wtc->size[0] = r_cpu_y->size[0];
      cpu_wtc->size[1] = r_cpu_y->size[1];
      emxEnsureCapacity_real32_T(cpu_wtc, i, &vb_emlrtRTEI);
      n = r_cpu_y->size[0] * r_cpu_y->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_wtc, &gpu_wtc, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel78<<<grid, block>>>(gpu_cfs2, gpu_cfs1, i_gpu_y, n,
          gpu_wtc);
      }

      wav_outdatedOnCpu = false;
    } else {
      if (wtc_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real32_T(cpu_wtc, &gpu_wtc);
      }

      gpuEmxMemcpyGpuToCpu_real32_T(r_cpu_y, &i_gpu_y);
      gpuEmxMemcpyGpuToCpu_real32_T(cpu_cfs1, &gpu_cfs1);
      gpuEmxMemcpyGpuToCpu_real32_T(cpu_cfs2, &gpu_cfs2);
      binary_expand_op_4(cpu_wtc, r_cpu_y, cpu_cfs1, cpu_cfs2);
      wav_outdatedOnCpu = true;
      interval_outdatedOnGpu = true;
    }

    cpu_lidx = cpu_wtc->size[0] * cpu_wtc->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
      2147483647U);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_real32_T(cpu_wtc, &gpu_wtc, !wav_outdatedOnCpu);
    }

    if (wav_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real32_T(&gpu_wtc, cpu_wtc);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel79<<<grid, block>>>(cpu_lidx, gpu_wtc);
    }

    wtc_outdatedOnCpu = true;

    //  Downsample
    // 'ec_wtcc:36' x = resample(x,ds(1),ds(2),Dimension=2);
    if ((cpu_wtc->size[0] == 1) || (cpu_wtc->size[1] == 1)) {
      fb_SignalPad = 1;
    } else {
      fb_SignalPad = 2;
    }

    opts_isRowVectorInput = (cpu_wtc->size[0] == 1);
    if (fb_SignalPad == 1) {
      if ((cpu_wtc->size[0] == 1) || (cpu_wtc->size[1] == 1)) {
        if ((cpu_wtc->size[0] == 0) || (cpu_wtc->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = cpu_wtc->size[0];
          ix = cpu_wtc->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = ix;
        cpu_opts_x->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_opts_x, i, &wb_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
        opts_x_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel80<<<grid, block>>>(gpu_wtc, ix - 1, gpu_opts_x);
        }

        opts_x_outdatedOnCpu = true;
      } else {
        i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = cpu_wtc->size[0];
        cpu_opts_x->size[1] = cpu_wtc->size[1];
        emxEnsureCapacity_real32_T(cpu_opts_x, i, &wb_emlrtRTEI);
        n = cpu_wtc->size[0] * cpu_wtc->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
        opts_x_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1234<<<grid, block>>>(gpu_wtc, n, gpu_opts_x);
        }

        opts_x_outdatedOnCpu = true;
      }
    } else {
      i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = cpu_wtc->size[1];
      cpu_opts_x->size[1] = cpu_wtc->size[0];
      emxEnsureCapacity_real32_T(cpu_opts_x, i, &wb_emlrtRTEI);
      n = cpu_wtc->size[0] - 1;
      itime = cpu_wtc->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n, itime), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
      opts_x_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1235<<<grid, block>>>(gpu_wtc, itime, n, gpu_opts_x,
          cpu_opts_x->size[0U], cpu_wtc->size[0U]);
      }

      opts_x_outdatedOnCpu = true;
    }

    s = static_cast<real_T>(ds[0]) / ds[1];
    b_p = s;
    r = std::abs(s);
    if (std::isinf(r) || std::isnan(r)) {
      b_r = rtNaN;
    } else if (r < 4.4501477170144028E-308) {
      b_r = 4.94065645841247E-324;
    } else {
      std::frexp(r, &exponent);
      b_r = std::ldexp(1.0, exponent - 53);
    }

    fb = std::fmax(1.0E-12, b_r);
    if (std::isinf(s) || std::isnan(s)) {
      if (!std::isnan(s)) {
        if (s < 0.0) {
          toler = -1.0;
        } else {
          toler = 1.0;
        }
      } else {
        toler = 0.0;
      }

      b_m = 0.0;
    } else {
      r = 1.0;
      d = 0.0;
      fa = 0.0;
      halfh = 1.0;
      do {
        exitg2 = 0;
        tol = std::round(s);
        if (!std::isinf(s)) {
          s -= tol;
          T = fa;
          fa = r;
          r = r * tol + T;
          T = halfh;
          halfh = d;
          d = d * tol + T;
        } else {
          fa = r;
          halfh = d;
          r = s;
          d = 0.0;
        }

        if ((s == 0.0) || (std::abs(r / d - b_p) <= fb)) {
          exitg2 = 1;
        } else {
          s = 1.0 / s;
        }
      } while (exitg2 == 0);

      if (std::isnan(d)) {
        halfh = rtNaN;
      } else if (d < 0.0) {
        halfh = -1.0;
      } else {
        halfh = (d > 0.0);
      }

      toler = r / halfh;
      b_m = std::abs(d);
    }

    fa = std::fmax(toler, b_m);
    fc = 0.5 / fa;
    fb = 20.0 * fa + 1.0;
    varargin_2[0] = 0.0;
    varargin_2[1] = 2.0 * fc;
    varargin_2[2] = 2.0 * fc;
    varargin_2[3] = 1.0;
    r = 0.0;
    fa = 0.0;
    Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] > 0.0));
    if (Nodd) {
      r = varargin_2[1];
    }

    Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] < 0.0));
    if (Nodd) {
      fa = varargin_2[1];
    }

    Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(r) || (r < varargin_2[2])));
    if (Nodd) {
      r = varargin_2[2];
    }

    Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(fa) || (fa > varargin_2
              [2])));
    if (Nodd) {
      fa = varargin_2[2];
    }

    Nodd = (std::isnan(r) || (r < 1.0));
    if (Nodd) {
      r = 1.0;
    }

    Nodd = (std::isnan(fa) || (fa > 1.0));
    if (Nodd) {
      fa = 1.0;
    }

    if ((!(r > 1.0)) && (!(fa < 0.0))) {
      for (itime = 0; itime < 4; itime++) {
        F[itime] = varargin_2[itime] / 2.0;
      }

      halfh = (((fb - 1.0) + 1.0) - 1.0) / 2.0;
      Nodd = (rt_remd_snf((fb - 1.0) + 1.0, 2.0) == 1.0);
      T = 0.0;
      if (!Nodd) {
        i = cpu_m->size[0] * cpu_m->size[1];
        cpu_m->size[0] = 1;
        cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
        emxEnsureCapacity_real_T(cpu_m, i, &bc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel81<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
        }
      } else {
        i = cpu_m->size[0] * cpu_m->size[1];
        cpu_m->size[0] = 1;
        cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
        emxEnsureCapacity_real_T(cpu_m, i, &ac_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1233<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
        }
      }

      i = cpu_k->size[0];
      cpu_k->size[0] = cpu_m->size[1];
      emxEnsureCapacity_real_T(cpu_k, i, &dc_emlrtRTEI);
      n = cpu_m->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel82<<<grid, block>>>(gpu_m, n, gpu_k);
      }

      wav_outdatedOnCpu = false;
      fb_Omega_outdatedOnGpu = true;
      first_iteration = (F[2] - F[1] != 0.0);
      bcoef = cpu_k->size[0];
      if (first_iteration) {
        i = cpu_G->size[0] * cpu_G->size[1];
        cpu_G->size[0] = cpu_k->size[0];
        cpu_G->size[1] = cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_G, i, &ec_emlrtRTEI);
        itime = cpu_k->size[0] * cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
        G_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel83<<<grid, block>>>(itime, gpu_G);
        }

        G_outdatedOnCpu = true;
        b_p = 2.0 * static_cast<real_T>(cpu_k->size[0]) - 1.0;
      } else {
        G_outdatedOnCpu = false;
        cpu_G->size[0] = 0;
        cpu_G->size[1] = 0;
        b_p = 0.0;
      }

      i = cpu_sinc1A->size[0] * cpu_sinc1A->size[1];
      cpu_sinc1A->size[0] = 1;
      cpu_sinc1A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(cpu_sinc1A, i, &fc_emlrtRTEI);
      subs_outdatedOnCpu = true;
      i = cpu_sinc2A->size[0] * cpu_sinc2A->size[1];
      cpu_sinc2A->size[0] = 1;
      cpu_sinc2A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(cpu_sinc2A, i, &gc_emlrtRTEI);
      fb_Omega_outdatedOnCpu = true;
      i = cpu_sinc3A->size[0] * cpu_sinc3A->size[1];
      cpu_sinc3A->size[0] = 1;
      cpu_sinc3A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(cpu_sinc3A, i, &hc_emlrtRTEI);
      y_outdatedOnCpu = true;
      i = cpu_sinc4A->size[0] * cpu_sinc4A->size[1];
      cpu_sinc4A->size[0] = 1;
      cpu_sinc4A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(cpu_sinc4A, i, &jc_emlrtRTEI);
      omega_tmp2_outdatedOnCpu = true;
      if (Nodd) {
        i1Start = -1;
        if (cpu_k->size[0] < 2) {
          cpu_lidx = 0;
          ix = 0;
        } else {
          cpu_lidx = 1;
          ix = cpu_k->size[0];
        }

        offsetH = ix - cpu_lidx;
        for (i = 0; i < offsetH; i++) {
          if (fb_Omega_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
          }

          cpu_k->data[i] = cpu_k->data[cpu_lidx + i];
          fb_Omega_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
        }

        i = cpu_k->size[0];
        cpu_k->size[0] = ix - cpu_lidx;
        emxEnsureCapacity_real_T(cpu_k, i, &mc_emlrtRTEI);
        interval_outdatedOnGpu = true;
      } else {
        i1Start = 0;
      }

      i = cpu_b->size[0];
      cpu_b->size[0] = cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_b, i, &kc_emlrtRTEI);
      itime = cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
      x_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel84<<<grid, block>>>(itime, gpu_b);
      }

      c_fb_Scales_needsGpuEnsureCapac = false;
      fb_Omega_needsGpuEnsureCapacity = true;
      for (nsubs = 0; nsubs < 2; nsubs++) {
        ix = nsubs << 1;
        n_idx_0 = A[ix];
        tol = F[ix + 1];
        s = F[ix];
        r = static_cast<real_T>(A[ix + 1] - n_idx_0) / (tol - s);
        fa = static_cast<real_T>(n_idx_0) - r * s;
        if (Nodd) {
          T += fa * (tol - s) + r / 2.0 * (tol * tol - s * s);
        }

        i = cpu_dv25->size[0];
        cpu_dv25->size[0] = cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_dv25, i, &qc_emlrtRTEI);
        itime = cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, !wav_outdatedOnCpu);
        }

        gpuEmxEnsureCapacity_real_T(cpu_dv25, &gpu_dv25, true);
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_k, cpu_k);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel85<<<grid, block>>>(tol, gpu_k, itime, gpu_dv25);
        }

        offsetH = cpu_dv25->size[0];
        i = cpu_dv26->size[0];
        cpu_dv26->size[0] = cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_dv26, i, &qc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_dv26, &gpu_dv26, true);
        wav_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel86<<<grid, block>>>(F[ix], gpu_k, offsetH - 1, gpu_dv26,
            gpu_dv25);
        }

        offsetH = cpu_dv26->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel87<<<grid, block>>>(offsetH - 1, gpu_dv26);
        }

        a = r / 39.478417604357432;
        if (cpu_dv25->size[0] == 1) {
          itime = cpu_k->size[0];
        } else {
          itime = cpu_dv25->size[0];
        }

        if ((cpu_dv25->size[0] == cpu_k->size[0]) && (cpu_b->size[0] == itime))
        {
          n = cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          interval_outdatedOnGpu = false;
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          x_outdatedOnCpu = false;
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel88<<<grid, block>>>(gpu_k, gpu_dv26, gpu_dv25, a, n,
              gpu_b);
          }

          c_fb_Scales_needsGpuEnsureCapac = false;
          fb_Omega_needsGpuEnsureCapacity = true;
        } else {
          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
          }

          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv25, &gpu_dv25);
          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv26, &gpu_dv26);
          if (fb_Omega_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
          }

          fb_Omega_outdatedOnGpu = false;
          binary_expand_op_1(cpu_b, a, cpu_dv25, cpu_dv26, cpu_k);
          fb_Omega_needsGpuEnsureCapacity = false;
          c_fb_Scales_needsGpuEnsureCapac = true;
          interval_outdatedOnGpu = true;
          x_outdatedOnCpu = true;
        }

        i = w_cpu_y->size[0];
        w_cpu_y->size[0] = cpu_k->size[0];
        emxEnsureCapacity_real_T(w_cpu_y, i, &qc_emlrtRTEI);
        itime = cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
        }

        gpuEmxEnsureCapacity_real_T(w_cpu_y, &j_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel89<<<grid, block>>>(F[ix + 1], gpu_k, itime, j_gpu_y);
        }

        cpu_lidx = w_cpu_y->size[0];
        s = F[ix + 1];
        a = s * (r * s + fa);
        i = x_cpu_y->size[0];
        x_cpu_y->size[0] = cpu_k->size[0];
        emxEnsureCapacity_real_T(x_cpu_y, i, &qc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        interval_outdatedOnGpu = false;
        gpuEmxEnsureCapacity_real_T(x_cpu_y, &k_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel90<<<grid, block>>>(F[ix], gpu_k, cpu_lidx - 1, k_gpu_y,
            j_gpu_y);
        }

        cpu_lidx = x_cpu_y->size[0];
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel91<<<grid, block>>>(cpu_lidx - 1, k_gpu_y);
        }

        s = F[ix];
        c_a = s * (r * s + fa);
        if (cpu_b->size[0] == w_cpu_y->size[0]) {
          n = cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          x_outdatedOnCpu = false;
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel92<<<grid, block>>>(k_gpu_y, c_a, j_gpu_y, a, n, gpu_b);
          }

          c_fb_Scales_needsGpuEnsureCapac = false;
          fb_Omega_needsGpuEnsureCapacity = true;
        } else {
          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
          }

          gpuEmxMemcpyGpuToCpu_real_T(w_cpu_y, &j_gpu_y);
          gpuEmxMemcpyGpuToCpu_real_T(x_cpu_y, &k_gpu_y);
          binary_expand_op(cpu_b, a, w_cpu_y, c_a, x_cpu_y);
          fb_Omega_needsGpuEnsureCapacity = false;
          c_fb_Scales_needsGpuEnsureCapac = true;
          x_outdatedOnCpu = true;
        }

        if (first_iteration) {
          r = 2.0 * F[ix + 1];
          fa = 2.0 * F[ix];
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(b_p) - 1),
            &grid, &block, 2147483647U);
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_sinc4A, &gpu_sinc4A, true);
          }

          if (y_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_sinc3A, &gpu_sinc3A, true);
          }

          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_sinc2A, &gpu_sinc2A, true);
          }

          if (subs_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_sinc1A, &gpu_sinc1A, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel93<<<grid, block>>>(fa, r, bcoef, i1Start,
              static_cast<int32_T>(b_p) - 1, gpu_sinc4A, gpu_sinc3A, gpu_sinc2A,
              gpu_sinc1A);
          }

          mwGetLaunchParameters1D(computeNumIters(bcoef - 1, bcoef - 1), &grid,
            &block, 2147483647U);
          omega_tmp2_outdatedOnCpu = false;
          fb_Omega_outdatedOnCpu = false;
          y_outdatedOnCpu = false;
          subs_outdatedOnCpu = false;
          if (G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
          }

          G_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel94<<<grid, block>>>(gpu_sinc4A, gpu_sinc2A, fa,
              gpu_sinc3A, gpu_sinc1A, r, bcoef, bcoef - 1, bcoef - 1, gpu_G,
              cpu_G->size[0U]);
          }

          G_outdatedOnCpu = true;
        }
      }

      if (Nodd) {
        i = cpu_b0->size[0];
        cpu_b0->size[0] = cpu_b->size[0] + 1;
        emxEnsureCapacity_real_T(cpu_b0, i, &nc_emlrtRTEI);
        gpuEmxEnsureCapacity_real_T(cpu_b0, &gpu_b0, true);
        ec_wtcc_kernel95<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(T, gpu_b0);
        offsetH = cpu_b->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        if (x_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !c_fb_Scales_needsGpuEnsureCapac);
        }

        if (c_fb_Scales_needsGpuEnsureCapac) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel96<<<grid, block>>>(gpu_b, offsetH - 1, gpu_b0);
        }

        i = cpu_b->size[0];
        cpu_b->size[0] = cpu_b0->size[0];
        emxEnsureCapacity_real_T(cpu_b, i, &tc_emlrtRTEI);
        n = cpu_b0->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
        x_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel97<<<grid, block>>>(gpu_b0, n, gpu_b);
        }

        c_fb_Scales_needsGpuEnsureCapac = false;
      }

      if (first_iteration) {
        if ((cpu_G->size[0] == 0) || (cpu_G->size[1] == 0) || (cpu_b->size[0] ==
             0)) {
          i = d_cpu_a->size[0];
          d_cpu_a->size[0] = cpu_G->size[1];
          emxEnsureCapacity_real_T(d_cpu_a, i, &pc_emlrtRTEI);
          n = cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
          subs_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel98<<<grid, block>>>(n, d_gpu_a);
          }

          interval_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
        } else if (cpu_G->size[0] == cpu_G->size[1]) {
          i = d_cpu_a->size[0];
          d_cpu_a->size[0] = cpu_b->size[0];
          emxEnsureCapacity_real_T(d_cpu_a, i, &pc_emlrtRTEI);
          n = cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1221<<<grid, block>>>(gpu_b, n, d_gpu_a);
          }

          i1Start = cpu_G->size[0];
          ix = cpu_G->size[1];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          i1Start = d_cpu_a->size[0];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          i = cpu_IPIV->size[0];
          cpu_IPIV->size[0] = ix;
          emxEnsureCapacity_int32_T(cpu_IPIV, i, &wc_emlrtRTEI);
          if (G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
          }

          cusolverCheck(cusolverDnDgetrf_bufferSize(getCuSolverGlobalHandle(),
            ix, ix, (double *)&gpu_G.data[0], cpu_G->size[0],
            getCuSolverWorkspaceReq()), __FILE__, __LINE__);
          setCuSolverWorkspaceTypeSize(8);
          cusolverInitWorkspace();
          G_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_int32_T(cpu_IPIV, &b_gpu_IPIV, true);
          cusolverCheck(cusolverDnDgetrf(getCuSolverGlobalHandle(), ix, ix,
            (double *)&gpu_G.data[0], cpu_G->size[0], static_cast<real_T *>
            (getCuSolverWorkspaceBuff()), &b_gpu_IPIV.data[0], gpu_lidx),
                        __FILE__, __LINE__);
          checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          if (cpu_lidx < 0) {
            omega_tmp2[0] = d_cpu_a->size[0];
            i = d_cpu_a->size[0];
            d_cpu_a->size[0] = omega_tmp2[0];
            emxEnsureCapacity_real_T(d_cpu_a, i, &fd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
            subs_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1222<<<grid, block>>>(omega_tmp2[0] - 1, d_gpu_a);
            }

            interval_outdatedOnGpu = false;
            wav_outdatedOnCpu = true;
          } else {
            subs_outdatedOnCpu = false;
            cusolverCheck(cusolverDnDgetrs(getCuSolverGlobalHandle(),
              CUBLAS_OP_N, ix, 1, (double *)&gpu_G.data[0], cpu_G->size[0],
              &b_gpu_IPIV.data[0], (double *)&d_gpu_a.data[0], d_cpu_a->size[0],
              gpu_lidx), __FILE__, __LINE__);
            interval_outdatedOnGpu = false;
            wav_outdatedOnCpu = true;
          }
        } else {
          ptrdiff_t info_t;
          offsetH = cpu_G->size[0];
          nsubs = cpu_G->size[1] - 1;
          i = cpu_jpvt->size[0] * cpu_jpvt->size[1];
          cpu_jpvt->size[0] = 1;
          cpu_jpvt->size[1] = cpu_G->size[1];
          emxEnsureCapacity_int32_T(cpu_jpvt, i, &vc_emlrtRTEI);
          n = cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &b_gpu_jpvt, true);
          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1223<<<grid, block>>>(n, b_gpu_jpvt);
          }

          fb_Omega_outdatedOnCpu = false;
          y_outdatedOnCpu = true;
          i1Start = cpu_G->size[0];
          cpu_lidx = cpu_G->size[1];
          if (i1Start <= cpu_lidx) {
            cpu_lidx = i1Start;
          }

          i = cpu_tau->size[0];
          cpu_tau->size[0] = cpu_lidx;
          emxEnsureCapacity_real_T(cpu_tau, i, &bd_emlrtRTEI);
          i = jpvt_t->size[0];
          jpvt_t->size[0] = cpu_G->size[1];
          emxEnsureCapacity_ptrdiff_t(jpvt_t, i, &dd_emlrtRTEI);
          for (i = 0; i < cpu_G->size[1]; i++) {
            jpvt_t->data[i] = (ptrdiff_t)0;
          }

          if (G_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
          }

          info_t = LAPACKE_dgeqp3(102, (ptrdiff_t)cpu_G->size[0], (ptrdiff_t)
            cpu_G->size[1], &cpu_G->data[0], (ptrdiff_t)cpu_G->size[0],
            &jpvt_t->data[0], &cpu_tau->data[0]);
          wav_outdatedOnCpu = true;
          G_outdatedOnCpu = false;
          fb_Omega_needsGpuEnsureCapacity = true;
          fb_Omega_outdatedOnGpu = true;
          G_needsGpuEnsureCapacity = true;
          if ((int32_T)info_t != 0) {
            mwGetLaunchParameters1D(computeNumIters(nsubs, offsetH - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, false);
            G_needsGpuEnsureCapacity = false;
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1224<<<grid, block>>>(offsetH - 1, nsubs, gpu_G,
                cpu_G->size[0U]);
            }

            fb_Omega_needsGpuEnsureCapacity = false;
            G_outdatedOnCpu = true;
            i1Start = cpu_G->size[0];
            ix = cpu_G->size[1];
            if (i1Start <= ix) {
              ix = i1Start;
            }

            mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_tau, &b_gpu_tau, false);
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_tau, cpu_tau);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1225<<<grid, block>>>(ix - 1, b_gpu_tau);
            }

            f = computeEndIdx(static_cast<int64_T>(ix + 1), static_cast<int64_T>
                              (cpu_lidx), 1L);
            mwGetLaunchParameters1D(computeNumIters(f), &grid, &block,
              2147483647U);
            fb_Omega_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1226<<<grid, block>>>(ix + 1, f, b_gpu_tau);
            }

            wav_outdatedOnCpu = false;
            mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
              2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1227<<<grid, block>>>(nsubs, b_gpu_jpvt);
            }
          } else {
            for (itime = 0; itime <= nsubs; itime++) {
              if (y_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &b_gpu_jpvt);
              }

              cpu_jpvt->data[itime] = (int32_T)jpvt_t->data[itime];
              y_outdatedOnCpu = false;
              fb_Omega_outdatedOnCpu = true;
              interval_outdatedOnGpu = true;
            }
          }

          nsubs = -1;
          if (cpu_G->size[0] < cpu_G->size[1]) {
            ix = cpu_G->size[0];
            cpu_lidx = cpu_G->size[1];
          } else {
            ix = cpu_G->size[1];
            cpu_lidx = cpu_G->size[0];
          }

          exitg1 = false;
          while ((!exitg1) && (nsubs + 1 < ix)) {
            if (G_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
            }

            G_outdatedOnCpu = false;
            if (!(std::abs(cpu_G->data[(nsubs + cpu_G->size[0] * (nsubs + 1)) +
                           1]) <= std::fmin(1.4901161193847656E-8,
                  2.2204460492503131E-15 * static_cast<real_T>(cpu_lidx)) * std::
                  abs(cpu_G->data[0]))) {
              G_needsGpuEnsureCapacity = true;
              nsubs++;
            } else {
              G_needsGpuEnsureCapacity = true;
              exitg1 = true;
            }
          }

          i = d_cpu_a->size[0];
          d_cpu_a->size[0] = cpu_G->size[1];
          emxEnsureCapacity_real_T(d_cpu_a, i, &pc_emlrtRTEI);
          n = cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1228<<<grid, block>>>(n, d_gpu_a);
          }

          cpu_lidx = 0;
          i1Start = cpu_G->size[0];
          ix = cpu_G->size[1];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          if (G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G,
              !fb_Omega_needsGpuEnsureCapacity);
          }

          if (fb_Omega_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_tau, &b_gpu_tau, !wav_outdatedOnCpu);
          }

          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_tau, cpu_tau);
          }

          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          cusolverCheck(cusolverDnDormqr_bufferSize(getCuSolverGlobalHandle(),
            CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, ix, (double *)
            &gpu_G.data[0], cpu_G->size[0], (double *)&b_gpu_tau.data[0],
            (double *)&gpu_b.data[0], cpu_b->size[0], getCuSolverWorkspaceReq()),
                        __FILE__, __LINE__);
          setCuSolverWorkspaceTypeSize(8);
          cusolverInitWorkspace();
          G_needsGpuEnsureCapacity = false;
          checkCudaError(cudaMemcpy(gpu_lidx, &cpu_lidx, 4UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
          cusolverCheck(cusolverDnDormqr(getCuSolverGlobalHandle(),
            CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, ix, (double *)
            &gpu_G.data[0], cpu_G->size[0], (double *)&b_gpu_tau.data[0],
            (double *)&gpu_b.data[0], cpu_b->size[0], static_cast<real_T *>
            (getCuSolverWorkspaceBuff()), *getCuSolverWorkspaceReq(), gpu_lidx),
                        __FILE__, __LINE__);
          checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          if (cpu_lidx < 0) {
            omega_tmp2[0] = cpu_b->size[0];
            i = cpu_b->size[0];
            cpu_b->size[0] = omega_tmp2[0];
            emxEnsureCapacity_real_T(cpu_b, i, &jd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1229<<<grid, block>>>(omega_tmp2[0] - 1, gpu_b);
            }
          }

          mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &b_gpu_jpvt,
              !fb_Omega_outdatedOnCpu);
          }

          subs_outdatedOnCpu = false;
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_jpvt, cpu_jpvt);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1230<<<grid, block>>>(gpu_b, b_gpu_jpvt, nsubs,
              d_gpu_a);
          }

          interval_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
          for (bcoef = 0; bcoef <= nsubs; bcoef++) {
            if (wav_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(d_cpu_a, &d_gpu_a);
            }

            if (y_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &b_gpu_jpvt);
            }

            y_outdatedOnCpu = false;
            if (G_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
            }

            G_outdatedOnCpu = false;
            d_cpu_a->data[cpu_jpvt->data[nsubs - bcoef] - 1] /= cpu_G->data
              [(nsubs - bcoef) + cpu_G->size[0] * (nsubs - bcoef)];
            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = true;
            G_needsGpuEnsureCapacity = true;
            subs_outdatedOnCpu = true;
            cpu_lidx = nsubs - bcoef;
            for (ix = 0; ix < cpu_lidx; ix++) {
              d_cpu_a->data[cpu_jpvt->data[ix] - 1] -= d_cpu_a->data
                [cpu_jpvt->data[nsubs - bcoef] - 1] * cpu_G->data[ix +
                cpu_G->size[0] * (nsubs - bcoef)];
            }
          }
        }
      } else {
        i = d_cpu_a->size[0];
        d_cpu_a->size[0] = cpu_b->size[0];
        emxEnsureCapacity_real_T(d_cpu_a, i, &oc_emlrtRTEI);
        n = cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (x_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !c_fb_Scales_needsGpuEnsureCapac);
        }

        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
        subs_outdatedOnCpu = false;
        if (c_fb_Scales_needsGpuEnsureCapac) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1231<<<grid, block>>>(gpu_b, n, d_gpu_a);
        }

        interval_outdatedOnGpu = false;
        wav_outdatedOnCpu = true;
        if (Nodd) {
          ec_wtcc_kernel1232<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_a);
        }
      }

      if (Nodd) {
        if (halfh + 1.0 < 2.0) {
          cpu_lidx = 0;
          ix = 1;
          bcoef = -1;
          nsubs = 0;
          i1Start = 0;
        } else {
          cpu_lidx = static_cast<int32_T>(halfh + 1.0) - 1;
          ix = -1;
          bcoef = 1;
          nsubs = 1;
          i1Start = static_cast<int32_T>(halfh + 1.0);
        }

        i = cpu_h->size[0] * cpu_h->size[1];
        cpu_h->size[0] = 1;
        cpu_h->size[1] = ((div_s32(bcoef - cpu_lidx, ix) + i1Start) - nsubs) + 2;
        emxEnsureCapacity_real_T(cpu_h, i, &gd_emlrtRTEI);
        offsetH = div_s32(bcoef - cpu_lidx, ix);
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&d_gpu_a, d_cpu_a);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel99<<<grid, block>>>(d_gpu_a, ix, cpu_lidx, offsetH,
            gpu_h);
        }

        h_needsGpuEnsureCapacity = false;
        ec_wtcc_kernel100<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_a, ix,
          cpu_lidx, bcoef, gpu_h);
        omega_tmp2_outdatedOnCpu = true;
        offsetH = i1Start - nsubs;
        for (i = 0; i < offsetH; i++) {
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_h, &gpu_h);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(d_cpu_a, &d_gpu_a);
          }

          wav_outdatedOnCpu = false;
          cpu_h->data[(i + div_s32(bcoef - cpu_lidx, ix)) + 2] = d_cpu_a->
            data[nsubs + i] / 2.0;
          omega_tmp2_outdatedOnCpu = false;
          h_outdatedOnGpu = true;
          h_needsGpuEnsureCapacity = true;
        }
      } else {
        i = h_cpu_x->size[0];
        h_cpu_x->size[0] = d_cpu_a->size[0];
        emxEnsureCapacity_real_T(h_cpu_x, i, &ad_emlrtRTEI);
        n = d_cpu_a->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(h_cpu_x, &r_gpu_x, true);
        subs_outdatedOnCpu = false;
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&d_gpu_a, d_cpu_a);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1219<<<grid, block>>>(d_gpu_a, n, r_gpu_x);
        }

        interval_outdatedOnGpu = false;
        x_outdatedOnCpu = true;
        offsetH = d_cpu_a->size[0] - 1;
        cpu_lidx = d_cpu_a->size[0] >> 1;
        for (ix = 0; ix < cpu_lidx; ix++) {
          if (x_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(h_cpu_x, &r_gpu_x);
          }

          r = h_cpu_x->data[ix];
          h_cpu_x->data[ix] = h_cpu_x->data[offsetH - ix];
          h_cpu_x->data[offsetH - ix] = r;
          x_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
          subs_outdatedOnCpu = true;
        }

        i = cpu_h->size[0] * cpu_h->size[1];
        cpu_h->size[0] = 1;
        cpu_h->size[1] = h_cpu_x->size[0] + d_cpu_a->size[0];
        emxEnsureCapacity_real_T(cpu_h, i, &hd_emlrtRTEI);
        offsetH = h_cpu_x->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(h_cpu_x, &r_gpu_x, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
        h_needsGpuEnsureCapacity = false;
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&r_gpu_x, h_cpu_x);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1220<<<grid, block>>>(r_gpu_x, offsetH - 1, gpu_h);
        }

        omega_tmp2_outdatedOnCpu = true;
        offsetH = d_cpu_a->size[0];
        for (i = 0; i < offsetH; i++) {
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_h, &gpu_h);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(d_cpu_a, &d_gpu_a);
          }

          wav_outdatedOnCpu = false;
          cpu_h->data[i + h_cpu_x->size[0]] = 0.5 * d_cpu_a->data[i];
          omega_tmp2_outdatedOnCpu = false;
          h_outdatedOnGpu = true;
          h_needsGpuEnsureCapacity = true;
        }
      }
    }

    if (fb == std::floor(fb)) {
      bcoef = static_cast<int32_T>(fb);
    } else {
      bcoef = static_cast<int32_T>(std::round(fb));
      coder::internal::warning();
    }

    i = cpu_dv23->size[0];
    cpu_dv23->size[0] = bcoef;
    emxEnsureCapacity_real_T(cpu_dv23, i, &xb_emlrtRTEI);
    if (bcoef <= 1) {
      i = cpu_dv23->size[0];
      cpu_dv23->size[0] = bcoef;
      emxEnsureCapacity_real_T(cpu_dv23, i, &yb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(bcoef - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel101<<<grid, block>>>(bcoef - 1, gpu_dv23);
      }

      subs_outdatedOnCpu = false;
    } else {
      ix = bcoef >> 1;
      f = computeEndIdx(static_cast<int64_T>(ix + 1), static_cast<int64_T>(bcoef),
                        1L);
      mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1218<<<grid, block>>>(gpu_dc6, *global_gpu_table100, dc7,
          gpu_dc, bcoef, ix, 1 - (bcoef & 1), ix + 1, f, gpu_dv23, q1[0], q1[1],
          q1[2], q1[3], q1[4], q1[5], q1[6], q1[7], p1[0], p1[1], p1[2], p1[3],
          p1[4], p1[5], p1[6], p1[7], q2[0], q2[1], q2[2], q2[3], q2[4], q2[5],
          q2[6], q2[7], p2[0], p2[1], p2[2], p2[3], p2[4], p2[5], p2[6], p2[7],
          q4[0], q4[1], q4[2], q4[3], q4[4], q4[5], q4[6], q4[7], p4[0], p4[1],
          p4[2], p4[3], p4[4], p4[5], p4[6], p4[7], d_c[0], d_c[1], d_c[2], d_c
          [3], d_c[4], d_c[5], d_c[6]);
      }

      subs_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      for (itime = 0; itime < ix; itime++) {
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv23, &gpu_dv23);
        }

        cpu_dv23->data[itime] = cpu_dv23->data[(bcoef - itime) - 1];
        interval_outdatedOnGpu = false;
        subs_outdatedOnCpu = true;
        wav_outdatedOnCpu = true;
      }
    }

    i = cpu_h1->size[0];
    cpu_h1->size[0] = cpu_h->size[1];
    emxEnsureCapacity_real_T(cpu_h1, i, &cc_emlrtRTEI);
    n = cpu_h->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, !subs_outdatedOnCpu);
    }

    if (h_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, !h_outdatedOnGpu);
    }

    h_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
    wav_outdatedOnCpu = false;
    if (subs_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_dv23, cpu_dv23);
    }

    if (h_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_h, cpu_h);
    }

    h_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel102<<<grid, block>>>(gpu_dv23, gpu_h, n, gpu_h1);
    }

    cpu_lidx = cpu_h1->size[0];
    if (cpu_h1->size[0] == 0) {
      halfh = 0.0;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(cpu_h1, &gpu_h1);
      halfh = cpu_h1->data[0];
      wav_outdatedOnCpu = true;
      for (itime = 0; itime <= cpu_lidx - 2; itime++) {
        halfh += cpu_h1->data[itime + 1];
      }
    }

    i = cpu_opts_filter->size[0];
    cpu_opts_filter->size[0] = cpu_h1->size[0];
    emxEnsureCapacity_real32_T(cpu_opts_filter, i, &wb_emlrtRTEI);
    n = cpu_h1->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
    }

    gpuEmxEnsureCapacity_real32_T(cpu_opts_filter, &gpu_opts_filter, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel103<<<grid, block>>>(halfh, gpu_h1, toler, n,
        gpu_opts_filter);
    }

    r = (static_cast<real_T>(cpu_opts_filter->size[0]) - 1.0) / 2.0;
    b_r = r;
    if (b_m == 0.0) {
      if (r == 0.0) {
        b_r = 0.0;
      }
    } else if (std::isnan(b_m)) {
      b_r = rtNaN;
    } else if (r == 0.0) {
      b_r = 0.0;
    } else if (std::isinf(b_m)) {
      if (r < 0.0) {
        b_r = b_m;
      }
    } else {
      b_r = std::fmod(r, b_m);
      if (b_r == 0.0) {
        b_r = b_m * 0.0;
      } else if (r < 0.0) {
        b_r += b_m;
      }
    }

    halfh = std::floor(b_m - b_r);
    T = std::floor(std::ceil(r + halfh) / b_m);
    r = static_cast<real_T>(cpu_opts_filter->size[0]) + halfh;
    fa = 0.0;
    cpu_lidx = cpu_opts_x->size[0];
    while (std::ceil((((static_cast<real_T>(cpu_lidx) - 1.0) * toler + r) + fa) /
                     b_m) - T < std::ceil(static_cast<real_T>(cpu_lidx) * toler /
            b_m)) {
      fa++;
    }

    i = b_cpu_h->size[0];
    b_cpu_h->size[0] = static_cast<int32_T>((halfh + static_cast<real_T>
      (cpu_opts_filter->size[0])) + fa);
    emxEnsureCapacity_real32_T(b_cpu_h, i, &ic_emlrtRTEI);
    n = static_cast<int32_T>((halfh + static_cast<real_T>(cpu_opts_filter->size
      [0])) + fa) - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_h, &b_gpu_h, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel104<<<grid, block>>>(n, b_gpu_h);
    }

    if (cpu_opts_filter->size[0] < 1) {
      v_cpu_y->size[0] = 1;
      v_cpu_y->size[1] = 0;
    } else {
      N = static_cast<uint32_T>(cpu_opts_filter->size[0]);
      i = v_cpu_y->size[0] * v_cpu_y->size[1];
      v_cpu_y->size[0] = 1;
      v_cpu_y->size[1] = cpu_opts_filter->size[0];
      emxEnsureCapacity_uint32_T(v_cpu_y, i, &h_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(N) - 1),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_uint32_T(v_cpu_y, &l_gpu_y, true);
      c_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1217<<<grid, block>>>(static_cast<int32_T>(N) - 1, l_gpu_y);
      }
    }

    i = cpu_iv19->size[0] * cpu_iv19->size[1];
    cpu_iv19->size[0] = 1;
    cpu_iv19->size[1] = v_cpu_y->size[1];
    emxEnsureCapacity_int32_T(cpu_iv19, i, &lc_emlrtRTEI);
    n = v_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (c_y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_uint32_T(v_cpu_y, &l_gpu_y, true);
    }

    c_y_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_int32_T(cpu_iv19, &gpu_iv19, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel105<<<grid, block>>>(l_gpu_y, halfh, n, gpu_iv19);
    }

    n = cpu_iv19->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel106<<<grid, block>>>(gpu_opts_filter, gpu_iv19, n, b_gpu_h);
    }

    if (fb_SignalPad == 1) {
      if (opts_isRowVectorInput) {
        if ((toler == 1.0) && (b_m == 1.0)) {
          i = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = cpu_opts_x->size[0];
          cpu_y1->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_real32_T(cpu_y1, i, &sc_emlrtRTEI);
          n = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel107<<<grid, block>>>(gpu_opts_x, n, gpu_y1);
          }
        } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
          if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
            ix = 0;
          } else {
            i1Start = cpu_opts_x->size[0];
            ix = cpu_opts_x->size[1];
            if (i1Start >= ix) {
              ix = i1Start;
            }
          }

          halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              r_y = nullptr;
              m23 = emlrtCreateCharArray(2, &iv29[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m23, &rfmt[0]);
              emlrtAssign(&r_y, m23);
              bb_y = nullptr;
              m29 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&bb_y, m29);
              emlrt_marshallIn(b_sprintf(r_y, bb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            i = i_cpu_yCol->size[0];
            i_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(i_cpu_yCol, i, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_yCol, &t_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel718<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                t_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel719<<<grid, block>>>(gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), t_gpu_yCol);
            }

            ec_wtcc_kernel720<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_origSiz);
            i = p_cpu_x->size[0] * p_cpu_x->size[1];
            p_cpu_x->size[0] = static_cast<int32_T>(toler);
            p_cpu_x->size[1] = 1;
            emxEnsureCapacity_real32_T(p_cpu_x, i, &id_emlrtRTEI);
            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(p_cpu_x, &i_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel721<<<grid, block>>>(t_gpu_yCol, cpu_origSiz[0] - 1,
                i_gpu_x);
            }

            if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              i = l_cpu_a->size[0];
              l_cpu_a->size[0] = 1;
              emxEnsureCapacity_real32_T(l_cpu_a, i, &jb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(l_cpu_a, &n_gpu_a, true);
              ec_wtcc_kernel722<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                t_gpu_yCol, gpu_cv_re, n_gpu_a);
              i = k_cpu_c->size[0];
              k_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(k_cpu_c, i, &lb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(k_cpu_c, &j_gpu_c, true);
              ec_wtcc_kernel723<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (gpu_cv_re, n_gpu_a, j_gpu_c);
              i = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = 1;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel724<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(j_gpu_c,
                db_gpu_w);
            } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              i = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = nsubs;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel736<<<grid, block>>>(nsubs - 1, db_gpu_w);
              }

              if (cpu_origSiz[0] == 0) {
                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = nsubs;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel737<<<grid, block>>>(nsubs - 1, db_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && (cpu_origSiz[0] == 1)) {
                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = 1;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel738<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (t_gpu_yCol, b_gpu_h, db_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = eb_cpu_expanded->size[0] * eb_cpu_expanded->size[1];
                eb_cpu_expanded->size[0] = i1Start;
                eb_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(eb_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + cpu_origSiz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(eb_cpu_expanded, &ac_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel739<<<grid, block>>>(n, ac_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = gc_cpu_y->size[0] * gc_cpu_y->size[1];
                gc_cpu_y->size[0] = 1;
                gc_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(gc_cpu_y, i, &ob_emlrtRTEI);
                gc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  gc_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv65->size[0];
                cpu_iv65->size[0] = gc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv65, i, &nb_emlrtRTEI);
                n = gc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(gc_cpu_y, &xd_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv65, &gpu_iv65, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xd_gpu_y, gc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel740<<<grid, block>>>(offsetH, xd_gpu_y, n,
                    gpu_iv65);
                }

                omega_tmp2[0] = cpu_iv65->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel741<<<grid, block>>>(b_gpu_h, gpu_iv65,
                    omega_tmp2[0] - 1, ac_gpu_expanded);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = o_cpu_rows->size[0] * o_cpu_rows->size[1];
                o_cpu_rows->size[0] = 1;
                o_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(o_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  o_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    o_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = OH;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(o_cpu_rows, &tb_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&tb_gpu_rows, o_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel742<<<grid, block>>>(t_gpu_yCol,
                      ac_gpu_expanded, tb_gpu_rows, *gpu_origSiz, OH - 1,
                      db_gpu_w);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
              }

              i = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = nsubs;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel743<<<grid, block>>>(nsubs - 1, db_gpu_w);
              }

              if (cpu_origSiz[0] == 0) {
                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = nsubs;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel744<<<grid, block>>>(nsubs - 1, db_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                i = s_cpu_c->size[0];
                s_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(s_cpu_c, i, &ld_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(s_cpu_c, &k_gpu_c, true);
                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &i_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&k_gpu_c.data[0], 1), __FILE__, __LINE__);
                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = nsubs;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel745<<<grid, block>>>(k_gpu_c, nsubs - 1,
                    db_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<
                     uint32_T>(b_cpu_h->size[0])) - 1U;
                bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                i = db_cpu_expanded->size[0] * db_cpu_expanded->size[1];
                db_cpu_expanded->size[0] = i1Start - 1;
                db_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(db_cpu_expanded, i, &nb_emlrtRTEI);
                n = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(db_cpu_expanded, &bc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel746<<<grid, block>>>(n, bc_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = cc_cpu_y->size[0] * cc_cpu_y->size[1];
                cc_cpu_y->size[0] = 1;
                cc_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(cc_cpu_y, i, &ob_emlrtRTEI);
                cc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  cc_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv67->size[0];
                cpu_iv67->size[0] = cc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv67, i, &nb_emlrtRTEI);
                n = cc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(cc_cpu_y, &yd_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv67, &gpu_iv67, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&yd_gpu_y, cc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel747<<<grid, block>>>(offsetH, yd_gpu_y, n,
                    gpu_iv67);
                }

                fx_size[0] = cpu_iv67->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel748<<<grid, block>>>(t_gpu_yCol, gpu_iv67,
                    fx_size[0] - 1, bc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = db_cpu_rows->size[0] * db_cpu_rows->size[1];
                db_cpu_rows->size[0] = 1;
                db_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(db_cpu_rows, i, &ob_emlrtRTEI);
                db_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  db_cpu_rows->data[itime + 1] = nsubs;
                }

                i = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = static_cast<int32_T>(N);
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(j_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(bcoef), 1U, 1U), &grid,
                    &block);
                  gpuEmxEnsureCapacity_int32_T(db_cpu_rows, &ub_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&ub_gpu_rows, db_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel749<<<grid, block>>>(bc_gpu_expanded,
                      ub_gpu_rows, b_gpu_h, OH - 1, db_gpu_w, b_cpu_h->size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              pb_y = nullptr;
              m46 = emlrtCreateCharArray(2, &iv40[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m46, &rfmt[0]);
              emlrtAssign(&pb_y, m46);
              wb_y = nullptr;
              m50 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&wb_y, m50);
              emlrt_marshallIn(b_sprintf(pb_y, wb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (j_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = j_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = j_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel725<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel726<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = ab_cpu_w->size[0] * ab_cpu_w->size[1];
            ab_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            ab_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(ab_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &db_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real32_T(ab_cpu_w, &eb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel727<<<grid, block>>>(db_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, eb_gpu_w, ab_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = pc_cpu_y->size[0] * pc_cpu_y->size[1];
            pc_cpu_y->size[0] = cpu_origSiz[0];
            pc_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(pc_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(pc_cpu_y, &td_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel728<<<grid, block>>>(eb_gpu_w, n, td_gpu_y);
            }

            r = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                          b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = ib_cpu_w->size[0] * ib_cpu_w->size[1];
              ib_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              ib_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real32_T(ib_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(ib_cpu_w, &fb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel729<<<grid, block>>>(db_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, fb_gpu_w, ib_cpu_w->size[0U]);
              }

              nsubs = pc_cpu_y->size[0] * pc_cpu_y->size[1];
              pc_cpu_y->size[0] = cpu_lidx;
              pc_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(pc_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(pc_cpu_y, &td_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel730<<<grid, block>>>(fb_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, td_gpu_y, pc_cpu_y->size[0U]);
              }
            }

            if (pc_cpu_y->size[0] * pc_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = pc_cpu_y->size[0] * pc_cpu_y->size[1];
            }

            omega_tmp2[0] = pc_cpu_y->size[0] * pc_cpu_y->size[1];
            i = ch_cpu_y->size[0] * ch_cpu_y->size[1];
            ch_cpu_y->size[0] = 1;
            ch_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(ch_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(ch_cpu_y, &ud_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel731<<<grid, block>>>(td_gpu_y, omega_tmp2[0] - 1,
                ud_gpu_y);
            }

            i = tb_cpu_y->size[0] * tb_cpu_y->size[1];
            tb_cpu_y->size[0] = n;
            tb_cpu_y->size[1] = 1;
            emxEnsureCapacity_real32_T(tb_cpu_y, i, &pd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(tb_cpu_y, &vd_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel732<<<grid, block>>>(ud_gpu_y, n - 1, vd_gpu_y);
            }
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              q_y = nullptr;
              m13 = emlrtCreateCharArray(2, &iv23[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m13, &rfmt[0]);
              emlrtAssign(&q_y, m13);
              ab_y = nullptr;
              m21 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&ab_y, m21);
              emlrt_marshallIn(b_sprintf(q_y, ab_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = cpu_opts_x->size[itime];
            }

            cpu_lidx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            i = c_cpu_yCol->size[0];
            c_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(c_cpu_yCol, i, &cd_emlrtRTEI);
            itime = offsetH * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &u_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel750<<<grid, block>>>(itime, u_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1))
                 || ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                   static_cast<int32_T>(toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = offsetH * static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel751<<<grid, block>>>(gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), u_gpu_yCol);
            }

            cpu_origSiz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
            i = j_cpu_x->size[0] * j_cpu_x->size[1];
            j_cpu_x->size[0] = cpu_origSiz[0];
            j_cpu_x->size[1] = cpu_opts_x->size[1];
            emxEnsureCapacity_real32_T(j_cpu_x, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(j_cpu_x, &j_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel752<<<grid, block>>>(u_gpu_yCol, n, j_gpu_x);
            }

            if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (cpu_opts_x->size[1] < 1) {
                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel753<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gb_gpu_w);
              } else {
                i = cpu_opts_x->size[1];
                nsubs = f_cpu_a->size[0];
                f_cpu_a->size[0] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(f_cpu_a, nsubs, &jb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(f_cpu_a, &o_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel760<<<grid, block>>>(u_gpu_yCol, i - 1, o_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
                cpu_cv_re = b_cpu_h->data[0];
                i = e_cpu_c->size[0];
                e_cpu_c->size[0] = f_cpu_a->size[0];
                emxEnsureCapacity_real32_T(e_cpu_c, i, &lb_emlrtRTEI);
                n = f_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(e_cpu_c, &l_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel761<<<grid, block>>>(n, l_gpu_c);
                }

                if (f_cpu_a->size[0] == 1) {
                  cpu_cv_re = b_cpu_h->data[0];
                  i = e_cpu_c->size[0];
                  e_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real32_T(e_cpu_c, i, &lb_emlrtRTEI);
                  gpuEmxEnsureCapacity_real32_T(e_cpu_c, &l_gpu_c, true);
                  ec_wtcc_kernel762<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_cv_re, o_gpu_a, l_gpu_c);
                } else {
                  bcoef = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(f_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(f_cpu_a->size[0])
                    + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                     (bcoef)));
                  OH = f_cpu_a->size[0];
                  if (f_cpu_a->size[0] > 2147483646) {
                    i1Start = MAX_int32_T;
                  } else {
                    i1Start = f_cpu_a->size[0] + 1;
                  }

                  i = j_cpu_expanded->size[0];
                  j_cpu_expanded->size[0] = i1Start - 1;
                  emxEnsureCapacity_real32_T(j_cpu_expanded, i, &nb_emlrtRTEI);
                  n = f_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real32_T(j_cpu_expanded, &cc_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel764<<<grid, block>>>(n, cc_gpu_expanded);
                  }

                  n = f_cpu_a->size[0];
                  i = eb_cpu_y->size[0] * eb_cpu_y->size[1];
                  eb_cpu_y->size[0] = 1;
                  eb_cpu_y->size[1] = f_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(eb_cpu_y, i, &ob_emlrtRTEI);
                  eb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    eb_cpu_y->data[itime + 1] = nsubs;
                  }

                  i = cpu_iv45->size[0];
                  cpu_iv45->size[0] = eb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv45, i, &nb_emlrtRTEI);
                  n = eb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(eb_cpu_y, &ae_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv45, &gpu_iv45, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&ae_gpu_y, eb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel765<<<grid, block>>>(ae_gpu_y, n, gpu_iv45);
                  }

                  omega_tmp2[0] = cpu_iv45->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel766<<<grid, block>>>(o_gpu_a, gpu_iv45,
                      omega_tmp2[0] - 1, cc_gpu_expanded);
                  }

                  i = e_cpu_c->size[0];
                  e_cpu_c->size[0] = f_cpu_a->size[0];
                  emxEnsureCapacity_real32_T(e_cpu_c, i, &nb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                    static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_real32_T(e_cpu_c, &l_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel767<<<grid, block>>>(cpu_cv_re,
                      cc_gpu_expanded, OH - 1, l_gpu_c);
                  }
                }

                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = e_cpu_c->size[0];
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                n = e_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel763<<<grid, block>>>(l_gpu_c, n, gb_gpu_w,
                    c_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = cpu_opts_x->size[1];
              }

              i = c_cpu_w->size[0] * c_cpu_w->size[1];
              c_cpu_w->size[0] = nsubs;
              c_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel768<<<grid, block>>>(itime, gb_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = nsubs;
                c_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel769<<<grid, block>>>(itime, gb_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                          (cpu_opts_x->size[1] == 1))) {
                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel770<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (u_gpu_yCol, b_gpu_h, gb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                b_blockDims[1] = cpu_lidx;
                ix = cpu_opts_x->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(n_cpu_expanded, i, &nb_emlrtRTEI);
                if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                }

                i = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(n_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_opts_x->size[1] +
                  cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(n_cpu_expanded, &dc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel771<<<grid, block>>>(n, dc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = ib_cpu_y->size[0] * ib_cpu_y->size[1];
                ib_cpu_y->size[0] = 1;
                ib_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ib_cpu_y, i, &ob_emlrtRTEI);
                ib_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ib_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv47->size[0];
                cpu_iv47->size[0] = ib_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv47, i, &nb_emlrtRTEI);
                n = ib_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ib_cpu_y, &be_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv47, &gpu_iv47, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&be_gpu_y, ib_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel772<<<grid, block>>>(offsetH, be_gpu_y, n,
                    gpu_iv47);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv47->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel773<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv47,
                    omega_tmp2[0] - 1, dc_gpu_expanded, n_cpu_expanded->size[0U]);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = g_cpu_rows->size[0] * g_cpu_rows->size[1];
                g_cpu_rows->size[0] = 1;
                g_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(g_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  g_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    g_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                n = cpu_opts_x->size[1];
                i = b_cpu_cols->size[0] * b_cpu_cols->size[1];
                b_cpu_cols->size[0] = 1;
                b_cpu_cols->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(b_cpu_cols, i, &ob_emlrtRTEI);
                b_cpu_cols->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  b_cpu_cols->data[itime + 1] = nsubs;
                }

                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = OH;
                c_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(c_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims
                    [1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(b_cpu_cols, &g_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(g_cpu_rows, &vb_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&g_gpu_cols, b_cpu_cols);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&vb_gpu_rows, g_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel774<<<grid, block>>>(u_gpu_yCol,
                      dc_gpu_expanded, g_gpu_cols, vb_gpu_rows, *gpu_origSiz, OH
                      - 1, ix - 1, gb_gpu_w, n_cpu_expanded->size[0U],
                      c_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = cpu_opts_x->size[1];
              }

              i = c_cpu_w->size[0] * c_cpu_w->size[1];
              c_cpu_w->size[0] = nsubs;
              c_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel775<<<grid, block>>>(itime, gb_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = nsubs;
                c_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel776<<<grid, block>>>(itime, gb_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                i = m_cpu_c->size[0];
                m_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(m_cpu_c, i, &ld_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(m_cpu_c, &m_gpu_c, true);
                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &j_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&m_gpu_c.data[0], 1), __FILE__, __LINE__);
                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = nsubs;
                c_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(c_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel777<<<grid, block>>>(m_gpu_c, itime, gb_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(b_cpu_h->size[0])) - 1U;
                bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                ix = cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                i = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
                m_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_real32_T(m_cpu_expanded, i, &nb_emlrtRTEI);
                if (cpu_opts_x->size[1] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = cpu_opts_x->size[1] + 1;
                }

                i = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
                m_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(m_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                  cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(m_cpu_expanded, &ec_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel778<<<grid, block>>>(n, ec_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = gb_cpu_y->size[0] * gb_cpu_y->size[1];
                gb_cpu_y->size[0] = 1;
                gb_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(gb_cpu_y, i, &ob_emlrtRTEI);
                gb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  gb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv52->size[0];
                cpu_iv52->size[0] = gb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv52, i, &nb_emlrtRTEI);
                n = gb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(gb_cpu_y, &ce_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv52, &gpu_iv52, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ce_gpu_y, gb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel779<<<grid, block>>>(offsetH, ce_gpu_y, n,
                    gpu_iv52);
                }

                n = cpu_opts_x->size[1];
                i = fc_cpu_y->size[0] * fc_cpu_y->size[1];
                fc_cpu_y->size[0] = 1;
                fc_cpu_y->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(fc_cpu_y, i, &ob_emlrtRTEI);
                fc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  fc_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv70->size[0];
                cpu_iv70->size[0] = fc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv70, i, &nb_emlrtRTEI);
                n = fc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(fc_cpu_y, &de_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv70, &gpu_iv70, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&de_gpu_y, fc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel780<<<grid, block>>>(de_gpu_y, n, gpu_iv70);
                }

                fx_size[0] = cpu_iv52->size[0];
                fx_size[1] = cpu_iv70->size[0];
                mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel781<<<grid, block>>>(u_gpu_yCol, fx_size[0],
                    gpu_iv70, gpu_iv52, fx_size[0] - 1, fx_size[1] - 1,
                    ec_gpu_expanded, m_cpu_expanded->size[0U]);
                }

                n = b_cpu_h->size[0];
                i = l_cpu_rows->size[0] * l_cpu_rows->size[1];
                l_cpu_rows->size[0] = 1;
                l_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(l_cpu_rows, i, &ob_emlrtRTEI);
                l_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  l_cpu_rows->data[itime + 1] = nsubs;
                }

                i = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = static_cast<int32_T>(N);
                c_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(c_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(bcoef), static_cast<uint32_T>(
                    static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(l_cpu_rows, &wb_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&wb_gpu_rows, l_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel782<<<grid, block>>>(ec_gpu_expanded,
                      wb_gpu_rows, b_gpu_h, OH - 1, ix - 1, gb_gpu_w,
                      b_cpu_h->size[0U], m_cpu_expanded->size[0U], c_cpu_w->
                      size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              nb_y = nullptr;
              m33 = emlrtCreateCharArray(2, &iv33[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m33, &rfmt[0]);
              emlrtAssign(&nb_y, m33);
              ub_y = nullptr;
              m39 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&ub_y, m39);
              emlrt_marshallIn(b_sprintf(nb_y, ub_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (c_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = c_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = c_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel754<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel755<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = x_cpu_w->size[0] * x_cpu_w->size[1];
            x_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            x_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(x_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &gb_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real32_T(x_cpu_w, &hb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel756<<<grid, block>>>(gb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, hb_gpu_w, x_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = tb_cpu_y->size[0] * tb_cpu_y->size[1];
            tb_cpu_y->size[0] = cpu_origSiz[0];
            tb_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(tb_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(tb_cpu_y, &vd_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel757<<<grid, block>>>(hb_gpu_w, n, vd_gpu_y);
            }

            r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                           toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              gb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real32_T(gb_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(gb_cpu_w, &ib_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel758<<<grid, block>>>(gb_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, ib_gpu_w, gb_cpu_w->size[0U]);
              }

              nsubs = tb_cpu_y->size[0] * tb_cpu_y->size[1];
              tb_cpu_y->size[0] = cpu_lidx;
              tb_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(tb_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(tb_cpu_y, &vd_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel759<<<grid, block>>>(ib_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, vd_gpu_y, tb_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            i = ic_cpu_y->size[0] * ic_cpu_y->size[1];
            ic_cpu_y->size[0] = 1;
            ic_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(ic_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(ic_cpu_y, &wd_gpu_y, true);
            f_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel733<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(wd_gpu_y);
          } else if (halfh < 1.0) {
            ic_cpu_y->size[0] = 1;
            ic_cpu_y->size[1] = 0;
          } else {
            i = ic_cpu_y->size[0] * ic_cpu_y->size[1];
            ic_cpu_y->size[0] = 1;
            ic_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(ic_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(ic_cpu_y, &wd_gpu_y, true);
            f_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel735<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), wd_gpu_y);
            }
          }

          i = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = static_cast<int32_T>(halfh);
          cpu_y1->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_y1, i, &sc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) -
            1), &grid, &block, 2147483647U);
          if (f_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(ic_cpu_y, &wd_gpu_y, true);
          }

          f_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel734<<<grid, block>>>(vd_gpu_y, wd_gpu_y, T,
              static_cast<int32_T>(halfh) - 1, gpu_y1);
          }
        } else {
          tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
          first_iteration = (cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_opts_x->size[0] *= cpu_opts_x->size[1];
            cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_real32_T(cpu_opts_x, i, &yc_emlrtRTEI);
            opts_x_needsGpuEnsureCapacity = true;
          }

          if (!(toler - 1.0 >= 0.0)) {
            l_y = nullptr;
            m12 = emlrtCreateCharArray(2, &iv22[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m12, &rfmt[0]);
            emlrtAssign(&l_y, m12);
            t_y = nullptr;
            m20 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&t_y, m20);
            emlrt_marshallIn(b_sprintf(l_y, t_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (cpu_opts_x->size[0] != 1) {
              nsubs = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = cpu_opts_x->size[itime];
          }

          cpu_lidx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          i = f_cpu_yCol->size[0];
          f_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(f_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(f_cpu_yCol, &v_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel811<<<grid, block>>>(itime, v_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          if (opts_x_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel812<<<grid, block>>>(gpu_opts_x, ix, div_s32(cpu_lidx
              - 1, ix), v_gpu_yCol);
          }

          cpu_origSiz[nsubs] = cpu_opts_x->size[nsubs] * static_cast<int32_T>
            (toler);
          i = m_cpu_x->size[0] * m_cpu_x->size[1];
          m_cpu_x->size[0] = cpu_origSiz[0];
          m_cpu_x->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(m_cpu_x, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(m_cpu_x, &k_gpu_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel813<<<grid, block>>>(v_gpu_yCol, n, k_gpu_x);
          }

          if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (cpu_origSiz[1] < 1) {
              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = 1;
              f_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel814<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (jb_gpu_w);
            } else {
              nsubs = i_cpu_a->size[0];
              i_cpu_a->size[0] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(i_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_a, &p_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel826<<<grid, block>>>(v_gpu_yCol, cpu_origSiz[1] -
                  1, p_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              i = h_cpu_c->size[0];
              h_cpu_c->size[0] = i_cpu_a->size[0];
              emxEnsureCapacity_real32_T(h_cpu_c, i, &lb_emlrtRTEI);
              n = i_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_c, &n_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel827<<<grid, block>>>(n, n_gpu_c);
              }

              if (i_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                i = h_cpu_c->size[0];
                h_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(h_cpu_c, i, &lb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(h_cpu_c, &n_gpu_c, true);
                ec_wtcc_kernel828<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, p_gpu_a, n_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (i_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(i_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>
                   (bcoef)));
                OH = i_cpu_a->size[0];
                if (i_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = i_cpu_a->size[0] + 1;
                }

                i = q_cpu_expanded->size[0];
                q_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_real32_T(q_cpu_expanded, i, &nb_emlrtRTEI);
                n = i_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(q_cpu_expanded, &jc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel830<<<grid, block>>>(n, jc_gpu_expanded);
                }

                n = i_cpu_a->size[0];
                i = lb_cpu_y->size[0] * lb_cpu_y->size[1];
                lb_cpu_y->size[0] = 1;
                lb_cpu_y->size[1] = i_cpu_a->size[0];
                emxEnsureCapacity_int32_T(lb_cpu_y, i, &ob_emlrtRTEI);
                lb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  lb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv51->size[0];
                cpu_iv51->size[0] = lb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv51, i, &nb_emlrtRTEI);
                n = lb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(lb_cpu_y, &le_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv51, &gpu_iv51, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&le_gpu_y, lb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel831<<<grid, block>>>(le_gpu_y, n, gpu_iv51);
                }

                omega_tmp2[0] = cpu_iv51->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel832<<<grid, block>>>(p_gpu_a, gpu_iv51,
                    omega_tmp2[0] - 1, jc_gpu_expanded);
                }

                i = h_cpu_c->size[0];
                h_cpu_c->size[0] = i_cpu_a->size[0];
                emxEnsureCapacity_real32_T(h_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_real32_T(h_cpu_c, &n_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel833<<<grid, block>>>(cpu_cv_re, jc_gpu_expanded,
                    OH - 1, n_gpu_c);
                }
              }

              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = 1;
              f_cpu_w->size[1] = h_cpu_c->size[0];
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              n = h_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel829<<<grid, block>>>(n_gpu_c, n, jb_gpu_w,
                  f_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = nsubs;
            f_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel834<<<grid, block>>>(itime, jb_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = nsubs;
              f_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel835<<<grid, block>>>(itime, jb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (cpu_origSiz[1] == 1))) {
              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = 1;
              f_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel836<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (v_gpu_yCol, b_gpu_h, jb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_origSiz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = w_cpu_expanded->size[0] * w_cpu_expanded->size[1];
              w_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(w_cpu_expanded, i, &nb_emlrtRTEI);
              if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                   - cpu_origSiz[1])) {
                i1Start = MIN_int32_T;
              } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T -
                          cpu_origSiz[1])) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + cpu_origSiz[1];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = w_cpu_expanded->size[0] * w_cpu_expanded->size[1];
              w_cpu_expanded->size[1] = i1Start;
              emxEnsureCapacity_real32_T(w_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
                - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(w_cpu_expanded, &kc_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel837<<<grid, block>>>(n, kc_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              i = sb_cpu_y->size[0] * sb_cpu_y->size[1];
              sb_cpu_y->size[0] = 1;
              sb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(sb_cpu_y, i, &ob_emlrtRTEI);
              sb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                sb_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv55->size[0];
              cpu_iv55->size[0] = sb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv55, i, &nb_emlrtRTEI);
              n = sb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(sb_cpu_y, &me_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv55, &gpu_iv55, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&me_gpu_y, sb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel838<<<grid, block>>>(offsetH, me_gpu_y, n,
                  gpu_iv55);
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv55->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel839<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv55,
                  omega_tmp2[0] - 1, kc_gpu_expanded, w_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = j_cpu_rows->size[0] * j_cpu_rows->size[1];
              j_cpu_rows->size[0] = 1;
              j_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(j_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                j_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  j_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              if (cpu_origSiz[1] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[1] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              wav_outdatedOnCpu = false;
              i = e_cpu_cols->size[0] * e_cpu_cols->size[1];
              e_cpu_cols->size[0] = 1;
              e_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(e_cpu_cols, i, &ob_emlrtRTEI);
              if (n > 0) {
                e_cpu_cols->data[0] = 0;
                wav_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  e_cpu_cols->data[itime + 1] = nsubs;
                }
              }

              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = OH;
              f_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(f_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((OH != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                nsubs = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  nsubs = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                                 (nsubs), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(e_cpu_cols, &h_gpu_cols,
                  !wav_outdatedOnCpu);
                gpuEmxEnsureCapacity_int32_T(j_cpu_rows, &cc_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (wav_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&h_gpu_cols, e_cpu_cols);
                }

                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&cc_gpu_rows, j_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel840<<<grid, block>>>(v_gpu_yCol, kc_gpu_expanded,
                    h_gpu_cols, cc_gpu_rows, *gpu_origSiz, OH - 1, ix - 1,
                    jb_gpu_w, w_cpu_expanded->size[0U], f_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = nsubs;
            f_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel841<<<grid, block>>>(itime, jb_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = nsubs;
              f_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel842<<<grid, block>>>(itime, jb_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              i = p_cpu_c->size[0];
              p_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(p_cpu_c, i, &ld_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(p_cpu_c, &o_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &k_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&o_gpu_c.data[0], 1), __FILE__, __LINE__);
              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = nsubs;
              f_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(f_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel843<<<grid, block>>>(o_gpu_c, itime, jb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              ix = cpu_origSiz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              i = v_cpu_expanded->size[0] * v_cpu_expanded->size[1];
              v_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_real32_T(v_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_origSiz[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + 1;
              }

              i = v_cpu_expanded->size[0] * v_cpu_expanded->size[1];
              v_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_real32_T(v_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                cpu_origSiz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(v_cpu_expanded, &lc_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel844<<<grid, block>>>(n, lc_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = ob_cpu_y->size[0] * ob_cpu_y->size[1];
              ob_cpu_y->size[0] = 1;
              ob_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(ob_cpu_y, i, &ob_emlrtRTEI);
              ob_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                ob_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv58->size[0];
              cpu_iv58->size[0] = ob_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv58, i, &nb_emlrtRTEI);
              n = ob_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ob_cpu_y, &ne_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv58, &gpu_iv58, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ne_gpu_y, ob_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel845<<<grid, block>>>(offsetH, ne_gpu_y, n,
                  gpu_iv58);
              }

              if (cpu_origSiz[1] < 1) {
                n = 0;
              } else {
                n = cpu_origSiz[1];
              }

              wav_outdatedOnCpu = false;
              i = oc_cpu_y->size[0] * oc_cpu_y->size[1];
              oc_cpu_y->size[0] = 1;
              oc_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(oc_cpu_y, i, &ob_emlrtRTEI);
              if (n > 0) {
                oc_cpu_y->data[0] = 1;
                wav_outdatedOnCpu = true;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  oc_cpu_y->data[itime + 1] = nsubs;
                }
              }

              i = cpu_iv75->size[0];
              cpu_iv75->size[0] = oc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv75, i, &nb_emlrtRTEI);
              n = oc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(oc_cpu_y, &oe_gpu_y,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv75, &gpu_iv75, true);
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&oe_gpu_y, oc_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel846<<<grid, block>>>(oe_gpu_y, n, gpu_iv75);
              }

              fx_size[0] = cpu_iv58->size[0];
              fx_size[1] = cpu_iv75->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel847<<<grid, block>>>(v_gpu_yCol, fx_size[0],
                  gpu_iv75, gpu_iv58, fx_size[0] - 1, fx_size[1] - 1,
                  lc_gpu_expanded, v_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              i = r_cpu_rows->size[0] * r_cpu_rows->size[1];
              r_cpu_rows->size[0] = 1;
              r_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(r_cpu_rows, i, &ob_emlrtRTEI);
              r_cpu_rows->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                r_cpu_rows->data[itime + 1] = nsubs;
              }

              i = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = static_cast<int32_T>(N);
              f_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(f_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = cpu_lidx;
                if (cpu_lidx < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(bcoef),
                                 static_cast<uint32_T>(i), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(r_cpu_rows, &dc_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&dc_gpu_rows, r_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel848<<<grid, block>>>(lc_gpu_expanded,
                    dc_gpu_rows, b_gpu_h, OH - 1, ix - 1, jb_gpu_w,
                    b_cpu_h->size[0U], v_cpu_expanded->size[0U], f_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            mb_y = nullptr;
            m37 = emlrtCreateCharArray(2, &iv37[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m37, &rfmt[0]);
            emlrtAssign(&mb_y, m37);
            tb_y = nullptr;
            m44 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&tb_y, m44);
            emlrt_marshallIn(b_sprintf(mb_y, tb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (f_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = f_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = f_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel815<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel816<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = db_cpu_w->size[0] * db_cpu_w->size[1];
          db_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          db_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(db_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(db_cpu_w, &kb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel817<<<grid, block>>>(jb_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lidx - 1, kb_gpu_w, db_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = yb_cpu_y->size[0] * yb_cpu_y->size[1];
          yb_cpu_y->size[0] = cpu_origSiz[0];
          yb_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(yb_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &ie_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel818<<<grid, block>>>(kb_gpu_w, n, ie_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = lb_cpu_w->size[0] * lb_cpu_w->size[1];
            lb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            lb_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_real32_T(lb_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(lb_cpu_w, &lb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel819<<<grid, block>>>(jb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, lb_gpu_w, lb_cpu_w->size[0U]);
            }

            nsubs = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            yb_cpu_y->size[0] = cpu_lidx;
            yb_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(yb_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &ie_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel820<<<grid, block>>>(lb_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, ie_gpu_y, yb_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            i = bh_cpu_y->size[0] * bh_cpu_y->size[1];
            bh_cpu_y->size[0] = 1;
            bh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(bh_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(bh_cpu_y, &je_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel821<<<grid, block>>>(ie_gpu_y, omega_tmp2[0] - 1,
                je_gpu_y, bh_cpu_y->size[0U]);
            }

            i = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            yb_cpu_y->size[0] = 1;
            yb_cpu_y->size[1] = bh_cpu_y->size[1];
            emxEnsureCapacity_real32_T(yb_cpu_y, i, &qd_emlrtRTEI);
            n = bh_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &ie_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel822<<<grid, block>>>(je_gpu_y, n, ie_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            i = tc_cpu_y->size[0] * tc_cpu_y->size[1];
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(tc_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(tc_cpu_y, &ke_gpu_y, true);
            i_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel823<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ke_gpu_y);
          } else if (tol < 1.0) {
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = 0;
          } else {
            i = tc_cpu_y->size[0] * tc_cpu_y->size[1];
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(tc_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(tc_cpu_y, &ke_gpu_y, true);
            i_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel825<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                ke_gpu_y);
            }
          }

          cpu_lidx = yb_cpu_y->size[1];
          i = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = tc_cpu_y->size[1];
          cpu_y1->size[1] = yb_cpu_y->size[1];
          emxEnsureCapacity_real32_T(cpu_y1, i, &sc_emlrtRTEI);
          n = tc_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid,
            &block, 2147483647U);
          if (i_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(tc_cpu_y, &ke_gpu_y, true);
          }

          i_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel824<<<grid, block>>>(ie_gpu_y, ke_gpu_y, T, n,
              cpu_lidx - 1, gpu_y1, cpu_y1->size[0U], yb_cpu_y->size[0U]);
          }
        }

        if ((cpu_y1->size[0] == 0) || (cpu_y1->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = cpu_y1->size[0];
          ix = cpu_y1->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = 1;
        cpu_opts_x->size[1] = ix;
        emxEnsureCapacity_real32_T(cpu_opts_x, i, &ed_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel108<<<grid, block>>>(gpu_y1, ix - 1, gpu_opts_x);
        }
      } else if ((!(toler == 1.0)) || (!(b_m == 1.0))) {
        if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
          if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
            ix = 0;
          } else {
            i1Start = cpu_opts_x->size[0];
            ix = cpu_opts_x->size[1];
            if (i1Start >= ix) {
              ix = i1Start;
            }
          }

          halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              p_y = nullptr;
              m22 = emlrtCreateCharArray(2, &iv28[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m22, &rfmt[0]);
              emlrtAssign(&p_y, m22);
              y_y = nullptr;
              m28 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&y_y, m28);
              emlrt_marshallIn(b_sprintf(p_y, y_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            i = h_cpu_yCol->size[0];
            h_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(h_cpu_yCol, i, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_yCol, &w_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel877<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                w_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel878<<<grid, block>>>(gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), w_gpu_yCol);
            }

            ec_wtcc_kernel879<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_origSiz);
            i = o_cpu_x->size[0] * o_cpu_x->size[1];
            o_cpu_x->size[0] = static_cast<int32_T>(toler);
            o_cpu_x->size[1] = 1;
            emxEnsureCapacity_real32_T(o_cpu_x, i, &id_emlrtRTEI);
            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(o_cpu_x, &l_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel880<<<grid, block>>>(w_gpu_yCol, cpu_origSiz[0] - 1,
                l_gpu_x);
            }

            if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              i = k_cpu_a->size[0];
              k_cpu_a->size[0] = 1;
              emxEnsureCapacity_real32_T(k_cpu_a, i, &jb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(k_cpu_a, &q_gpu_a, true);
              ec_wtcc_kernel881<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                w_gpu_yCol, gpu_cv_re, q_gpu_a);
              i = j_cpu_c->size[0];
              j_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(j_cpu_c, i, &lb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(j_cpu_c, &p_gpu_c, true);
              ec_wtcc_kernel882<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (gpu_cv_re, q_gpu_a, p_gpu_c);
              i = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = 1;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel883<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(p_gpu_c,
                mb_gpu_w);
            } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              i = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = nsubs;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel895<<<grid, block>>>(nsubs - 1, mb_gpu_w);
              }

              if (cpu_origSiz[0] == 0) {
                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = nsubs;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel896<<<grid, block>>>(nsubs - 1, mb_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && (cpu_origSiz[0] == 1)) {
                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = 1;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel897<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (w_gpu_yCol, b_gpu_h, mb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = cb_cpu_expanded->size[0] * cb_cpu_expanded->size[1];
                cb_cpu_expanded->size[0] = i1Start;
                cb_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(cb_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + cpu_origSiz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(cb_cpu_expanded, &qc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel898<<<grid, block>>>(n, qc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = ec_cpu_y->size[0] * ec_cpu_y->size[1];
                ec_cpu_y->size[0] = 1;
                ec_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ec_cpu_y, i, &ob_emlrtRTEI);
                ec_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ec_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv64->size[0];
                cpu_iv64->size[0] = ec_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv64, i, &nb_emlrtRTEI);
                n = ec_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ec_cpu_y, &xe_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv64, &gpu_iv64, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xe_gpu_y, ec_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel899<<<grid, block>>>(offsetH, xe_gpu_y, n,
                    gpu_iv64);
                }

                omega_tmp2[0] = cpu_iv64->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel900<<<grid, block>>>(b_gpu_h, gpu_iv64,
                    omega_tmp2[0] - 1, qc_gpu_expanded);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = n_cpu_rows->size[0] * n_cpu_rows->size[1];
                n_cpu_rows->size[0] = 1;
                n_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(n_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  n_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    n_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = OH;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(n_cpu_rows, &ic_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&ic_gpu_rows, n_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel901<<<grid, block>>>(w_gpu_yCol,
                      qc_gpu_expanded, ic_gpu_rows, *gpu_origSiz, OH - 1,
                      mb_gpu_w);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
              }

              i = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = nsubs;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel902<<<grid, block>>>(nsubs - 1, mb_gpu_w);
              }

              if (cpu_origSiz[0] == 0) {
                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = nsubs;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel903<<<grid, block>>>(nsubs - 1, mb_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                i = r_cpu_c->size[0];
                r_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(r_cpu_c, i, &ld_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(r_cpu_c, &q_gpu_c, true);
                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &l_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&q_gpu_c.data[0], 1), __FILE__, __LINE__);
                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = nsubs;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel904<<<grid, block>>>(q_gpu_c, nsubs - 1,
                    mb_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<
                     uint32_T>(b_cpu_h->size[0])) - 1U;
                bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                i = bb_cpu_expanded->size[0] * bb_cpu_expanded->size[1];
                bb_cpu_expanded->size[0] = i1Start - 1;
                bb_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(bb_cpu_expanded, i, &nb_emlrtRTEI);
                n = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(bb_cpu_expanded, &rc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel905<<<grid, block>>>(n, rc_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = bc_cpu_y->size[0] * bc_cpu_y->size[1];
                bc_cpu_y->size[0] = 1;
                bc_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(bc_cpu_y, i, &ob_emlrtRTEI);
                bc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  bc_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv66->size[0];
                cpu_iv66->size[0] = bc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv66, i, &nb_emlrtRTEI);
                n = bc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(bc_cpu_y, &ye_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv66, &gpu_iv66, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ye_gpu_y, bc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel906<<<grid, block>>>(offsetH, ye_gpu_y, n,
                    gpu_iv66);
                }

                fx_size[0] = cpu_iv66->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel907<<<grid, block>>>(w_gpu_yCol, gpu_iv66,
                    fx_size[0] - 1, rc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = bb_cpu_rows->size[0] * bb_cpu_rows->size[1];
                bb_cpu_rows->size[0] = 1;
                bb_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(bb_cpu_rows, i, &ob_emlrtRTEI);
                bb_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  bb_cpu_rows->data[itime + 1] = nsubs;
                }

                i = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = static_cast<int32_T>(N);
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(i_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(bcoef), 1U, 1U), &grid,
                    &block);
                  gpuEmxEnsureCapacity_int32_T(bb_cpu_rows, &jc_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&jc_gpu_rows, bb_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel908<<<grid, block>>>(rc_gpu_expanded,
                      jc_gpu_rows, b_gpu_h, OH - 1, mb_gpu_w, b_cpu_h->size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              ob_y = nullptr;
              m45 = emlrtCreateCharArray(2, &iv39[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m45, &rfmt[0]);
              emlrtAssign(&ob_y, m45);
              vb_y = nullptr;
              m49 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&vb_y, m49);
              emlrt_marshallIn(b_sprintf(ob_y, vb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (i_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = i_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = i_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel884<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel885<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = y_cpu_w->size[0] * y_cpu_w->size[1];
            y_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            y_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(y_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &mb_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real32_T(y_cpu_w, &nb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel886<<<grid, block>>>(mb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, nb_gpu_w, y_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = nc_cpu_y->size[0] * nc_cpu_y->size[1];
            nc_cpu_y->size[0] = cpu_origSiz[0];
            nc_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(nc_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(nc_cpu_y, &te_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel887<<<grid, block>>>(nb_gpu_w, n, te_gpu_y);
            }

            r = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                          b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              hb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real32_T(hb_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(hb_cpu_w, &ob_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel888<<<grid, block>>>(mb_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, ob_gpu_w, hb_cpu_w->size[0U]);
              }

              nsubs = nc_cpu_y->size[0] * nc_cpu_y->size[1];
              nc_cpu_y->size[0] = cpu_lidx;
              nc_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(nc_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(nc_cpu_y, &te_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel889<<<grid, block>>>(ob_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, te_gpu_y, nc_cpu_y->size[0U]);
              }
            }

            if (nc_cpu_y->size[0] * nc_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = nc_cpu_y->size[0] * nc_cpu_y->size[1];
            }

            omega_tmp2[0] = nc_cpu_y->size[0] * nc_cpu_y->size[1];
            i = ah_cpu_y->size[0] * ah_cpu_y->size[1];
            ah_cpu_y->size[0] = 1;
            ah_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(ah_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(ah_cpu_y, &ue_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel890<<<grid, block>>>(te_gpu_y, omega_tmp2[0] - 1,
                ue_gpu_y);
            }

            i = rb_cpu_y->size[0] * rb_cpu_y->size[1];
            rb_cpu_y->size[0] = n;
            rb_cpu_y->size[1] = 1;
            emxEnsureCapacity_real32_T(rb_cpu_y, i, &pd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &ve_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel891<<<grid, block>>>(ue_gpu_y, n - 1, ve_gpu_y);
            }
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              o_y = nullptr;
              m11 = emlrtCreateCharArray(2, &iv21[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m11, &rfmt[0]);
              emlrtAssign(&o_y, m11);
              x_y = nullptr;
              m19 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&x_y, m19);
              emlrt_marshallIn(b_sprintf(o_y, x_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = cpu_opts_x->size[itime];
            }

            cpu_lidx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            i = b_cpu_yCol->size[0];
            b_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(b_cpu_yCol, i, &cd_emlrtRTEI);
            itime = offsetH * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &x_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel909<<<grid, block>>>(itime, x_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1))
                 || ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                   static_cast<int32_T>(toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = offsetH * static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel910<<<grid, block>>>(gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), x_gpu_yCol);
            }

            cpu_origSiz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
            i = i_cpu_x->size[0] * i_cpu_x->size[1];
            i_cpu_x->size[0] = cpu_origSiz[0];
            i_cpu_x->size[1] = cpu_opts_x->size[1];
            emxEnsureCapacity_real32_T(i_cpu_x, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_x, &m_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel911<<<grid, block>>>(x_gpu_yCol, n, m_gpu_x);
            }

            if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (cpu_opts_x->size[1] < 1) {
                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = 1;
                b_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel912<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (pb_gpu_w);
              } else {
                i = cpu_opts_x->size[1];
                nsubs = e_cpu_a->size[0];
                e_cpu_a->size[0] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(e_cpu_a, nsubs, &jb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(e_cpu_a, &r_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel919<<<grid, block>>>(x_gpu_yCol, i - 1, r_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
                cpu_cv_re = b_cpu_h->data[0];
                i = d_cpu_c->size[0];
                d_cpu_c->size[0] = e_cpu_a->size[0];
                emxEnsureCapacity_real32_T(d_cpu_c, i, &lb_emlrtRTEI);
                n = e_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(d_cpu_c, &r_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel920<<<grid, block>>>(n, r_gpu_c);
                }

                if (e_cpu_a->size[0] == 1) {
                  cpu_cv_re = b_cpu_h->data[0];
                  i = d_cpu_c->size[0];
                  d_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real32_T(d_cpu_c, i, &lb_emlrtRTEI);
                  gpuEmxEnsureCapacity_real32_T(d_cpu_c, &r_gpu_c, true);
                  ec_wtcc_kernel921<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_cv_re, r_gpu_a, r_gpu_c);
                } else {
                  bcoef = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(e_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(e_cpu_a->size[0])
                    + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                     (bcoef)));
                  OH = e_cpu_a->size[0];
                  if (e_cpu_a->size[0] > 2147483646) {
                    i1Start = MAX_int32_T;
                  } else {
                    i1Start = e_cpu_a->size[0] + 1;
                  }

                  i = i_cpu_expanded->size[0];
                  i_cpu_expanded->size[0] = i1Start - 1;
                  emxEnsureCapacity_real32_T(i_cpu_expanded, i, &nb_emlrtRTEI);
                  n = e_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real32_T(i_cpu_expanded, &sc_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel923<<<grid, block>>>(n, sc_gpu_expanded);
                  }

                  n = e_cpu_a->size[0];
                  i = db_cpu_y->size[0] * db_cpu_y->size[1];
                  db_cpu_y->size[0] = 1;
                  db_cpu_y->size[1] = e_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(db_cpu_y, i, &ob_emlrtRTEI);
                  db_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    db_cpu_y->data[itime + 1] = nsubs;
                  }

                  i = cpu_iv44->size[0];
                  cpu_iv44->size[0] = db_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv44, i, &nb_emlrtRTEI);
                  n = db_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(db_cpu_y, &af_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv44, &gpu_iv44, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&af_gpu_y, db_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel924<<<grid, block>>>(af_gpu_y, n, gpu_iv44);
                  }

                  omega_tmp2[0] = cpu_iv44->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel925<<<grid, block>>>(r_gpu_a, gpu_iv44,
                      omega_tmp2[0] - 1, sc_gpu_expanded);
                  }

                  i = d_cpu_c->size[0];
                  d_cpu_c->size[0] = e_cpu_a->size[0];
                  emxEnsureCapacity_real32_T(d_cpu_c, i, &nb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                    static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_real32_T(d_cpu_c, &r_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel926<<<grid, block>>>(cpu_cv_re,
                      sc_gpu_expanded, OH - 1, r_gpu_c);
                  }
                }

                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = 1;
                b_cpu_w->size[1] = d_cpu_c->size[0];
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                n = d_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel922<<<grid, block>>>(r_gpu_c, n, pb_gpu_w,
                    b_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = cpu_opts_x->size[1];
              }

              i = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = nsubs;
              b_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel927<<<grid, block>>>(itime, pb_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = nsubs;
                b_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel928<<<grid, block>>>(itime, pb_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                          (cpu_opts_x->size[1] == 1))) {
                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = 1;
                b_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel929<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (x_gpu_yCol, b_gpu_h, pb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                b_blockDims[1] = cpu_lidx;
                ix = cpu_opts_x->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = l_cpu_expanded->size[0] * l_cpu_expanded->size[1];
                l_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(l_cpu_expanded, i, &nb_emlrtRTEI);
                if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                }

                i = l_cpu_expanded->size[0] * l_cpu_expanded->size[1];
                l_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(l_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_opts_x->size[1] +
                  cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(l_cpu_expanded, &tc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel930<<<grid, block>>>(n, tc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                i = hb_cpu_y->size[0] * hb_cpu_y->size[1];
                hb_cpu_y->size[0] = 1;
                hb_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(hb_cpu_y, i, &ob_emlrtRTEI);
                hb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  hb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv46->size[0];
                cpu_iv46->size[0] = hb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv46, i, &nb_emlrtRTEI);
                n = hb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(hb_cpu_y, &bf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv46, &gpu_iv46, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&bf_gpu_y, hb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel931<<<grid, block>>>(offsetH, bf_gpu_y, n,
                    gpu_iv46);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv46->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel932<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv46,
                    omega_tmp2[0] - 1, tc_gpu_expanded, l_cpu_expanded->size[0U]);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = f_cpu_rows->size[0] * f_cpu_rows->size[1];
                f_cpu_rows->size[0] = 1;
                f_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(f_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  f_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    f_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                n = cpu_opts_x->size[1];
                i = cpu_cols->size[0] * cpu_cols->size[1];
                cpu_cols->size[0] = 1;
                cpu_cols->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(cpu_cols, i, &ob_emlrtRTEI);
                cpu_cols->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  cpu_cols->data[itime + 1] = nsubs;
                }

                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = OH;
                b_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(b_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims
                    [1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(cpu_cols, &i_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(f_cpu_rows, &kc_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&i_gpu_cols, cpu_cols);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&kc_gpu_rows, f_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel933<<<grid, block>>>(x_gpu_yCol,
                      tc_gpu_expanded, i_gpu_cols, kc_gpu_rows, *gpu_origSiz, OH
                      - 1, ix - 1, pb_gpu_w, l_cpu_expanded->size[0U],
                      b_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = cpu_opts_x->size[1];
              }

              i = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = nsubs;
              b_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel934<<<grid, block>>>(itime, pb_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = nsubs;
                b_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel935<<<grid, block>>>(itime, pb_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                i = l_cpu_c->size[0];
                l_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(l_cpu_c, i, &ld_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(l_cpu_c, &s_gpu_c, true);
                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &m_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&s_gpu_c.data[0], 1), __FILE__, __LINE__);
                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = nsubs;
                b_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_real32_T(b_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel936<<<grid, block>>>(s_gpu_c, itime, pb_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(b_cpu_h->size[0])) - 1U;
                bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                ix = cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                i = k_cpu_expanded->size[0] * k_cpu_expanded->size[1];
                k_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_real32_T(k_cpu_expanded, i, &nb_emlrtRTEI);
                if (cpu_opts_x->size[1] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = cpu_opts_x->size[1] + 1;
                }

                i = k_cpu_expanded->size[0] * k_cpu_expanded->size[1];
                k_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(k_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                  cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(k_cpu_expanded, &uc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel937<<<grid, block>>>(n, uc_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = fb_cpu_y->size[0] * fb_cpu_y->size[1];
                fb_cpu_y->size[0] = 1;
                fb_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(fb_cpu_y, i, &ob_emlrtRTEI);
                fb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  fb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv50->size[0];
                cpu_iv50->size[0] = fb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv50, i, &nb_emlrtRTEI);
                n = fb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(fb_cpu_y, &cf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv50, &gpu_iv50, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&cf_gpu_y, fb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel938<<<grid, block>>>(offsetH, cf_gpu_y, n,
                    gpu_iv50);
                }

                n = cpu_opts_x->size[1];
                i = dc_cpu_y->size[0] * dc_cpu_y->size[1];
                dc_cpu_y->size[0] = 1;
                dc_cpu_y->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(dc_cpu_y, i, &ob_emlrtRTEI);
                dc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  dc_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv69->size[0];
                cpu_iv69->size[0] = dc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv69, i, &nb_emlrtRTEI);
                n = dc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(dc_cpu_y, &df_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv69, &gpu_iv69, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&df_gpu_y, dc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel939<<<grid, block>>>(df_gpu_y, n, gpu_iv69);
                }

                fx_size[0] = cpu_iv50->size[0];
                fx_size[1] = cpu_iv69->size[0];
                mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel940<<<grid, block>>>(x_gpu_yCol, fx_size[0],
                    gpu_iv69, gpu_iv50, fx_size[0] - 1, fx_size[1] - 1,
                    uc_gpu_expanded, k_cpu_expanded->size[0U]);
                }

                n = b_cpu_h->size[0];
                i = k_cpu_rows->size[0] * k_cpu_rows->size[1];
                k_cpu_rows->size[0] = 1;
                k_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(k_cpu_rows, i, &ob_emlrtRTEI);
                k_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  k_cpu_rows->data[itime + 1] = nsubs;
                }

                i = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = static_cast<int32_T>(N);
                b_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real32_T(b_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(bcoef), static_cast<uint32_T>(
                    static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(k_cpu_rows, &lc_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&lc_gpu_rows, k_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel941<<<grid, block>>>(uc_gpu_expanded,
                      lc_gpu_rows, b_gpu_h, OH - 1, ix - 1, pb_gpu_w,
                      b_cpu_h->size[0U], k_cpu_expanded->size[0U], b_cpu_w->
                      size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              lb_y = nullptr;
              m32 = emlrtCreateCharArray(2, &iv32[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m32, &rfmt[0]);
              emlrtAssign(&lb_y, m32);
              sb_y = nullptr;
              m38 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&sb_y, m38);
              emlrt_marshallIn(b_sprintf(lb_y, sb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (b_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = b_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = b_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel913<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel914<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = w_cpu_w->size[0] * w_cpu_w->size[1];
            w_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            w_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(w_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &pb_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real32_T(w_cpu_w, &qb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel915<<<grid, block>>>(pb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, qb_gpu_w, w_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = rb_cpu_y->size[0] * rb_cpu_y->size[1];
            rb_cpu_y->size[0] = cpu_origSiz[0];
            rb_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(rb_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &ve_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel916<<<grid, block>>>(qb_gpu_w, n, ve_gpu_y);
            }

            r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                           toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = fb_cpu_w->size[0] * fb_cpu_w->size[1];
              fb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              fb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real32_T(fb_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(fb_cpu_w, &rb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel917<<<grid, block>>>(pb_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, rb_gpu_w, fb_cpu_w->size[0U]);
              }

              nsubs = rb_cpu_y->size[0] * rb_cpu_y->size[1];
              rb_cpu_y->size[0] = cpu_lidx;
              rb_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(rb_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &ve_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel918<<<grid, block>>>(rb_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, ve_gpu_y, rb_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            i = hc_cpu_y->size[0] * hc_cpu_y->size[1];
            hc_cpu_y->size[0] = 1;
            hc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(hc_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(hc_cpu_y, &we_gpu_y, true);
            e_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel892<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(we_gpu_y);
          } else if (halfh < 1.0) {
            hc_cpu_y->size[0] = 1;
            hc_cpu_y->size[1] = 0;
          } else {
            i = hc_cpu_y->size[0] * hc_cpu_y->size[1];
            hc_cpu_y->size[0] = 1;
            hc_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(hc_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(hc_cpu_y, &we_gpu_y, true);
            e_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel894<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), we_gpu_y);
            }
          }

          i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = static_cast<int32_T>(halfh);
          cpu_opts_x->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_opts_x, i, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) -
            1), &grid, &block, 2147483647U);
          if (e_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(hc_cpu_y, &we_gpu_y, true);
          }

          e_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel893<<<grid, block>>>(ve_gpu_y, we_gpu_y, T,
              static_cast<int32_T>(halfh) - 1, gpu_opts_x);
          }
        } else {
          tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
          first_iteration = (cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_opts_x->size[0] *= cpu_opts_x->size[1];
            cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_real32_T(cpu_opts_x, i, &yc_emlrtRTEI);
            opts_x_needsGpuEnsureCapacity = true;
          }

          if (!(toler - 1.0 >= 0.0)) {
            k_y = nullptr;
            m10 = emlrtCreateCharArray(2, &iv20[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m10, &rfmt[0]);
            emlrtAssign(&k_y, m10);
            s_y = nullptr;
            m18 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&s_y, m18);
            emlrt_marshallIn(b_sprintf(k_y, s_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (cpu_opts_x->size[0] != 1) {
              nsubs = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = cpu_opts_x->size[itime];
          }

          cpu_lidx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          i = e_cpu_yCol->size[0];
          e_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(e_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(e_cpu_yCol, &y_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel970<<<grid, block>>>(itime, y_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          if (opts_x_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel971<<<grid, block>>>(gpu_opts_x, ix, div_s32(cpu_lidx
              - 1, ix), y_gpu_yCol);
          }

          cpu_origSiz[nsubs] = cpu_opts_x->size[nsubs] * static_cast<int32_T>
            (toler);
          i = l_cpu_x->size[0] * l_cpu_x->size[1];
          l_cpu_x->size[0] = cpu_origSiz[0];
          l_cpu_x->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(l_cpu_x, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(l_cpu_x, &n_gpu_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel972<<<grid, block>>>(y_gpu_yCol, n, n_gpu_x);
          }

          if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (cpu_origSiz[1] < 1) {
              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel973<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (sb_gpu_w);
            } else {
              nsubs = h_cpu_a->size[0];
              h_cpu_a->size[0] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(h_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_a, &s_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel985<<<grid, block>>>(y_gpu_yCol, cpu_origSiz[1] -
                  1, s_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              i = g_cpu_c->size[0];
              g_cpu_c->size[0] = h_cpu_a->size[0];
              emxEnsureCapacity_real32_T(g_cpu_c, i, &lb_emlrtRTEI);
              n = h_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(g_cpu_c, &t_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel986<<<grid, block>>>(n, t_gpu_c);
              }

              if (h_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                i = g_cpu_c->size[0];
                g_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(g_cpu_c, i, &lb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(g_cpu_c, &t_gpu_c, true);
                ec_wtcc_kernel987<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, s_gpu_a, t_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (h_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(h_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>
                   (bcoef)));
                OH = h_cpu_a->size[0];
                if (h_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = h_cpu_a->size[0] + 1;
                }

                i = p_cpu_expanded->size[0];
                p_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_real32_T(p_cpu_expanded, i, &nb_emlrtRTEI);
                n = h_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(p_cpu_expanded, &ad_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel989<<<grid, block>>>(n, ad_gpu_expanded);
                }

                n = h_cpu_a->size[0];
                i = kb_cpu_y->size[0] * kb_cpu_y->size[1];
                kb_cpu_y->size[0] = 1;
                kb_cpu_y->size[1] = h_cpu_a->size[0];
                emxEnsureCapacity_int32_T(kb_cpu_y, i, &ob_emlrtRTEI);
                kb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  kb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv49->size[0];
                cpu_iv49->size[0] = kb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv49, i, &nb_emlrtRTEI);
                n = kb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(kb_cpu_y, &lf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv49, &gpu_iv49, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&lf_gpu_y, kb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel990<<<grid, block>>>(lf_gpu_y, n, gpu_iv49);
                }

                omega_tmp2[0] = cpu_iv49->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel991<<<grid, block>>>(s_gpu_a, gpu_iv49,
                    omega_tmp2[0] - 1, ad_gpu_expanded);
                }

                i = g_cpu_c->size[0];
                g_cpu_c->size[0] = h_cpu_a->size[0];
                emxEnsureCapacity_real32_T(g_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_real32_T(g_cpu_c, &t_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel992<<<grid, block>>>(cpu_cv_re, ad_gpu_expanded,
                    OH - 1, t_gpu_c);
                }
              }

              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = g_cpu_c->size[0];
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              n = g_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel988<<<grid, block>>>(t_gpu_c, n, sb_gpu_w,
                  e_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = e_cpu_w->size[0] * e_cpu_w->size[1];
            e_cpu_w->size[0] = nsubs;
            e_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel993<<<grid, block>>>(itime, sb_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = nsubs;
              e_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel994<<<grid, block>>>(itime, sb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (cpu_origSiz[1] == 1))) {
              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel995<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (y_gpu_yCol, b_gpu_h, sb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_origSiz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = u_cpu_expanded->size[0] * u_cpu_expanded->size[1];
              u_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(u_cpu_expanded, i, &nb_emlrtRTEI);
              if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                   - cpu_origSiz[1])) {
                i1Start = MIN_int32_T;
              } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T -
                          cpu_origSiz[1])) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + cpu_origSiz[1];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = u_cpu_expanded->size[0] * u_cpu_expanded->size[1];
              u_cpu_expanded->size[1] = i1Start;
              emxEnsureCapacity_real32_T(u_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
                - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(u_cpu_expanded, &bd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel996<<<grid, block>>>(n, bd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              i = qb_cpu_y->size[0] * qb_cpu_y->size[1];
              qb_cpu_y->size[0] = 1;
              qb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(qb_cpu_y, i, &ob_emlrtRTEI);
              qb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                qb_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv54->size[0];
              cpu_iv54->size[0] = qb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv54, i, &nb_emlrtRTEI);
              n = qb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(qb_cpu_y, &mf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv54, &gpu_iv54, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&mf_gpu_y, qb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel997<<<grid, block>>>(offsetH, mf_gpu_y, n,
                  gpu_iv54);
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv54->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel998<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv54,
                  omega_tmp2[0] - 1, bd_gpu_expanded, u_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = i_cpu_rows->size[0] * i_cpu_rows->size[1];
              i_cpu_rows->size[0] = 1;
              i_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(i_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                i_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  i_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              if (cpu_origSiz[1] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[1] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              wav_outdatedOnCpu = false;
              i = d_cpu_cols->size[0] * d_cpu_cols->size[1];
              d_cpu_cols->size[0] = 1;
              d_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(d_cpu_cols, i, &ob_emlrtRTEI);
              if (n > 0) {
                d_cpu_cols->data[0] = 0;
                wav_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  d_cpu_cols->data[itime + 1] = nsubs;
                }
              }

              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = OH;
              e_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(e_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((OH != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                nsubs = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  nsubs = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                                 (nsubs), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(d_cpu_cols, &j_gpu_cols,
                  !wav_outdatedOnCpu);
                gpuEmxEnsureCapacity_int32_T(i_cpu_rows, &qc_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (wav_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&j_gpu_cols, d_cpu_cols);
                }

                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&qc_gpu_rows, i_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel999<<<grid, block>>>(y_gpu_yCol, bd_gpu_expanded,
                    j_gpu_cols, qc_gpu_rows, *gpu_origSiz, OH - 1, ix - 1,
                    sb_gpu_w, u_cpu_expanded->size[0U], e_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = e_cpu_w->size[0] * e_cpu_w->size[1];
            e_cpu_w->size[0] = nsubs;
            e_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1000<<<grid, block>>>(itime, sb_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = nsubs;
              e_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1001<<<grid, block>>>(itime, sb_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              i = o_cpu_c->size[0];
              o_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(o_cpu_c, i, &ld_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(o_cpu_c, &u_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &n_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&u_gpu_c.data[0], 1), __FILE__, __LINE__);
              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = nsubs;
              e_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(e_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1002<<<grid, block>>>(u_gpu_c, itime, sb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              ix = cpu_origSiz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              i = t_cpu_expanded->size[0] * t_cpu_expanded->size[1];
              t_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_real32_T(t_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_origSiz[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + 1;
              }

              i = t_cpu_expanded->size[0] * t_cpu_expanded->size[1];
              t_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_real32_T(t_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                cpu_origSiz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(t_cpu_expanded, &cd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1003<<<grid, block>>>(n, cd_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = nb_cpu_y->size[0] * nb_cpu_y->size[1];
              nb_cpu_y->size[0] = 1;
              nb_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(nb_cpu_y, i, &ob_emlrtRTEI);
              nb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                nb_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv57->size[0];
              cpu_iv57->size[0] = nb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv57, i, &nb_emlrtRTEI);
              n = nb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(nb_cpu_y, &nf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv57, &gpu_iv57, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&nf_gpu_y, nb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1004<<<grid, block>>>(offsetH, nf_gpu_y, n,
                  gpu_iv57);
              }

              if (cpu_origSiz[1] < 1) {
                n = 0;
              } else {
                n = cpu_origSiz[1];
              }

              wav_outdatedOnCpu = false;
              i = mc_cpu_y->size[0] * mc_cpu_y->size[1];
              mc_cpu_y->size[0] = 1;
              mc_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(mc_cpu_y, i, &ob_emlrtRTEI);
              if (n > 0) {
                mc_cpu_y->data[0] = 1;
                wav_outdatedOnCpu = true;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  mc_cpu_y->data[itime + 1] = nsubs;
                }
              }

              i = cpu_iv74->size[0];
              cpu_iv74->size[0] = mc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv74, i, &nb_emlrtRTEI);
              n = mc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(mc_cpu_y, &of_gpu_y,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv74, &gpu_iv74, true);
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&of_gpu_y, mc_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1005<<<grid, block>>>(of_gpu_y, n, gpu_iv74);
              }

              fx_size[0] = cpu_iv57->size[0];
              fx_size[1] = cpu_iv74->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1006<<<grid, block>>>(y_gpu_yCol, fx_size[0],
                  gpu_iv74, gpu_iv57, fx_size[0] - 1, fx_size[1] - 1,
                  cd_gpu_expanded, t_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              i = q_cpu_rows->size[0] * q_cpu_rows->size[1];
              q_cpu_rows->size[0] = 1;
              q_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(q_cpu_rows, i, &ob_emlrtRTEI);
              q_cpu_rows->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                q_cpu_rows->data[itime + 1] = nsubs;
              }

              i = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = static_cast<int32_T>(N);
              e_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_real32_T(e_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = cpu_lidx;
                if (cpu_lidx < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(bcoef),
                                 static_cast<uint32_T>(i), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(q_cpu_rows, &rc_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&rc_gpu_rows, q_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1007<<<grid, block>>>(cd_gpu_expanded,
                    rc_gpu_rows, b_gpu_h, OH - 1, ix - 1, sb_gpu_w,
                    b_cpu_h->size[0U], t_cpu_expanded->size[0U], e_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            kb_y = nullptr;
            m36 = emlrtCreateCharArray(2, &iv36[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m36, &rfmt[0]);
            emlrtAssign(&kb_y, m36);
            rb_y = nullptr;
            m43 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&rb_y, m43);
            emlrt_marshallIn(b_sprintf(kb_y, rb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (e_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = e_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = e_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel974<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel975<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = cb_cpu_w->size[0] * cb_cpu_w->size[1];
          cb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          cb_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(cb_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(cb_cpu_w, &tb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel976<<<grid, block>>>(sb_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lidx - 1, tb_gpu_w, cb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = xb_cpu_y->size[0] * xb_cpu_y->size[1];
          xb_cpu_y->size[0] = cpu_origSiz[0];
          xb_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(xb_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &if_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel977<<<grid, block>>>(tb_gpu_w, n, if_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = kb_cpu_w->size[0] * kb_cpu_w->size[1];
            kb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            kb_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_real32_T(kb_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(kb_cpu_w, &ub_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel978<<<grid, block>>>(sb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, ub_gpu_w, kb_cpu_w->size[0U]);
            }

            nsubs = xb_cpu_y->size[0] * xb_cpu_y->size[1];
            xb_cpu_y->size[0] = cpu_lidx;
            xb_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(xb_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &if_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel979<<<grid, block>>>(ub_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, if_gpu_y, xb_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = xb_cpu_y->size[0] * xb_cpu_y->size[1];
            i = yg_cpu_y->size[0] * yg_cpu_y->size[1];
            yg_cpu_y->size[0] = 1;
            yg_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(yg_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(yg_cpu_y, &jf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel980<<<grid, block>>>(if_gpu_y, omega_tmp2[0] - 1,
                jf_gpu_y, yg_cpu_y->size[0U]);
            }

            i = xb_cpu_y->size[0] * xb_cpu_y->size[1];
            xb_cpu_y->size[0] = 1;
            xb_cpu_y->size[1] = yg_cpu_y->size[1];
            emxEnsureCapacity_real32_T(xb_cpu_y, i, &qd_emlrtRTEI);
            n = yg_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &if_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel981<<<grid, block>>>(jf_gpu_y, n, if_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            i = sc_cpu_y->size[0] * sc_cpu_y->size[1];
            sc_cpu_y->size[0] = 1;
            sc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(sc_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(sc_cpu_y, &kf_gpu_y, true);
            h_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel982<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(kf_gpu_y);
          } else if (tol < 1.0) {
            sc_cpu_y->size[0] = 1;
            sc_cpu_y->size[1] = 0;
          } else {
            i = sc_cpu_y->size[0] * sc_cpu_y->size[1];
            sc_cpu_y->size[0] = 1;
            sc_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(sc_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(sc_cpu_y, &kf_gpu_y, true);
            h_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel984<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                kf_gpu_y);
            }
          }

          cpu_lidx = xb_cpu_y->size[1];
          i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = sc_cpu_y->size[1];
          cpu_opts_x->size[1] = xb_cpu_y->size[1];
          emxEnsureCapacity_real32_T(cpu_opts_x, i, &ed_emlrtRTEI);
          n = sc_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid,
            &block, 2147483647U);
          if (h_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(sc_cpu_y, &kf_gpu_y, true);
          }

          h_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel983<<<grid, block>>>(if_gpu_y, kf_gpu_y, T, n,
              cpu_lidx - 1, gpu_opts_x, cpu_opts_x->size[0U], xb_cpu_y->size[0U]);
          }
        }
      }
    } else {
      if (cpu_opts_x->size[0] == 1) {
        halfh = std::ceil(toler / b_m);
        i = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = static_cast<int32_T>(halfh);
        cpu_y1->size[1] = cpu_opts_x->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, i, &uc_emlrtRTEI);
        interval_outdatedOnGpu = true;
        bcoef = cpu_opts_x->size[1];
        if (cpu_opts_x->size[1] - 1 >= 0) {
          if ((static_cast<int32_T>(toler) == 0) || ((static_cast<int32_T>(toler)
                > 0) && (static_cast<int32_T>(toler) < 1))) {
            i71 = 1;
            i74 = 0;
          } else {
            i71 = static_cast<int32_T>(toler);
            i74 = static_cast<int32_T>(toler);
          }

          c_p = (static_cast<int32_T>(toler) == 1);
          Ly = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                         b_m);
        }

        for (fb_SignalPad = 0; fb_SignalPad < bcoef; fb_SignalPad++) {
          if (!(toler - 1.0 >= 0.0)) {
            u_y = nullptr;
            m16 = emlrtCreateCharArray(2, &iv26[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m16, &rfmt[0]);
            emlrtAssign(&u_y, m16);
            db_y = nullptr;
            m25 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&db_y, m25);
            emlrt_marshallIn(b_sprintf(u_y, db_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          i = cpu_yCol->size[0];
          cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(cpu_yCol, i, &cd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(cpu_yCol, &ab_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1036<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              ab_gpu_yCol);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(i74 - 1, i71)), &grid,
            &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1037<<<grid, block>>>(gpu_opts_x, fb_SignalPad, i71,
              div_s32(i74 - 1, i71), ab_gpu_yCol);
          }

          if (c_p && (b_cpu_h->size[0] == 1)) {
            i = g_cpu_w->size[0];
            g_cpu_w->size[0] = 1;
            emxEnsureCapacity_real32_T(g_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
            ec_wtcc_kernel1038<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
              ab_gpu_yCol, vb_gpu_w);
          } else if (b_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = b_cpu_h->size[0] + static_cast<int32_T>(toler);
            } else {
              nsubs = (b_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            i = g_cpu_w->size[0];
            g_cpu_w->size[0] = nsubs;
            emxEnsureCapacity_real32_T(g_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1043<<<grid, block>>>(nsubs - 1, vb_gpu_w);
            }

            if (static_cast<int32_T>(toler) != 0) {
              if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) == 1))
              {
                ec_wtcc_kernel1044<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (ab_gpu_yCol, gpu_cv_re);
                i = g_cpu_w->size[0];
                g_cpu_w->size[0] = 1;
                emxEnsureCapacity_real32_T(g_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
                ec_wtcc_kernel1045<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_cv_re, b_gpu_h, vb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (static_cast<int32_T>(toler))) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                               2.0) + std::floor((static_cast<real_T>(
                  static_cast<int32_T>(toler)) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (static_cast<int32_T>(toler) < MIN_int32_T - OH))
                {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (static_cast<int32_T>(toler) >
                                        MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + static_cast<int32_T>(toler);
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = h_cpu_expanded->size[0];
                h_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(h_cpu_expanded, i, &nb_emlrtRTEI);
                itime = (OH + static_cast<int32_T>(toler)) - 2;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(h_cpu_expanded, &hd_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1046<<<grid, block>>>(itime, hd_gpu_expanded);
                }

                i = b_cpu_h->size[0];
                nsubs = bb_cpu_y->size[0] * bb_cpu_y->size[1];
                bb_cpu_y->size[0] = 1;
                bb_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(bb_cpu_y, nsubs, &ob_emlrtRTEI);
                bb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= i - 2; itime++) {
                  nsubs++;
                  bb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv43->size[0];
                cpu_iv43->size[0] = bb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv43, i, &nb_emlrtRTEI);
                n = bb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(bb_cpu_y, &vf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv43, &gpu_iv43, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&vf_gpu_y, bb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1047<<<grid, block>>>(offsetH, vf_gpu_y, n,
                    gpu_iv43);
                }

                omega_tmp2[0] = cpu_iv43->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1048<<<grid, block>>>(b_gpu_h, gpu_iv43,
                    omega_tmp2[0] - 1, hd_gpu_expanded);
                }

                if (static_cast<int32_T>(toler) < -2147483647) {
                  i1Start = MIN_int32_T;
                  cpu_lidx = MIN_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(toler) - 1;
                  cpu_lidx = static_cast<int32_T>(toler) - 1;
                }

                i = e_cpu_rows->size[0] * e_cpu_rows->size[1];
                e_cpu_rows->size[0] = 1;
                e_cpu_rows->size[1] = cpu_lidx + 1;
                emxEnsureCapacity_int32_T(e_cpu_rows, i, &ob_emlrtRTEI);
                e_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime < i1Start; itime++) {
                  nsubs++;
                  e_cpu_rows->data[itime + 1] = nsubs;
                }

                i = g_cpu_w->size[0];
                g_cpu_w->size[0] = OH;
                emxEnsureCapacity_real32_T(g_cpu_w, i, &nb_emlrtRTEI);
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(N, 1U, 1U),
                  dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(e_cpu_rows, &wc_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&wc_gpu_rows, e_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1049<<<grid, block>>>(ab_gpu_yCol,
                    hd_gpu_expanded, wc_gpu_rows, toler, OH - 1, vb_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = static_cast<int32_T>(toler) + b_cpu_h->size[0];
            } else {
              nsubs = (static_cast<int32_T>(toler) + b_cpu_h->size[0]) - 1;
            }

            i = g_cpu_w->size[0];
            g_cpu_w->size[0] = nsubs;
            emxEnsureCapacity_real32_T(g_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1050<<<grid, block>>>(nsubs - 1, vb_gpu_w);
            }

            if (static_cast<int32_T>(toler) != 0) {
              if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] == 1))
              {
                i = g_cpu_w->size[0];
                g_cpu_w->size[0] = 1;
                emxEnsureCapacity_real32_T(g_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
                ec_wtcc_kernel1051<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (b_gpu_h, ab_gpu_yCol, vb_gpu_w);
              } else {
                r = (static_cast<real_T>(static_cast<int32_T>(toler)) +
                     static_cast<real_T>(b_cpu_h->size[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((OH < 0) && (b_cpu_h->size[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (b_cpu_h->size[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + b_cpu_h->size[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = g_cpu_expanded->size[0];
                g_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(g_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + b_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(g_cpu_expanded, &id_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1052<<<grid, block>>>(n, id_gpu_expanded);
                }

                n = static_cast<int32_T>(toler);
                i = ab_cpu_y->size[0] * ab_cpu_y->size[1];
                ab_cpu_y->size[0] = 1;
                ab_cpu_y->size[1] = static_cast<int32_T>(toler);
                emxEnsureCapacity_int32_T(ab_cpu_y, i, &ob_emlrtRTEI);
                ab_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ab_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv42->size[0];
                cpu_iv42->size[0] = ab_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv42, i, &nb_emlrtRTEI);
                n = ab_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ab_cpu_y, &wf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv42, &gpu_iv42, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&wf_gpu_y, ab_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1053<<<grid, block>>>(offsetH, wf_gpu_y, n,
                    gpu_iv42);
                }

                omega_tmp2[0] = cpu_iv42->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1054<<<grid, block>>>(ab_gpu_yCol, gpu_iv42,
                    omega_tmp2[0] - 1, id_gpu_expanded);
                }

                i = b_cpu_h->size[0];
                nsubs = d_cpu_rows->size[0] * d_cpu_rows->size[1];
                d_cpu_rows->size[0] = 1;
                d_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(d_cpu_rows, nsubs, &ob_emlrtRTEI);
                d_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= i - 2; itime++) {
                  nsubs++;
                  d_cpu_rows->data[itime + 1] = nsubs;
                }

                i = g_cpu_w->size[0];
                g_cpu_w->size[0] = OH;
                emxEnsureCapacity_real32_T(g_cpu_w, i, &nb_emlrtRTEI);
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(N, 1U, 1U),
                  dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(d_cpu_rows, &xc_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(g_cpu_w, &vb_gpu_w, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xc_gpu_rows, d_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1055<<<grid, block>>>(id_gpu_expanded,
                    xc_gpu_rows, b_gpu_h, OH - 1, vb_gpu_w, b_cpu_h->size[0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            fb_y = nullptr;
            m34 = emlrtCreateCharArray(2, &iv34[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m34, &rfmt[0]);
            emlrtAssign(&fb_y, m34);
            gb_y = nullptr;
            m40 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&gb_y, m40);
            emlrt_marshallIn(b_sprintf(fb_y, gb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          if (b_m == 0.0) {
            cpu_lidx = 1;
            ix = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            ix = g_cpu_w->size[0] - 1;
          }

          i = y_cpu_y->size[0];
          y_cpu_y->size[0] = div_s32(ix, cpu_lidx) + 1;
          emxEnsureCapacity_real32_T(y_cpu_y, i, &id_emlrtRTEI);
          itime = ix / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(y_cpu_y, &tf_gpu_y, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1039<<<grid, block>>>(vb_gpu_w, cpu_lidx, itime,
              tf_gpu_y);
          }

          if (!(div_s32(ix, cpu_lidx) + 1 < Ly)) {
            i = y_cpu_y->size[0];
            if (Ly < 1.0) {
              y_cpu_y->size[0] = 0;
            } else {
              y_cpu_y->size[0] = static_cast<int32_T>(Ly);
            }

            emxEnsureCapacity_real32_T(y_cpu_y, i, &kd_emlrtRTEI);
            wav_outdatedOnCpu = true;
          }

          if (std::isnan(halfh)) {
            i = cb_cpu_y->size[0] * cb_cpu_y->size[1];
            cb_cpu_y->size[0] = 1;
            cb_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(cb_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(cb_cpu_y, &uf_gpu_y, true);
            d_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel1040<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(uf_gpu_y);
          } else if (halfh < 1.0) {
            cb_cpu_y->size[0] = 1;
            cb_cpu_y->size[1] = 0;
          } else {
            i = cb_cpu_y->size[0] * cb_cpu_y->size[1];
            cb_cpu_y->size[0] = 1;
            cb_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(cb_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(cb_cpu_y, &uf_gpu_y, true);
            d_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1042<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), uf_gpu_y);
            }
          }

          cpu_lidx = cpu_y1->size[0];
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(y_cpu_y, &tf_gpu_y, true);
          }

          if (d_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cb_cpu_y, &uf_gpu_y, true);
          }

          d_y_needsGpuEnsureCapacity = false;
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
          }

          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1041<<<grid, block>>>(tf_gpu_y, uf_gpu_y, T,
              fb_SignalPad, cpu_lidx - 1, gpu_y1, cpu_y1->size[0U]);
          }
        }
      } else if ((toler == 1.0) && (b_m == 1.0)) {
        i = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = cpu_opts_x->size[0];
        cpu_y1->size[1] = cpu_opts_x->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, i, &rc_emlrtRTEI);
        n = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1058<<<grid, block>>>(gpu_opts_x, n, gpu_y1);
        }
      } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
        if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = cpu_opts_x->size[0];
          ix = cpu_opts_x->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
        if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            n_y = nullptr;
            m27 = emlrtCreateCharArray(2, &iv30[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m27, &rfmt[0]);
            emlrtAssign(&n_y, m27);
            w_y = nullptr;
            m31 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&w_y, m31);
            emlrt_marshallIn(b_sprintf(n_y, w_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          i = j_cpu_yCol->size[0];
          j_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(j_cpu_yCol, i, &cd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &bb_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1059<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              bb_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1060<<<grid, block>>>(gpu_opts_x, ix, div_s32(cpu_lidx
              - 1, ix), bb_gpu_yCol);
          }

          i = q_cpu_x->size[0] * q_cpu_x->size[1];
          q_cpu_x->size[0] = static_cast<int32_T>(toler);
          q_cpu_x->size[1] = 1;
          emxEnsureCapacity_real32_T(q_cpu_x, i, &id_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(q_cpu_x, &o_gpu_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1061<<<grid, block>>>(bb_gpu_yCol, static_cast<int32_T>
              (toler) - 1, o_gpu_x);
          }

          if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] == 1)) {
            i = k_cpu_w->size[0] * k_cpu_w->size[1];
            k_cpu_w->size[0] = 1;
            k_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel1062<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
              bb_gpu_yCol, wb_gpu_w);
          } else if (b_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (b_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            i = k_cpu_w->size[0] * k_cpu_w->size[1];
            k_cpu_w->size[0] = nsubs;
            k_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1074<<<grid, block>>>(nsubs - 1, wb_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = nsubs;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1075<<<grid, block>>>(nsubs - 1, wb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) ==
                        1)) {
              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = 1;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel1076<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (bb_gpu_yCol, b_gpu_h, wb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (static_cast<int32_T>(toler) < MIN_int32_T - OH))
              {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (static_cast<int32_T>(toler) > MAX_int32_T
                                      - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + static_cast<int32_T>(toler);
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = gb_cpu_expanded->size[0] * gb_cpu_expanded->size[1];
              gb_cpu_expanded->size[0] = i1Start;
              gb_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(gb_cpu_expanded, i, &nb_emlrtRTEI);
              itime = (OH + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(gb_cpu_expanded, &jd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1077<<<grid, block>>>(itime, jd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              i = rc_cpu_y->size[0] * rc_cpu_y->size[1];
              rc_cpu_y->size[0] = 1;
              rc_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(rc_cpu_y, i, &ob_emlrtRTEI);
              rc_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                rc_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv71->size[0];
              cpu_iv71->size[0] = rc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv71, i, &nb_emlrtRTEI);
              n = rc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(rc_cpu_y, &cg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv71, &gpu_iv71, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&cg_gpu_y, rc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1078<<<grid, block>>>(offsetH, cg_gpu_y, n,
                  gpu_iv71);
              }

              omega_tmp2[0] = cpu_iv71->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1079<<<grid, block>>>(b_gpu_h, gpu_iv71,
                  omega_tmp2[0] - 1, jd_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = static_cast<int32_T>(toler) - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = u_cpu_rows->size[0] * u_cpu_rows->size[1];
              u_cpu_rows->size[0] = 1;
              u_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(u_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                u_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  u_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = OH;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (OH != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                  1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(u_cpu_rows, &yc_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&yc_gpu_rows, u_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1080<<<grid, block>>>(bb_gpu_yCol,
                    jd_gpu_expanded, yc_gpu_rows, toler, OH - 1, wb_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (static_cast<int32_T>(toler) + b_cpu_h->size[0]) - 1;
            }

            i = k_cpu_w->size[0] * k_cpu_w->size[1];
            k_cpu_w->size[0] = nsubs;
            k_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1081<<<grid, block>>>(nsubs - 1, wb_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = nsubs;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1082<<<grid, block>>>(nsubs - 1, wb_gpu_w);
              }
            } else if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] ==
                        1)) {
              i = t_cpu_c->size[0];
              t_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(t_cpu_c, i, &ld_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(t_cpu_c, &v_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &o_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&v_gpu_c.data[0], 1), __FILE__, __LINE__);
              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = nsubs;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1083<<<grid, block>>>(v_gpu_c, nsubs - 1, wb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(static_cast<int32_T>(toler)) +
                   static_cast<uint32_T>(b_cpu_h->size[0])) - 1U;
              bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              i = fb_cpu_expanded->size[0] * fb_cpu_expanded->size[1];
              fb_cpu_expanded->size[0] = i1Start - 1;
              fb_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(fb_cpu_expanded, i, &nb_emlrtRTEI);
              n = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(fb_cpu_expanded, &kd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1084<<<grid, block>>>(n, kd_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              i = lc_cpu_y->size[0] * lc_cpu_y->size[1];
              lc_cpu_y->size[0] = 1;
              lc_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(lc_cpu_y, i, &ob_emlrtRTEI);
              lc_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                lc_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv73->size[0];
              cpu_iv73->size[0] = lc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv73, i, &nb_emlrtRTEI);
              n = lc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(lc_cpu_y, &dg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv73, &gpu_iv73, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&dg_gpu_y, lc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1085<<<grid, block>>>(offsetH, dg_gpu_y, n,
                  gpu_iv73);
              }

              fx_size[0] = cpu_iv73->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1086<<<grid, block>>>(bb_gpu_yCol, gpu_iv73,
                  fx_size[0] - 1, kd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              i = nb_cpu_rows->size[0] * nb_cpu_rows->size[1];
              nb_cpu_rows->size[0] = 1;
              nb_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(nb_cpu_rows, i, &ob_emlrtRTEI);
              nb_cpu_rows->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                nb_cpu_rows->data[itime + 1] = nsubs;
              }

              i = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = static_cast<int32_T>(N);
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                  1U), dim3(static_cast<uint32_T>(bcoef), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(nb_cpu_rows, &ad_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&ad_gpu_rows, nb_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1087<<<grid, block>>>(kd_gpu_expanded,
                    ad_gpu_rows, b_gpu_h, OH - 1, wb_gpu_w, b_cpu_h->size[0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            hb_y = nullptr;
            m48 = emlrtCreateCharArray(2, &iv41[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m48, &rfmt[0]);
            emlrtAssign(&hb_y, m48);
            ib_y = nullptr;
            m51 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&ib_y, m51);
            emlrt_marshallIn(b_sprintf(hb_y, ib_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (k_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = k_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = k_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1063<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1064<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = v_cpu_w->size[0] * v_cpu_w->size[1];
          v_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          v_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(v_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(k_cpu_w, &wb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(v_cpu_w, &xb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1065<<<grid, block>>>(wb_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lidx - 1, xb_gpu_w, v_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = vc_cpu_y->size[0] * vc_cpu_y->size[1];
          vc_cpu_y->size[0] = cpu_origSiz[0];
          vc_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(vc_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(vc_cpu_y, &xf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1066<<<grid, block>>>(xb_gpu_w, n, xf_gpu_y);
          }

          r = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                        b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = eb_cpu_w->size[0] * eb_cpu_w->size[1];
            eb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            eb_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_real32_T(eb_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(eb_cpu_w, &yb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1067<<<grid, block>>>(wb_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, yb_gpu_w, eb_cpu_w->size[0U]);
            }

            nsubs = vc_cpu_y->size[0] * vc_cpu_y->size[1];
            vc_cpu_y->size[0] = cpu_lidx;
            vc_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(vc_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(vc_cpu_y, &xf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1068<<<grid, block>>>(yb_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, xf_gpu_y, vc_cpu_y->size[0U]);
            }
          }

          if (vc_cpu_y->size[0] * vc_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = vc_cpu_y->size[0] * vc_cpu_y->size[1];
          }

          omega_tmp2[0] = vc_cpu_y->size[0] * vc_cpu_y->size[1];
          i = xg_cpu_y->size[0] * xg_cpu_y->size[1];
          xg_cpu_y->size[0] = 1;
          xg_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(xg_cpu_y, i, &od_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(xg_cpu_y, &yf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1069<<<grid, block>>>(xf_gpu_y, omega_tmp2[0] - 1,
              yf_gpu_y);
          }

          i = wb_cpu_y->size[0] * wb_cpu_y->size[1];
          wb_cpu_y->size[0] = n;
          wb_cpu_y->size[1] = 1;
          emxEnsureCapacity_real32_T(wb_cpu_y, i, &pd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ag_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1070<<<grid, block>>>(yf_gpu_y, n - 1, ag_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            m_y = nullptr;
            m15 = emlrtCreateCharArray(2, &iv25[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m15, &rfmt[0]);
            emlrtAssign(&m_y, m15);
            v_y = nullptr;
            m24 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&v_y, m24);
            emlrt_marshallIn(b_sprintf(m_y, v_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = cpu_opts_x->size[itime];
          }

          cpu_lidx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          i = d_cpu_yCol->size[0];
          d_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(d_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(d_cpu_yCol, &cb_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1088<<<grid, block>>>(itime, cb_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1089<<<grid, block>>>(gpu_opts_x, ix, div_s32(cpu_lidx
              - 1, ix), cb_gpu_yCol);
          }

          cpu_origSiz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
          i = k_cpu_x->size[0] * k_cpu_x->size[1];
          k_cpu_x->size[0] = cpu_origSiz[0];
          k_cpu_x->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_real32_T(k_cpu_x, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(k_cpu_x, &p_gpu_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1090<<<grid, block>>>(cb_gpu_yCol, n, p_gpu_x);
          }

          if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (cpu_opts_x->size[1] < 1) {
              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel1091<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (ac_gpu_w);
            } else {
              i = cpu_opts_x->size[1];
              nsubs = g_cpu_a->size[0];
              g_cpu_a->size[0] = cpu_opts_x->size[1];
              emxEnsureCapacity_real32_T(g_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(g_cpu_a, &t_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1098<<<grid, block>>>(cb_gpu_yCol, i - 1, t_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              i = f_cpu_c->size[0];
              f_cpu_c->size[0] = g_cpu_a->size[0];
              emxEnsureCapacity_real32_T(f_cpu_c, i, &lb_emlrtRTEI);
              n = g_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_c, &w_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1099<<<grid, block>>>(n, w_gpu_c);
              }

              if (g_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                i = f_cpu_c->size[0];
                f_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(f_cpu_c, i, &lb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(f_cpu_c, &w_gpu_c, true);
                ec_wtcc_kernel1100<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, t_gpu_a, w_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (g_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(g_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                   (bcoef)));
                OH = g_cpu_a->size[0];
                if (g_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = g_cpu_a->size[0] + 1;
                }

                i = o_cpu_expanded->size[0];
                o_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_real32_T(o_cpu_expanded, i, &nb_emlrtRTEI);
                n = g_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(o_cpu_expanded, &ld_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1102<<<grid, block>>>(n, ld_gpu_expanded);
                }

                n = g_cpu_a->size[0];
                i = jb_cpu_y->size[0] * jb_cpu_y->size[1];
                jb_cpu_y->size[0] = 1;
                jb_cpu_y->size[1] = g_cpu_a->size[0];
                emxEnsureCapacity_int32_T(jb_cpu_y, i, &ob_emlrtRTEI);
                jb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  jb_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv48->size[0];
                cpu_iv48->size[0] = jb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv48, i, &nb_emlrtRTEI);
                n = jb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(jb_cpu_y, &eg_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv48, &gpu_iv48, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&eg_gpu_y, jb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1103<<<grid, block>>>(eg_gpu_y, n, gpu_iv48);
                }

                omega_tmp2[0] = cpu_iv48->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1104<<<grid, block>>>(t_gpu_a, gpu_iv48,
                    omega_tmp2[0] - 1, ld_gpu_expanded);
                }

                i = f_cpu_c->size[0];
                f_cpu_c->size[0] = g_cpu_a->size[0];
                emxEnsureCapacity_real32_T(f_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_real32_T(f_cpu_c, &w_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1105<<<grid, block>>>(cpu_cv_re, ld_gpu_expanded,
                    OH - 1, w_gpu_c);
                }
              }

              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = f_cpu_c->size[0];
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              n = f_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1101<<<grid, block>>>(w_gpu_c, n, ac_gpu_w,
                  d_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_opts_x->size[1];
            }

            i = d_cpu_w->size[0] * d_cpu_w->size[1];
            d_cpu_w->size[0] = nsubs;
            d_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1106<<<grid, block>>>(itime, ac_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = nsubs;
              d_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1107<<<grid, block>>>(itime, ac_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (cpu_opts_x->size[1] == 1))) {
              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel1108<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cb_gpu_yCol, b_gpu_h, ac_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_opts_x->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = s_cpu_expanded->size[0] * s_cpu_expanded->size[1];
              s_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(s_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_opts_x->size[1] + cpu_opts_x->size[1];
              }

              i = s_cpu_expanded->size[0] * s_cpu_expanded->size[1];
              s_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_real32_T(s_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_opts_x->size[1] +
                cpu_opts_x->size[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(s_cpu_expanded, &md_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1109<<<grid, block>>>(n, md_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              i = pb_cpu_y->size[0] * pb_cpu_y->size[1];
              pb_cpu_y->size[0] = 1;
              pb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(pb_cpu_y, i, &ob_emlrtRTEI);
              pb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                pb_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv53->size[0];
              cpu_iv53->size[0] = pb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv53, i, &nb_emlrtRTEI);
              n = pb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pb_cpu_y, &fg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv53, &gpu_iv53, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&fg_gpu_y, pb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1110<<<grid, block>>>(offsetH, fg_gpu_y, n,
                  gpu_iv53);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::floor
                ((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv53->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1111<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv53,
                  omega_tmp2[0] - 1, md_gpu_expanded, s_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = h_cpu_rows->size[0] * h_cpu_rows->size[1];
              h_cpu_rows->size[0] = 1;
              h_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(h_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                h_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  h_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              n = cpu_opts_x->size[1];
              i = c_cpu_cols->size[0] * c_cpu_cols->size[1];
              c_cpu_cols->size[0] = 1;
              c_cpu_cols->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(c_cpu_cols, i, &ob_emlrtRTEI);
              c_cpu_cols->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                c_cpu_cols->data[itime + 1] = nsubs;
              }

              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = OH;
              d_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_real32_T(d_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (OH != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                  (static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims[1]),
                   1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(c_cpu_cols, &k_gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(h_cpu_rows, &bd_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&k_gpu_cols, c_cpu_cols);
                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&bd_gpu_rows, h_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1112<<<grid, block>>>(cb_gpu_yCol,
                    md_gpu_expanded, k_gpu_cols, bd_gpu_rows, *gpu_origSiz, OH -
                    1, ix - 1, ac_gpu_w, s_cpu_expanded->size[0U], d_cpu_w->
                    size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_opts_x->size[1];
            }

            i = d_cpu_w->size[0] * d_cpu_w->size[1];
            d_cpu_w->size[0] = nsubs;
            d_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1113<<<grid, block>>>(itime, ac_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = nsubs;
              d_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1114<<<grid, block>>>(itime, ac_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              i = n_cpu_c->size[0];
              n_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(n_cpu_c, i, &ld_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(n_cpu_c, &x_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &p_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&x_gpu_c.data[0], 1), __FILE__, __LINE__);
              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = nsubs;
              d_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_real32_T(d_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1115<<<grid, block>>>(x_gpu_c, itime, ac_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              ix = cpu_opts_x->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              i = r_cpu_expanded->size[0] * r_cpu_expanded->size[1];
              r_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_real32_T(r_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_opts_x->size[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_opts_x->size[1] + 1;
              }

              i = r_cpu_expanded->size[0] * r_cpu_expanded->size[1];
              r_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_real32_T(r_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(r_cpu_expanded, &nd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1116<<<grid, block>>>(n, nd_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = mb_cpu_y->size[0] * mb_cpu_y->size[1];
              mb_cpu_y->size[0] = 1;
              mb_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(mb_cpu_y, i, &ob_emlrtRTEI);
              mb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                mb_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv56->size[0];
              cpu_iv56->size[0] = mb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv56, i, &nb_emlrtRTEI);
              n = mb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(mb_cpu_y, &gg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv56, &gpu_iv56, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&gg_gpu_y, mb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1117<<<grid, block>>>(offsetH, gg_gpu_y, n,
                  gpu_iv56);
              }

              n = cpu_opts_x->size[1];
              i = kc_cpu_y->size[0] * kc_cpu_y->size[1];
              kc_cpu_y->size[0] = 1;
              kc_cpu_y->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(kc_cpu_y, i, &ob_emlrtRTEI);
              kc_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                kc_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv72->size[0];
              cpu_iv72->size[0] = kc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv72, i, &nb_emlrtRTEI);
              n = kc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(kc_cpu_y, &hg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv72, &gpu_iv72, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&hg_gpu_y, kc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1118<<<grid, block>>>(hg_gpu_y, n, gpu_iv72);
              }

              fx_size[0] = cpu_iv56->size[0];
              fx_size[1] = cpu_iv72->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1119<<<grid, block>>>(cb_gpu_yCol, fx_size[0],
                  gpu_iv72, gpu_iv56, fx_size[0] - 1, fx_size[1] - 1,
                  nd_gpu_expanded, r_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              i = p_cpu_rows->size[0] * p_cpu_rows->size[1];
              p_cpu_rows->size[0] = 1;
              p_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(p_cpu_rows, i, &ob_emlrtRTEI);
              p_cpu_rows->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                p_cpu_rows->data[itime + 1] = nsubs;
              }

              i = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = static_cast<int32_T>(N);
              d_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_real32_T(d_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                  (static_cast<uint32_T>(bcoef), static_cast<uint32_T>(
                  static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(p_cpu_rows, &cd_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&cd_gpu_rows, p_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1120<<<grid, block>>>(nd_gpu_expanded,
                    cd_gpu_rows, b_gpu_h, OH - 1, ix - 1, ac_gpu_w,
                    b_cpu_h->size[0U], r_cpu_expanded->size[0U], d_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            jb_y = nullptr;
            m35 = emlrtCreateCharArray(2, &iv35[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m35, &rfmt[0]);
            emlrtAssign(&jb_y, m35);
            qb_y = nullptr;
            m42 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&qb_y, m42);
            emlrt_marshallIn(b_sprintf(jb_y, qb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (d_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = d_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = d_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1092<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1093<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = bb_cpu_w->size[0] * bb_cpu_w->size[1];
          bb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          bb_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(bb_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &ac_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(bb_cpu_w, &bc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1094<<<grid, block>>>(ac_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lidx - 1, bc_gpu_w, bb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = wb_cpu_y->size[0] * wb_cpu_y->size[1];
          wb_cpu_y->size[0] = cpu_origSiz[0];
          wb_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(wb_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ag_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1095<<<grid, block>>>(bc_gpu_w, n, ag_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            jb_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_real32_T(jb_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(jb_cpu_w, &cc_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1096<<<grid, block>>>(ac_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, cc_gpu_w, jb_cpu_w->size[0U]);
            }

            nsubs = wb_cpu_y->size[0] * wb_cpu_y->size[1];
            wb_cpu_y->size[0] = cpu_lidx;
            wb_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(wb_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ag_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1097<<<grid, block>>>(cc_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, ag_gpu_y, wb_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          i = qc_cpu_y->size[0] * qc_cpu_y->size[1];
          qc_cpu_y->size[0] = 1;
          qc_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(qc_cpu_y, i, &h_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(qc_cpu_y, &bg_gpu_y, true);
          g_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel1071<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(bg_gpu_y);
        } else if (halfh < 1.0) {
          qc_cpu_y->size[0] = 1;
          qc_cpu_y->size[1] = 0;
        } else {
          i = qc_cpu_y->size[0] * qc_cpu_y->size[1];
          qc_cpu_y->size[0] = 1;
          qc_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(qc_cpu_y, i, &h_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(qc_cpu_y, &bg_gpu_y, true);
          g_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1073<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              bg_gpu_y);
          }
        }

        i = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = static_cast<int32_T>(halfh);
        cpu_y1->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_y1, i, &rc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (g_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(qc_cpu_y, &bg_gpu_y, true);
        }

        g_y_needsGpuEnsureCapacity = false;
        gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1072<<<grid, block>>>(ag_gpu_y, bg_gpu_y, T,
            static_cast<int32_T>(halfh) - 1, gpu_y1);
        }
      } else {
        tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
        first_iteration = (cpu_opts_x->size[0] == 1);
        if (first_iteration) {
          i = cpu_xCol->size[0] * cpu_xCol->size[1];
          cpu_xCol->size[0] = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_xCol->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_xCol, i, &yc_emlrtRTEI);
          n = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(cpu_xCol, &b_gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1149<<<grid, block>>>(gpu_opts_x, n, b_gpu_xCol);
          }
        } else {
          i = cpu_xCol->size[0] * cpu_xCol->size[1];
          cpu_xCol->size[0] = cpu_opts_x->size[0];
          cpu_xCol->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_real32_T(cpu_xCol, i, &xc_emlrtRTEI);
          n = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(cpu_xCol, &b_gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1216<<<grid, block>>>(gpu_opts_x, n, b_gpu_xCol);
          }
        }

        if (!(toler - 1.0 >= 0.0)) {
          cb_y = nullptr;
          m17 = emlrtCreateCharArray(2, &iv27[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m17, &rfmt[0]);
          emlrtAssign(&cb_y, m17);
          eb_y = nullptr;
          m26 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&eb_y, m26);
          emlrt_marshallIn(b_sprintf(cb_y, eb_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        offsetH = cpu_xCol->size[0] * cpu_xCol->size[1];
        if ((cpu_xCol->size[0] == 1) && (cpu_xCol->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (cpu_xCol->size[0] != 1) {
            nsubs = 0;
          }
        }

        for (itime = 0; itime < 2; itime++) {
          cpu_origSiz[itime] = cpu_xCol->size[itime];
        }

        cpu_lidx = cpu_xCol->size[0] * cpu_xCol->size[1];
        i = g_cpu_yCol->size[0];
        g_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
        emxEnsureCapacity_real32_T(g_cpu_yCol, i, &cd_emlrtRTEI);
        itime = offsetH * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(g_cpu_yCol, &db_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1150<<<grid, block>>>(itime, db_gpu_yCol);
        }

        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (cpu_lidx * static_cast<
               int32_T>(toler) > 1)))) {
          ix = 1;
          cpu_lidx = 0;
        } else {
          ix = static_cast<int32_T>(toler);
          cpu_lidx = offsetH * static_cast<int32_T>(toler);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1151<<<grid, block>>>(b_gpu_xCol, ix, div_s32(cpu_lidx -
            1, ix), db_gpu_yCol);
        }

        cpu_origSiz[nsubs] = cpu_xCol->size[nsubs] * static_cast<int32_T>(toler);
        i = n_cpu_x->size[0] * n_cpu_x->size[1];
        n_cpu_x->size[0] = cpu_origSiz[0];
        n_cpu_x->size[1] = cpu_origSiz[1];
        emxEnsureCapacity_real32_T(n_cpu_x, i, &id_emlrtRTEI);
        n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(n_cpu_x, &q_gpu_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1152<<<grid, block>>>(db_gpu_yCol, n, q_gpu_x);
        }

        if ((cpu_origSiz[0] == 1) && (b_cpu_h->size[0] == 1)) {
          if (cpu_origSiz[1] < 1) {
            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = 1;
            h_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel1153<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(dc_gpu_w);
          } else {
            nsubs = j_cpu_a->size[0];
            j_cpu_a->size[0] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(j_cpu_a, nsubs, &jb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(j_cpu_a, &u_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1165<<<grid, block>>>(db_gpu_yCol, cpu_origSiz[1] -
                1, u_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
            cpu_cv_re = b_cpu_h->data[0];
            i = i_cpu_c->size[0];
            i_cpu_c->size[0] = j_cpu_a->size[0];
            emxEnsureCapacity_real32_T(i_cpu_c, i, &lb_emlrtRTEI);
            n = j_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_c, &y_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1166<<<grid, block>>>(n, y_gpu_c);
            }

            if (j_cpu_a->size[0] == 1) {
              cpu_cv_re = b_cpu_h->data[0];
              i = i_cpu_c->size[0];
              i_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(i_cpu_c, i, &lb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(i_cpu_c, &y_gpu_c, true);
              ec_wtcc_kernel1167<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cpu_cv_re, u_gpu_a, y_gpu_c);
            } else {
              bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (j_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(j_cpu_a->size[0]) +
                static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
              OH = j_cpu_a->size[0];
              if (j_cpu_a->size[0] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = j_cpu_a->size[0] + 1;
              }

              i = x_cpu_expanded->size[0];
              x_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_real32_T(x_cpu_expanded, i, &nb_emlrtRTEI);
              n = j_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(x_cpu_expanded, &sd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1169<<<grid, block>>>(n, sd_gpu_expanded);
              }

              n = j_cpu_a->size[0];
              i = ub_cpu_y->size[0] * ub_cpu_y->size[1];
              ub_cpu_y->size[0] = 1;
              ub_cpu_y->size[1] = j_cpu_a->size[0];
              emxEnsureCapacity_int32_T(ub_cpu_y, i, &ob_emlrtRTEI);
              ub_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                ub_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv59->size[0];
              cpu_iv59->size[0] = ub_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv59, i, &nb_emlrtRTEI);
              n = ub_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ub_cpu_y, &pg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv59, &gpu_iv59, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&pg_gpu_y, ub_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1170<<<grid, block>>>(pg_gpu_y, n, gpu_iv59);
              }

              omega_tmp2[0] = cpu_iv59->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1171<<<grid, block>>>(u_gpu_a, gpu_iv59,
                  omega_tmp2[0] - 1, sd_gpu_expanded);
              }

              i = i_cpu_c->size[0];
              i_cpu_c->size[0] = j_cpu_a->size[0];
              emxEnsureCapacity_real32_T(i_cpu_c, i, &nb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(OH - 1), dim3
                (static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                &grid, &block);
              gpuEmxEnsureCapacity_real32_T(i_cpu_c, &y_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1172<<<grid, block>>>(cpu_cv_re, sd_gpu_expanded,
                  OH - 1, y_gpu_c);
              }
            }

            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = 1;
            h_cpu_w->size[1] = i_cpu_c->size[0];
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            n = i_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1168<<<grid, block>>>(y_gpu_c, n, dc_gpu_w,
                h_cpu_w->size[0U]);
            }
          }
        } else if (b_cpu_h->size[0] > cpu_origSiz[0]) {
          if (cpu_origSiz[0] == 0) {
            nsubs = b_cpu_h->size[0];
          } else {
            nsubs = (b_cpu_h->size[0] + cpu_origSiz[0]) - 1;
          }

          if (cpu_origSiz[1] == 0) {
            cpu_lidx = 1;
          } else {
            cpu_lidx = cpu_origSiz[1];
          }

          i = h_cpu_w->size[0] * h_cpu_w->size[1];
          h_cpu_w->size[0] = nsubs;
          h_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
          itime = nsubs * cpu_lidx - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1173<<<grid, block>>>(itime, dc_gpu_w);
          }

          if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = nsubs;
            h_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1174<<<grid, block>>>(itime, dc_gpu_w);
            }
          } else if ((b_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                      (cpu_origSiz[1] == 1))) {
            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = 1;
            h_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel1175<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (db_gpu_yCol, b_gpu_h, dc_gpu_w);
          } else {
            r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                 (cpu_origSiz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (cpu_origSiz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              i = static_cast<int32_T>(s);
            } else {
              i = MIN_int32_T;
            }

            b_blockDims[0] = i;
            b_blockDims[1] = cpu_lidx;
            ix = cpu_origSiz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                OH = static_cast<int32_T>(r);
              } else {
                OH = MIN_int32_T;
              }
            } else {
              OH = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
              floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
              i1Start = MIN_int32_T;
            } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = OH + cpu_origSiz[0];
            }

            if (i1Start >= -2147483647) {
              i1Start--;
            }

            i = ab_cpu_expanded->size[0] * ab_cpu_expanded->size[1];
            ab_cpu_expanded->size[0] = i1Start;
            emxEnsureCapacity_real32_T(ab_cpu_expanded, i, &nb_emlrtRTEI);
            if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                 - cpu_origSiz[1])) {
              i1Start = MIN_int32_T;
            } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T
                        - cpu_origSiz[1])) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = cpu_origSiz[1] + cpu_origSiz[1];
            }

            if (i1Start >= -2147483647) {
              i1Start--;
            }

            i = ab_cpu_expanded->size[0] * ab_cpu_expanded->size[1];
            ab_cpu_expanded->size[1] = i1Start;
            emxEnsureCapacity_real32_T(ab_cpu_expanded, i, &nb_emlrtRTEI);
            n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
              - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(ab_cpu_expanded, &td_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1176<<<grid, block>>>(n, td_gpu_expanded);
            }

            n = b_cpu_h->size[0];
            i = ac_cpu_y->size[0] * ac_cpu_y->size[1];
            ac_cpu_y->size[0] = 1;
            ac_cpu_y->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(ac_cpu_y, i, &ob_emlrtRTEI);
            ac_cpu_y->data[0] = 1;
            nsubs = 1;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              ac_cpu_y->data[itime + 1] = nsubs;
            }

            i = cpu_iv62->size[0];
            cpu_iv62->size[0] = ac_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv62, i, &nb_emlrtRTEI);
            n = ac_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(ac_cpu_y, &qg_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv62, &gpu_iv62, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&qg_gpu_y, ac_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1177<<<grid, block>>>(offsetH, qg_gpu_y, n, gpu_iv62);
            }

            s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
              floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv62->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1178<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv62,
                omega_tmp2[0] - 1, td_gpu_expanded, ab_cpu_expanded->size[0U]);
            }

            if (cpu_origSiz[0] < -2147483647) {
              i1Start = MIN_int32_T;
            } else {
              i1Start = cpu_origSiz[0] - 1;
            }

            if (i1Start < 0) {
              n = 0;
            } else {
              n = i1Start + 1;
            }

            y_outdatedOnCpu = false;
            i = m_cpu_rows->size[0] * m_cpu_rows->size[1];
            m_cpu_rows->size[0] = 1;
            m_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(m_cpu_rows, i, &ob_emlrtRTEI);
            if (n > 0) {
              m_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                m_cpu_rows->data[itime + 1] = nsubs;
              }
            }

            if (cpu_origSiz[1] < -2147483647) {
              i1Start = MIN_int32_T;
            } else {
              i1Start = cpu_origSiz[1] - 1;
            }

            if (i1Start < 0) {
              n = 0;
            } else {
              n = i1Start + 1;
            }

            wav_outdatedOnCpu = false;
            i = f_cpu_cols->size[0] * f_cpu_cols->size[1];
            f_cpu_cols->size[0] = 1;
            f_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(f_cpu_cols, i, &ob_emlrtRTEI);
            if (n > 0) {
              f_cpu_cols->data[0] = 0;
              wav_outdatedOnCpu = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                f_cpu_cols->data[itime + 1] = nsubs;
              }
            }

            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = OH;
            h_cpu_w->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(h_cpu_w, i, &nb_emlrtRTEI);
            fb_Omega_outdatedOnCpu = true;
            if ((OH != 0) && (cpu_origSiz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              i = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                i = 0;
              }

              nsubs = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                nsubs = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                               (nsubs), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(f_cpu_cols, &l_gpu_cols,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(m_cpu_rows, &hd_gpu_rows,
                !y_outdatedOnCpu);
              gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&l_gpu_cols, f_cpu_cols);
              }

              if (y_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&hd_gpu_rows, m_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1179<<<grid, block>>>(db_gpu_yCol, td_gpu_expanded,
                  l_gpu_cols, hd_gpu_rows, *gpu_origSiz, OH - 1, ix - 1,
                  dc_gpu_w, ab_cpu_expanded->size[0U], h_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (cpu_origSiz[0] == 0) {
            nsubs = b_cpu_h->size[0];
          } else {
            nsubs = (cpu_origSiz[0] + b_cpu_h->size[0]) - 1;
          }

          if (cpu_origSiz[1] == 0) {
            cpu_lidx = 1;
          } else {
            cpu_lidx = cpu_origSiz[1];
          }

          i = h_cpu_w->size[0] * h_cpu_w->size[1];
          h_cpu_w->size[0] = nsubs;
          h_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
          itime = nsubs * cpu_lidx - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1180<<<grid, block>>>(itime, dc_gpu_w);
          }

          if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = nsubs;
            h_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1181<<<grid, block>>>(itime, dc_gpu_w);
            }
          } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                     (b_cpu_h->size[0] == 1)) {
            i = q_cpu_c->size[0];
            q_cpu_c->size[0] = 1;
            emxEnsureCapacity_real32_T(q_cpu_c, i, &ld_emlrtRTEI);
            cpu_cv_re = 1.0F;
            cv_im = 0.0F;
            gpuEmxEnsureCapacity_real32_T(q_cpu_c, &ab_gpu_c, true);
            cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
              CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)&q_gpu_x.data
              [0], 1, (float *)&b_gpu_h.data[0], 1, (float *)&cv_im, (float *)
              &ab_gpu_c.data[0], 1), __FILE__, __LINE__);
            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = nsubs;
            h_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(h_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1182<<<grid, block>>>(ab_gpu_c, itime, dc_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                 (b_cpu_h->size[0])) - 1U;
            bcoef = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (cpu_origSiz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((static_cast<real_T>(N) +
              (static_cast<real_T>(bcoef) - 1.0)) / static_cast<real_T>(bcoef));
            c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            ix = cpu_origSiz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            OH = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = static_cast<int32_T>(N) + b_cpu_h->size[0];
            }

            i = y_cpu_expanded->size[0] * y_cpu_expanded->size[1];
            y_cpu_expanded->size[0] = i1Start - 1;
            emxEnsureCapacity_real32_T(y_cpu_expanded, i, &nb_emlrtRTEI);
            if (cpu_origSiz[1] > 2147483646) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = cpu_origSiz[1] + 1;
            }

            i = y_cpu_expanded->size[0] * y_cpu_expanded->size[1];
            y_cpu_expanded->size[1] = i1Start - 1;
            emxEnsureCapacity_real32_T(y_cpu_expanded, i, &nb_emlrtRTEI);
            n = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
              cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(y_cpu_expanded, &ud_gpu_expanded, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1183<<<grid, block>>>(n, ud_gpu_expanded);
            }

            n = cpu_origSiz[0];
            i = vb_cpu_y->size[0] * vb_cpu_y->size[1];
            vb_cpu_y->size[0] = 1;
            vb_cpu_y->size[1] = cpu_origSiz[0];
            emxEnsureCapacity_int32_T(vb_cpu_y, i, &ob_emlrtRTEI);
            vb_cpu_y->data[0] = 1;
            nsubs = 1;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              vb_cpu_y->data[itime + 1] = nsubs;
            }

            i = cpu_iv63->size[0];
            cpu_iv63->size[0] = vb_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv63, i, &nb_emlrtRTEI);
            n = vb_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(vb_cpu_y, &rg_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv63, &gpu_iv63, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&rg_gpu_y, vb_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1184<<<grid, block>>>(offsetH, rg_gpu_y, n, gpu_iv63);
            }

            if (cpu_origSiz[1] < 1) {
              n = 0;
            } else {
              n = cpu_origSiz[1];
            }

            wav_outdatedOnCpu = false;
            i = uc_cpu_y->size[0] * uc_cpu_y->size[1];
            uc_cpu_y->size[0] = 1;
            uc_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(uc_cpu_y, i, &ob_emlrtRTEI);
            if (n > 0) {
              uc_cpu_y->data[0] = 1;
              wav_outdatedOnCpu = true;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                uc_cpu_y->data[itime + 1] = nsubs;
              }
            }

            i = cpu_iv80->size[0];
            cpu_iv80->size[0] = uc_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv80, i, &nb_emlrtRTEI);
            n = uc_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(uc_cpu_y, &sg_gpu_y, !wav_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv80, &gpu_iv80, true);
            if (wav_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&sg_gpu_y, uc_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1185<<<grid, block>>>(sg_gpu_y, n, gpu_iv80);
            }

            fx_size[0] = cpu_iv63->size[0];
            fx_size[1] = cpu_iv80->size[0];
            mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1186<<<grid, block>>>(db_gpu_yCol, fx_size[0],
                gpu_iv80, gpu_iv63, fx_size[0] - 1, fx_size[1] - 1,
                ud_gpu_expanded, y_cpu_expanded->size[0U]);
            }

            n = b_cpu_h->size[0];
            i = x_cpu_rows->size[0] * x_cpu_rows->size[1];
            x_cpu_rows->size[0] = 1;
            x_cpu_rows->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(x_cpu_rows, i, &ob_emlrtRTEI);
            x_cpu_rows->data[0] = 0;
            nsubs = 0;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              x_cpu_rows->data[itime + 1] = nsubs;
            }

            i = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = static_cast<int32_T>(N);
            h_cpu_w->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_real32_T(h_cpu_w, i, &nb_emlrtRTEI);
            fb_Omega_outdatedOnCpu = true;
            if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              i = cpu_lidx;
              if (cpu_lidx < 0) {
                i = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                b_u, 1U), dim3(static_cast<uint32_T>(bcoef),
                               static_cast<uint32_T>(i), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(x_cpu_rows, &id_gpu_rows, false);
              gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              gpuEmxMemcpyCpuToGpu_int32_T(&id_gpu_rows, x_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1187<<<grid, block>>>(ud_gpu_expanded, id_gpu_rows,
                  b_gpu_h, OH - 1, ix - 1, dc_gpu_w, b_cpu_h->size[0U],
                  y_cpu_expanded->size[0U], h_cpu_w->size[0U]);
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          xb_y = nullptr;
          m41 = emlrtCreateCharArray(2, &iv38[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m41, &rfmt[0]);
          emlrtAssign(&xb_y, m41);
          yb_y = nullptr;
          m47 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&yb_y, m47);
          emlrt_marshallIn(b_sprintf(xb_y, yb_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (h_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        wav_outdatedOnCpu = false;
        interval_outdatedOnGpu = false;
        for (itime = 0; itime < 2; itime++) {
          cpu_origSiz[itime] = h_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
          cpu_lshift[itime] = h_cpu_w->size[itime];
          wav_outdatedOnCpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (wav_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1154<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *gpu_lshift);
          }

          checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        cpu_lidx = cpu_lshift[0];
        cpu_lshift[0] = cpu_lshift[1];
        cpu_lshift[1] = cpu_lidx;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
          ix = 1;
          bcoef = -1;
        } else {
          ix = static_cast<int32_T>(b_m);
          bcoef = cpu_lshift[0] - 1;
        }

        if (interval_outdatedOnGpu) {
          checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel1155<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
          nsubs, *gpu_origSiz);
        i = mb_cpu_w->size[0] * mb_cpu_w->size[1];
        mb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
        mb_cpu_w->size[1] = cpu_lidx;
        emxEnsureCapacity_real32_T(mb_cpu_w, i, &nd_emlrtRTEI);
        itime = bcoef / ix;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
          &block, 2147483647U);
        if (fb_Omega_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real32_T(h_cpu_w, &dc_gpu_w, true);
        }

        gpuEmxEnsureCapacity_real32_T(mb_cpu_w, &ec_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1156<<<grid, block>>>(dc_gpu_w, cpu_lshift[0], ix, itime,
            cpu_lidx - 1, ec_gpu_w, mb_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        i = jc_cpu_y->size[0] * jc_cpu_y->size[1];
        jc_cpu_y->size[0] = cpu_origSiz[0];
        jc_cpu_y->size[1] = cpu_origSiz[1];
        emxEnsureCapacity_real32_T(jc_cpu_y, i, &id_emlrtRTEI);
        n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(jc_cpu_y, &mg_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1157<<<grid, block>>>(ec_gpu_w, n, mg_gpu_y);
        }

        r = std::ceil(((static_cast<real_T>(cpu_xCol->size[0]) - 1.0) * toler +
                       static_cast<real_T>(b_cpu_h->size[0])) / b_m);
        if (!(cpu_origSiz[0] < r)) {
          if (r < 1.0) {
            cpu_lidx = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(r);
          }

          nsubs = nb_cpu_w->size[0] * nb_cpu_w->size[1];
          nb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          nb_cpu_w->size[1] = cpu_lshift[1];
          emxEnsureCapacity_real32_T(nb_cpu_w, nsubs, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(nb_cpu_w, &fc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1158<<<grid, block>>>(dc_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lshift[1] - 1, fc_gpu_w, nb_cpu_w->size[0U]);
          }

          nsubs = jc_cpu_y->size[0] * jc_cpu_y->size[1];
          jc_cpu_y->size[0] = cpu_lidx;
          jc_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_real32_T(jc_cpu_y, nsubs, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(jc_cpu_y, &mg_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1159<<<grid, block>>>(fc_gpu_w, cpu_origSiz[0],
              cpu_lidx - 1, cpu_origSiz[1] - 1, mg_gpu_y, jc_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = jc_cpu_y->size[0] * jc_cpu_y->size[1];
          i = dh_cpu_y->size[0] * dh_cpu_y->size[1];
          dh_cpu_y->size[0] = 1;
          dh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(dh_cpu_y, i, &od_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(dh_cpu_y, &ng_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1160<<<grid, block>>>(mg_gpu_y, omega_tmp2[0] - 1,
              ng_gpu_y, dh_cpu_y->size[0U]);
          }

          i = jc_cpu_y->size[0] * jc_cpu_y->size[1];
          jc_cpu_y->size[0] = 1;
          jc_cpu_y->size[1] = dh_cpu_y->size[1];
          emxEnsureCapacity_real32_T(jc_cpu_y, i, &qd_emlrtRTEI);
          n = dh_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(jc_cpu_y, &mg_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1161<<<grid, block>>>(ng_gpu_y, n, mg_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          i = bd_cpu_y->size[0] * bd_cpu_y->size[1];
          bd_cpu_y->size[0] = 1;
          bd_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(bd_cpu_y, i, &h_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(bd_cpu_y, &og_gpu_y, true);
          j_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel1162<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(og_gpu_y);
        } else if (tol < 1.0) {
          bd_cpu_y->size[0] = 1;
          bd_cpu_y->size[1] = 0;
        } else {
          i = bd_cpu_y->size[0] * bd_cpu_y->size[1];
          bd_cpu_y->size[0] = 1;
          bd_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(bd_cpu_y, i, &h_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(bd_cpu_y, &og_gpu_y, true);
          j_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1164<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              og_gpu_y);
          }
        }

        cpu_lidx = jc_cpu_y->size[1];
        i = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = bd_cpu_y->size[1];
        cpu_y1->size[1] = jc_cpu_y->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, i, &rc_emlrtRTEI);
        n = bd_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid, &block,
          2147483647U);
        if (j_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(bd_cpu_y, &og_gpu_y, true);
        }

        j_y_needsGpuEnsureCapacity = false;
        gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1163<<<grid, block>>>(mg_gpu_y, og_gpu_y, T, n, cpu_lidx
            - 1, gpu_y1, cpu_y1->size[0U], jc_cpu_y->size[0U]);
        }
      }

      if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
        N = static_cast<uint32_T>(cpu_y1->size[0]);
        i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = cpu_wtc->size[0];
        cpu_opts_x->size[1] = cpu_y1->size[0];
        emxEnsureCapacity_real32_T(cpu_opts_x, i, &ed_emlrtRTEI);
        n = cpu_wtc->size[0] * static_cast<int32_T>(N) - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1056<<<grid, block>>>(gpu_y1, n, gpu_opts_x);
        }
      } else {
        i = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = cpu_y1->size[1];
        cpu_opts_x->size[1] = cpu_y1->size[0];
        emxEnsureCapacity_real32_T(cpu_opts_x, i, &ed_emlrtRTEI);
        n = cpu_y1->size[0] - 1;
        itime = cpu_y1->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n, itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &gpu_y1, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_opts_x, &gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1057<<<grid, block>>>(gpu_y1, itime, n, gpu_opts_x,
            cpu_opts_x->size[0U], cpu_y1->size[0U]);
        }
      }
    }

    // 'ec_wtcc:37' y = resample(y,ds(1),ds(2),Dimension=2);
    if ((cpu_crossCFS->size[0] == 1) || (cpu_crossCFS->size[1] == 1)) {
      fb_SignalPad = 1;
    } else {
      fb_SignalPad = 2;
    }

    opts_isRowVectorInput = (cpu_crossCFS->size[0] == 1);
    if (fb_SignalPad == 1) {
      if ((cpu_crossCFS->size[0] == 1) || (cpu_crossCFS->size[1] == 1)) {
        if ((cpu_crossCFS->size[0] == 0) || (cpu_crossCFS->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = cpu_crossCFS->size[0];
          ix = cpu_crossCFS->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
        b_cpu_opts_x->size[0] = ix;
        b_cpu_opts_x->size[1] = 1;
        emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &wb_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
        opts_x_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel109<<<grid, block>>>(gpu_crossCFS, ix - 1, b_gpu_opts_x);
        }
      } else {
        i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
        b_cpu_opts_x->size[0] = cpu_crossCFS->size[0];
        b_cpu_opts_x->size[1] = cpu_crossCFS->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &wb_emlrtRTEI);
        n = cpu_crossCFS->size[0] * cpu_crossCFS->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
        opts_x_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel716<<<grid, block>>>(gpu_crossCFS, n, b_gpu_opts_x);
        }
      }
    } else {
      i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
      b_cpu_opts_x->size[0] = cpu_crossCFS->size[1];
      b_cpu_opts_x->size[1] = cpu_crossCFS->size[0];
      emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &wb_emlrtRTEI);
      n = cpu_crossCFS->size[0] - 1;
      itime = cpu_crossCFS->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n, itime), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
      opts_x_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel717<<<grid, block>>>(gpu_crossCFS, itime, n, b_gpu_opts_x,
          b_cpu_opts_x->size[0U], cpu_crossCFS->size[0U]);
      }
    }

    s = static_cast<real_T>(ds[0]) / ds[1];
    b_p = s;
    r = std::abs(s);
    if (std::isinf(r) || std::isnan(r)) {
      b_r = rtNaN;
    } else if (r < 4.4501477170144028E-308) {
      b_r = 4.94065645841247E-324;
    } else {
      std::frexp(r, &b_exponent);
      b_r = std::ldexp(1.0, b_exponent - 53);
    }

    fb = std::fmax(1.0E-12, b_r);
    if (std::isinf(s) || std::isnan(s)) {
      if (!std::isnan(s)) {
        if (s < 0.0) {
          toler = -1.0;
        } else {
          toler = 1.0;
        }
      } else {
        toler = 0.0;
      }

      b_m = 0.0;
    } else {
      r = 1.0;
      d = 0.0;
      fa = 0.0;
      halfh = 1.0;
      do {
        exitg2 = 0;
        tol = std::round(s);
        if (!std::isinf(s)) {
          s -= tol;
          T = fa;
          fa = r;
          r = r * tol + T;
          T = halfh;
          halfh = d;
          d = d * tol + T;
        } else {
          fa = r;
          halfh = d;
          r = s;
          d = 0.0;
        }

        if ((s == 0.0) || (std::abs(r / d - b_p) <= fb)) {
          exitg2 = 1;
        } else {
          s = 1.0 / s;
        }
      } while (exitg2 == 0);

      if (std::isnan(d)) {
        halfh = rtNaN;
      } else if (d < 0.0) {
        halfh = -1.0;
      } else {
        halfh = (d > 0.0);
      }

      toler = r / halfh;
      b_m = std::abs(d);
    }

    fa = std::fmax(toler, b_m);
    fc = 0.5 / fa;
    fb = 20.0 * fa + 1.0;
    varargin_2[0] = 0.0;
    varargin_2[1] = 2.0 * fc;
    varargin_2[2] = 2.0 * fc;
    varargin_2[3] = 1.0;
    r = 0.0;
    fa = 0.0;
    Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] > 0.0));
    if (Nodd) {
      r = varargin_2[1];
    }

    Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] < 0.0));
    if (Nodd) {
      fa = varargin_2[1];
    }

    Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(r) || (r < varargin_2[2])));
    if (Nodd) {
      r = varargin_2[2];
    }

    Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(fa) || (fa > varargin_2
              [2])));
    if (Nodd) {
      fa = varargin_2[2];
    }

    Nodd = (std::isnan(r) || (r < 1.0));
    if (Nodd) {
      r = 1.0;
    }

    Nodd = (std::isnan(fa) || (fa > 1.0));
    if (Nodd) {
      fa = 1.0;
    }

    if ((!(r > 1.0)) && (!(fa < 0.0))) {
      for (itime = 0; itime < 4; itime++) {
        F[itime] = varargin_2[itime] / 2.0;
      }

      halfh = (((fb - 1.0) + 1.0) - 1.0) / 2.0;
      Nodd = (rt_remd_snf((fb - 1.0) + 1.0, 2.0) == 1.0);
      T = 0.0;
      if (!Nodd) {
        i = b_cpu_m->size[0] * b_cpu_m->size[1];
        b_cpu_m->size[0] = 1;
        b_cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
        emxEnsureCapacity_real_T(b_cpu_m, i, &bc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(b_cpu_m, &b_gpu_m, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel110<<<grid, block>>>(static_cast<int32_T>(halfh),
            b_gpu_m);
        }
      } else {
        i = b_cpu_m->size[0] * b_cpu_m->size[1];
        b_cpu_m->size[0] = 1;
        b_cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
        emxEnsureCapacity_real_T(b_cpu_m, i, &ac_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(b_cpu_m, &b_gpu_m, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel715<<<grid, block>>>(static_cast<int32_T>(halfh),
            b_gpu_m);
        }
      }

      i = b_cpu_k->size[0];
      b_cpu_k->size[0] = b_cpu_m->size[1];
      emxEnsureCapacity_real_T(b_cpu_k, i, &dc_emlrtRTEI);
      n = b_cpu_m->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel111<<<grid, block>>>(b_gpu_m, n, b_gpu_k);
      }

      wav_outdatedOnCpu = false;
      fb_Omega_outdatedOnGpu = true;
      first_iteration = (F[2] - F[1] != 0.0);
      bcoef = b_cpu_k->size[0];
      if (first_iteration) {
        i = b_cpu_G->size[0] * b_cpu_G->size[1];
        b_cpu_G->size[0] = b_cpu_k->size[0];
        b_cpu_G->size[1] = b_cpu_k->size[0];
        emxEnsureCapacity_real_T(b_cpu_G, i, &ec_emlrtRTEI);
        itime = b_cpu_k->size[0] * b_cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
        b_G_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel112<<<grid, block>>>(itime, b_gpu_G);
        }

        G_outdatedOnCpu = true;
        b_p = 2.0 * static_cast<real_T>(b_cpu_k->size[0]) - 1.0;
      } else {
        G_outdatedOnCpu = false;
        b_cpu_G->size[0] = 0;
        b_cpu_G->size[1] = 0;
        b_p = 0.0;
      }

      i = b_cpu_sinc1A->size[0] * b_cpu_sinc1A->size[1];
      b_cpu_sinc1A->size[0] = 1;
      b_cpu_sinc1A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(b_cpu_sinc1A, i, &fc_emlrtRTEI);
      subs_outdatedOnCpu = true;
      i = b_cpu_sinc2A->size[0] * b_cpu_sinc2A->size[1];
      b_cpu_sinc2A->size[0] = 1;
      b_cpu_sinc2A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(b_cpu_sinc2A, i, &gc_emlrtRTEI);
      fb_Omega_outdatedOnCpu = true;
      i = b_cpu_sinc3A->size[0] * b_cpu_sinc3A->size[1];
      b_cpu_sinc3A->size[0] = 1;
      b_cpu_sinc3A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(b_cpu_sinc3A, i, &hc_emlrtRTEI);
      y_outdatedOnCpu = true;
      i = b_cpu_sinc4A->size[0] * b_cpu_sinc4A->size[1];
      b_cpu_sinc4A->size[0] = 1;
      b_cpu_sinc4A->size[1] = static_cast<int32_T>(b_p);
      emxEnsureCapacity_real_T(b_cpu_sinc4A, i, &jc_emlrtRTEI);
      omega_tmp2_outdatedOnCpu = true;
      if (Nodd) {
        i1Start = -1;
        if (b_cpu_k->size[0] < 2) {
          cpu_lidx = 0;
          ix = 0;
        } else {
          cpu_lidx = 1;
          ix = b_cpu_k->size[0];
        }

        offsetH = ix - cpu_lidx;
        for (i = 0; i < offsetH; i++) {
          if (fb_Omega_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_k, &b_gpu_k);
          }

          b_cpu_k->data[i] = b_cpu_k->data[cpu_lidx + i];
          fb_Omega_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
        }

        i = b_cpu_k->size[0];
        b_cpu_k->size[0] = ix - cpu_lidx;
        emxEnsureCapacity_real_T(b_cpu_k, i, &mc_emlrtRTEI);
        interval_outdatedOnGpu = true;
      } else {
        i1Start = 0;
      }

      i = b_cpu_b->size[0];
      b_cpu_b->size[0] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(b_cpu_b, i, &kc_emlrtRTEI);
      itime = b_cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
      x_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel113<<<grid, block>>>(itime, b_gpu_b);
      }

      c_fb_Scales_needsGpuEnsureCapac = false;
      fb_Omega_needsGpuEnsureCapacity = true;
      for (nsubs = 0; nsubs < 2; nsubs++) {
        ix = nsubs << 1;
        n_idx_0 = A[ix];
        tol = F[ix + 1];
        s = F[ix];
        r = static_cast<real_T>(A[ix + 1] - n_idx_0) / (tol - s);
        fa = static_cast<real_T>(n_idx_0) - r * s;
        if (Nodd) {
          T += fa * (tol - s) + r / 2.0 * (tol * tol - s * s);
        }

        i = cpu_dv29->size[0];
        cpu_dv29->size[0] = b_cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_dv29, i, &qc_emlrtRTEI);
        itime = b_cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, !wav_outdatedOnCpu);
        }

        gpuEmxEnsureCapacity_real_T(cpu_dv29, &gpu_dv29, true);
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_k, b_cpu_k);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel114<<<grid, block>>>(tol, b_gpu_k, itime, gpu_dv29);
        }

        offsetH = cpu_dv29->size[0];
        i = cpu_dv31->size[0];
        cpu_dv31->size[0] = b_cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_dv31, i, &qc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_dv31, &gpu_dv31, true);
        wav_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel115<<<grid, block>>>(F[ix], b_gpu_k, offsetH - 1,
            gpu_dv31, gpu_dv29);
        }

        offsetH = cpu_dv31->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel116<<<grid, block>>>(offsetH - 1, gpu_dv31);
        }

        a = r / 39.478417604357432;
        if (cpu_dv29->size[0] == 1) {
          itime = b_cpu_k->size[0];
        } else {
          itime = cpu_dv29->size[0];
        }

        if ((cpu_dv29->size[0] == b_cpu_k->size[0]) && (b_cpu_b->size[0] ==
             itime)) {
          n = b_cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          interval_outdatedOnGpu = false;
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          x_outdatedOnCpu = false;
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel117<<<grid, block>>>(b_gpu_k, gpu_dv31, gpu_dv29, a, n,
              b_gpu_b);
          }

          c_fb_Scales_needsGpuEnsureCapac = false;
          fb_Omega_needsGpuEnsureCapacity = true;
        } else {
          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_b, &b_gpu_b);
          }

          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv29, &gpu_dv29);
          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv31, &gpu_dv31);
          if (fb_Omega_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_k, &b_gpu_k);
          }

          fb_Omega_outdatedOnGpu = false;
          binary_expand_op_1(b_cpu_b, a, cpu_dv29, cpu_dv31, b_cpu_k);
          fb_Omega_needsGpuEnsureCapacity = false;
          c_fb_Scales_needsGpuEnsureCapac = true;
          interval_outdatedOnGpu = true;
          x_outdatedOnCpu = true;
        }

        i = xd_cpu_y->size[0];
        xd_cpu_y->size[0] = b_cpu_k->size[0];
        emxEnsureCapacity_real_T(xd_cpu_y, i, &qc_emlrtRTEI);
        itime = b_cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, true);
        }

        gpuEmxEnsureCapacity_real_T(xd_cpu_y, &m_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel118<<<grid, block>>>(F[ix + 1], b_gpu_k, itime, m_gpu_y);
        }

        cpu_lidx = xd_cpu_y->size[0];
        s = F[ix + 1];
        a = s * (r * s + fa);
        i = yd_cpu_y->size[0];
        yd_cpu_y->size[0] = b_cpu_k->size[0];
        emxEnsureCapacity_real_T(yd_cpu_y, i, &qc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        interval_outdatedOnGpu = false;
        gpuEmxEnsureCapacity_real_T(yd_cpu_y, &n_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel119<<<grid, block>>>(F[ix], b_gpu_k, cpu_lidx - 1,
            n_gpu_y, m_gpu_y);
        }

        cpu_lidx = yd_cpu_y->size[0];
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel120<<<grid, block>>>(cpu_lidx - 1, n_gpu_y);
        }

        s = F[ix];
        c_a = s * (r * s + fa);
        if (b_cpu_b->size[0] == xd_cpu_y->size[0]) {
          n = b_cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          x_outdatedOnCpu = false;
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel121<<<grid, block>>>(n_gpu_y, c_a, m_gpu_y, a, n,
              b_gpu_b);
          }

          c_fb_Scales_needsGpuEnsureCapac = false;
          fb_Omega_needsGpuEnsureCapacity = true;
        } else {
          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_b, &b_gpu_b);
          }

          gpuEmxMemcpyGpuToCpu_real_T(xd_cpu_y, &m_gpu_y);
          gpuEmxMemcpyGpuToCpu_real_T(yd_cpu_y, &n_gpu_y);
          binary_expand_op(b_cpu_b, a, xd_cpu_y, c_a, yd_cpu_y);
          fb_Omega_needsGpuEnsureCapacity = false;
          c_fb_Scales_needsGpuEnsureCapac = true;
          x_outdatedOnCpu = true;
        }

        if (first_iteration) {
          r = 2.0 * F[ix + 1];
          fa = 2.0 * F[ix];
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(b_p) - 1),
            &grid, &block, 2147483647U);
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_sinc4A, &b_gpu_sinc4A, true);
          }

          if (y_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_sinc3A, &b_gpu_sinc3A, true);
          }

          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_sinc2A, &b_gpu_sinc2A, true);
          }

          if (subs_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_sinc1A, &b_gpu_sinc1A, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel122<<<grid, block>>>(fa, r, bcoef, i1Start,
              static_cast<int32_T>(b_p) - 1, b_gpu_sinc4A, b_gpu_sinc3A,
              b_gpu_sinc2A, b_gpu_sinc1A);
          }

          mwGetLaunchParameters1D(computeNumIters(bcoef - 1, bcoef - 1), &grid,
            &block, 2147483647U);
          omega_tmp2_outdatedOnCpu = false;
          fb_Omega_outdatedOnCpu = false;
          y_outdatedOnCpu = false;
          subs_outdatedOnCpu = false;
          if (b_G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
          }

          b_G_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel123<<<grid, block>>>(b_gpu_sinc4A, b_gpu_sinc2A, fa,
              b_gpu_sinc3A, b_gpu_sinc1A, r, bcoef, bcoef - 1, bcoef - 1,
              b_gpu_G, b_cpu_G->size[0U]);
          }

          G_outdatedOnCpu = true;
        }
      }

      if (Nodd) {
        i = b_cpu_b0->size[0];
        b_cpu_b0->size[0] = b_cpu_b->size[0] + 1;
        emxEnsureCapacity_real_T(b_cpu_b0, i, &nc_emlrtRTEI);
        gpuEmxEnsureCapacity_real_T(b_cpu_b0, &b_gpu_b0, true);
        ec_wtcc_kernel124<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(T, b_gpu_b0);
        offsetH = b_cpu_b->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        if (x_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !c_fb_Scales_needsGpuEnsureCapac);
        }

        if (c_fb_Scales_needsGpuEnsureCapac) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel125<<<grid, block>>>(b_gpu_b, offsetH - 1, b_gpu_b0);
        }

        i = b_cpu_b->size[0];
        b_cpu_b->size[0] = b_cpu_b0->size[0];
        emxEnsureCapacity_real_T(b_cpu_b, i, &tc_emlrtRTEI);
        n = b_cpu_b0->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
        x_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel126<<<grid, block>>>(b_gpu_b0, n, b_gpu_b);
        }

        c_fb_Scales_needsGpuEnsureCapac = false;
      }

      if (first_iteration) {
        if ((b_cpu_G->size[0] == 0) || (b_cpu_G->size[1] == 0) || (b_cpu_b->
             size[0] == 0)) {
          i = m_cpu_a->size[0];
          m_cpu_a->size[0] = b_cpu_G->size[1];
          emxEnsureCapacity_real_T(m_cpu_a, i, &pc_emlrtRTEI);
          n = b_cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, true);
          subs_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel127<<<grid, block>>>(n, e_gpu_a);
          }

          interval_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
        } else if (b_cpu_G->size[0] == b_cpu_G->size[1]) {
          i = m_cpu_a->size[0];
          m_cpu_a->size[0] = b_cpu_b->size[0];
          emxEnsureCapacity_real_T(m_cpu_a, i, &pc_emlrtRTEI);
          n = b_cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, true);
          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel703<<<grid, block>>>(b_gpu_b, n, e_gpu_a);
          }

          i1Start = b_cpu_G->size[0];
          ix = b_cpu_G->size[1];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          i1Start = m_cpu_a->size[0];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          i = b_cpu_IPIV->size[0];
          b_cpu_IPIV->size[0] = ix;
          emxEnsureCapacity_int32_T(b_cpu_IPIV, i, &wc_emlrtRTEI);
          if (b_G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
          }

          cusolverCheck(cusolverDnDgetrf_bufferSize(getCuSolverGlobalHandle(),
            ix, ix, (double *)&b_gpu_G.data[0], b_cpu_G->size[0],
            getCuSolverWorkspaceReq()), __FILE__, __LINE__);
          setCuSolverWorkspaceTypeSize(8);
          cusolverInitWorkspace();
          b_G_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_int32_T(b_cpu_IPIV, &gpu_IPIV, true);
          cusolverCheck(cusolverDnDgetrf(getCuSolverGlobalHandle(), ix, ix,
            (double *)&b_gpu_G.data[0], b_cpu_G->size[0], static_cast<real_T *>
            (getCuSolverWorkspaceBuff()), &gpu_IPIV.data[0], gpu_lidx), __FILE__,
                        __LINE__);
          checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          if (cpu_lidx < 0) {
            omega_tmp2[0] = m_cpu_a->size[0];
            i = m_cpu_a->size[0];
            m_cpu_a->size[0] = omega_tmp2[0];
            emxEnsureCapacity_real_T(m_cpu_a, i, &fd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, true);
            subs_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel704<<<grid, block>>>(omega_tmp2[0] - 1, e_gpu_a);
            }

            interval_outdatedOnGpu = false;
            wav_outdatedOnCpu = true;
          } else {
            subs_outdatedOnCpu = false;
            cusolverCheck(cusolverDnDgetrs(getCuSolverGlobalHandle(),
              CUBLAS_OP_N, ix, 1, (double *)&b_gpu_G.data[0], b_cpu_G->size[0],
              &gpu_IPIV.data[0], (double *)&e_gpu_a.data[0], m_cpu_a->size[0],
              gpu_lidx), __FILE__, __LINE__);
            interval_outdatedOnGpu = false;
            wav_outdatedOnCpu = true;
          }
        } else {
          ptrdiff_t b_info_t;
          offsetH = b_cpu_G->size[0];
          nsubs = b_cpu_G->size[1] - 1;
          i = b_cpu_jpvt->size[0] * b_cpu_jpvt->size[1];
          b_cpu_jpvt->size[0] = 1;
          b_cpu_jpvt->size[1] = b_cpu_G->size[1];
          emxEnsureCapacity_int32_T(b_cpu_jpvt, i, &vc_emlrtRTEI);
          n = b_cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_int32_T(b_cpu_jpvt, &gpu_jpvt, true);
          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel705<<<grid, block>>>(n, gpu_jpvt);
          }

          fb_Omega_outdatedOnCpu = false;
          y_outdatedOnCpu = true;
          i1Start = b_cpu_G->size[0];
          cpu_lidx = b_cpu_G->size[1];
          if (i1Start <= cpu_lidx) {
            cpu_lidx = i1Start;
          }

          i = b_cpu_tau->size[0];
          b_cpu_tau->size[0] = cpu_lidx;
          emxEnsureCapacity_real_T(b_cpu_tau, i, &bd_emlrtRTEI);
          i = b_jpvt_t->size[0];
          b_jpvt_t->size[0] = b_cpu_G->size[1];
          emxEnsureCapacity_ptrdiff_t(b_jpvt_t, i, &dd_emlrtRTEI);
          for (i = 0; i < b_cpu_G->size[1]; i++) {
            b_jpvt_t->data[i] = (ptrdiff_t)0;
          }

          if (G_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
          }

          b_info_t = LAPACKE_dgeqp3(102, (ptrdiff_t)b_cpu_G->size[0], (ptrdiff_t)
            b_cpu_G->size[1], &b_cpu_G->data[0], (ptrdiff_t)b_cpu_G->size[0],
            &b_jpvt_t->data[0], &b_cpu_tau->data[0]);
          wav_outdatedOnCpu = true;
          G_outdatedOnCpu = false;
          fb_Omega_needsGpuEnsureCapacity = true;
          fb_Omega_outdatedOnGpu = true;
          b_G_needsGpuEnsureCapacity = true;
          if ((int32_T)b_info_t != 0) {
            mwGetLaunchParameters1D(computeNumIters(nsubs, offsetH - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, false);
            b_G_needsGpuEnsureCapacity = false;
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_G, b_cpu_G);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel706<<<grid, block>>>(offsetH - 1, nsubs, b_gpu_G,
                b_cpu_G->size[0U]);
            }

            fb_Omega_needsGpuEnsureCapacity = false;
            G_outdatedOnCpu = true;
            i1Start = b_cpu_G->size[0];
            ix = b_cpu_G->size[1];
            if (i1Start <= ix) {
              ix = i1Start;
            }

            mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(b_cpu_tau, &gpu_tau, false);
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, b_cpu_tau);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel707<<<grid, block>>>(ix - 1, gpu_tau);
            }

            f = computeEndIdx(static_cast<int64_T>(ix + 1), static_cast<int64_T>
                              (cpu_lidx), 1L);
            mwGetLaunchParameters1D(computeNumIters(f), &grid, &block,
              2147483647U);
            fb_Omega_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel708<<<grid, block>>>(ix + 1, f, gpu_tau);
            }

            wav_outdatedOnCpu = false;
            mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
              2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel709<<<grid, block>>>(nsubs, gpu_jpvt);
            }
          } else {
            for (itime = 0; itime <= nsubs; itime++) {
              if (y_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_int32_T(b_cpu_jpvt, &gpu_jpvt);
              }

              b_cpu_jpvt->data[itime] = (int32_T)b_jpvt_t->data[itime];
              y_outdatedOnCpu = false;
              fb_Omega_outdatedOnCpu = true;
              interval_outdatedOnGpu = true;
            }
          }

          nsubs = -1;
          if (b_cpu_G->size[0] < b_cpu_G->size[1]) {
            ix = b_cpu_G->size[0];
            cpu_lidx = b_cpu_G->size[1];
          } else {
            ix = b_cpu_G->size[1];
            cpu_lidx = b_cpu_G->size[0];
          }

          exitg1 = false;
          while ((!exitg1) && (nsubs + 1 < ix)) {
            if (G_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
            }

            G_outdatedOnCpu = false;
            if (!(std::abs(b_cpu_G->data[(nsubs + b_cpu_G->size[0] * (nsubs + 1))
                           + 1]) <= std::fmin(1.4901161193847656E-8,
                  2.2204460492503131E-15 * static_cast<real_T>(cpu_lidx)) * std::
                  abs(b_cpu_G->data[0]))) {
              b_G_needsGpuEnsureCapacity = true;
              nsubs++;
            } else {
              b_G_needsGpuEnsureCapacity = true;
              exitg1 = true;
            }
          }

          i = m_cpu_a->size[0];
          m_cpu_a->size[0] = b_cpu_G->size[1];
          emxEnsureCapacity_real_T(m_cpu_a, i, &pc_emlrtRTEI);
          n = b_cpu_G->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel710<<<grid, block>>>(n, e_gpu_a);
          }

          cpu_lidx = 0;
          i1Start = b_cpu_G->size[0];
          ix = b_cpu_G->size[1];
          if (i1Start <= ix) {
            ix = i1Start;
          }

          if (b_G_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G,
              !fb_Omega_needsGpuEnsureCapacity);
          }

          if (fb_Omega_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_tau, &gpu_tau, !wav_outdatedOnCpu);
          }

          if (x_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
              !c_fb_Scales_needsGpuEnsureCapac);
          }

          if (fb_Omega_needsGpuEnsureCapacity) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_G, b_cpu_G);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, b_cpu_tau);
          }

          if (c_fb_Scales_needsGpuEnsureCapac) {
            gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
          }

          cusolverCheck(cusolverDnDormqr_bufferSize(getCuSolverGlobalHandle(),
            CUBLAS_SIDE_LEFT, CUBLAS_OP_T, b_cpu_b->size[0], 1, ix, (double *)
            &b_gpu_G.data[0], b_cpu_G->size[0], (double *)&gpu_tau.data[0],
            (double *)&b_gpu_b.data[0], b_cpu_b->size[0],
            getCuSolverWorkspaceReq()), __FILE__, __LINE__);
          setCuSolverWorkspaceTypeSize(8);
          cusolverInitWorkspace();
          b_G_needsGpuEnsureCapacity = false;
          checkCudaError(cudaMemcpy(gpu_lidx, &cpu_lidx, 4UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
          cusolverCheck(cusolverDnDormqr(getCuSolverGlobalHandle(),
            CUBLAS_SIDE_LEFT, CUBLAS_OP_T, b_cpu_b->size[0], 1, ix, (double *)
            &b_gpu_G.data[0], b_cpu_G->size[0], (double *)&gpu_tau.data[0],
            (double *)&b_gpu_b.data[0], b_cpu_b->size[0], static_cast<real_T *>
            (getCuSolverWorkspaceBuff()), *getCuSolverWorkspaceReq(), gpu_lidx),
                        __FILE__, __LINE__);
          checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          if (cpu_lidx < 0) {
            omega_tmp2[0] = b_cpu_b->size[0];
            i = b_cpu_b->size[0];
            b_cpu_b->size[0] = omega_tmp2[0];
            emxEnsureCapacity_real_T(b_cpu_b, i, &jd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel711<<<grid, block>>>(omega_tmp2[0] - 1, b_gpu_b);
            }
          }

          mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_int32_T(b_cpu_jpvt, &gpu_jpvt,
              !fb_Omega_outdatedOnCpu);
          }

          subs_outdatedOnCpu = false;
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxMemcpyCpuToGpu_int32_T(&gpu_jpvt, b_cpu_jpvt);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel712<<<grid, block>>>(b_gpu_b, gpu_jpvt, nsubs, e_gpu_a);
          }

          interval_outdatedOnGpu = false;
          wav_outdatedOnCpu = true;
          for (bcoef = 0; bcoef <= nsubs; bcoef++) {
            if (wav_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(m_cpu_a, &e_gpu_a);
            }

            if (y_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_int32_T(b_cpu_jpvt, &gpu_jpvt);
            }

            y_outdatedOnCpu = false;
            if (G_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
            }

            G_outdatedOnCpu = false;
            m_cpu_a->data[b_cpu_jpvt->data[nsubs - bcoef] - 1] /= b_cpu_G->data
              [(nsubs - bcoef) + b_cpu_G->size[0] * (nsubs - bcoef)];
            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = true;
            b_G_needsGpuEnsureCapacity = true;
            subs_outdatedOnCpu = true;
            cpu_lidx = nsubs - bcoef;
            for (ix = 0; ix < cpu_lidx; ix++) {
              m_cpu_a->data[b_cpu_jpvt->data[ix] - 1] -= m_cpu_a->
                data[b_cpu_jpvt->data[nsubs - bcoef] - 1] * b_cpu_G->data[ix +
                b_cpu_G->size[0] * (nsubs - bcoef)];
            }
          }
        }
      } else {
        i = m_cpu_a->size[0];
        m_cpu_a->size[0] = b_cpu_b->size[0];
        emxEnsureCapacity_real_T(m_cpu_a, i, &oc_emlrtRTEI);
        n = b_cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (x_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !c_fb_Scales_needsGpuEnsureCapac);
        }

        gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, true);
        subs_outdatedOnCpu = false;
        if (c_fb_Scales_needsGpuEnsureCapac) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel713<<<grid, block>>>(b_gpu_b, n, e_gpu_a);
        }

        interval_outdatedOnGpu = false;
        wav_outdatedOnCpu = true;
        if (Nodd) {
          ec_wtcc_kernel714<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(e_gpu_a);
        }
      }

      if (Nodd) {
        if (halfh + 1.0 < 2.0) {
          cpu_lidx = 0;
          ix = 1;
          bcoef = -1;
          nsubs = 0;
          i1Start = 0;
        } else {
          cpu_lidx = static_cast<int32_T>(halfh + 1.0) - 1;
          ix = -1;
          bcoef = 1;
          nsubs = 1;
          i1Start = static_cast<int32_T>(halfh + 1.0);
        }

        i = c_cpu_h->size[0] * c_cpu_h->size[1];
        c_cpu_h->size[0] = 1;
        c_cpu_h->size[1] = ((div_s32(bcoef - cpu_lidx, ix) + i1Start) - nsubs) +
          2;
        emxEnsureCapacity_real_T(c_cpu_h, i, &gd_emlrtRTEI);
        offsetH = div_s32(bcoef - cpu_lidx, ix);
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, true);
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&e_gpu_a, m_cpu_a);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel128<<<grid, block>>>(e_gpu_a, ix, cpu_lidx, offsetH,
            c_gpu_h);
        }

        b_h_needsGpuEnsureCapacity = false;
        ec_wtcc_kernel129<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(e_gpu_a, ix,
          cpu_lidx, bcoef, c_gpu_h);
        omega_tmp2_outdatedOnCpu = true;
        offsetH = i1Start - nsubs;
        for (i = 0; i < offsetH; i++) {
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(c_cpu_h, &c_gpu_h);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(m_cpu_a, &e_gpu_a);
          }

          wav_outdatedOnCpu = false;
          c_cpu_h->data[(i + div_s32(bcoef - cpu_lidx, ix)) + 2] = m_cpu_a->
            data[nsubs + i] / 2.0;
          omega_tmp2_outdatedOnCpu = false;
          b_h_outdatedOnGpu = true;
          b_h_needsGpuEnsureCapacity = true;
        }
      } else {
        i = r_cpu_x->size[0];
        r_cpu_x->size[0] = m_cpu_a->size[0];
        emxEnsureCapacity_real_T(r_cpu_x, i, &ad_emlrtRTEI);
        n = m_cpu_a->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(m_cpu_a, &e_gpu_a, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(r_cpu_x, &h_gpu_x, true);
        subs_outdatedOnCpu = false;
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&e_gpu_a, m_cpu_a);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel701<<<grid, block>>>(e_gpu_a, n, h_gpu_x);
        }

        interval_outdatedOnGpu = false;
        x_outdatedOnCpu = true;
        offsetH = m_cpu_a->size[0] - 1;
        cpu_lidx = m_cpu_a->size[0] >> 1;
        for (ix = 0; ix < cpu_lidx; ix++) {
          if (x_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(r_cpu_x, &h_gpu_x);
          }

          r = r_cpu_x->data[ix];
          r_cpu_x->data[ix] = r_cpu_x->data[offsetH - ix];
          r_cpu_x->data[offsetH - ix] = r;
          x_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
          subs_outdatedOnCpu = true;
        }

        i = c_cpu_h->size[0] * c_cpu_h->size[1];
        c_cpu_h->size[0] = 1;
        c_cpu_h->size[1] = r_cpu_x->size[0] + m_cpu_a->size[0];
        emxEnsureCapacity_real_T(c_cpu_h, i, &hd_emlrtRTEI);
        offsetH = r_cpu_x->size[0];
        mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
          2147483647U);
        if (subs_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(r_cpu_x, &h_gpu_x, !interval_outdatedOnGpu);
        }

        gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, true);
        b_h_needsGpuEnsureCapacity = false;
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&h_gpu_x, r_cpu_x);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel702<<<grid, block>>>(h_gpu_x, offsetH - 1, c_gpu_h);
        }

        omega_tmp2_outdatedOnCpu = true;
        offsetH = m_cpu_a->size[0];
        for (i = 0; i < offsetH; i++) {
          if (omega_tmp2_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(c_cpu_h, &c_gpu_h);
          }

          if (wav_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(m_cpu_a, &e_gpu_a);
          }

          wav_outdatedOnCpu = false;
          c_cpu_h->data[i + r_cpu_x->size[0]] = 0.5 * m_cpu_a->data[i];
          omega_tmp2_outdatedOnCpu = false;
          b_h_outdatedOnGpu = true;
          b_h_needsGpuEnsureCapacity = true;
        }
      }
    }

    if (fb == std::floor(fb)) {
      bcoef = static_cast<int32_T>(fb);
    } else {
      bcoef = static_cast<int32_T>(std::round(fb));
      coder::internal::warning();
    }

    i = cpu_dv27->size[0];
    cpu_dv27->size[0] = bcoef;
    emxEnsureCapacity_real_T(cpu_dv27, i, &xb_emlrtRTEI);
    if (bcoef <= 1) {
      i = cpu_dv27->size[0];
      cpu_dv27->size[0] = bcoef;
      emxEnsureCapacity_real_T(cpu_dv27, i, &yb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(bcoef - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel130<<<grid, block>>>(bcoef - 1, gpu_dv27);
      }

      subs_outdatedOnCpu = false;
    } else {
      ix = bcoef >> 1;
      f = computeEndIdx(static_cast<int64_T>(ix + 1), static_cast<int64_T>(bcoef),
                        1L);
      mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, true);
      wav_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel700<<<grid, block>>>(gpu_dc6, *global_gpu_table100, dc7,
          gpu_dc, bcoef, ix, 1 - (bcoef & 1), ix + 1, f, gpu_dv27, q1[0], q1[1],
          q1[2], q1[3], q1[4], q1[5], q1[6], q1[7], p1[0], p1[1], p1[2], p1[3],
          p1[4], p1[5], p1[6], p1[7], q2[0], q2[1], q2[2], q2[3], q2[4], q2[5],
          q2[6], q2[7], p2[0], p2[1], p2[2], p2[3], p2[4], p2[5], p2[6], p2[7],
          q4[0], q4[1], q4[2], q4[3], q4[4], q4[5], q4[6], q4[7], p4[0], p4[1],
          p4[2], p4[3], p4[4], p4[5], p4[6], p4[7], d_c[0], d_c[1], d_c[2], d_c
          [3], d_c[4], d_c[5], d_c[6]);
      }

      subs_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      for (itime = 0; itime < ix; itime++) {
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_dv27, &gpu_dv27);
        }

        cpu_dv27->data[itime] = cpu_dv27->data[(bcoef - itime) - 1];
        interval_outdatedOnGpu = false;
        subs_outdatedOnCpu = true;
        wav_outdatedOnCpu = true;
      }
    }

    i = b_cpu_h1->size[0];
    b_cpu_h1->size[0] = c_cpu_h->size[1];
    emxEnsureCapacity_real_T(b_cpu_h1, i, &cc_emlrtRTEI);
    n = c_cpu_h->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, !subs_outdatedOnCpu);
    }

    if (b_h_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, !b_h_outdatedOnGpu);
    }

    b_h_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_real_T(b_cpu_h1, &b_gpu_h1, true);
    wav_outdatedOnCpu = false;
    if (subs_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_dv27, cpu_dv27);
    }

    if (b_h_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&c_gpu_h, c_cpu_h);
    }

    b_h_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel131<<<grid, block>>>(gpu_dv27, c_gpu_h, n, b_gpu_h1);
    }

    cpu_lidx = b_cpu_h1->size[0];
    if (b_cpu_h1->size[0] == 0) {
      halfh = 0.0;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h1, &b_gpu_h1);
      halfh = b_cpu_h1->data[0];
      wav_outdatedOnCpu = true;
      for (itime = 0; itime <= cpu_lidx - 2; itime++) {
        halfh += b_cpu_h1->data[itime + 1];
      }
    }

    i = b_cpu_opts_filter->size[0];
    b_cpu_opts_filter->size[0] = b_cpu_h1->size[0];
    emxEnsureCapacity_real32_T(b_cpu_opts_filter, i, &wb_emlrtRTEI);
    n = b_cpu_h1->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (wav_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(b_cpu_h1, &b_gpu_h1, true);
    }

    gpuEmxEnsureCapacity_real32_T(b_cpu_opts_filter, &b_gpu_opts_filter, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel132<<<grid, block>>>(halfh, b_gpu_h1, toler, n,
        b_gpu_opts_filter);
    }

    r = (static_cast<real_T>(b_cpu_opts_filter->size[0]) - 1.0) / 2.0;
    b_r = r;
    if (b_m == 0.0) {
      if (r == 0.0) {
        b_r = 0.0;
      }
    } else if (std::isnan(b_m)) {
      b_r = rtNaN;
    } else if (r == 0.0) {
      b_r = 0.0;
    } else if (std::isinf(b_m)) {
      if (r < 0.0) {
        b_r = b_m;
      }
    } else {
      b_r = std::fmod(r, b_m);
      if (b_r == 0.0) {
        b_r = b_m * 0.0;
      } else if (r < 0.0) {
        b_r += b_m;
      }
    }

    halfh = std::floor(b_m - b_r);
    T = std::floor(std::ceil(r + halfh) / b_m);
    r = static_cast<real_T>(b_cpu_opts_filter->size[0]) + halfh;
    fa = 0.0;
    cpu_lidx = b_cpu_opts_x->size[0];
    while (std::ceil((((static_cast<real_T>(cpu_lidx) - 1.0) * toler + r) + fa) /
                     b_m) - T < std::ceil(static_cast<real_T>(cpu_lidx) * toler /
            b_m)) {
      fa++;
    }

    i = d_cpu_h->size[0];
    d_cpu_h->size[0] = static_cast<int32_T>((halfh + static_cast<real_T>
      (b_cpu_opts_filter->size[0])) + fa);
    emxEnsureCapacity_real32_T(d_cpu_h, i, &ic_emlrtRTEI);
    n = static_cast<int32_T>((halfh + static_cast<real_T>
      (b_cpu_opts_filter->size[0])) + fa) - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel133<<<grid, block>>>(n, d_gpu_h);
    }

    if (b_cpu_opts_filter->size[0] < 1) {
      td_cpu_y->size[0] = 1;
      td_cpu_y->size[1] = 0;
    } else {
      N = static_cast<uint32_T>(b_cpu_opts_filter->size[0]);
      i = td_cpu_y->size[0] * td_cpu_y->size[1];
      td_cpu_y->size[0] = 1;
      td_cpu_y->size[1] = b_cpu_opts_filter->size[0];
      emxEnsureCapacity_uint32_T(td_cpu_y, i, &h_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(N) - 1),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_uint32_T(td_cpu_y, &o_gpu_y, true);
      k_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel699<<<grid, block>>>(static_cast<int32_T>(N) - 1, o_gpu_y);
      }
    }

    i = cpu_iv93->size[0] * cpu_iv93->size[1];
    cpu_iv93->size[0] = 1;
    cpu_iv93->size[1] = td_cpu_y->size[1];
    emxEnsureCapacity_int32_T(cpu_iv93, i, &lc_emlrtRTEI);
    n = td_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    if (k_y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_uint32_T(td_cpu_y, &o_gpu_y, true);
    }

    k_y_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_int32_T(cpu_iv93, &gpu_iv93, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel134<<<grid, block>>>(o_gpu_y, halfh, n, gpu_iv93);
    }

    n = cpu_iv93->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
    subs_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel135<<<grid, block>>>(b_gpu_opts_filter, gpu_iv93, n, d_gpu_h);
    }

    omega_tmp2_outdatedOnCpu = true;
    if (fb_SignalPad == 1) {
      if (opts_isRowVectorInput) {
        if ((toler == 1.0) && (b_m == 1.0)) {
          i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
          b_cpu_y1->size[0] = b_cpu_opts_x->size[0];
          b_cpu_y1->size[1] = b_cpu_opts_x->size[1];
          emxEnsureCapacity_creal32_T(b_cpu_y1, i, &sc_emlrtRTEI);
          n = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel136<<<grid, block>>>(b_gpu_opts_x, n, b_gpu_y1);
          }
        } else if ((b_cpu_opts_x->size[0] == 1) || (b_cpu_opts_x->size[1] == 1))
        {
          if ((b_cpu_opts_x->size[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
            ix = 0;
          } else {
            i1Start = b_cpu_opts_x->size[0];
            ix = b_cpu_opts_x->size[1];
            if (i1Start >= ix) {
              ix = i1Start;
            }
          }

          halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
          if ((b_cpu_opts_x->size[0] == 1) && (b_cpu_opts_x->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              hc_y = nullptr;
              m65 = emlrtCreateCharArray(2, &iv126[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m65, &rfmt[0]);
              emlrtAssign(&hc_y, m65);
              qc_y = nullptr;
              m71 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&qc_y, m71);
              emlrt_marshallIn(b_sprintf(hc_y, qc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            i = s_cpu_yCol->size[0];
            s_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(s_cpu_yCol, i, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(s_cpu_yCol, &gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel139<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel140<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), gpu_yCol);
            }

            ec_wtcc_kernel141<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_origSiz);
            if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
              real32_T f3;
              i = u_cpu_a->size[0];
              u_cpu_a->size[0] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_a, i, &jb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_a, &f_gpu_a, true);
              ec_wtcc_kernel142<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_yCol, gpu_cv_re, f_gpu_a);
              i = b_c->size[0];
              b_c->size[0] = 1;
              emxEnsureCapacity_creal32_T(b_c, i, &lb_emlrtRTEI);
              checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              gpuEmxMemcpyGpuToCpu_creal32_T(u_cpu_a, &f_gpu_a);
              f3 = cpu_cv_re * u_cpu_a->data[0].re;
              cv_im = cpu_cv_re * u_cpu_a->data[0].im;
              b_c->data[0].im = cv_im;
              b_c->data[0].re = f3;
              i = t_cpu_w->size[0] * t_cpu_w->size[1];
              t_cpu_w->size[0] = 1;
              t_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
              t_cpu_w->data[0] = b_c->data[0];
              subs_outdatedOnCpu = true;
              fb_Omega_outdatedOnCpu = true;
            } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
              if (static_cast<int32_T>(toler) == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
              }

              i = t_cpu_w->size[0] * t_cpu_w->size[1];
              t_cpu_w->size[0] = nsubs;
              t_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel154<<<grid, block>>>(nsubs - 1, gpu_w);
              }

              subs_outdatedOnCpu = false;
              checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (cpu_origSiz[0] == 0) {
                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = nsubs;
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel155<<<grid, block>>>(nsubs - 1, gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && (cpu_origSiz[0] == 1)) {
                ec_wtcc_kernel156<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f13);
                ec_wtcc_kernel157<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f13, *gpu_a_data);
                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = 1;
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel158<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_yCol, *gpu_a_data, gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = ed_cpu_expanded->size[0] * ed_cpu_expanded->size[1];
                ed_cpu_expanded->size[0] = i1Start;
                ed_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(ed_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + cpu_origSiz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(ed_cpu_expanded, &gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel159<<<grid, block>>>(n, gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = hf_cpu_y->size[0] * hf_cpu_y->size[1];
                hf_cpu_y->size[0] = 1;
                hf_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(hf_cpu_y, i, &ob_emlrtRTEI);
                hf_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  hf_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv162->size[0];
                cpu_iv162->size[0] = hf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv162, i, &nb_emlrtRTEI);
                n = hf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(hf_cpu_y, &t_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv162, &gpu_iv162, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&t_gpu_y, hf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel160<<<grid, block>>>(offsetH, t_gpu_y, n,
                    gpu_iv162);
                }

                omega_tmp2[0] = cpu_iv162->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel161<<<grid, block>>>(d_gpu_h, gpu_iv162,
                    omega_tmp2[0] - 1, gpu_expanded);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = ic_cpu_rows->size[0] * ic_cpu_rows->size[1];
                ic_cpu_rows->size[0] = 1;
                ic_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(ic_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  ic_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    ic_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = OH;
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(ic_cpu_rows, &gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&gpu_rows, ic_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel162<<<grid, block>>>(gpu_expanded, gpu_rows,
                      gpu_yCol, *gpu_origSiz, OH - 1, gpu_w);
                  }
                }
              }
            } else {
              if (static_cast<int32_T>(toler) == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
              }

              i = t_cpu_w->size[0] * t_cpu_w->size[1];
              t_cpu_w->size[0] = nsubs;
              t_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel163<<<grid, block>>>(nsubs - 1, gpu_w);
              }

              subs_outdatedOnCpu = false;
              checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (cpu_origSiz[0] == 0) {
                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = nsubs;
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel164<<<grid, block>>>(nsubs - 1, gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel165<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f12);
                ec_wtcc_kernel166<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f12, *gpu_a_data);
                i = v_cpu_yCol->size[0];
                v_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(v_cpu_yCol, i, &mb_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(v_cpu_yCol, &b_gpu_yCol, true);
                ec_wtcc_kernel167<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_yCol, *gpu_a_data, b_gpu_yCol);
                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = nsubs;
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel168<<<grid, block>>>(b_gpu_yCol, nsubs - 1,
                    gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                i = dd_cpu_expanded->size[0] * dd_cpu_expanded->size[1];
                dd_cpu_expanded->size[0] = i1Start - 1;
                dd_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_creal32_T(dd_cpu_expanded, i, &nb_emlrtRTEI);
                n = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(dd_cpu_expanded, &b_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel169<<<grid, block>>>(n, b_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = df_cpu_y->size[0] * df_cpu_y->size[1];
                df_cpu_y->size[0] = 1;
                df_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(df_cpu_y, i, &ob_emlrtRTEI);
                df_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  df_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv164->size[0];
                cpu_iv164->size[0] = df_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv164, i, &nb_emlrtRTEI);
                n = df_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(df_cpu_y, &u_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv164, &gpu_iv164, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&u_gpu_y, df_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel170<<<grid, block>>>(offsetH, u_gpu_y, n,
                    gpu_iv164);
                }

                fx_size[0] = cpu_iv164->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel171<<<grid, block>>>(gpu_yCol, gpu_iv164,
                    fx_size[0] - 1, b_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = wc_cpu_rows->size[0] * wc_cpu_rows->size[1];
                wc_cpu_rows->size[0] = 1;
                wc_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(wc_cpu_rows, i, &ob_emlrtRTEI);
                wc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                fb_Omega_needsGpuEnsureCapacity = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  wc_cpu_rows->data[itime + 1] = nsubs;
                }

                i = t_cpu_w->size[0] * t_cpu_w->size[1];
                t_cpu_w->size[0] = static_cast<int32_T>(N);
                t_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(t_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nsubs = 0; nsubs < OH; nsubs++) {
                    i = u_cpu_newIm->size[0];
                    u_cpu_newIm->size[0] = wc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(u_cpu_newIm, i, &nb_emlrtRTEI);
                    n = wc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                      2147483647U);
                    if (fb_Omega_needsGpuEnsureCapacity) {
                      gpuEmxEnsureCapacity_int32_T(wc_cpu_rows, &b_gpu_rows,
                        !y_outdatedOnCpu);
                    }

                    fb_Omega_needsGpuEnsureCapacity = false;
                    gpuEmxEnsureCapacity_creal32_T(u_cpu_newIm, &gpu_newIm, true);
                    if (y_outdatedOnCpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_rows, wc_cpu_rows);
                    }

                    y_outdatedOnCpu = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel172<<<grid, block>>>(b_gpu_expanded, nsubs,
                        b_gpu_rows, n, gpu_newIm);
                    }

                    fb_Omega_outdatedOnGpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                      if (fb_Omega_outdatedOnGpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(u_cpu_newIm, &gpu_newIm);
                      }

                      if (omega_tmp2_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += u_cpu_newIm->data[offsetH].re * d_cpu_h->
                        data[(d_cpu_h->size[0] - offsetH) - 1];
                      fb_Omega_outdatedOnGpu = false;
                      omega_tmp2_outdatedOnCpu = false;
                      cv_im += u_cpu_newIm->data[offsetH].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - offsetH) - 1];
                    }

                    if (fb_Omega_outdatedOnCpu) {
                      gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w, true);
                    }

                    fb_Omega_outdatedOnCpu = false;
                    ec_wtcc_kernel173<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nsubs, gpu_w);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              fd_y = nullptr;
              m88 = emlrtCreateCharArray(2, &iv137[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m88, &rfmt[0]);
              emlrtAssign(&fd_y, m88);
              md_y = nullptr;
              m92 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&md_y, m92);
              emlrt_marshallIn(b_sprintf(fd_y, md_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (t_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = t_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = t_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel143<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel144<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = sb_cpu_w->size[0] * sb_cpu_w->size[1];
            sb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            sb_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(sb_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_creal32_T(t_cpu_w, &gpu_w,
                !subs_outdatedOnCpu);
            }

            gpuEmxEnsureCapacity_creal32_T(sb_cpu_w, &b_gpu_w, true);
            if (subs_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_w, t_cpu_w);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel145<<<grid, block>>>(gpu_w, cpu_lshift[0], ix, itime,
                cpu_lidx - 1, b_gpu_w, sb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = qf_cpu_y->size[0] * qf_cpu_y->size[1];
            qf_cpu_y->size[0] = cpu_origSiz[0];
            qf_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(qf_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(qf_cpu_y, &p_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel146<<<grid, block>>>(b_gpu_w, n, p_gpu_y);
            }

            r = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                          b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = bc_cpu_w->size[0] * bc_cpu_w->size[1];
              bc_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              bc_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_creal32_T(bc_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(bc_cpu_w, &c_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel147<<<grid, block>>>(gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, c_gpu_w, bc_cpu_w->size[0U]);
              }

              nsubs = qf_cpu_y->size[0] * qf_cpu_y->size[1];
              qf_cpu_y->size[0] = cpu_lidx;
              qf_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(qf_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(qf_cpu_y, &p_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel148<<<grid, block>>>(c_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, p_gpu_y, qf_cpu_y->size[0U]);
              }
            }

            if (qf_cpu_y->size[0] * qf_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = qf_cpu_y->size[0] * qf_cpu_y->size[1];
            }

            omega_tmp2[0] = qf_cpu_y->size[0] * qf_cpu_y->size[1];
            i = ih_cpu_y->size[0] * ih_cpu_y->size[1];
            ih_cpu_y->size[0] = 1;
            ih_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(ih_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ih_cpu_y, &q_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel149<<<grid, block>>>(p_gpu_y, omega_tmp2[0] - 1,
                q_gpu_y);
            }

            i = ue_cpu_y->size[0] * ue_cpu_y->size[1];
            ue_cpu_y->size[0] = n;
            ue_cpu_y->size[1] = 1;
            emxEnsureCapacity_creal32_T(ue_cpu_y, i, &pd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ue_cpu_y, &r_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel150<<<grid, block>>>(q_gpu_y, n - 1, r_gpu_y);
            }
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              gc_y = nullptr;
              m55 = emlrtCreateCharArray(2, &iv120[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m55, &rfmt[0]);
              emlrtAssign(&gc_y, m55);
              pc_y = nullptr;
              m63 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&pc_y, m63);
              emlrt_marshallIn(b_sprintf(gc_y, pc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = b_cpu_opts_x->size[itime];
            }

            cpu_lidx = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            i = m_cpu_yCol->size[0];
            m_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(m_cpu_yCol, i, &cd_emlrtRTEI);
            itime = offsetH * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(m_cpu_yCol, &c_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel174<<<grid, block>>>(itime, c_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1))
                 || ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                   static_cast<int32_T>(toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = offsetH * static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel175<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), c_gpu_yCol);
            }

            cpu_origSiz[0] = b_cpu_opts_x->size[0] * static_cast<int32_T>(toler);
            if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
              if (b_cpu_opts_x->size[1] < 1) {
                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = 1;
                m_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel176<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_w);
              } else {
                i = b_cpu_opts_x->size[1];
                nsubs = o_cpu_a->size[0];
                o_cpu_a->size[0] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(o_cpu_a, nsubs, &jb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(o_cpu_a, &g_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel183<<<grid, block>>>(c_gpu_yCol, i - 1, g_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                cpu_cv_re = d_cpu_h->data[0];
                i = v_cpu_c->size[0];
                v_cpu_c->size[0] = o_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(v_cpu_c, i, &lb_emlrtRTEI);
                n = o_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &d_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel184<<<grid, block>>>(n, d_gpu_c);
                }

                if (o_cpu_a->size[0] == 1) {
                  cpu_cv_re = d_cpu_h->data[0];
                  i = v_cpu_c->size[0];
                  v_cpu_c->size[0] = 1;
                  emxEnsureCapacity_creal32_T(v_cpu_c, i, &lb_emlrtRTEI);
                  ec_wtcc_kernel185<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (g_gpu_a, cpu_cv_re, gpu_f28, gpu_f29);
                  gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &d_gpu_c, true);
                  ec_wtcc_kernel186<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (gpu_f29, gpu_f28, d_gpu_c);
                } else {
                  bcoef = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(o_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(o_cpu_a->size[0])
                    + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                     (bcoef)));
                  OH = o_cpu_a->size[0];
                  if (o_cpu_a->size[0] > 2147483646) {
                    i1Start = MAX_int32_T;
                  } else {
                    i1Start = o_cpu_a->size[0] + 1;
                  }

                  i = jc_cpu_expanded->size[0];
                  jc_cpu_expanded->size[0] = i1Start - 1;
                  emxEnsureCapacity_creal32_T(jc_cpu_expanded, i, &nb_emlrtRTEI);
                  n = o_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_creal32_T(jc_cpu_expanded,
                    &c_gpu_expanded, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel188<<<grid, block>>>(n, c_gpu_expanded);
                  }

                  n = o_cpu_a->size[0];
                  i = fe_cpu_y->size[0] * fe_cpu_y->size[1];
                  fe_cpu_y->size[0] = 1;
                  fe_cpu_y->size[1] = o_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(fe_cpu_y, i, &ob_emlrtRTEI);
                  fe_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    fe_cpu_y->data[itime + 1] = nsubs;
                  }

                  i = cpu_iv142->size[0];
                  cpu_iv142->size[0] = fe_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv142, i, &nb_emlrtRTEI);
                  n = fe_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(fe_cpu_y, &v_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv142, &gpu_iv142, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&v_gpu_y, fe_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel189<<<grid, block>>>(v_gpu_y, n, gpu_iv142);
                  }

                  omega_tmp2[0] = cpu_iv142->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel190<<<grid, block>>>(g_gpu_a, gpu_iv142,
                      omega_tmp2[0] - 1, c_gpu_expanded);
                  }

                  i = v_cpu_c->size[0];
                  v_cpu_c->size[0] = o_cpu_a->size[0];
                  emxEnsureCapacity_creal32_T(v_cpu_c, i, &nb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                    static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &d_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel191<<<grid, block>>>(c_gpu_expanded, cpu_cv_re,
                      OH - 1, d_gpu_c);
                  }
                }

                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = 1;
                m_cpu_w->size[1] = v_cpu_c->size[0];
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                n = v_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel187<<<grid, block>>>(d_gpu_c, n, d_gpu_w,
                    m_cpu_w->size[0U]);
                }
              }
            } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              if (b_cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = b_cpu_opts_x->size[1];
              }

              i = m_cpu_w->size[0] * m_cpu_w->size[1];
              m_cpu_w->size[0] = nsubs;
              m_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel192<<<grid, block>>>(itime, d_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = nsubs;
                m_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel193<<<grid, block>>>(itime, d_gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                          (b_cpu_opts_x->size[1] == 1))) {
                ec_wtcc_kernel194<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f19);
                ec_wtcc_kernel195<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f19, *gpu_a_data);
                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = 1;
                m_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel196<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (c_gpu_yCol, *gpu_a_data, d_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(b_cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(b_cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                b_blockDims[1] = cpu_lidx;
                ix = b_cpu_opts_x->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = nc_cpu_expanded->size[0] * nc_cpu_expanded->size[1];
                nc_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(nc_cpu_expanded, i, &nb_emlrtRTEI);
                if (b_cpu_opts_x->size[1] > MAX_int32_T - b_cpu_opts_x->size[1])
                {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = b_cpu_opts_x->size[1] + b_cpu_opts_x->size[1];
                }

                i = nc_cpu_expanded->size[0] * nc_cpu_expanded->size[1];
                nc_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(nc_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((OH + cpu_origSiz[0]) - 1) * ((b_cpu_opts_x->size[1] +
                  b_cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(nc_cpu_expanded, &d_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel197<<<grid, block>>>(n, d_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = je_cpu_y->size[0] * je_cpu_y->size[1];
                je_cpu_y->size[0] = 1;
                je_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(je_cpu_y, i, &ob_emlrtRTEI);
                je_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  je_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv144->size[0];
                cpu_iv144->size[0] = je_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv144, i, &nb_emlrtRTEI);
                n = je_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(je_cpu_y, &w_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv144, &gpu_iv144, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&w_gpu_y, je_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel198<<<grid, block>>>(offsetH, w_gpu_y, n,
                    gpu_iv144);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(b_cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv144->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel199<<<grid, block>>>(d_gpu_h, cpu_lidx,
                    gpu_iv144, omega_tmp2[0] - 1, d_gpu_expanded,
                    nc_cpu_expanded->size[0U]);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = ac_cpu_rows->size[0] * ac_cpu_rows->size[1];
                ac_cpu_rows->size[0] = 1;
                ac_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(ac_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  ac_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    ac_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                n = b_cpu_opts_x->size[1];
                i = h_cpu_cols->size[0] * h_cpu_cols->size[1];
                h_cpu_cols->size[0] = 1;
                h_cpu_cols->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(h_cpu_cols, i, &ob_emlrtRTEI);
                h_cpu_cols->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  h_cpu_cols->data[itime + 1] = nsubs;
                }

                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = OH;
                m_cpu_w->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims
                    [1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(h_cpu_cols, &gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(ac_cpu_rows, &c_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&gpu_cols, h_cpu_cols);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_rows, ac_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel200<<<grid, block>>>(d_gpu_expanded, gpu_cols,
                      c_gpu_rows, c_gpu_yCol, *gpu_origSiz, OH - 1, ix - 1,
                      d_gpu_w, nc_cpu_expanded->size[0U], m_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
              }

              if (b_cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = b_cpu_opts_x->size[1];
              }

              i = m_cpu_w->size[0] * m_cpu_w->size[1];
              m_cpu_w->size[0] = nsubs;
              m_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel201<<<grid, block>>>(itime, d_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = nsubs;
                m_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel202<<<grid, block>>>(itime, d_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (b_cpu_opts_x->size[1] == 1) &&
                         (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel203<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f18);
                ec_wtcc_kernel204<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f18, *gpu_a_data);
                i = y_cpu_yCol->size[0];
                y_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(y_cpu_yCol, i, &mb_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(y_cpu_yCol, &d_gpu_yCol, true);
                ec_wtcc_kernel205<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (c_gpu_yCol, *gpu_a_data, d_gpu_yCol);
                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = nsubs;
                m_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &id_emlrtRTEI);
                n = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel206<<<grid, block>>>(d_gpu_yCol, n, d_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
                ix = b_cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                i = mc_cpu_expanded->size[0] * mc_cpu_expanded->size[1];
                mc_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_creal32_T(mc_cpu_expanded, i, &nb_emlrtRTEI);
                if (b_cpu_opts_x->size[1] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = b_cpu_opts_x->size[1] + 1;
                }

                i = mc_cpu_expanded->size[0] * mc_cpu_expanded->size[1];
                mc_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_creal32_T(mc_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                  b_cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(mc_cpu_expanded, &e_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel207<<<grid, block>>>(n, e_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = he_cpu_y->size[0] * he_cpu_y->size[1];
                he_cpu_y->size[0] = 1;
                he_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(he_cpu_y, i, &ob_emlrtRTEI);
                he_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  he_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv149->size[0];
                cpu_iv149->size[0] = he_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv149, i, &nb_emlrtRTEI);
                n = he_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(he_cpu_y, &x_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv149, &gpu_iv149, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_y, he_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel208<<<grid, block>>>(offsetH, x_gpu_y, n,
                    gpu_iv149);
                }

                n = b_cpu_opts_x->size[1];
                i = gf_cpu_y->size[0] * gf_cpu_y->size[1];
                gf_cpu_y->size[0] = 1;
                gf_cpu_y->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(gf_cpu_y, i, &ob_emlrtRTEI);
                gf_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  gf_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv167->size[0];
                cpu_iv167->size[0] = gf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv167, i, &nb_emlrtRTEI);
                n = gf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(gf_cpu_y, &y_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv167, &gpu_iv167, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&y_gpu_y, gf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel209<<<grid, block>>>(y_gpu_y, n, gpu_iv167);
                }

                fx_size[0] = cpu_iv149->size[0];
                fx_size[1] = cpu_iv167->size[0];
                mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel210<<<grid, block>>>(c_gpu_yCol, fx_size[0],
                    gpu_iv167, gpu_iv149, fx_size[0] - 1, fx_size[1] - 1,
                    e_gpu_expanded, mc_cpu_expanded->size[0U]);
                }

                n = d_cpu_h->size[0];
                i = fc_cpu_rows->size[0] * fc_cpu_rows->size[1];
                fc_cpu_rows->size[0] = 1;
                fc_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(fc_cpu_rows, i, &ob_emlrtRTEI);
                fc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                fb_Omega_needsGpuEnsureCapacity = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  fc_cpu_rows->data[itime + 1] = nsubs;
                }

                i = m_cpu_w->size[0] * m_cpu_w->size[1];
                m_cpu_w->size[0] = static_cast<int32_T>(N);
                m_cpu_w->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(m_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  for (bcoef = 0; bcoef < ix; bcoef++) {
                    cpu_lidx = d_cpu_h->size[0];
                    for (nsubs = 0; nsubs < OH; nsubs++) {
                      i = d_cpu_newIm->size[0];
                      d_cpu_newIm->size[0] = fc_cpu_rows->size[1];
                      emxEnsureCapacity_creal32_T(d_cpu_newIm, i, &nb_emlrtRTEI);
                      n = fc_cpu_rows->size[1] - 1;
                      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                        2147483647U);
                      if (fb_Omega_needsGpuEnsureCapacity) {
                        gpuEmxEnsureCapacity_int32_T(fc_cpu_rows, &d_gpu_rows,
                          !y_outdatedOnCpu);
                      }

                      fb_Omega_needsGpuEnsureCapacity = false;
                      gpuEmxEnsureCapacity_creal32_T(d_cpu_newIm, &b_gpu_newIm,
                        true);
                      if (y_outdatedOnCpu) {
                        gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_rows, fc_cpu_rows);
                      }

                      y_outdatedOnCpu = false;
                      validLaunchParams = mwValidateLaunchParameters(grid, block);
                      if (validLaunchParams) {
                        ec_wtcc_kernel211<<<grid, block>>>(bcoef, e_gpu_expanded,
                          nsubs, d_gpu_rows, n, b_gpu_newIm,
                          mc_cpu_expanded->size[0U]);
                      }

                      fb_Omega_outdatedOnGpu = true;
                      cpu_cv_re = 0.0F;
                      cv_im = 0.0F;
                      for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                        if (fb_Omega_outdatedOnGpu) {
                          gpuEmxMemcpyGpuToCpu_creal32_T(d_cpu_newIm,
                            &b_gpu_newIm);
                        }

                        if (omega_tmp2_outdatedOnCpu) {
                          gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                        }

                        cpu_cv_re += d_cpu_newIm->data[offsetH].re *
                          d_cpu_h->data[(d_cpu_h->size[0] - offsetH) - 1];
                        fb_Omega_outdatedOnGpu = false;
                        omega_tmp2_outdatedOnCpu = false;
                        cv_im += d_cpu_newIm->data[offsetH].im * d_cpu_h->data
                          [(d_cpu_h->size[0] - offsetH) - 1];
                      }

                      if (fb_Omega_outdatedOnCpu) {
                        gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
                      }

                      fb_Omega_outdatedOnCpu = false;
                      ec_wtcc_kernel212<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                        (cv_im, cpu_cv_re, bcoef, nsubs, d_gpu_w, m_cpu_w->size
                         [0U]);
                    }
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              dd_y = nullptr;
              m75 = emlrtCreateCharArray(2, &iv130[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m75, &rfmt[0]);
              emlrtAssign(&dd_y, m75);
              kd_y = nullptr;
              m81 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&kd_y, m81);
              emlrt_marshallIn(b_sprintf(dd_y, kd_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (m_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = m_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = m_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel177<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel178<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = qb_cpu_w->size[0] * qb_cpu_w->size[1];
            qb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            qb_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(qb_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_creal32_T(m_cpu_w, &d_gpu_w, true);
            }

            gpuEmxEnsureCapacity_creal32_T(qb_cpu_w, &e_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel179<<<grid, block>>>(d_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, e_gpu_w, qb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = ue_cpu_y->size[0] * ue_cpu_y->size[1];
            ue_cpu_y->size[0] = cpu_origSiz[0];
            ue_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(ue_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ue_cpu_y, &r_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel180<<<grid, block>>>(e_gpu_w, n, r_gpu_y);
            }

            r = std::ceil(((static_cast<real_T>(b_cpu_opts_x->size[0]) - 1.0) *
                           toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = yb_cpu_w->size[0] * yb_cpu_w->size[1];
              yb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              yb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_creal32_T(yb_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(yb_cpu_w, &f_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel181<<<grid, block>>>(d_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, f_gpu_w, yb_cpu_w->size[0U]);
              }

              nsubs = ue_cpu_y->size[0] * ue_cpu_y->size[1];
              ue_cpu_y->size[0] = cpu_lidx;
              ue_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(ue_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(ue_cpu_y, &r_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel182<<<grid, block>>>(f_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, r_gpu_y, ue_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            i = jf_cpu_y->size[0] * jf_cpu_y->size[1];
            jf_cpu_y->size[0] = 1;
            jf_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(jf_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(jf_cpu_y, &s_gpu_y, true);
            n_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel151<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(s_gpu_y);
          } else if (halfh < 1.0) {
            jf_cpu_y->size[0] = 1;
            jf_cpu_y->size[1] = 0;
          } else {
            i = jf_cpu_y->size[0] * jf_cpu_y->size[1];
            jf_cpu_y->size[0] = 1;
            jf_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(jf_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(jf_cpu_y, &s_gpu_y, true);
            n_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel153<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), s_gpu_y);
            }
          }

          i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
          b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
          b_cpu_y1->size[1] = 1;
          emxEnsureCapacity_creal32_T(b_cpu_y1, i, &sc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) -
            1), &grid, &block, 2147483647U);
          if (n_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(jf_cpu_y, &s_gpu_y, true);
          }

          n_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel152<<<grid, block>>>(r_gpu_y, s_gpu_y, T, static_cast<
              int32_T>(halfh) - 1, b_gpu_y1);
          }
        } else {
          tol = std::ceil(static_cast<real_T>(b_cpu_opts_x->size[0]) * toler /
                          b_m);
          first_iteration = (b_cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            b_cpu_opts_x->size[0] *= b_cpu_opts_x->size[1];
            b_cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &yc_emlrtRTEI);
            opts_x_needsGpuEnsureCapacity = true;
          }

          if (!(toler - 1.0 >= 0.0)) {
            bc_y = nullptr;
            m54 = emlrtCreateCharArray(2, &iv119[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m54, &rfmt[0]);
            emlrtAssign(&bc_y, m54);
            jc_y = nullptr;
            m62 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&jc_y, m62);
            emlrt_marshallIn(b_sprintf(bc_y, jc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          if ((b_cpu_opts_x->size[0] == 1) && (b_cpu_opts_x->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (b_cpu_opts_x->size[0] != 1) {
              nsubs = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = b_cpu_opts_x->size[itime];
          }

          cpu_lidx = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          i = p_cpu_yCol->size[0];
          p_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(p_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(p_cpu_yCol, &e_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel243<<<grid, block>>>(itime, e_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          if (opts_x_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel244<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
              (cpu_lidx - 1, ix), e_gpu_yCol);
          }

          cpu_origSiz[nsubs] = b_cpu_opts_x->size[nsubs] * static_cast<int32_T>
            (toler);
          if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (cpu_origSiz[1] < 1) {
              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = 1;
              p_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel245<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(g_gpu_w);
            } else {
              nsubs = r_cpu_a->size[0];
              r_cpu_a->size[0] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(r_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(r_cpu_a, &h_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel257<<<grid, block>>>(e_gpu_yCol, cpu_origSiz[1] -
                  1, h_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              i = y_cpu_c->size[0];
              y_cpu_c->size[0] = r_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(y_cpu_c, i, &lb_emlrtRTEI);
              n = r_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(y_cpu_c, &e_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel258<<<grid, block>>>(n, e_gpu_c);
              }

              if (r_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                i = y_cpu_c->size[0];
                y_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(y_cpu_c, i, &lb_emlrtRTEI);
                ec_wtcc_kernel259<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (h_gpu_a, cpu_cv_re, gpu_f32, gpu_f33);
                gpuEmxEnsureCapacity_creal32_T(y_cpu_c, &e_gpu_c, true);
                ec_wtcc_kernel260<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f33, gpu_f32, e_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (r_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(r_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>
                   (bcoef)));
                OH = r_cpu_a->size[0];
                if (r_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = r_cpu_a->size[0] + 1;
                }

                i = qc_cpu_expanded->size[0];
                qc_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_creal32_T(qc_cpu_expanded, i, &nb_emlrtRTEI);
                n = r_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(qc_cpu_expanded, &j_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel262<<<grid, block>>>(n, j_gpu_expanded);
                }

                n = r_cpu_a->size[0];
                i = me_cpu_y->size[0] * me_cpu_y->size[1];
                me_cpu_y->size[0] = 1;
                me_cpu_y->size[1] = r_cpu_a->size[0];
                emxEnsureCapacity_int32_T(me_cpu_y, i, &ob_emlrtRTEI);
                me_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  me_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv148->size[0];
                cpu_iv148->size[0] = me_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv148, i, &nb_emlrtRTEI);
                n = me_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(me_cpu_y, &hb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv148, &gpu_iv148, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&hb_gpu_y, me_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel263<<<grid, block>>>(hb_gpu_y, n, gpu_iv148);
                }

                omega_tmp2[0] = cpu_iv148->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel264<<<grid, block>>>(h_gpu_a, gpu_iv148,
                    omega_tmp2[0] - 1, j_gpu_expanded);
                }

                i = y_cpu_c->size[0];
                y_cpu_c->size[0] = r_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(y_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(y_cpu_c, &e_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel265<<<grid, block>>>(j_gpu_expanded, cpu_cv_re,
                    OH - 1, e_gpu_c);
                }
              }

              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = 1;
              p_cpu_w->size[1] = y_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              n = y_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel261<<<grid, block>>>(e_gpu_c, n, g_gpu_w,
                  p_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = p_cpu_w->size[0] * p_cpu_w->size[1];
            p_cpu_w->size[0] = nsubs;
            p_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel266<<<grid, block>>>(itime, g_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = nsubs;
              p_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel267<<<grid, block>>>(itime, g_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (cpu_origSiz[1] == 1))) {
              ec_wtcc_kernel268<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f23);
              ec_wtcc_kernel269<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f23,
                *gpu_a_data);
              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = 1;
              p_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel270<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (e_gpu_yCol, *gpu_a_data, g_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_origSiz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = wc_cpu_expanded->size[0] * wc_cpu_expanded->size[1];
              wc_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(wc_cpu_expanded, i, &nb_emlrtRTEI);
              if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                   - cpu_origSiz[1])) {
                i1Start = MIN_int32_T;
              } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T -
                          cpu_origSiz[1])) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + cpu_origSiz[1];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = wc_cpu_expanded->size[0] * wc_cpu_expanded->size[1];
              wc_cpu_expanded->size[1] = i1Start;
              emxEnsureCapacity_real32_T(wc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
                - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(wc_cpu_expanded, &k_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel271<<<grid, block>>>(n, k_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              i = te_cpu_y->size[0] * te_cpu_y->size[1];
              te_cpu_y->size[0] = 1;
              te_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(te_cpu_y, i, &ob_emlrtRTEI);
              te_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                te_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv152->size[0];
              cpu_iv152->size[0] = te_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv152, i, &nb_emlrtRTEI);
              n = te_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(te_cpu_y, &ib_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv152, &gpu_iv152, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ib_gpu_y, te_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel272<<<grid, block>>>(offsetH, ib_gpu_y, n,
                  gpu_iv152);
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv152->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel273<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv152,
                  omega_tmp2[0] - 1, k_gpu_expanded, wc_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = dc_cpu_rows->size[0] * dc_cpu_rows->size[1];
              dc_cpu_rows->size[0] = 1;
              dc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(dc_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                dc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  dc_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              if (cpu_origSiz[1] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[1] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              wav_outdatedOnCpu = false;
              i = k_cpu_cols->size[0] * k_cpu_cols->size[1];
              k_cpu_cols->size[0] = 1;
              k_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(k_cpu_cols, i, &ob_emlrtRTEI);
              if (n > 0) {
                k_cpu_cols->data[0] = 0;
                wav_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  k_cpu_cols->data[itime + 1] = nsubs;
                }
              }

              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = OH;
              p_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((OH != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                nsubs = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  nsubs = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                                 (nsubs), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(k_cpu_cols, &b_gpu_cols,
                  !wav_outdatedOnCpu);
                gpuEmxEnsureCapacity_int32_T(dc_cpu_rows, &i_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (wav_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_cols, k_cpu_cols);
                }

                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&i_gpu_rows, dc_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel274<<<grid, block>>>(k_gpu_expanded, b_gpu_cols,
                    i_gpu_rows, e_gpu_yCol, *gpu_origSiz, OH - 1, ix - 1,
                    g_gpu_w, wc_cpu_expanded->size[0U], p_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = p_cpu_w->size[0] * p_cpu_w->size[1];
            p_cpu_w->size[0] = nsubs;
            p_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel275<<<grid, block>>>(itime, g_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = nsubs;
              p_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel276<<<grid, block>>>(itime, g_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel277<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f22);
              ec_wtcc_kernel278<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f22,
                *gpu_a_data);
              i = cb_cpu_yCol->size[0];
              cb_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(cb_cpu_yCol, i, &mb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(cb_cpu_yCol, &f_gpu_yCol, true);
              ec_wtcc_kernel279<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (e_gpu_yCol, *gpu_a_data, f_gpu_yCol);
              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = nsubs;
              p_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &id_emlrtRTEI);
              n = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel280<<<grid, block>>>(f_gpu_yCol, n, g_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = cpu_origSiz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              i = vc_cpu_expanded->size[0] * vc_cpu_expanded->size[1];
              vc_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_creal32_T(vc_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_origSiz[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + 1;
              }

              i = vc_cpu_expanded->size[0] * vc_cpu_expanded->size[1];
              vc_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_creal32_T(vc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                cpu_origSiz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(vc_cpu_expanded, &l_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel281<<<grid, block>>>(n, l_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = pe_cpu_y->size[0] * pe_cpu_y->size[1];
              pe_cpu_y->size[0] = 1;
              pe_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(pe_cpu_y, i, &ob_emlrtRTEI);
              pe_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                pe_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv155->size[0];
              cpu_iv155->size[0] = pe_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv155, i, &nb_emlrtRTEI);
              n = pe_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pe_cpu_y, &jb_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv155, &gpu_iv155, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&jb_gpu_y, pe_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel282<<<grid, block>>>(offsetH, jb_gpu_y, n,
                  gpu_iv155);
              }

              if (cpu_origSiz[1] < 1) {
                n = 0;
              } else {
                n = cpu_origSiz[1];
              }

              wav_outdatedOnCpu = false;
              i = pf_cpu_y->size[0] * pf_cpu_y->size[1];
              pf_cpu_y->size[0] = 1;
              pf_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(pf_cpu_y, i, &ob_emlrtRTEI);
              if (n > 0) {
                pf_cpu_y->data[0] = 1;
                wav_outdatedOnCpu = true;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  pf_cpu_y->data[itime + 1] = nsubs;
                }
              }

              i = cpu_iv172->size[0];
              cpu_iv172->size[0] = pf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv172, i, &nb_emlrtRTEI);
              n = pf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pf_cpu_y, &kb_gpu_y,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv172, &gpu_iv172, true);
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&kb_gpu_y, pf_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel283<<<grid, block>>>(kb_gpu_y, n, gpu_iv172);
              }

              fx_size[0] = cpu_iv155->size[0];
              fx_size[1] = cpu_iv172->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel284<<<grid, block>>>(e_gpu_yCol, fx_size[0],
                  gpu_iv172, gpu_iv155, fx_size[0] - 1, fx_size[1] - 1,
                  l_gpu_expanded, vc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              i = lc_cpu_rows->size[0] * lc_cpu_rows->size[1];
              lc_cpu_rows->size[0] = 1;
              lc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(lc_cpu_rows, i, &ob_emlrtRTEI);
              lc_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              fb_Omega_needsGpuEnsureCapacity = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                lc_cpu_rows->data[itime + 1] = nsubs;
              }

              i = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = static_cast<int32_T>(N);
              p_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(p_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
                for (bcoef = 0; bcoef < ix; bcoef++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nsubs = 0; nsubs < OH; nsubs++) {
                    i = i_cpu_newIm->size[0];
                    i_cpu_newIm->size[0] = lc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(i_cpu_newIm, i, &nb_emlrtRTEI);
                    n = lc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                      2147483647U);
                    if (fb_Omega_needsGpuEnsureCapacity) {
                      gpuEmxEnsureCapacity_int32_T(lc_cpu_rows, &j_gpu_rows,
                        !y_outdatedOnCpu);
                    }

                    fb_Omega_needsGpuEnsureCapacity = false;
                    gpuEmxEnsureCapacity_creal32_T(i_cpu_newIm, &e_gpu_newIm,
                      true);
                    if (y_outdatedOnCpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&j_gpu_rows, lc_cpu_rows);
                    }

                    y_outdatedOnCpu = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel285<<<grid, block>>>(bcoef, l_gpu_expanded,
                        nsubs, j_gpu_rows, n, e_gpu_newIm, vc_cpu_expanded->
                        size[0U]);
                    }

                    fb_Omega_outdatedOnGpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                      if (fb_Omega_outdatedOnGpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(i_cpu_newIm, &e_gpu_newIm);
                      }

                      if (omega_tmp2_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += i_cpu_newIm->data[offsetH].re * d_cpu_h->
                        data[(d_cpu_h->size[0] - offsetH) - 1];
                      fb_Omega_outdatedOnGpu = false;
                      omega_tmp2_outdatedOnCpu = false;
                      cv_im += i_cpu_newIm->data[offsetH].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - offsetH) - 1];
                    }

                    if (fb_Omega_outdatedOnCpu) {
                      gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
                    }

                    fb_Omega_outdatedOnCpu = false;
                    ec_wtcc_kernel286<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, bcoef, nsubs, g_gpu_w, p_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            cd_y = nullptr;
            m79 = emlrtCreateCharArray(2, &iv134[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m79, &rfmt[0]);
            emlrtAssign(&cd_y, m79);
            jd_y = nullptr;
            m86 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&jd_y, m86);
            emlrt_marshallIn(b_sprintf(cd_y, jd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (p_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = p_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = p_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel246<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel247<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = vb_cpu_w->size[0] * vb_cpu_w->size[1];
          vb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          vb_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(vb_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(p_cpu_w, &g_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(vb_cpu_w, &h_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel248<<<grid, block>>>(g_gpu_w, cpu_lshift[0], ix, itime,
              cpu_lidx - 1, h_gpu_w, vb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = af_cpu_y->size[0] * af_cpu_y->size[1];
          af_cpu_y->size[0] = cpu_origSiz[0];
          af_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_creal32_T(af_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(af_cpu_y, &eb_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel249<<<grid, block>>>(h_gpu_w, n, eb_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(b_cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = ec_cpu_w->size[0] * ec_cpu_w->size[1];
            ec_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            ec_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_creal32_T(ec_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ec_cpu_w, &i_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel250<<<grid, block>>>(g_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, i_gpu_w, ec_cpu_w->size[0U]);
            }

            nsubs = af_cpu_y->size[0] * af_cpu_y->size[1];
            af_cpu_y->size[0] = cpu_lidx;
            af_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(af_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(af_cpu_y, &eb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel251<<<grid, block>>>(i_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, eb_gpu_y, af_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = af_cpu_y->size[0] * af_cpu_y->size[1];
            i = hh_cpu_y->size[0] * hh_cpu_y->size[1];
            hh_cpu_y->size[0] = 1;
            hh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(hh_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(hh_cpu_y, &fb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel252<<<grid, block>>>(eb_gpu_y, omega_tmp2[0] - 1,
                fb_gpu_y, hh_cpu_y->size[0U]);
            }

            i = af_cpu_y->size[0] * af_cpu_y->size[1];
            af_cpu_y->size[0] = 1;
            af_cpu_y->size[1] = hh_cpu_y->size[1];
            emxEnsureCapacity_creal32_T(af_cpu_y, i, &qd_emlrtRTEI);
            n = hh_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(af_cpu_y, &eb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel253<<<grid, block>>>(fb_gpu_y, n, eb_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            i = uf_cpu_y->size[0] * uf_cpu_y->size[1];
            uf_cpu_y->size[0] = 1;
            uf_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(uf_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(uf_cpu_y, &gb_gpu_y, true);
            q_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel254<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gb_gpu_y);
          } else if (tol < 1.0) {
            uf_cpu_y->size[0] = 1;
            uf_cpu_y->size[1] = 0;
          } else {
            i = uf_cpu_y->size[0] * uf_cpu_y->size[1];
            uf_cpu_y->size[0] = 1;
            uf_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(uf_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(uf_cpu_y, &gb_gpu_y, true);
            q_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel256<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                gb_gpu_y);
            }
          }

          cpu_lidx = af_cpu_y->size[1];
          i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
          b_cpu_y1->size[0] = uf_cpu_y->size[1];
          b_cpu_y1->size[1] = af_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(b_cpu_y1, i, &sc_emlrtRTEI);
          n = uf_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid,
            &block, 2147483647U);
          if (q_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(uf_cpu_y, &gb_gpu_y, true);
          }

          q_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel255<<<grid, block>>>(eb_gpu_y, gb_gpu_y, T, n,
              cpu_lidx - 1, b_gpu_y1, b_cpu_y1->size[0U], af_cpu_y->size[0U]);
          }
        }

        if ((b_cpu_y1->size[0] == 0) || (b_cpu_y1->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = b_cpu_y1->size[0];
          ix = b_cpu_y1->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
        b_cpu_opts_x->size[0] = 1;
        b_cpu_opts_x->size[1] = ix;
        emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &rd_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel137<<<grid, block>>>(b_gpu_y1, ix - 1, b_gpu_opts_x);
        }
      } else if ((!(toler == 1.0)) || (!(b_m == 1.0))) {
        if ((b_cpu_opts_x->size[0] == 1) || (b_cpu_opts_x->size[1] == 1)) {
          if ((b_cpu_opts_x->size[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
            ix = 0;
          } else {
            i1Start = b_cpu_opts_x->size[0];
            ix = b_cpu_opts_x->size[1];
            if (i1Start >= ix) {
              ix = i1Start;
            }
          }

          halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
          if ((b_cpu_opts_x->size[0] == 1) && (b_cpu_opts_x->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              fc_y = nullptr;
              m64 = emlrtCreateCharArray(2, &iv125[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m64, &rfmt[0]);
              emlrtAssign(&fc_y, m64);
              oc_y = nullptr;
              m70 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&oc_y, m70);
              emlrt_marshallIn(b_sprintf(fc_y, oc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            i = r_cpu_yCol->size[0];
            r_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(r_cpu_yCol, i, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_yCol, &g_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel317<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                g_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel318<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), g_gpu_yCol);
            }

            ec_wtcc_kernel319<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_origSiz);
            if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
              real32_T f3;
              i = t_cpu_a->size[0];
              t_cpu_a->size[0] = 1;
              emxEnsureCapacity_creal32_T(t_cpu_a, i, &jb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(t_cpu_a, &i_gpu_a, true);
              ec_wtcc_kernel320<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                g_gpu_yCol, gpu_cv_re, i_gpu_a);
              i = c->size[0];
              c->size[0] = 1;
              emxEnsureCapacity_creal32_T(c, i, &lb_emlrtRTEI);
              checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              gpuEmxMemcpyGpuToCpu_creal32_T(t_cpu_a, &i_gpu_a);
              f3 = cpu_cv_re * t_cpu_a->data[0].re;
              cv_im = cpu_cv_re * t_cpu_a->data[0].im;
              c->data[0].im = cv_im;
              c->data[0].re = f3;
              i = s_cpu_w->size[0] * s_cpu_w->size[1];
              s_cpu_w->size[0] = 1;
              s_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
              s_cpu_w->data[0] = c->data[0];
              subs_outdatedOnCpu = true;
              fb_Omega_outdatedOnCpu = true;
            } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
              if (static_cast<int32_T>(toler) == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
              }

              i = s_cpu_w->size[0] * s_cpu_w->size[1];
              s_cpu_w->size[0] = nsubs;
              s_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel332<<<grid, block>>>(nsubs - 1, j_gpu_w);
              }

              subs_outdatedOnCpu = false;
              checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (cpu_origSiz[0] == 0) {
                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = nsubs;
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel333<<<grid, block>>>(nsubs - 1, j_gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && (cpu_origSiz[0] == 1)) {
                ec_wtcc_kernel334<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f11);
                ec_wtcc_kernel335<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f11, *gpu_a_data);
                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = 1;
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel336<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_yCol, *gpu_a_data, j_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = cd_cpu_expanded->size[0] * cd_cpu_expanded->size[1];
                cd_cpu_expanded->size[0] = i1Start;
                cd_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(cd_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + cpu_origSiz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(cd_cpu_expanded, &q_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel337<<<grid, block>>>(n, q_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = ff_cpu_y->size[0] * ff_cpu_y->size[1];
                ff_cpu_y->size[0] = 1;
                ff_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ff_cpu_y, i, &ob_emlrtRTEI);
                ff_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ff_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv161->size[0];
                cpu_iv161->size[0] = ff_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv161, i, &nb_emlrtRTEI);
                n = ff_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ff_cpu_y, &tb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv161, &gpu_iv161, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&tb_gpu_y, ff_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel338<<<grid, block>>>(offsetH, tb_gpu_y, n,
                    gpu_iv161);
                }

                omega_tmp2[0] = cpu_iv161->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel339<<<grid, block>>>(d_gpu_h, gpu_iv161,
                    omega_tmp2[0] - 1, q_gpu_expanded);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = hc_cpu_rows->size[0] * hc_cpu_rows->size[1];
                hc_cpu_rows->size[0] = 1;
                hc_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(hc_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  hc_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    hc_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = OH;
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                    1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(hc_cpu_rows, &o_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&o_gpu_rows, hc_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel340<<<grid, block>>>(q_gpu_expanded,
                      o_gpu_rows, g_gpu_yCol, *gpu_origSiz, OH - 1, j_gpu_w);
                  }
                }
              }
            } else {
              if (static_cast<int32_T>(toler) == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
              }

              i = s_cpu_w->size[0] * s_cpu_w->size[1];
              s_cpu_w->size[0] = nsubs;
              s_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel341<<<grid, block>>>(nsubs - 1, j_gpu_w);
              }

              subs_outdatedOnCpu = false;
              checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (cpu_origSiz[0] == 0) {
                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = nsubs;
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel342<<<grid, block>>>(nsubs - 1, j_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel343<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f10);
                ec_wtcc_kernel344<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f10, *gpu_a_data);
                i = u_cpu_yCol->size[0];
                u_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(u_cpu_yCol, i, &mb_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(u_cpu_yCol, &h_gpu_yCol, true);
                ec_wtcc_kernel345<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_yCol, *gpu_a_data, h_gpu_yCol);
                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = nsubs;
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &id_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel346<<<grid, block>>>(h_gpu_yCol, nsubs - 1,
                    j_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                i = bd_cpu_expanded->size[0] * bd_cpu_expanded->size[1];
                bd_cpu_expanded->size[0] = i1Start - 1;
                bd_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_creal32_T(bd_cpu_expanded, i, &nb_emlrtRTEI);
                n = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(bd_cpu_expanded, &r_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel347<<<grid, block>>>(n, r_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = cf_cpu_y->size[0] * cf_cpu_y->size[1];
                cf_cpu_y->size[0] = 1;
                cf_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(cf_cpu_y, i, &ob_emlrtRTEI);
                cf_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  cf_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv163->size[0];
                cpu_iv163->size[0] = cf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv163, i, &nb_emlrtRTEI);
                n = cf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(cf_cpu_y, &ub_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv163, &gpu_iv163, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ub_gpu_y, cf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel348<<<grid, block>>>(offsetH, ub_gpu_y, n,
                    gpu_iv163);
                }

                fx_size[0] = cpu_iv163->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel349<<<grid, block>>>(g_gpu_yCol, gpu_iv163,
                    fx_size[0] - 1, r_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = uc_cpu_rows->size[0] * uc_cpu_rows->size[1];
                uc_cpu_rows->size[0] = 1;
                uc_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(uc_cpu_rows, i, &ob_emlrtRTEI);
                uc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                fb_Omega_needsGpuEnsureCapacity = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  uc_cpu_rows->data[itime + 1] = nsubs;
                }

                i = s_cpu_w->size[0] * s_cpu_w->size[1];
                s_cpu_w->size[0] = static_cast<int32_T>(N);
                s_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nsubs = 0; nsubs < OH; nsubs++) {
                    i = s_cpu_newIm->size[0];
                    s_cpu_newIm->size[0] = uc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(s_cpu_newIm, i, &nb_emlrtRTEI);
                    n = uc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                      2147483647U);
                    if (fb_Omega_needsGpuEnsureCapacity) {
                      gpuEmxEnsureCapacity_int32_T(uc_cpu_rows, &p_gpu_rows,
                        !y_outdatedOnCpu);
                    }

                    fb_Omega_needsGpuEnsureCapacity = false;
                    gpuEmxEnsureCapacity_creal32_T(s_cpu_newIm, &h_gpu_newIm,
                      true);
                    if (y_outdatedOnCpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&p_gpu_rows, uc_cpu_rows);
                    }

                    y_outdatedOnCpu = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel350<<<grid, block>>>(r_gpu_expanded, nsubs,
                        p_gpu_rows, n, h_gpu_newIm);
                    }

                    fb_Omega_outdatedOnGpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                      if (fb_Omega_outdatedOnGpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(s_cpu_newIm, &h_gpu_newIm);
                      }

                      if (omega_tmp2_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += s_cpu_newIm->data[offsetH].re * d_cpu_h->
                        data[(d_cpu_h->size[0] - offsetH) - 1];
                      fb_Omega_outdatedOnGpu = false;
                      omega_tmp2_outdatedOnCpu = false;
                      cv_im += s_cpu_newIm->data[offsetH].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - offsetH) - 1];
                    }

                    if (fb_Omega_outdatedOnCpu) {
                      gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w, true);
                    }

                    fb_Omega_outdatedOnCpu = false;
                    ec_wtcc_kernel351<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nsubs, j_gpu_w);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              ed_y = nullptr;
              m87 = emlrtCreateCharArray(2, &iv136[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m87, &rfmt[0]);
              emlrtAssign(&ed_y, m87);
              ld_y = nullptr;
              m91 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&ld_y, m91);
              emlrt_marshallIn(b_sprintf(ed_y, ld_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (s_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = s_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = s_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel321<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel322<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = rb_cpu_w->size[0] * rb_cpu_w->size[1];
            rb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            rb_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(rb_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_creal32_T(s_cpu_w, &j_gpu_w,
                !subs_outdatedOnCpu);
            }

            gpuEmxEnsureCapacity_creal32_T(rb_cpu_w, &k_gpu_w, true);
            if (subs_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_creal32_T(&j_gpu_w, s_cpu_w);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel323<<<grid, block>>>(j_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, k_gpu_w, rb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = of_cpu_y->size[0] * of_cpu_y->size[1];
            of_cpu_y->size[0] = cpu_origSiz[0];
            of_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(of_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(of_cpu_y, &pb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel324<<<grid, block>>>(k_gpu_w, n, pb_gpu_y);
            }

            r = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                          b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = ac_cpu_w->size[0] * ac_cpu_w->size[1];
              ac_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              ac_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_creal32_T(ac_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(ac_cpu_w, &l_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel325<<<grid, block>>>(j_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, l_gpu_w, ac_cpu_w->size[0U]);
              }

              nsubs = of_cpu_y->size[0] * of_cpu_y->size[1];
              of_cpu_y->size[0] = cpu_lidx;
              of_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(of_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(of_cpu_y, &pb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel326<<<grid, block>>>(l_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, pb_gpu_y, of_cpu_y->size[0U]);
              }
            }

            if (of_cpu_y->size[0] * of_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = of_cpu_y->size[0] * of_cpu_y->size[1];
            }

            omega_tmp2[0] = of_cpu_y->size[0] * of_cpu_y->size[1];
            i = gh_cpu_y->size[0] * gh_cpu_y->size[1];
            gh_cpu_y->size[0] = 1;
            gh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(gh_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(gh_cpu_y, &qb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel327<<<grid, block>>>(pb_gpu_y, omega_tmp2[0] - 1,
                qb_gpu_y);
            }

            i = se_cpu_y->size[0] * se_cpu_y->size[1];
            se_cpu_y->size[0] = n;
            se_cpu_y->size[1] = 1;
            emxEnsureCapacity_creal32_T(se_cpu_y, i, &pd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(se_cpu_y, &rb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel328<<<grid, block>>>(qb_gpu_y, n - 1, rb_gpu_y);
            }
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              ec_y = nullptr;
              m53 = emlrtCreateCharArray(2, &iv118[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m53, &rfmt[0]);
              emlrtAssign(&ec_y, m53);
              nc_y = nullptr;
              m61 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&nc_y, m61);
              emlrt_marshallIn(b_sprintf(ec_y, nc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = b_cpu_opts_x->size[itime];
            }

            cpu_lidx = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            i = l_cpu_yCol->size[0];
            l_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(l_cpu_yCol, i, &cd_emlrtRTEI);
            itime = offsetH * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(l_cpu_yCol, &i_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel352<<<grid, block>>>(itime, i_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1))
                 || ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                   static_cast<int32_T>(toler) > 1)))) {
              ix = 1;
              cpu_lidx = 0;
            } else {
              ix = static_cast<int32_T>(toler);
              cpu_lidx = offsetH * static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel353<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
                (cpu_lidx - 1, ix), i_gpu_yCol);
            }

            cpu_origSiz[0] = b_cpu_opts_x->size[0] * static_cast<int32_T>(toler);
            if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
              if (b_cpu_opts_x->size[1] < 1) {
                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = 1;
                l_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel354<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (m_gpu_w);
              } else {
                i = b_cpu_opts_x->size[1];
                nsubs = n_cpu_a->size[0];
                n_cpu_a->size[0] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(n_cpu_a, nsubs, &jb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(n_cpu_a, &j_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel361<<<grid, block>>>(i_gpu_yCol, i - 1, j_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                cpu_cv_re = d_cpu_h->data[0];
                i = u_cpu_c->size[0];
                u_cpu_c->size[0] = n_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(u_cpu_c, i, &lb_emlrtRTEI);
                n = n_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &f_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel362<<<grid, block>>>(n, f_gpu_c);
                }

                if (n_cpu_a->size[0] == 1) {
                  cpu_cv_re = d_cpu_h->data[0];
                  i = u_cpu_c->size[0];
                  u_cpu_c->size[0] = 1;
                  emxEnsureCapacity_creal32_T(u_cpu_c, i, &lb_emlrtRTEI);
                  ec_wtcc_kernel363<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (j_gpu_a, cpu_cv_re, gpu_f26, gpu_f27);
                  gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &f_gpu_c, true);
                  ec_wtcc_kernel364<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (gpu_f27, gpu_f26, f_gpu_c);
                } else {
                  bcoef = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(n_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(n_cpu_a->size[0])
                    + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                     (bcoef)));
                  OH = n_cpu_a->size[0];
                  if (n_cpu_a->size[0] > 2147483646) {
                    i1Start = MAX_int32_T;
                  } else {
                    i1Start = n_cpu_a->size[0] + 1;
                  }

                  i = ic_cpu_expanded->size[0];
                  ic_cpu_expanded->size[0] = i1Start - 1;
                  emxEnsureCapacity_creal32_T(ic_cpu_expanded, i, &nb_emlrtRTEI);
                  n = n_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_creal32_T(ic_cpu_expanded,
                    &s_gpu_expanded, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel366<<<grid, block>>>(n, s_gpu_expanded);
                  }

                  n = n_cpu_a->size[0];
                  i = ee_cpu_y->size[0] * ee_cpu_y->size[1];
                  ee_cpu_y->size[0] = 1;
                  ee_cpu_y->size[1] = n_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(ee_cpu_y, i, &ob_emlrtRTEI);
                  ee_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    ee_cpu_y->data[itime + 1] = nsubs;
                  }

                  i = cpu_iv141->size[0];
                  cpu_iv141->size[0] = ee_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv141, i, &nb_emlrtRTEI);
                  n = ee_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(ee_cpu_y, &vb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv141, &gpu_iv141, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&vb_gpu_y, ee_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel367<<<grid, block>>>(vb_gpu_y, n, gpu_iv141);
                  }

                  omega_tmp2[0] = cpu_iv141->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel368<<<grid, block>>>(j_gpu_a, gpu_iv141,
                      omega_tmp2[0] - 1, s_gpu_expanded);
                  }

                  i = u_cpu_c->size[0];
                  u_cpu_c->size[0] = n_cpu_a->size[0];
                  emxEnsureCapacity_creal32_T(u_cpu_c, i, &nb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                    static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &f_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel369<<<grid, block>>>(s_gpu_expanded, cpu_cv_re,
                      OH - 1, f_gpu_c);
                  }
                }

                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = 1;
                l_cpu_w->size[1] = u_cpu_c->size[0];
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                n = u_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel365<<<grid, block>>>(f_gpu_c, n, m_gpu_w,
                    l_cpu_w->size[0U]);
                }
              }
            } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
              if (cpu_origSiz[0] == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
              }

              if (b_cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = b_cpu_opts_x->size[1];
              }

              i = l_cpu_w->size[0] * l_cpu_w->size[1];
              l_cpu_w->size[0] = nsubs;
              l_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel370<<<grid, block>>>(itime, m_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = nsubs;
                l_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel371<<<grid, block>>>(itime, m_gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                          (b_cpu_opts_x->size[1] == 1))) {
                ec_wtcc_kernel372<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f17);
                ec_wtcc_kernel373<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f17, *gpu_a_data);
                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = 1;
                l_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                ec_wtcc_kernel374<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (i_gpu_yCol, *gpu_a_data, m_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (cpu_origSiz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(b_cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(b_cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                b_blockDims[1] = cpu_lidx;
                ix = b_cpu_opts_x->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + cpu_origSiz[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = lc_cpu_expanded->size[0] * lc_cpu_expanded->size[1];
                lc_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(lc_cpu_expanded, i, &nb_emlrtRTEI);
                if (b_cpu_opts_x->size[1] > MAX_int32_T - b_cpu_opts_x->size[1])
                {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = b_cpu_opts_x->size[1] + b_cpu_opts_x->size[1];
                }

                i = lc_cpu_expanded->size[0] * lc_cpu_expanded->size[1];
                lc_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_real32_T(lc_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((OH + cpu_origSiz[0]) - 1) * ((b_cpu_opts_x->size[1] +
                  b_cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(lc_cpu_expanded, &t_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel375<<<grid, block>>>(n, t_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                i = ie_cpu_y->size[0] * ie_cpu_y->size[1];
                ie_cpu_y->size[0] = 1;
                ie_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ie_cpu_y, i, &ob_emlrtRTEI);
                ie_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ie_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv143->size[0];
                cpu_iv143->size[0] = ie_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv143, i, &nb_emlrtRTEI);
                n = ie_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ie_cpu_y, &wb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv143, &gpu_iv143, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&wb_gpu_y, ie_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel376<<<grid, block>>>(offsetH, wb_gpu_y, n,
                    gpu_iv143);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(b_cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv143->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel377<<<grid, block>>>(d_gpu_h, cpu_lidx,
                    gpu_iv143, omega_tmp2[0] - 1, t_gpu_expanded,
                    lc_cpu_expanded->size[0U]);
                }

                if (cpu_origSiz[0] < -2147483647) {
                  i1Start = MIN_int32_T;
                } else {
                  i1Start = cpu_origSiz[0] - 1;
                }

                if (i1Start < 0) {
                  n = 0;
                } else {
                  n = i1Start + 1;
                }

                y_outdatedOnCpu = false;
                i = yb_cpu_rows->size[0] * yb_cpu_rows->size[1];
                yb_cpu_rows->size[0] = 1;
                yb_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(yb_cpu_rows, i, &ob_emlrtRTEI);
                if (n > 0) {
                  yb_cpu_rows->data[0] = 0;
                  y_outdatedOnCpu = true;
                  nsubs = 0;
                  for (itime = 0; itime <= n - 2; itime++) {
                    nsubs++;
                    yb_cpu_rows->data[itime + 1] = nsubs;
                  }
                }

                n = b_cpu_opts_x->size[1];
                i = g_cpu_cols->size[0] * g_cpu_cols->size[1];
                g_cpu_cols->size[0] = 1;
                g_cpu_cols->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(g_cpu_cols, i, &ob_emlrtRTEI);
                g_cpu_cols->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  g_cpu_cols->data[itime + 1] = nsubs;
                }

                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = OH;
                l_cpu_w->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  i = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    i = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3
                    (N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims
                    [1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(g_cpu_cols, &c_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(yb_cpu_rows, &q_gpu_rows,
                    !y_outdatedOnCpu);
                  gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                  fb_Omega_outdatedOnCpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_cols, g_cpu_cols);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&q_gpu_rows, yb_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel378<<<grid, block>>>(t_gpu_expanded,
                      c_gpu_cols, q_gpu_rows, i_gpu_yCol, *gpu_origSiz, OH - 1,
                      ix - 1, m_gpu_w, lc_cpu_expanded->size[0U], l_cpu_w->size
                      [0U]);
                  }
                }
              }
            } else {
              if (cpu_origSiz[0] == 0) {
                nsubs = d_cpu_h->size[0];
              } else {
                nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
              }

              if (b_cpu_opts_x->size[1] == 0) {
                cpu_lidx = 1;
              } else {
                cpu_lidx = b_cpu_opts_x->size[1];
              }

              i = l_cpu_w->size[0] * l_cpu_w->size[1];
              l_cpu_w->size[0] = nsubs;
              l_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel379<<<grid, block>>>(itime, m_gpu_w);
              }

              if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = nsubs;
                l_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                itime = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel380<<<grid, block>>>(itime, m_gpu_w);
                }
              } else if ((cpu_origSiz[0] == 1) && (b_cpu_opts_x->size[1] == 1) &&
                         (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel381<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f16);
                ec_wtcc_kernel382<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f16, *gpu_a_data);
                i = x_cpu_yCol->size[0];
                x_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(x_cpu_yCol, i, &mb_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(x_cpu_yCol, &j_gpu_yCol, true);
                ec_wtcc_kernel383<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (i_gpu_yCol, *gpu_a_data, j_gpu_yCol);
                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = nsubs;
                l_cpu_w->size[1] = cpu_lidx;
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &id_emlrtRTEI);
                n = nsubs * cpu_lidx - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel384<<<grid, block>>>(j_gpu_yCol, n, m_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(cpu_origSiz[0]) +
                     static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
                ix = b_cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                OH = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                i = kc_cpu_expanded->size[0] * kc_cpu_expanded->size[1];
                kc_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_creal32_T(kc_cpu_expanded, i, &nb_emlrtRTEI);
                if (b_cpu_opts_x->size[1] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = b_cpu_opts_x->size[1] + 1;
                }

                i = kc_cpu_expanded->size[0] * kc_cpu_expanded->size[1];
                kc_cpu_expanded->size[1] = i1Start - 1;
                emxEnsureCapacity_creal32_T(kc_cpu_expanded, i, &nb_emlrtRTEI);
                n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                  b_cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(kc_cpu_expanded, &u_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel385<<<grid, block>>>(n, u_gpu_expanded);
                }

                n = cpu_origSiz[0];
                i = ge_cpu_y->size[0] * ge_cpu_y->size[1];
                ge_cpu_y->size[0] = 1;
                ge_cpu_y->size[1] = cpu_origSiz[0];
                emxEnsureCapacity_int32_T(ge_cpu_y, i, &ob_emlrtRTEI);
                ge_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ge_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv147->size[0];
                cpu_iv147->size[0] = ge_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv147, i, &nb_emlrtRTEI);
                n = ge_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ge_cpu_y, &xb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv147, &gpu_iv147, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xb_gpu_y, ge_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel386<<<grid, block>>>(offsetH, xb_gpu_y, n,
                    gpu_iv147);
                }

                n = b_cpu_opts_x->size[1];
                i = ef_cpu_y->size[0] * ef_cpu_y->size[1];
                ef_cpu_y->size[0] = 1;
                ef_cpu_y->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(ef_cpu_y, i, &ob_emlrtRTEI);
                ef_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ef_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv166->size[0];
                cpu_iv166->size[0] = ef_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv166, i, &nb_emlrtRTEI);
                n = ef_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ef_cpu_y, &yb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv166, &gpu_iv166, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&yb_gpu_y, ef_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel387<<<grid, block>>>(yb_gpu_y, n, gpu_iv166);
                }

                fx_size[0] = cpu_iv147->size[0];
                fx_size[1] = cpu_iv166->size[0];
                mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel388<<<grid, block>>>(i_gpu_yCol, fx_size[0],
                    gpu_iv166, gpu_iv147, fx_size[0] - 1, fx_size[1] - 1,
                    u_gpu_expanded, kc_cpu_expanded->size[0U]);
                }

                n = d_cpu_h->size[0];
                i = ec_cpu_rows->size[0] * ec_cpu_rows->size[1];
                ec_cpu_rows->size[0] = 1;
                ec_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ec_cpu_rows, i, &ob_emlrtRTEI);
                ec_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                fb_Omega_needsGpuEnsureCapacity = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ec_cpu_rows->data[itime + 1] = nsubs;
                }

                i = l_cpu_w->size[0] * l_cpu_w->size[1];
                l_cpu_w->size[0] = static_cast<int32_T>(N);
                l_cpu_w->size[1] = b_cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(l_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  for (bcoef = 0; bcoef < ix; bcoef++) {
                    cpu_lidx = d_cpu_h->size[0];
                    for (nsubs = 0; nsubs < OH; nsubs++) {
                      i = c_cpu_newIm->size[0];
                      c_cpu_newIm->size[0] = ec_cpu_rows->size[1];
                      emxEnsureCapacity_creal32_T(c_cpu_newIm, i, &nb_emlrtRTEI);
                      n = ec_cpu_rows->size[1] - 1;
                      mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                        2147483647U);
                      if (fb_Omega_needsGpuEnsureCapacity) {
                        gpuEmxEnsureCapacity_int32_T(ec_cpu_rows, &r_gpu_rows,
                          !y_outdatedOnCpu);
                      }

                      fb_Omega_needsGpuEnsureCapacity = false;
                      gpuEmxEnsureCapacity_creal32_T(c_cpu_newIm, &i_gpu_newIm,
                        true);
                      if (y_outdatedOnCpu) {
                        gpuEmxMemcpyCpuToGpu_int32_T(&r_gpu_rows, ec_cpu_rows);
                      }

                      y_outdatedOnCpu = false;
                      validLaunchParams = mwValidateLaunchParameters(grid, block);
                      if (validLaunchParams) {
                        ec_wtcc_kernel389<<<grid, block>>>(bcoef, u_gpu_expanded,
                          nsubs, r_gpu_rows, n, i_gpu_newIm,
                          kc_cpu_expanded->size[0U]);
                      }

                      fb_Omega_outdatedOnGpu = true;
                      cpu_cv_re = 0.0F;
                      cv_im = 0.0F;
                      for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                        if (fb_Omega_outdatedOnGpu) {
                          gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_newIm,
                            &i_gpu_newIm);
                        }

                        if (omega_tmp2_outdatedOnCpu) {
                          gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                        }

                        cpu_cv_re += c_cpu_newIm->data[offsetH].re *
                          d_cpu_h->data[(d_cpu_h->size[0] - offsetH) - 1];
                        fb_Omega_outdatedOnGpu = false;
                        omega_tmp2_outdatedOnCpu = false;
                        cv_im += c_cpu_newIm->data[offsetH].im * d_cpu_h->data
                          [(d_cpu_h->size[0] - offsetH) - 1];
                      }

                      if (fb_Omega_outdatedOnCpu) {
                        gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
                      }

                      fb_Omega_outdatedOnCpu = false;
                      ec_wtcc_kernel390<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                        (cv_im, cpu_cv_re, bcoef, nsubs, m_gpu_w, l_cpu_w->size
                         [0U]);
                    }
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              bd_y = nullptr;
              m74 = emlrtCreateCharArray(2, &iv129[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m74, &rfmt[0]);
              emlrtAssign(&bd_y, m74);
              id_y = nullptr;
              m80 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&id_y, m80);
              emlrt_marshallIn(b_sprintf(bd_y, id_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (l_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            wav_outdatedOnCpu = false;
            interval_outdatedOnGpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_origSiz[itime] = l_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
              cpu_lshift[itime] = l_cpu_w->size[itime];
              wav_outdatedOnCpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel355<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
              ix = 1;
              bcoef = -1;
            } else {
              ix = static_cast<int32_T>(b_m);
              bcoef = cpu_lshift[0] - 1;
            }

            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel356<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
              nsubs, *gpu_origSiz);
            i = pb_cpu_w->size[0] * pb_cpu_w->size[1];
            pb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            pb_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(pb_cpu_w, i, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
              &block, 2147483647U);
            if (fb_Omega_outdatedOnCpu) {
              gpuEmxEnsureCapacity_creal32_T(l_cpu_w, &m_gpu_w, true);
            }

            gpuEmxEnsureCapacity_creal32_T(pb_cpu_w, &n_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel357<<<grid, block>>>(m_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lidx - 1, n_gpu_w, pb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            i = se_cpu_y->size[0] * se_cpu_y->size[1];
            se_cpu_y->size[0] = cpu_origSiz[0];
            se_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(se_cpu_y, i, &id_emlrtRTEI);
            n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(se_cpu_y, &rb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel358<<<grid, block>>>(n_gpu_w, n, rb_gpu_y);
            }

            r = std::ceil(((static_cast<real_T>(b_cpu_opts_x->size[0]) - 1.0) *
                           toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
            if (!(cpu_origSiz[0] < r)) {
              if (r < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(r);
              }

              nsubs = xb_cpu_w->size[0] * xb_cpu_w->size[1];
              xb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
              xb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_creal32_T(xb_cpu_w, nsubs, &nd_emlrtRTEI);
              itime = bcoef / ix;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(xb_cpu_w, &o_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel359<<<grid, block>>>(m_gpu_w, cpu_lshift[0], ix,
                  itime, cpu_lshift[1] - 1, o_gpu_w, xb_cpu_w->size[0U]);
              }

              nsubs = se_cpu_y->size[0] * se_cpu_y->size[1];
              se_cpu_y->size[0] = cpu_lidx;
              se_cpu_y->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(se_cpu_y, nsubs, &kd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1,
                cpu_lidx - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(se_cpu_y, &rb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel360<<<grid, block>>>(o_gpu_w, cpu_origSiz[0],
                  cpu_lidx - 1, cpu_origSiz[1] - 1, rb_gpu_y, se_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            i = if_cpu_y->size[0] * if_cpu_y->size[1];
            if_cpu_y->size[0] = 1;
            if_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(if_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(if_cpu_y, &sb_gpu_y, true);
            m_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel329<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(sb_gpu_y);
          } else if (halfh < 1.0) {
            if_cpu_y->size[0] = 1;
            if_cpu_y->size[1] = 0;
          } else {
            i = if_cpu_y->size[0] * if_cpu_y->size[1];
            if_cpu_y->size[0] = 1;
            if_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(if_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(if_cpu_y, &sb_gpu_y, true);
            m_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel331<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), sb_gpu_y);
            }
          }

          i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          b_cpu_opts_x->size[0] = static_cast<int32_T>(halfh);
          b_cpu_opts_x->size[1] = 1;
          emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &rd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) -
            1), &grid, &block, 2147483647U);
          if (m_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(if_cpu_y, &sb_gpu_y, true);
          }

          m_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel330<<<grid, block>>>(rb_gpu_y, sb_gpu_y, T,
              static_cast<int32_T>(halfh) - 1, b_gpu_opts_x);
          }
        } else {
          tol = std::ceil(static_cast<real_T>(b_cpu_opts_x->size[0]) * toler /
                          b_m);
          first_iteration = (b_cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
            b_cpu_opts_x->size[0] *= b_cpu_opts_x->size[1];
            b_cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &yc_emlrtRTEI);
            opts_x_needsGpuEnsureCapacity = true;
          }

          if (!(toler - 1.0 >= 0.0)) {
            ac_y = nullptr;
            m52 = emlrtCreateCharArray(2, &iv117[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m52, &rfmt[0]);
            emlrtAssign(&ac_y, m52);
            ic_y = nullptr;
            m60 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&ic_y, m60);
            emlrt_marshallIn(b_sprintf(ac_y, ic_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          if ((b_cpu_opts_x->size[0] == 1) && (b_cpu_opts_x->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (b_cpu_opts_x->size[0] != 1) {
              nsubs = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = b_cpu_opts_x->size[itime];
          }

          cpu_lidx = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          i = o_cpu_yCol->size[0];
          o_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(o_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(o_cpu_yCol, &k_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel421<<<grid, block>>>(itime, k_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          if (opts_x_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel422<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
              (cpu_lidx - 1, ix), k_gpu_yCol);
          }

          cpu_origSiz[nsubs] = b_cpu_opts_x->size[nsubs] * static_cast<int32_T>
            (toler);
          if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (cpu_origSiz[1] < 1) {
              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = 1;
              o_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel423<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(p_gpu_w);
            } else {
              nsubs = q_cpu_a->size[0];
              q_cpu_a->size[0] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(q_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(q_cpu_a, &k_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel435<<<grid, block>>>(k_gpu_yCol, cpu_origSiz[1] -
                  1, k_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              i = x_cpu_c->size[0];
              x_cpu_c->size[0] = q_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(x_cpu_c, i, &lb_emlrtRTEI);
              n = q_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &g_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel436<<<grid, block>>>(n, g_gpu_c);
              }

              if (q_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                i = x_cpu_c->size[0];
                x_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(x_cpu_c, i, &lb_emlrtRTEI);
                ec_wtcc_kernel437<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (k_gpu_a, cpu_cv_re, gpu_f30, gpu_f31);
                gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &g_gpu_c, true);
                ec_wtcc_kernel438<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f31, gpu_f30, g_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (q_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(q_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>
                   (bcoef)));
                OH = q_cpu_a->size[0];
                if (q_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = q_cpu_a->size[0] + 1;
                }

                i = pc_cpu_expanded->size[0];
                pc_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_creal32_T(pc_cpu_expanded, i, &nb_emlrtRTEI);
                n = q_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(pc_cpu_expanded, &ab_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel440<<<grid, block>>>(n, ab_gpu_expanded);
                }

                n = q_cpu_a->size[0];
                i = le_cpu_y->size[0] * le_cpu_y->size[1];
                le_cpu_y->size[0] = 1;
                le_cpu_y->size[1] = q_cpu_a->size[0];
                emxEnsureCapacity_int32_T(le_cpu_y, i, &ob_emlrtRTEI);
                le_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  le_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv146->size[0];
                cpu_iv146->size[0] = le_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv146, i, &nb_emlrtRTEI);
                n = le_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(le_cpu_y, &hc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv146, &gpu_iv146, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&hc_gpu_y, le_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel441<<<grid, block>>>(hc_gpu_y, n, gpu_iv146);
                }

                omega_tmp2[0] = cpu_iv146->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel442<<<grid, block>>>(k_gpu_a, gpu_iv146,
                    omega_tmp2[0] - 1, ab_gpu_expanded);
                }

                i = x_cpu_c->size[0];
                x_cpu_c->size[0] = q_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(x_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &g_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel443<<<grid, block>>>(ab_gpu_expanded, cpu_cv_re,
                    OH - 1, g_gpu_c);
                }
              }

              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = 1;
              o_cpu_w->size[1] = x_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              n = x_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel439<<<grid, block>>>(g_gpu_c, n, p_gpu_w,
                  o_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = o_cpu_w->size[0] * o_cpu_w->size[1];
            o_cpu_w->size[0] = nsubs;
            o_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel444<<<grid, block>>>(itime, p_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = nsubs;
              o_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel445<<<grid, block>>>(itime, p_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (cpu_origSiz[1] == 1))) {
              ec_wtcc_kernel446<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f21);
              ec_wtcc_kernel447<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f21,
                *gpu_a_data);
              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = 1;
              o_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel448<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (k_gpu_yCol, *gpu_a_data, p_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_origSiz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1])
                + 1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_origSiz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = uc_cpu_expanded->size[0] * uc_cpu_expanded->size[1];
              uc_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(uc_cpu_expanded, i, &nb_emlrtRTEI);
              if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                   - cpu_origSiz[1])) {
                i1Start = MIN_int32_T;
              } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T -
                          cpu_origSiz[1])) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + cpu_origSiz[1];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = uc_cpu_expanded->size[0] * uc_cpu_expanded->size[1];
              uc_cpu_expanded->size[1] = i1Start;
              emxEnsureCapacity_real32_T(uc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
                - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(uc_cpu_expanded, &bb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel449<<<grid, block>>>(n, bb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              i = re_cpu_y->size[0] * re_cpu_y->size[1];
              re_cpu_y->size[0] = 1;
              re_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(re_cpu_y, i, &ob_emlrtRTEI);
              re_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                re_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv151->size[0];
              cpu_iv151->size[0] = re_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv151, i, &nb_emlrtRTEI);
              n = re_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(re_cpu_y, &ic_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv151, &gpu_iv151, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ic_gpu_y, re_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel450<<<grid, block>>>(offsetH, ic_gpu_y, n,
                  gpu_iv151);
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv151->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel451<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv151,
                  omega_tmp2[0] - 1, bb_gpu_expanded, uc_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = cc_cpu_rows->size[0] * cc_cpu_rows->size[1];
              cc_cpu_rows->size[0] = 1;
              cc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(cc_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                cc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  cc_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              if (cpu_origSiz[1] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[1] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              wav_outdatedOnCpu = false;
              i = j_cpu_cols->size[0] * j_cpu_cols->size[1];
              j_cpu_cols->size[0] = 1;
              j_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(j_cpu_cols, i, &ob_emlrtRTEI);
              if (n > 0) {
                j_cpu_cols->data[0] = 0;
                wav_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  j_cpu_cols->data[itime + 1] = nsubs;
                }
              }

              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = OH;
              o_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((OH != 0) && (cpu_origSiz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                nsubs = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  nsubs = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                                 (nsubs), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(j_cpu_cols, &d_gpu_cols,
                  !wav_outdatedOnCpu);
                gpuEmxEnsureCapacity_int32_T(cc_cpu_rows, &w_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (wav_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_cols, j_cpu_cols);
                }

                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&w_gpu_rows, cc_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel452<<<grid, block>>>(bb_gpu_expanded, d_gpu_cols,
                    w_gpu_rows, k_gpu_yCol, *gpu_origSiz, OH - 1, ix - 1,
                    p_gpu_w, uc_cpu_expanded->size[0U], o_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
            }

            if (cpu_origSiz[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = cpu_origSiz[1];
            }

            i = o_cpu_w->size[0] * o_cpu_w->size[1];
            o_cpu_w->size[0] = nsubs;
            o_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel453<<<grid, block>>>(itime, p_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = nsubs;
              o_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel454<<<grid, block>>>(itime, p_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel455<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f20);
              ec_wtcc_kernel456<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f20,
                *gpu_a_data);
              i = bb_cpu_yCol->size[0];
              bb_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(bb_cpu_yCol, i, &mb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(bb_cpu_yCol, &l_gpu_yCol, true);
              ec_wtcc_kernel457<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (k_gpu_yCol, *gpu_a_data, l_gpu_yCol);
              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = nsubs;
              o_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &id_emlrtRTEI);
              n = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel458<<<grid, block>>>(l_gpu_yCol, n, p_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = cpu_origSiz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              i = tc_cpu_expanded->size[0] * tc_cpu_expanded->size[1];
              tc_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_creal32_T(tc_cpu_expanded, i, &nb_emlrtRTEI);
              if (cpu_origSiz[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = cpu_origSiz[1] + 1;
              }

              i = tc_cpu_expanded->size[0] * tc_cpu_expanded->size[1];
              tc_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_creal32_T(tc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                cpu_origSiz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(tc_cpu_expanded, &cb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel459<<<grid, block>>>(n, cb_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = oe_cpu_y->size[0] * oe_cpu_y->size[1];
              oe_cpu_y->size[0] = 1;
              oe_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(oe_cpu_y, i, &ob_emlrtRTEI);
              oe_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                oe_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv154->size[0];
              cpu_iv154->size[0] = oe_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv154, i, &nb_emlrtRTEI);
              n = oe_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(oe_cpu_y, &jc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv154, &gpu_iv154, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&jc_gpu_y, oe_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel460<<<grid, block>>>(offsetH, jc_gpu_y, n,
                  gpu_iv154);
              }

              if (cpu_origSiz[1] < 1) {
                n = 0;
              } else {
                n = cpu_origSiz[1];
              }

              wav_outdatedOnCpu = false;
              i = nf_cpu_y->size[0] * nf_cpu_y->size[1];
              nf_cpu_y->size[0] = 1;
              nf_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(nf_cpu_y, i, &ob_emlrtRTEI);
              if (n > 0) {
                nf_cpu_y->data[0] = 1;
                wav_outdatedOnCpu = true;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  nf_cpu_y->data[itime + 1] = nsubs;
                }
              }

              i = cpu_iv171->size[0];
              cpu_iv171->size[0] = nf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv171, i, &nb_emlrtRTEI);
              n = nf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(nf_cpu_y, &kc_gpu_y,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv171, &gpu_iv171, true);
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&kc_gpu_y, nf_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel461<<<grid, block>>>(kc_gpu_y, n, gpu_iv171);
              }

              fx_size[0] = cpu_iv154->size[0];
              fx_size[1] = cpu_iv171->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel462<<<grid, block>>>(k_gpu_yCol, fx_size[0],
                  gpu_iv171, gpu_iv154, fx_size[0] - 1, fx_size[1] - 1,
                  cb_gpu_expanded, tc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              i = kc_cpu_rows->size[0] * kc_cpu_rows->size[1];
              kc_cpu_rows->size[0] = 1;
              kc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(kc_cpu_rows, i, &ob_emlrtRTEI);
              kc_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              fb_Omega_needsGpuEnsureCapacity = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                kc_cpu_rows->data[itime + 1] = nsubs;
              }

              i = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = static_cast<int32_T>(N);
              o_cpu_w->size[1] = cpu_origSiz[1];
              emxEnsureCapacity_creal32_T(o_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
                for (bcoef = 0; bcoef < ix; bcoef++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nsubs = 0; nsubs < OH; nsubs++) {
                    i = h_cpu_newIm->size[0];
                    h_cpu_newIm->size[0] = kc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(h_cpu_newIm, i, &nb_emlrtRTEI);
                    n = kc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                      2147483647U);
                    if (fb_Omega_needsGpuEnsureCapacity) {
                      gpuEmxEnsureCapacity_int32_T(kc_cpu_rows, &x_gpu_rows,
                        !y_outdatedOnCpu);
                    }

                    fb_Omega_needsGpuEnsureCapacity = false;
                    gpuEmxEnsureCapacity_creal32_T(h_cpu_newIm, &l_gpu_newIm,
                      true);
                    if (y_outdatedOnCpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_rows, kc_cpu_rows);
                    }

                    y_outdatedOnCpu = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel463<<<grid, block>>>(bcoef, cb_gpu_expanded,
                        nsubs, x_gpu_rows, n, l_gpu_newIm, tc_cpu_expanded->
                        size[0U]);
                    }

                    fb_Omega_outdatedOnGpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                      if (fb_Omega_outdatedOnGpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(h_cpu_newIm, &l_gpu_newIm);
                      }

                      if (omega_tmp2_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += h_cpu_newIm->data[offsetH].re * d_cpu_h->
                        data[(d_cpu_h->size[0] - offsetH) - 1];
                      fb_Omega_outdatedOnGpu = false;
                      omega_tmp2_outdatedOnCpu = false;
                      cv_im += h_cpu_newIm->data[offsetH].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - offsetH) - 1];
                    }

                    if (fb_Omega_outdatedOnCpu) {
                      gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
                    }

                    fb_Omega_outdatedOnCpu = false;
                    ec_wtcc_kernel464<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, bcoef, nsubs, p_gpu_w, o_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            ad_y = nullptr;
            m78 = emlrtCreateCharArray(2, &iv133[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m78, &rfmt[0]);
            emlrtAssign(&ad_y, m78);
            hd_y = nullptr;
            m85 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&hd_y, m85);
            emlrt_marshallIn(b_sprintf(ad_y, hd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (o_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = o_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = o_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel424<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel425<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = ub_cpu_w->size[0] * ub_cpu_w->size[1];
          ub_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          ub_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(ub_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(o_cpu_w, &p_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(ub_cpu_w, &q_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel426<<<grid, block>>>(p_gpu_w, cpu_lshift[0], ix, itime,
              cpu_lidx - 1, q_gpu_w, ub_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = ye_cpu_y->size[0] * ye_cpu_y->size[1];
          ye_cpu_y->size[0] = cpu_origSiz[0];
          ye_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_creal32_T(ye_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &ec_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel427<<<grid, block>>>(q_gpu_w, n, ec_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(b_cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = dc_cpu_w->size[0] * dc_cpu_w->size[1];
            dc_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            dc_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_creal32_T(dc_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(dc_cpu_w, &r_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel428<<<grid, block>>>(p_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, r_gpu_w, dc_cpu_w->size[0U]);
            }

            nsubs = ye_cpu_y->size[0] * ye_cpu_y->size[1];
            ye_cpu_y->size[0] = cpu_lidx;
            ye_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(ye_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &ec_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel429<<<grid, block>>>(r_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, ec_gpu_y, ye_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = ye_cpu_y->size[0] * ye_cpu_y->size[1];
            i = fh_cpu_y->size[0] * fh_cpu_y->size[1];
            fh_cpu_y->size[0] = 1;
            fh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(fh_cpu_y, i, &od_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(fh_cpu_y, &fc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel430<<<grid, block>>>(ec_gpu_y, omega_tmp2[0] - 1,
                fc_gpu_y, fh_cpu_y->size[0U]);
            }

            i = ye_cpu_y->size[0] * ye_cpu_y->size[1];
            ye_cpu_y->size[0] = 1;
            ye_cpu_y->size[1] = fh_cpu_y->size[1];
            emxEnsureCapacity_creal32_T(ye_cpu_y, i, &qd_emlrtRTEI);
            n = fh_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &ec_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel431<<<grid, block>>>(fc_gpu_y, n, ec_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            i = tf_cpu_y->size[0] * tf_cpu_y->size[1];
            tf_cpu_y->size[0] = 1;
            tf_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(tf_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(tf_cpu_y, &gc_gpu_y, true);
            p_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel432<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gc_gpu_y);
          } else if (tol < 1.0) {
            tf_cpu_y->size[0] = 1;
            tf_cpu_y->size[1] = 0;
          } else {
            i = tf_cpu_y->size[0] * tf_cpu_y->size[1];
            tf_cpu_y->size[0] = 1;
            tf_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(tf_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(tf_cpu_y, &gc_gpu_y, true);
            p_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel434<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                gc_gpu_y);
            }
          }

          cpu_lidx = ye_cpu_y->size[1];
          i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          b_cpu_opts_x->size[0] = tf_cpu_y->size[1];
          b_cpu_opts_x->size[1] = ye_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &rd_emlrtRTEI);
          n = tf_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid,
            &block, 2147483647U);
          if (p_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(tf_cpu_y, &gc_gpu_y, true);
          }

          p_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel433<<<grid, block>>>(ec_gpu_y, gc_gpu_y, T, n,
              cpu_lidx - 1, b_gpu_opts_x, b_cpu_opts_x->size[0U], ye_cpu_y->
              size[0U]);
          }
        }
      }
    } else {
      if (b_cpu_opts_x->size[0] == 1) {
        halfh = std::ceil(toler / b_m);
        i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
        b_cpu_y1->size[1] = b_cpu_opts_x->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, i, &uc_emlrtRTEI);
        interval_outdatedOnGpu = true;
        bcoef = b_cpu_opts_x->size[1];
        if (b_cpu_opts_x->size[1] - 1 >= 0) {
          if ((static_cast<int32_T>(toler) == 0) || ((static_cast<int32_T>(toler)
                > 0) && (static_cast<int32_T>(toler) < 1))) {
            i269 = 1;
            i275 = 0;
          } else {
            i269 = static_cast<int32_T>(toler);
            i275 = static_cast<int32_T>(toler);
          }

          d_p = (static_cast<int32_T>(toler) == 1);
          b_Ly = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0]))
                           / b_m);
        }

        for (fb_SignalPad = 0; fb_SignalPad < bcoef; fb_SignalPad++) {
          if (!(toler - 1.0 >= 0.0)) {
            kc_y = nullptr;
            m58 = emlrtCreateCharArray(2, &iv123[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m58, &rfmt[0]);
            emlrtAssign(&kc_y, m58);
            sc_y = nullptr;
            m67 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&sc_y, m67);
            emlrt_marshallIn(b_sprintf(kc_y, sc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          i = k_cpu_yCol->size[0];
          k_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(k_cpu_yCol, i, &cd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(k_cpu_yCol, &m_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel495<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              m_gpu_yCol);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(i275 - 1, i269)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel496<<<grid, block>>>(b_gpu_opts_x, fb_SignalPad, i269,
              div_s32(i275 - 1, i269), m_gpu_yCol);
          }

          if (d_p && (d_cpu_h->size[0] == 1)) {
            i = q_cpu_w->size[0];
            q_cpu_w->size[0] = 1;
            emxEnsureCapacity_creal32_T(q_cpu_w, i, &id_emlrtRTEI);
            if (subs_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
            }

            subs_outdatedOnCpu = false;
            gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel497<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (m_gpu_yCol, d_gpu_h, s_gpu_w);
          } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = d_cpu_h->size[0] + static_cast<int32_T>(toler);
            } else {
              nsubs = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            i = q_cpu_w->size[0];
            q_cpu_w->size[0] = nsubs;
            emxEnsureCapacity_creal32_T(q_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel502<<<grid, block>>>(nsubs - 1, s_gpu_w);
            }

            if (static_cast<int32_T>(toler) != 0) {
              if ((d_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) == 1))
              {
                ec_wtcc_kernel503<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (m_gpu_yCol, c_gpu_cfsposdft);
                i = q_cpu_w->size[0];
                q_cpu_w->size[0] = 1;
                emxEnsureCapacity_creal32_T(q_cpu_w, i, &id_emlrtRTEI);
                if (subs_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
                }

                subs_outdatedOnCpu = false;
                ec_wtcc_kernel504<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (c_gpu_cfsposdft, d_gpu_h, gpu_f8, gpu_f9);
                gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
                ec_wtcc_kernel505<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f9, gpu_f8, s_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (static_cast<int32_T>(toler))) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  i = static_cast<int32_T>(s);
                } else {
                  i = MIN_int32_T;
                }

                b_blockDims[0] = i;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                               2.0) + std::floor((static_cast<real_T>(
                  static_cast<int32_T>(toler)) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((OH < 0) && (static_cast<int32_T>(toler) < MIN_int32_T - OH))
                {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (static_cast<int32_T>(toler) >
                                        MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + static_cast<int32_T>(toler);
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = hc_cpu_expanded->size[0];
                hc_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_real32_T(hc_cpu_expanded, i, &nb_emlrtRTEI);
                itime = (OH + static_cast<int32_T>(toler)) - 2;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(hc_cpu_expanded, &hb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel506<<<grid, block>>>(itime, hb_gpu_expanded);
                }

                i = d_cpu_h->size[0];
                nsubs = ce_cpu_y->size[0] * ce_cpu_y->size[1];
                ce_cpu_y->size[0] = 1;
                ce_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ce_cpu_y, nsubs, &ob_emlrtRTEI);
                ce_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= i - 2; itime++) {
                  nsubs++;
                  ce_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv140->size[0];
                cpu_iv140->size[0] = ce_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv140, i, &nb_emlrtRTEI);
                n = ce_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ce_cpu_y, &rc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv140, &gpu_iv140, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&rc_gpu_y, ce_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel507<<<grid, block>>>(offsetH, rc_gpu_y, n,
                    gpu_iv140);
                }

                omega_tmp2[0] = cpu_iv140->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                if (subs_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
                }

                subs_outdatedOnCpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel508<<<grid, block>>>(d_gpu_h, gpu_iv140,
                    omega_tmp2[0] - 1, hb_gpu_expanded);
                }

                if (static_cast<int32_T>(toler) < -2147483647) {
                  i1Start = MIN_int32_T;
                  cpu_lidx = MIN_int32_T;
                } else {
                  i1Start = static_cast<int32_T>(toler) - 1;
                  cpu_lidx = static_cast<int32_T>(toler) - 1;
                }

                i = xb_cpu_rows->size[0] * xb_cpu_rows->size[1];
                xb_cpu_rows->size[0] = 1;
                xb_cpu_rows->size[1] = cpu_lidx + 1;
                emxEnsureCapacity_int32_T(xb_cpu_rows, i, &ob_emlrtRTEI);
                xb_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (itime = 0; itime < i1Start; itime++) {
                  nsubs++;
                  xb_cpu_rows->data[itime + 1] = nsubs;
                }

                i = q_cpu_w->size[0];
                q_cpu_w->size[0] = OH;
                emxEnsureCapacity_creal32_T(q_cpu_w, i, &nb_emlrtRTEI);
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(N, 1U, 1U),
                  dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(xb_cpu_rows, &db_gpu_rows, false);
                gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&db_gpu_rows, xb_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel509<<<grid, block>>>(hb_gpu_expanded,
                    db_gpu_rows, m_gpu_yCol, toler, OH - 1, s_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = static_cast<int32_T>(toler) + d_cpu_h->size[0];
            } else {
              nsubs = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
            }

            i = q_cpu_w->size[0];
            q_cpu_w->size[0] = nsubs;
            emxEnsureCapacity_creal32_T(q_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel510<<<grid, block>>>(nsubs - 1, s_gpu_w);
            }

            if (static_cast<int32_T>(toler) != 0) {
              if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1))
              {
                i = q_cpu_w->size[0];
                q_cpu_w->size[0] = 1;
                emxEnsureCapacity_creal32_T(q_cpu_w, i, &id_emlrtRTEI);
                if (subs_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
                }

                subs_outdatedOnCpu = false;
                gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
                ec_wtcc_kernel511<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (m_gpu_yCol, d_gpu_h, s_gpu_w);
              } else {
                r = (static_cast<real_T>(static_cast<int32_T>(toler)) +
                     static_cast<real_T>(d_cpu_h->size[0])) - 1.0;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    OH = static_cast<int32_T>(r);
                  } else {
                    OH = MIN_int32_T;
                  }
                } else {
                  OH = MAX_int32_T;
                }

                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((OH < 0) && (d_cpu_h->size[0] < MIN_int32_T - OH)) {
                  i1Start = MIN_int32_T;
                } else if ((OH > 0) && (d_cpu_h->size[0] > MAX_int32_T - OH)) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = OH + d_cpu_h->size[0];
                }

                if (i1Start >= -2147483647) {
                  i1Start--;
                }

                i = gc_cpu_expanded->size[0];
                gc_cpu_expanded->size[0] = i1Start;
                emxEnsureCapacity_creal32_T(gc_cpu_expanded, i, &nb_emlrtRTEI);
                n = (OH + d_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(gc_cpu_expanded, &ib_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel512<<<grid, block>>>(n, ib_gpu_expanded);
                }

                n = static_cast<int32_T>(toler);
                i = be_cpu_y->size[0] * be_cpu_y->size[1];
                be_cpu_y->size[0] = 1;
                be_cpu_y->size[1] = static_cast<int32_T>(toler);
                emxEnsureCapacity_int32_T(be_cpu_y, i, &ob_emlrtRTEI);
                be_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  be_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv139->size[0];
                cpu_iv139->size[0] = be_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv139, i, &nb_emlrtRTEI);
                n = be_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(be_cpu_y, &sc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv139, &gpu_iv139, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&sc_gpu_y, be_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel513<<<grid, block>>>(offsetH, sc_gpu_y, n,
                    gpu_iv139);
                }

                omega_tmp2[0] = cpu_iv139->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel514<<<grid, block>>>(m_gpu_yCol, gpu_iv139,
                    omega_tmp2[0] - 1, ib_gpu_expanded);
                }

                i = d_cpu_h->size[0];
                nsubs = wb_cpu_rows->size[0] * wb_cpu_rows->size[1];
                wb_cpu_rows->size[0] = 1;
                wb_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(wb_cpu_rows, nsubs, &ob_emlrtRTEI);
                wb_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                fb_Omega_needsGpuEnsureCapacity = true;
                nsubs = 0;
                for (itime = 0; itime <= i - 2; itime++) {
                  nsubs++;
                  wb_cpu_rows->data[itime + 1] = nsubs;
                }

                i = q_cpu_w->size[0];
                q_cpu_w->size[0] = OH;
                emxEnsureCapacity_creal32_T(q_cpu_w, i, &nb_emlrtRTEI);
                fb_Omega_outdatedOnCpu = true;
                if (OH - 1 >= 0) {
                  i392 = d_cpu_h->size[0];
                }

                for (nsubs = 0; nsubs < OH; nsubs++) {
                  i = b_cpu_newIm->size[0];
                  b_cpu_newIm->size[0] = wb_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(b_cpu_newIm, i, &nb_emlrtRTEI);
                  n = wb_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  if (fb_Omega_needsGpuEnsureCapacity) {
                    gpuEmxEnsureCapacity_int32_T(wb_cpu_rows, &eb_gpu_rows,
                      !y_outdatedOnCpu);
                  }

                  fb_Omega_needsGpuEnsureCapacity = false;
                  gpuEmxEnsureCapacity_creal32_T(b_cpu_newIm, &o_gpu_newIm, true);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&eb_gpu_rows, wb_cpu_rows);
                  }

                  y_outdatedOnCpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel515<<<grid, block>>>(ib_gpu_expanded, nsubs,
                      eb_gpu_rows, n, o_gpu_newIm);
                  }

                  fb_Omega_outdatedOnGpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (offsetH = 0; offsetH < i392; offsetH++) {
                    if (fb_Omega_outdatedOnGpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_newIm, &o_gpu_newIm);
                    }

                    if (omega_tmp2_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += b_cpu_newIm->data[offsetH].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                    fb_Omega_outdatedOnGpu = false;
                    omega_tmp2_outdatedOnCpu = false;
                    cv_im += b_cpu_newIm->data[offsetH].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                    subs_outdatedOnCpu = true;
                  }

                  if (fb_Omega_outdatedOnCpu) {
                    gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
                  }

                  fb_Omega_outdatedOnCpu = false;
                  ec_wtcc_kernel516<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nsubs, s_gpu_w);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            uc_y = nullptr;
            m77 = emlrtCreateCharArray(2, &iv132[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m77, &rfmt[0]);
            emlrtAssign(&uc_y, m77);
            wc_y = nullptr;
            m84 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&wc_y, m84);
            emlrt_marshallIn(b_sprintf(uc_y, wc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          if (b_m == 0.0) {
            cpu_lidx = 1;
            ix = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            ix = q_cpu_w->size[0] - 1;
          }

          i = ae_cpu_y->size[0];
          ae_cpu_y->size[0] = div_s32(ix, cpu_lidx) + 1;
          emxEnsureCapacity_creal32_T(ae_cpu_y, i, &id_emlrtRTEI);
          itime = ix / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(q_cpu_w, &s_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(ae_cpu_y, &pc_gpu_y, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel498<<<grid, block>>>(s_gpu_w, cpu_lidx, itime,
              pc_gpu_y);
          }

          if (!(div_s32(ix, cpu_lidx) + 1 < b_Ly)) {
            i = ae_cpu_y->size[0];
            if (b_Ly < 1.0) {
              ae_cpu_y->size[0] = 0;
            } else {
              ae_cpu_y->size[0] = static_cast<int32_T>(b_Ly);
            }

            emxEnsureCapacity_creal32_T(ae_cpu_y, i, &kd_emlrtRTEI);
            wav_outdatedOnCpu = true;
          }

          if (std::isnan(halfh)) {
            i = de_cpu_y->size[0] * de_cpu_y->size[1];
            de_cpu_y->size[0] = 1;
            de_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(de_cpu_y, i, &h_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(de_cpu_y, &qc_gpu_y, true);
            l_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel499<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(qc_gpu_y);
          } else if (halfh < 1.0) {
            de_cpu_y->size[0] = 1;
            de_cpu_y->size[1] = 0;
          } else {
            i = de_cpu_y->size[0] * de_cpu_y->size[1];
            de_cpu_y->size[0] = 1;
            de_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(de_cpu_y, i, &h_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(de_cpu_y, &qc_gpu_y, true);
            l_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel501<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), qc_gpu_y);
            }
          }

          cpu_lidx = b_cpu_y1->size[0];
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(ae_cpu_y, &pc_gpu_y, true);
          }

          if (l_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(de_cpu_y, &qc_gpu_y, true);
          }

          l_y_needsGpuEnsureCapacity = false;
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
          }

          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel500<<<grid, block>>>(pc_gpu_y, qc_gpu_y, T,
              fb_SignalPad, cpu_lidx - 1, b_gpu_y1, b_cpu_y1->size[0U]);
          }
        }
      } else if ((toler == 1.0) && (b_m == 1.0)) {
        i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = b_cpu_opts_x->size[0];
        b_cpu_y1->size[1] = b_cpu_opts_x->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, i, &rc_emlrtRTEI);
        n = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel519<<<grid, block>>>(b_gpu_opts_x, n, b_gpu_y1);
        }
      } else if ((b_cpu_opts_x->size[0] == 1) || (b_cpu_opts_x->size[1] == 1)) {
        if ((b_cpu_opts_x->size[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
          ix = 0;
        } else {
          i1Start = b_cpu_opts_x->size[0];
          ix = b_cpu_opts_x->size[1];
          if (i1Start >= ix) {
            ix = i1Start;
          }
        }

        halfh = std::ceil(static_cast<real_T>(ix) * toler / b_m);
        if ((b_cpu_opts_x->size[0] == 1) && (b_cpu_opts_x->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            dc_y = nullptr;
            m69 = emlrtCreateCharArray(2, &iv127[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m69, &rfmt[0]);
            emlrtAssign(&dc_y, m69);
            mc_y = nullptr;
            m73 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&mc_y, m73);
            emlrt_marshallIn(b_sprintf(dc_y, mc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          i = t_cpu_yCol->size[0];
          t_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(t_cpu_yCol, i, &cd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(t_cpu_yCol, &n_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel520<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              n_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel521<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
              (cpu_lidx - 1, ix), n_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
            i = u_cpu_w->size[0] * u_cpu_w->size[1];
            u_cpu_w->size[0] = 1;
            u_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel522<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (n_gpu_yCol, d_gpu_h, t_gpu_w);
          } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            i = u_cpu_w->size[0] * u_cpu_w->size[1];
            u_cpu_w->size[0] = nsubs;
            u_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel534<<<grid, block>>>(nsubs - 1, t_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = nsubs;
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel535<<<grid, block>>>(nsubs - 1, t_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) ==
                        1)) {
              ec_wtcc_kernel536<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f7);
              ec_wtcc_kernel537<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f7,
                *gpu_a_data);
              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = 1;
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel538<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (n_gpu_yCol, *gpu_a_data, t_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (static_cast<int32_T>(toler) < MIN_int32_T - OH))
              {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (static_cast<int32_T>(toler) > MAX_int32_T
                                      - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + static_cast<int32_T>(toler);
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = gd_cpu_expanded->size[0] * gd_cpu_expanded->size[1];
              gd_cpu_expanded->size[0] = i1Start;
              gd_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(gd_cpu_expanded, i, &nb_emlrtRTEI);
              itime = (OH + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(gd_cpu_expanded, &jb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel539<<<grid, block>>>(itime, jb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              i = sf_cpu_y->size[0] * sf_cpu_y->size[1];
              sf_cpu_y->size[0] = 1;
              sf_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(sf_cpu_y, i, &ob_emlrtRTEI);
              sf_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                sf_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv168->size[0];
              cpu_iv168->size[0] = sf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv168, i, &nb_emlrtRTEI);
              n = sf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(sf_cpu_y, &xc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv168, &gpu_iv168, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&xc_gpu_y, sf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel540<<<grid, block>>>(offsetH, xc_gpu_y, n,
                  gpu_iv168);
              }

              omega_tmp2[0] = cpu_iv168->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel541<<<grid, block>>>(d_gpu_h, gpu_iv168,
                  omega_tmp2[0] - 1, jb_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = static_cast<int32_T>(toler) - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = oc_cpu_rows->size[0] * oc_cpu_rows->size[1];
              oc_cpu_rows->size[0] = 1;
              oc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(oc_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                oc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  oc_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = OH;
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (OH != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, OH - 1), dim3(N, 1U,
                  1U), dim3(static_cast<uint32_T>(i), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(oc_cpu_rows, &fb_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&fb_gpu_rows, oc_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel542<<<grid, block>>>(jb_gpu_expanded,
                    fb_gpu_rows, n_gpu_yCol, toler, OH - 1, t_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
            }

            i = u_cpu_w->size[0] * u_cpu_w->size[1];
            u_cpu_w->size[0] = nsubs;
            u_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel543<<<grid, block>>>(nsubs - 1, t_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = nsubs;
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel544<<<grid, block>>>(nsubs - 1, t_gpu_w);
              }
            } else if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] ==
                        1)) {
              ec_wtcc_kernel545<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f6);
              ec_wtcc_kernel546<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f6,
                *gpu_a_data);
              i = w_cpu_yCol->size[0];
              w_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(w_cpu_yCol, i, &mb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(w_cpu_yCol, &o_gpu_yCol, true);
              ec_wtcc_kernel547<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (n_gpu_yCol, *gpu_a_data, o_gpu_yCol);
              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = nsubs;
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &id_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel548<<<grid, block>>>(o_gpu_yCol, nsubs - 1,
                  t_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(static_cast<int32_T>(toler)) +
                   static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              i = fd_cpu_expanded->size[0] * fd_cpu_expanded->size[1];
              fd_cpu_expanded->size[0] = i1Start - 1;
              fd_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_creal32_T(fd_cpu_expanded, i, &nb_emlrtRTEI);
              n = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(fd_cpu_expanded, &kb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel549<<<grid, block>>>(n, kb_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              i = mf_cpu_y->size[0] * mf_cpu_y->size[1];
              mf_cpu_y->size[0] = 1;
              mf_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(mf_cpu_y, i, &ob_emlrtRTEI);
              mf_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                mf_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv170->size[0];
              cpu_iv170->size[0] = mf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv170, i, &nb_emlrtRTEI);
              n = mf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(mf_cpu_y, &yc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv170, &gpu_iv170, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&yc_gpu_y, mf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel550<<<grid, block>>>(offsetH, yc_gpu_y, n,
                  gpu_iv170);
              }

              fx_size[0] = cpu_iv170->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, fx_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel551<<<grid, block>>>(n_gpu_yCol, gpu_iv170,
                  fx_size[0] - 1, kb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              i = hd_cpu_rows->size[0] * hd_cpu_rows->size[1];
              hd_cpu_rows->size[0] = 1;
              hd_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(hd_cpu_rows, i, &ob_emlrtRTEI);
              hd_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              fb_Omega_needsGpuEnsureCapacity = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                hd_cpu_rows->data[itime + 1] = nsubs;
              }

              i = u_cpu_w->size[0] * u_cpu_w->size[1];
              u_cpu_w->size[0] = static_cast<int32_T>(N);
              u_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (static_cast<int32_T>(N) != 0) {
                cpu_lidx = d_cpu_h->size[0];
                for (nsubs = 0; nsubs < OH; nsubs++) {
                  i = w_cpu_newIm->size[0];
                  w_cpu_newIm->size[0] = hd_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(w_cpu_newIm, i, &nb_emlrtRTEI);
                  n = hd_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  if (fb_Omega_needsGpuEnsureCapacity) {
                    gpuEmxEnsureCapacity_int32_T(hd_cpu_rows, &gb_gpu_rows,
                      !y_outdatedOnCpu);
                  }

                  fb_Omega_needsGpuEnsureCapacity = false;
                  gpuEmxEnsureCapacity_creal32_T(w_cpu_newIm, &p_gpu_newIm, true);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&gb_gpu_rows, hd_cpu_rows);
                  }

                  y_outdatedOnCpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel552<<<grid, block>>>(kb_gpu_expanded, nsubs,
                      gb_gpu_rows, n, p_gpu_newIm);
                  }

                  fb_Omega_outdatedOnGpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                    if (fb_Omega_outdatedOnGpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(w_cpu_newIm, &p_gpu_newIm);
                    }

                    if (omega_tmp2_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += w_cpu_newIm->data[offsetH].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                    fb_Omega_outdatedOnGpu = false;
                    omega_tmp2_outdatedOnCpu = false;
                    cv_im += w_cpu_newIm->data[offsetH].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                  }

                  if (fb_Omega_outdatedOnCpu) {
                    gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
                  }

                  fb_Omega_outdatedOnCpu = false;
                  ec_wtcc_kernel553<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nsubs, t_gpu_w);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            vc_y = nullptr;
            m90 = emlrtCreateCharArray(2, &iv138[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m90, &rfmt[0]);
            emlrtAssign(&vc_y, m90);
            xc_y = nullptr;
            m93 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&xc_y, m93);
            emlrt_marshallIn(b_sprintf(vc_y, xc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (u_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = u_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = u_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel523<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel524<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = ob_cpu_w->size[0] * ob_cpu_w->size[1];
          ob_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          ob_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(ob_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(u_cpu_w, &t_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(ob_cpu_w, &u_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel525<<<grid, block>>>(t_gpu_w, cpu_lshift[0], ix, itime,
              cpu_lidx - 1, u_gpu_w, ob_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = wf_cpu_y->size[0] * wf_cpu_y->size[1];
          wf_cpu_y->size[0] = cpu_origSiz[0];
          wf_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_creal32_T(wf_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(wf_cpu_y, &tc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel526<<<grid, block>>>(u_gpu_w, n, tc_gpu_y);
          }

          r = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                        b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = wb_cpu_w->size[0] * wb_cpu_w->size[1];
            wb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            wb_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_creal32_T(wb_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(wb_cpu_w, &v_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel527<<<grid, block>>>(t_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, v_gpu_w, wb_cpu_w->size[0U]);
            }

            nsubs = wf_cpu_y->size[0] * wf_cpu_y->size[1];
            wf_cpu_y->size[0] = cpu_lidx;
            wf_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(wf_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(wf_cpu_y, &tc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel528<<<grid, block>>>(v_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, tc_gpu_y, wf_cpu_y->size[0U]);
            }
          }

          if (wf_cpu_y->size[0] * wf_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = wf_cpu_y->size[0] * wf_cpu_y->size[1];
          }

          omega_tmp2[0] = wf_cpu_y->size[0] * wf_cpu_y->size[1];
          i = eh_cpu_y->size[0] * eh_cpu_y->size[1];
          eh_cpu_y->size[0] = 1;
          eh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(eh_cpu_y, i, &od_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(eh_cpu_y, &uc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel529<<<grid, block>>>(tc_gpu_y, omega_tmp2[0] - 1,
              uc_gpu_y);
          }

          i = xe_cpu_y->size[0] * xe_cpu_y->size[1];
          xe_cpu_y->size[0] = n;
          xe_cpu_y->size[1] = 1;
          emxEnsureCapacity_creal32_T(xe_cpu_y, i, &pd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(xe_cpu_y, &vc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel530<<<grid, block>>>(uc_gpu_y, n - 1, vc_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            cc_y = nullptr;
            m57 = emlrtCreateCharArray(2, &iv122[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m57, &rfmt[0]);
            emlrtAssign(&cc_y, m57);
            lc_y = nullptr;
            m66 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&lc_y, m66);
            emlrt_marshallIn(b_sprintf(cc_y, lc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = b_cpu_opts_x->size[itime];
          }

          cpu_lidx = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          i = n_cpu_yCol->size[0];
          n_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(n_cpu_yCol, i, &cd_emlrtRTEI);
          itime = offsetH * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(n_cpu_yCol, &p_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel554<<<grid, block>>>(itime, p_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (cpu_lidx *
                 static_cast<int32_T>(toler) > 1)))) {
            ix = 1;
            cpu_lidx = 0;
          } else {
            ix = static_cast<int32_T>(toler);
            cpu_lidx = offsetH * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel555<<<grid, block>>>(b_gpu_opts_x, ix, div_s32
              (cpu_lidx - 1, ix), p_gpu_yCol);
          }

          cpu_origSiz[0] = b_cpu_opts_x->size[0] * static_cast<int32_T>(toler);
          if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (b_cpu_opts_x->size[1] < 1) {
              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = 1;
              n_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel556<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(w_gpu_w);
            } else {
              i = b_cpu_opts_x->size[1];
              nsubs = p_cpu_a->size[0];
              p_cpu_a->size[0] = b_cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(p_cpu_a, nsubs, &jb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(i - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(p_cpu_a, &l_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel563<<<grid, block>>>(p_gpu_yCol, i - 1, l_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              i = w_cpu_c->size[0];
              w_cpu_c->size[0] = p_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(w_cpu_c, i, &lb_emlrtRTEI);
              n = p_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &h_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel564<<<grid, block>>>(n, h_gpu_c);
              }

              if (p_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                i = w_cpu_c->size[0];
                w_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(w_cpu_c, i, &lb_emlrtRTEI);
                ec_wtcc_kernel565<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (l_gpu_a, cpu_cv_re, gpu_f24, gpu_f25);
                gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &h_gpu_c, true);
                ec_wtcc_kernel566<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f25, gpu_f24, h_gpu_c);
              } else {
                bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (p_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(p_cpu_a->size[0])
                  + static_cast<uint32_T>(bcoef)) - 1U) / static_cast<real_T>
                   (bcoef)));
                OH = p_cpu_a->size[0];
                if (p_cpu_a->size[0] > 2147483646) {
                  i1Start = MAX_int32_T;
                } else {
                  i1Start = p_cpu_a->size[0] + 1;
                }

                i = oc_cpu_expanded->size[0];
                oc_cpu_expanded->size[0] = i1Start - 1;
                emxEnsureCapacity_creal32_T(oc_cpu_expanded, i, &nb_emlrtRTEI);
                n = p_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(oc_cpu_expanded, &lb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel568<<<grid, block>>>(n, lb_gpu_expanded);
                }

                n = p_cpu_a->size[0];
                i = ke_cpu_y->size[0] * ke_cpu_y->size[1];
                ke_cpu_y->size[0] = 1;
                ke_cpu_y->size[1] = p_cpu_a->size[0];
                emxEnsureCapacity_int32_T(ke_cpu_y, i, &ob_emlrtRTEI);
                ke_cpu_y->data[0] = 1;
                nsubs = 1;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  ke_cpu_y->data[itime + 1] = nsubs;
                }

                i = cpu_iv145->size[0];
                cpu_iv145->size[0] = ke_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv145, i, &nb_emlrtRTEI);
                n = ke_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ke_cpu_y, &ad_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv145, &gpu_iv145, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ad_gpu_y, ke_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel569<<<grid, block>>>(ad_gpu_y, n, gpu_iv145);
                }

                omega_tmp2[0] = cpu_iv145->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel570<<<grid, block>>>(l_gpu_a, gpu_iv145,
                    omega_tmp2[0] - 1, lb_gpu_expanded);
                }

                i = w_cpu_c->size[0];
                w_cpu_c->size[0] = p_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(w_cpu_c, i, &nb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(OH - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &h_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel571<<<grid, block>>>(lb_gpu_expanded, cpu_cv_re,
                    OH - 1, h_gpu_c);
                }
              }

              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = 1;
              n_cpu_w->size[1] = w_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              n = w_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel567<<<grid, block>>>(h_gpu_c, n, w_gpu_w,
                  n_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
            }

            if (b_cpu_opts_x->size[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = b_cpu_opts_x->size[1];
            }

            i = n_cpu_w->size[0] * n_cpu_w->size[1];
            n_cpu_w->size[0] = nsubs;
            n_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel572<<<grid, block>>>(itime, w_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = nsubs;
              n_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel573<<<grid, block>>>(itime, w_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                        (b_cpu_opts_x->size[1] == 1))) {
              ec_wtcc_kernel574<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f15);
              ec_wtcc_kernel575<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f15,
                *gpu_a_data);
              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = 1;
              n_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              ec_wtcc_kernel576<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (p_gpu_yCol, *gpu_a_data, w_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (cpu_origSiz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(b_cpu_opts_x->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(b_cpu_opts_x->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                i = static_cast<int32_T>(s);
              } else {
                i = MIN_int32_T;
              }

              b_blockDims[0] = i;
              b_blockDims[1] = cpu_lidx;
              ix = b_cpu_opts_x->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  OH = static_cast<int32_T>(r);
                } else {
                  OH = MIN_int32_T;
                }
              } else {
                OH = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
                i1Start = MIN_int32_T;
              } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = OH + cpu_origSiz[0];
              }

              if (i1Start >= -2147483647) {
                i1Start--;
              }

              i = sc_cpu_expanded->size[0] * sc_cpu_expanded->size[1];
              sc_cpu_expanded->size[0] = i1Start;
              emxEnsureCapacity_real32_T(sc_cpu_expanded, i, &nb_emlrtRTEI);
              if (b_cpu_opts_x->size[1] > MAX_int32_T - b_cpu_opts_x->size[1]) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = b_cpu_opts_x->size[1] + b_cpu_opts_x->size[1];
              }

              i = sc_cpu_expanded->size[0] * sc_cpu_expanded->size[1];
              sc_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_real32_T(sc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((OH + cpu_origSiz[0]) - 1) * ((b_cpu_opts_x->size[1] +
                b_cpu_opts_x->size[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(sc_cpu_expanded, &mb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel577<<<grid, block>>>(n, mb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              i = qe_cpu_y->size[0] * qe_cpu_y->size[1];
              qe_cpu_y->size[0] = 1;
              qe_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(qe_cpu_y, i, &ob_emlrtRTEI);
              qe_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                qe_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv150->size[0];
              cpu_iv150->size[0] = qe_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv150, i, &nb_emlrtRTEI);
              n = qe_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(qe_cpu_y, &bd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv150, &gpu_iv150, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&bd_gpu_y, qe_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel578<<<grid, block>>>(offsetH, bd_gpu_y, n,
                  gpu_iv150);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                floor((static_cast<real_T>(b_cpu_opts_x->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv150->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel579<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv150,
                  omega_tmp2[0] - 1, mb_gpu_expanded, sc_cpu_expanded->size[0U]);
              }

              if (cpu_origSiz[0] < -2147483647) {
                i1Start = MIN_int32_T;
              } else {
                i1Start = cpu_origSiz[0] - 1;
              }

              if (i1Start < 0) {
                n = 0;
              } else {
                n = i1Start + 1;
              }

              y_outdatedOnCpu = false;
              i = bc_cpu_rows->size[0] * bc_cpu_rows->size[1];
              bc_cpu_rows->size[0] = 1;
              bc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(bc_cpu_rows, i, &ob_emlrtRTEI);
              if (n > 0) {
                bc_cpu_rows->data[0] = 0;
                y_outdatedOnCpu = true;
                nsubs = 0;
                for (itime = 0; itime <= n - 2; itime++) {
                  nsubs++;
                  bc_cpu_rows->data[itime + 1] = nsubs;
                }
              }

              n = b_cpu_opts_x->size[1];
              i = i_cpu_cols->size[0] * i_cpu_cols->size[1];
              i_cpu_cols->size[0] = 1;
              i_cpu_cols->size[1] = b_cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(i_cpu_cols, i, &ob_emlrtRTEI);
              i_cpu_cols->data[0] = 0;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                i_cpu_cols->data[itime + 1] = nsubs;
              }

              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = OH;
              n_cpu_w->size[1] = b_cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (OH != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                i = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  i = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                  static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                  (static_cast<uint32_T>(i), static_cast<uint32_T>(b_blockDims[1]),
                   1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(i_cpu_cols, &e_gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(bc_cpu_rows, &hb_gpu_rows,
                  !y_outdatedOnCpu);
                gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
                fb_Omega_outdatedOnCpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&e_gpu_cols, i_cpu_cols);
                if (y_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&hb_gpu_rows, bc_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel580<<<grid, block>>>(mb_gpu_expanded, e_gpu_cols,
                    hb_gpu_rows, p_gpu_yCol, *gpu_origSiz, OH - 1, ix - 1,
                    w_gpu_w, sc_cpu_expanded->size[0U], n_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_origSiz[0] == 0) {
              nsubs = d_cpu_h->size[0];
            } else {
              nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
            }

            if (b_cpu_opts_x->size[1] == 0) {
              cpu_lidx = 1;
            } else {
              cpu_lidx = b_cpu_opts_x->size[1];
            }

            i = n_cpu_w->size[0] * n_cpu_w->size[1];
            n_cpu_w->size[0] = nsubs;
            n_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel581<<<grid, block>>>(itime, w_gpu_w);
            }

            if ((cpu_origSiz[0] == 0) || (b_cpu_opts_x->size[1] == 0)) {
              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = nsubs;
              n_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              itime = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel582<<<grid, block>>>(itime, w_gpu_w);
              }
            } else if ((cpu_origSiz[0] == 1) && (b_cpu_opts_x->size[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel583<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f14);
              ec_wtcc_kernel584<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f14,
                *gpu_a_data);
              i = ab_cpu_yCol->size[0];
              ab_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(ab_cpu_yCol, i, &mb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(ab_cpu_yCol, &q_gpu_yCol, true);
              ec_wtcc_kernel585<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (p_gpu_yCol, *gpu_a_data, q_gpu_yCol);
              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = nsubs;
              n_cpu_w->size[1] = cpu_lidx;
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &id_emlrtRTEI);
              n = nsubs * cpu_lidx - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel586<<<grid, block>>>(q_gpu_yCol, n, w_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = b_cpu_opts_x->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              OH = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              i = rc_cpu_expanded->size[0] * rc_cpu_expanded->size[1];
              rc_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_creal32_T(rc_cpu_expanded, i, &nb_emlrtRTEI);
              if (b_cpu_opts_x->size[1] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = b_cpu_opts_x->size[1] + 1;
              }

              i = rc_cpu_expanded->size[0] * rc_cpu_expanded->size[1];
              rc_cpu_expanded->size[1] = i1Start - 1;
              emxEnsureCapacity_creal32_T(rc_cpu_expanded, i, &nb_emlrtRTEI);
              n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                b_cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(rc_cpu_expanded, &nb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel587<<<grid, block>>>(n, nb_gpu_expanded);
              }

              n = cpu_origSiz[0];
              i = ne_cpu_y->size[0] * ne_cpu_y->size[1];
              ne_cpu_y->size[0] = 1;
              ne_cpu_y->size[1] = cpu_origSiz[0];
              emxEnsureCapacity_int32_T(ne_cpu_y, i, &ob_emlrtRTEI);
              ne_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                ne_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv153->size[0];
              cpu_iv153->size[0] = ne_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv153, i, &nb_emlrtRTEI);
              n = ne_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ne_cpu_y, &cd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv153, &gpu_iv153, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&cd_gpu_y, ne_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel588<<<grid, block>>>(offsetH, cd_gpu_y, n,
                  gpu_iv153);
              }

              n = b_cpu_opts_x->size[1];
              i = lf_cpu_y->size[0] * lf_cpu_y->size[1];
              lf_cpu_y->size[0] = 1;
              lf_cpu_y->size[1] = b_cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(lf_cpu_y, i, &ob_emlrtRTEI);
              lf_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                lf_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv169->size[0];
              cpu_iv169->size[0] = lf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv169, i, &nb_emlrtRTEI);
              n = lf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(lf_cpu_y, &dd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv169, &gpu_iv169, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&dd_gpu_y, lf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel589<<<grid, block>>>(dd_gpu_y, n, gpu_iv169);
              }

              fx_size[0] = cpu_iv153->size[0];
              fx_size[1] = cpu_iv169->size[0];
              mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel590<<<grid, block>>>(p_gpu_yCol, fx_size[0],
                  gpu_iv169, gpu_iv153, fx_size[0] - 1, fx_size[1] - 1,
                  nb_gpu_expanded, rc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              i = jc_cpu_rows->size[0] * jc_cpu_rows->size[1];
              jc_cpu_rows->size[0] = 1;
              jc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(jc_cpu_rows, i, &ob_emlrtRTEI);
              jc_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              fb_Omega_needsGpuEnsureCapacity = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                jc_cpu_rows->data[itime + 1] = nsubs;
              }

              i = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = static_cast<int32_T>(N);
              n_cpu_w->size[1] = b_cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(n_cpu_w, i, &nb_emlrtRTEI);
              fb_Omega_outdatedOnCpu = true;
              if (static_cast<int32_T>(N) != 0) {
                for (bcoef = 0; bcoef < ix; bcoef++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nsubs = 0; nsubs < OH; nsubs++) {
                    i = g_cpu_newIm->size[0];
                    g_cpu_newIm->size[0] = jc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(g_cpu_newIm, i, &nb_emlrtRTEI);
                    n = jc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                      2147483647U);
                    if (fb_Omega_needsGpuEnsureCapacity) {
                      gpuEmxEnsureCapacity_int32_T(jc_cpu_rows, &ib_gpu_rows,
                        !y_outdatedOnCpu);
                    }

                    fb_Omega_needsGpuEnsureCapacity = false;
                    gpuEmxEnsureCapacity_creal32_T(g_cpu_newIm, &q_gpu_newIm,
                      true);
                    if (y_outdatedOnCpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&ib_gpu_rows, jc_cpu_rows);
                    }

                    y_outdatedOnCpu = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel591<<<grid, block>>>(bcoef, nb_gpu_expanded,
                        nsubs, ib_gpu_rows, n, q_gpu_newIm,
                        rc_cpu_expanded->size[0U]);
                    }

                    fb_Omega_outdatedOnGpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                      if (fb_Omega_outdatedOnGpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(g_cpu_newIm, &q_gpu_newIm);
                      }

                      if (omega_tmp2_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += g_cpu_newIm->data[offsetH].re * d_cpu_h->
                        data[(d_cpu_h->size[0] - offsetH) - 1];
                      fb_Omega_outdatedOnGpu = false;
                      omega_tmp2_outdatedOnCpu = false;
                      cv_im += g_cpu_newIm->data[offsetH].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - offsetH) - 1];
                    }

                    if (fb_Omega_outdatedOnCpu) {
                      gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
                    }

                    fb_Omega_outdatedOnCpu = false;
                    ec_wtcc_kernel592<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, bcoef, nsubs, w_gpu_w, n_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            yc_y = nullptr;
            m76 = emlrtCreateCharArray(2, &iv131[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m76, &rfmt[0]);
            emlrtAssign(&yc_y, m76);
            gd_y = nullptr;
            m83 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&gd_y, m83);
            emlrt_marshallIn(b_sprintf(yc_y, gd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (n_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          wav_outdatedOnCpu = false;
          interval_outdatedOnGpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_origSiz[itime] = n_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
            cpu_lshift[itime] = n_cpu_w->size[itime];
            wav_outdatedOnCpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (wav_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel557<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
            ix = 1;
            bcoef = -1;
          } else {
            ix = static_cast<int32_T>(b_m);
            bcoef = cpu_lshift[0] - 1;
          }

          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel558<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
            nsubs, *gpu_origSiz);
          i = tb_cpu_w->size[0] * tb_cpu_w->size[1];
          tb_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          tb_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(tb_cpu_w, i, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
            &block, 2147483647U);
          if (fb_Omega_outdatedOnCpu) {
            gpuEmxEnsureCapacity_creal32_T(n_cpu_w, &w_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(tb_cpu_w, &x_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel559<<<grid, block>>>(w_gpu_w, cpu_lshift[0], ix, itime,
              cpu_lidx - 1, x_gpu_w, tb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          i = xe_cpu_y->size[0] * xe_cpu_y->size[1];
          xe_cpu_y->size[0] = cpu_origSiz[0];
          xe_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_creal32_T(xe_cpu_y, i, &id_emlrtRTEI);
          n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(xe_cpu_y, &vc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel560<<<grid, block>>>(x_gpu_w, n, vc_gpu_y);
          }

          r = std::ceil(((static_cast<real_T>(b_cpu_opts_x->size[0]) - 1.0) *
                         toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(cpu_origSiz[0] < r)) {
            if (r < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(r);
            }

            nsubs = cc_cpu_w->size[0] * cc_cpu_w->size[1];
            cc_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
            cc_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_creal32_T(cc_cpu_w, nsubs, &nd_emlrtRTEI);
            itime = bcoef / ix;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(cc_cpu_w, &y_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel561<<<grid, block>>>(w_gpu_w, cpu_lshift[0], ix,
                itime, cpu_lshift[1] - 1, y_gpu_w, cc_cpu_w->size[0U]);
            }

            nsubs = xe_cpu_y->size[0] * xe_cpu_y->size[1];
            xe_cpu_y->size[0] = cpu_lidx;
            xe_cpu_y->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(xe_cpu_y, nsubs, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(xe_cpu_y, &vc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel562<<<grid, block>>>(y_gpu_w, cpu_origSiz[0],
                cpu_lidx - 1, cpu_origSiz[1] - 1, vc_gpu_y, xe_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          i = rf_cpu_y->size[0] * rf_cpu_y->size[1];
          rf_cpu_y->size[0] = 1;
          rf_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(rf_cpu_y, i, &h_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(rf_cpu_y, &wc_gpu_y, true);
          o_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel531<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(wc_gpu_y);
        } else if (halfh < 1.0) {
          rf_cpu_y->size[0] = 1;
          rf_cpu_y->size[1] = 0;
        } else {
          i = rf_cpu_y->size[0] * rf_cpu_y->size[1];
          rf_cpu_y->size[0] = 1;
          rf_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(rf_cpu_y, i, &h_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(rf_cpu_y, &wc_gpu_y, true);
          o_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel533<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              wc_gpu_y);
          }
        }

        i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
        b_cpu_y1->size[1] = 1;
        emxEnsureCapacity_creal32_T(b_cpu_y1, i, &rc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (o_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(rf_cpu_y, &wc_gpu_y, true);
        }

        o_y_needsGpuEnsureCapacity = false;
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel532<<<grid, block>>>(vc_gpu_y, wc_gpu_y, T, static_cast<
            int32_T>(halfh) - 1, b_gpu_y1);
        }
      } else {
        tol = std::ceil(static_cast<real_T>(b_cpu_opts_x->size[0]) * toler / b_m);
        first_iteration = (b_cpu_opts_x->size[0] == 1);
        if (first_iteration) {
          i = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
          b_cpu_xCol->size[0] = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
          b_cpu_xCol->size[1] = 1;
          emxEnsureCapacity_creal32_T(b_cpu_xCol, i, &yc_emlrtRTEI);
          n = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(b_cpu_xCol, &gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel623<<<grid, block>>>(b_gpu_opts_x, n, gpu_xCol);
          }
        } else {
          i = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
          b_cpu_xCol->size[0] = b_cpu_opts_x->size[0];
          b_cpu_xCol->size[1] = b_cpu_opts_x->size[1];
          emxEnsureCapacity_creal32_T(b_cpu_xCol, i, &xc_emlrtRTEI);
          n = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(b_cpu_xCol, &gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel698<<<grid, block>>>(b_gpu_opts_x, n, gpu_xCol);
          }
        }

        if (!(toler - 1.0 >= 0.0)) {
          rc_y = nullptr;
          m59 = emlrtCreateCharArray(2, &iv124[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m59, &rfmt[0]);
          emlrtAssign(&rc_y, m59);
          tc_y = nullptr;
          m68 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&tc_y, m68);
          emlrt_marshallIn(b_sprintf(rc_y, tc_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        offsetH = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
        if ((b_cpu_xCol->size[0] == 1) && (b_cpu_xCol->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (b_cpu_xCol->size[0] != 1) {
            nsubs = 0;
          }
        }

        for (itime = 0; itime < 2; itime++) {
          cpu_origSiz[itime] = b_cpu_xCol->size[itime];
        }

        cpu_lidx = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
        i = q_cpu_yCol->size[0];
        q_cpu_yCol->size[0] = offsetH * static_cast<int32_T>(toler);
        emxEnsureCapacity_creal32_T(q_cpu_yCol, i, &cd_emlrtRTEI);
        itime = offsetH * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(q_cpu_yCol, &r_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel624<<<grid, block>>>(itime, r_gpu_yCol);
        }

        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (cpu_lidx * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (cpu_lidx * static_cast<
               int32_T>(toler) > 1)))) {
          ix = 1;
          cpu_lidx = 0;
        } else {
          ix = static_cast<int32_T>(toler);
          cpu_lidx = offsetH * static_cast<int32_T>(toler);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, ix)),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel625<<<grid, block>>>(gpu_xCol, ix, div_s32(cpu_lidx - 1,
            ix), r_gpu_yCol);
        }

        cpu_origSiz[nsubs] = b_cpu_xCol->size[nsubs] * static_cast<int32_T>
          (toler);
        if ((cpu_origSiz[0] == 1) && (d_cpu_h->size[0] == 1)) {
          if (cpu_origSiz[1] < 1) {
            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = 1;
            r_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel626<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ab_gpu_w);
          } else {
            nsubs = s_cpu_a->size[0];
            s_cpu_a->size[0] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(s_cpu_a, nsubs, &jb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(s_cpu_a, &m_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel638<<<grid, block>>>(r_gpu_yCol, cpu_origSiz[1] - 1,
                m_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
            cpu_cv_re = d_cpu_h->data[0];
            i = ab_cpu_c->size[0];
            ab_cpu_c->size[0] = s_cpu_a->size[0];
            emxEnsureCapacity_creal32_T(ab_cpu_c, i, &lb_emlrtRTEI);
            n = s_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ab_cpu_c, &i_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel639<<<grid, block>>>(n, i_gpu_c);
            }

            if (s_cpu_a->size[0] == 1) {
              cpu_cv_re = d_cpu_h->data[0];
              i = ab_cpu_c->size[0];
              ab_cpu_c->size[0] = 1;
              emxEnsureCapacity_creal32_T(ab_cpu_c, i, &lb_emlrtRTEI);
              ec_wtcc_kernel640<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(m_gpu_a,
                cpu_cv_re, gpu_f36, gpu_f37);
              gpuEmxEnsureCapacity_creal32_T(ab_cpu_c, &i_gpu_c, true);
              ec_wtcc_kernel641<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f37,
                gpu_f36, i_gpu_c);
            } else {
              bcoef = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (s_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(s_cpu_a->size[0]) +
                static_cast<uint32_T>(bcoef)) - 1.0) / static_cast<real_T>(bcoef)));
              OH = s_cpu_a->size[0];
              if (s_cpu_a->size[0] > 2147483646) {
                i1Start = MAX_int32_T;
              } else {
                i1Start = s_cpu_a->size[0] + 1;
              }

              i = xc_cpu_expanded->size[0];
              xc_cpu_expanded->size[0] = i1Start - 1;
              emxEnsureCapacity_creal32_T(xc_cpu_expanded, i, &nb_emlrtRTEI);
              n = s_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(xc_cpu_expanded, &sb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel643<<<grid, block>>>(n, sb_gpu_expanded);
              }

              n = s_cpu_a->size[0];
              i = ve_cpu_y->size[0] * ve_cpu_y->size[1];
              ve_cpu_y->size[0] = 1;
              ve_cpu_y->size[1] = s_cpu_a->size[0];
              emxEnsureCapacity_int32_T(ve_cpu_y, i, &ob_emlrtRTEI);
              ve_cpu_y->data[0] = 1;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                ve_cpu_y->data[itime + 1] = nsubs;
              }

              i = cpu_iv156->size[0];
              cpu_iv156->size[0] = ve_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv156, i, &nb_emlrtRTEI);
              n = ve_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ve_cpu_y, &ld_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv156, &gpu_iv156, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ld_gpu_y, ve_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel644<<<grid, block>>>(ld_gpu_y, n, gpu_iv156);
              }

              omega_tmp2[0] = cpu_iv156->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel645<<<grid, block>>>(m_gpu_a, gpu_iv156,
                  omega_tmp2[0] - 1, sb_gpu_expanded);
              }

              i = ab_cpu_c->size[0];
              ab_cpu_c->size[0] = s_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(ab_cpu_c, i, &nb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(OH - 1), dim3
                (static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(static_cast<int8_T>(bcoef)), 1U, 1U),
                &grid, &block);
              gpuEmxEnsureCapacity_creal32_T(ab_cpu_c, &i_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel646<<<grid, block>>>(sb_gpu_expanded, cpu_cv_re,
                  OH - 1, i_gpu_c);
              }
            }

            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = 1;
            r_cpu_w->size[1] = ab_cpu_c->size[0];
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            n = ab_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel642<<<grid, block>>>(i_gpu_c, n, ab_gpu_w,
                r_cpu_w->size[0U]);
            }
          }
        } else if (d_cpu_h->size[0] > cpu_origSiz[0]) {
          if (cpu_origSiz[0] == 0) {
            nsubs = d_cpu_h->size[0];
          } else {
            nsubs = (d_cpu_h->size[0] + cpu_origSiz[0]) - 1;
          }

          if (cpu_origSiz[1] == 0) {
            cpu_lidx = 1;
          } else {
            cpu_lidx = cpu_origSiz[1];
          }

          i = r_cpu_w->size[0] * r_cpu_w->size[1];
          r_cpu_w->size[0] = nsubs;
          r_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
          itime = nsubs * cpu_lidx - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel647<<<grid, block>>>(itime, ab_gpu_w);
          }

          if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = nsubs;
            r_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel648<<<grid, block>>>(itime, ab_gpu_w);
            }
          } else if ((d_cpu_h->size[0] == 1) && ((cpu_origSiz[0] == 1) &&
                      (cpu_origSiz[1] == 1))) {
            ec_wtcc_kernel649<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f35);
            ec_wtcc_kernel650<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f35, *
              gpu_a_data);
            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = 1;
            r_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            ec_wtcc_kernel651<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (r_gpu_yCol, *gpu_a_data, ab_gpu_w);
          } else {
            r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                 (cpu_origSiz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (cpu_origSiz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(cpu_origSiz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              i = static_cast<int32_T>(s);
            } else {
              i = MIN_int32_T;
            }

            b_blockDims[0] = i;
            b_blockDims[1] = cpu_lidx;
            ix = cpu_origSiz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                OH = static_cast<int32_T>(r);
              } else {
                OH = MIN_int32_T;
              }
            } else {
              OH = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(cpu_origSiz[0]) / 2.0) + std::
              floor((static_cast<real_T>(cpu_origSiz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((OH < 0) && (cpu_origSiz[0] < MIN_int32_T - OH)) {
              i1Start = MIN_int32_T;
            } else if ((OH > 0) && (cpu_origSiz[0] > MAX_int32_T - OH)) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = OH + cpu_origSiz[0];
            }

            if (i1Start >= -2147483647) {
              i1Start--;
            }

            i = ad_cpu_expanded->size[0] * ad_cpu_expanded->size[1];
            ad_cpu_expanded->size[0] = i1Start;
            emxEnsureCapacity_real32_T(ad_cpu_expanded, i, &nb_emlrtRTEI);
            if ((cpu_origSiz[1] < 0) && (cpu_origSiz[1] < MIN_int32_T
                 - cpu_origSiz[1])) {
              i1Start = MIN_int32_T;
            } else if ((cpu_origSiz[1] > 0) && (cpu_origSiz[1] > MAX_int32_T
                        - cpu_origSiz[1])) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = cpu_origSiz[1] + cpu_origSiz[1];
            }

            if (i1Start >= -2147483647) {
              i1Start--;
            }

            i = ad_cpu_expanded->size[0] * ad_cpu_expanded->size[1];
            ad_cpu_expanded->size[1] = i1Start;
            emxEnsureCapacity_real32_T(ad_cpu_expanded, i, &nb_emlrtRTEI);
            n = ((OH + cpu_origSiz[0]) - 1) * ((cpu_origSiz[1] + cpu_origSiz[1])
              - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(ad_cpu_expanded, &tb_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel652<<<grid, block>>>(n, tb_gpu_expanded);
            }

            n = d_cpu_h->size[0];
            i = bf_cpu_y->size[0] * bf_cpu_y->size[1];
            bf_cpu_y->size[0] = 1;
            bf_cpu_y->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(bf_cpu_y, i, &ob_emlrtRTEI);
            bf_cpu_y->data[0] = 1;
            nsubs = 1;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              bf_cpu_y->data[itime + 1] = nsubs;
            }

            i = cpu_iv159->size[0];
            cpu_iv159->size[0] = bf_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv159, i, &nb_emlrtRTEI);
            n = bf_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(bf_cpu_y, &md_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv159, &gpu_iv159, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&md_gpu_y, bf_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel653<<<grid, block>>>(offsetH, md_gpu_y, n, gpu_iv159);
            }

            s = std::floor(static_cast<real_T>(cpu_origSiz[1]) / 2.0) + std::
              floor((static_cast<real_T>(cpu_origSiz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv159->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel654<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv159,
                omega_tmp2[0] - 1, tb_gpu_expanded, ad_cpu_expanded->size[0U]);
            }

            if (cpu_origSiz[0] < -2147483647) {
              i1Start = MIN_int32_T;
            } else {
              i1Start = cpu_origSiz[0] - 1;
            }

            if (i1Start < 0) {
              n = 0;
            } else {
              n = i1Start + 1;
            }

            y_outdatedOnCpu = false;
            i = gc_cpu_rows->size[0] * gc_cpu_rows->size[1];
            gc_cpu_rows->size[0] = 1;
            gc_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(gc_cpu_rows, i, &ob_emlrtRTEI);
            if (n > 0) {
              gc_cpu_rows->data[0] = 0;
              y_outdatedOnCpu = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                gc_cpu_rows->data[itime + 1] = nsubs;
              }
            }

            if (cpu_origSiz[1] < -2147483647) {
              i1Start = MIN_int32_T;
            } else {
              i1Start = cpu_origSiz[1] - 1;
            }

            if (i1Start < 0) {
              n = 0;
            } else {
              n = i1Start + 1;
            }

            wav_outdatedOnCpu = false;
            i = l_cpu_cols->size[0] * l_cpu_cols->size[1];
            l_cpu_cols->size[0] = 1;
            l_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(l_cpu_cols, i, &ob_emlrtRTEI);
            if (n > 0) {
              l_cpu_cols->data[0] = 0;
              wav_outdatedOnCpu = true;
              nsubs = 0;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                l_cpu_cols->data[itime + 1] = nsubs;
              }
            }

            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = OH;
            r_cpu_w->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &nb_emlrtRTEI);
            fb_Omega_outdatedOnCpu = true;
            if ((OH != 0) && (cpu_origSiz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              i = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                i = 0;
              }

              nsubs = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                nsubs = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, OH - 1), dim3(N,
                b_u, 1U), dim3(static_cast<uint32_T>(i), static_cast<uint32_T>
                               (nsubs), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(l_cpu_cols, &f_gpu_cols,
                !wav_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(gc_cpu_rows, &nb_gpu_rows,
                !y_outdatedOnCpu);
              gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
              fb_Omega_outdatedOnCpu = false;
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&f_gpu_cols, l_cpu_cols);
              }

              if (y_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&nb_gpu_rows, gc_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel655<<<grid, block>>>(tb_gpu_expanded, f_gpu_cols,
                  nb_gpu_rows, r_gpu_yCol, *gpu_origSiz, OH - 1, ix - 1,
                  ab_gpu_w, ad_cpu_expanded->size[0U], r_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (cpu_origSiz[0] == 0) {
            nsubs = d_cpu_h->size[0];
          } else {
            nsubs = (cpu_origSiz[0] + d_cpu_h->size[0]) - 1;
          }

          if (cpu_origSiz[1] == 0) {
            cpu_lidx = 1;
          } else {
            cpu_lidx = cpu_origSiz[1];
          }

          i = r_cpu_w->size[0] * r_cpu_w->size[1];
          r_cpu_w->size[0] = nsubs;
          r_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
          itime = nsubs * cpu_lidx - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel656<<<grid, block>>>(itime, ab_gpu_w);
          }

          if ((cpu_origSiz[0] == 0) || (cpu_origSiz[1] == 0)) {
            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = nsubs;
            r_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            itime = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel657<<<grid, block>>>(itime, ab_gpu_w);
            }
          } else if ((cpu_origSiz[0] == 1) && (cpu_origSiz[1] == 1) &&
                     (d_cpu_h->size[0] == 1)) {
            ec_wtcc_kernel658<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f34);
            ec_wtcc_kernel659<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f34, *
              gpu_a_data);
            i = db_cpu_yCol->size[0];
            db_cpu_yCol->size[0] = 1;
            emxEnsureCapacity_creal32_T(db_cpu_yCol, i, &mb_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(db_cpu_yCol, &s_gpu_yCol, true);
            ec_wtcc_kernel660<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (r_gpu_yCol, *gpu_a_data, s_gpu_yCol);
            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = nsubs;
            r_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &id_emlrtRTEI);
            n = nsubs * cpu_lidx - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
            fb_Omega_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel661<<<grid, block>>>(s_gpu_yCol, n, ab_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(cpu_origSiz[0]) + static_cast<uint32_T>
                 (d_cpu_h->size[0])) - 1U;
            ix = cpu_origSiz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            OH = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = static_cast<int32_T>(N) + d_cpu_h->size[0];
            }

            i = yc_cpu_expanded->size[0] * yc_cpu_expanded->size[1];
            yc_cpu_expanded->size[0] = i1Start - 1;
            emxEnsureCapacity_creal32_T(yc_cpu_expanded, i, &nb_emlrtRTEI);
            if (cpu_origSiz[1] > 2147483646) {
              i1Start = MAX_int32_T;
            } else {
              i1Start = cpu_origSiz[1] + 1;
            }

            i = yc_cpu_expanded->size[0] * yc_cpu_expanded->size[1];
            yc_cpu_expanded->size[1] = i1Start - 1;
            emxEnsureCapacity_creal32_T(yc_cpu_expanded, i, &nb_emlrtRTEI);
            n = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
              cpu_origSiz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(yc_cpu_expanded, &ub_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel662<<<grid, block>>>(n, ub_gpu_expanded);
            }

            n = cpu_origSiz[0];
            i = we_cpu_y->size[0] * we_cpu_y->size[1];
            we_cpu_y->size[0] = 1;
            we_cpu_y->size[1] = cpu_origSiz[0];
            emxEnsureCapacity_int32_T(we_cpu_y, i, &ob_emlrtRTEI);
            we_cpu_y->data[0] = 1;
            nsubs = 1;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              we_cpu_y->data[itime + 1] = nsubs;
            }

            i = cpu_iv160->size[0];
            cpu_iv160->size[0] = we_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv160, i, &nb_emlrtRTEI);
            n = we_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(we_cpu_y, &nd_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv160, &gpu_iv160, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&nd_gpu_y, we_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel663<<<grid, block>>>(offsetH, nd_gpu_y, n, gpu_iv160);
            }

            if (cpu_origSiz[1] < 1) {
              n = 0;
            } else {
              n = cpu_origSiz[1];
            }

            wav_outdatedOnCpu = false;
            i = vf_cpu_y->size[0] * vf_cpu_y->size[1];
            vf_cpu_y->size[0] = 1;
            vf_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(vf_cpu_y, i, &ob_emlrtRTEI);
            if (n > 0) {
              vf_cpu_y->data[0] = 1;
              wav_outdatedOnCpu = true;
              nsubs = 1;
              for (itime = 0; itime <= n - 2; itime++) {
                nsubs++;
                vf_cpu_y->data[itime + 1] = nsubs;
              }
            }

            i = cpu_iv177->size[0];
            cpu_iv177->size[0] = vf_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv177, i, &nb_emlrtRTEI);
            n = vf_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(vf_cpu_y, &od_gpu_y, !wav_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv177, &gpu_iv177, true);
            if (wav_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&od_gpu_y, vf_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel664<<<grid, block>>>(od_gpu_y, n, gpu_iv177);
            }

            fx_size[0] = cpu_iv160->size[0];
            fx_size[1] = cpu_iv177->size[0];
            mwGetLaunchParameters1D(computeNumIters(fx_size[1] - 1, fx_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel665<<<grid, block>>>(r_gpu_yCol, fx_size[0],
                gpu_iv177, gpu_iv160, fx_size[0] - 1, fx_size[1] - 1,
                ub_gpu_expanded, yc_cpu_expanded->size[0U]);
            }

            n = d_cpu_h->size[0];
            i = rc_cpu_rows->size[0] * rc_cpu_rows->size[1];
            rc_cpu_rows->size[0] = 1;
            rc_cpu_rows->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(rc_cpu_rows, i, &ob_emlrtRTEI);
            rc_cpu_rows->data[0] = 0;
            y_outdatedOnCpu = true;
            fb_Omega_needsGpuEnsureCapacity = true;
            nsubs = 0;
            for (itime = 0; itime <= n - 2; itime++) {
              nsubs++;
              rc_cpu_rows->data[itime + 1] = nsubs;
            }

            i = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = static_cast<int32_T>(N);
            r_cpu_w->size[1] = cpu_origSiz[1];
            emxEnsureCapacity_creal32_T(r_cpu_w, i, &nb_emlrtRTEI);
            fb_Omega_outdatedOnCpu = true;
            if ((static_cast<int32_T>(N) != 0) && (cpu_origSiz[1] != 0)) {
              for (bcoef = 0; bcoef < ix; bcoef++) {
                cpu_lidx = d_cpu_h->size[0];
                for (nsubs = 0; nsubs < OH; nsubs++) {
                  i = o_cpu_newIm->size[0];
                  o_cpu_newIm->size[0] = rc_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(o_cpu_newIm, i, &nb_emlrtRTEI);
                  n = rc_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(n), &grid, &block,
                    2147483647U);
                  if (fb_Omega_needsGpuEnsureCapacity) {
                    gpuEmxEnsureCapacity_int32_T(rc_cpu_rows, &ob_gpu_rows,
                      !y_outdatedOnCpu);
                  }

                  fb_Omega_needsGpuEnsureCapacity = false;
                  gpuEmxEnsureCapacity_creal32_T(o_cpu_newIm, &t_gpu_newIm, true);
                  if (y_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&ob_gpu_rows, rc_cpu_rows);
                  }

                  y_outdatedOnCpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel666<<<grid, block>>>(bcoef, ub_gpu_expanded,
                      nsubs, ob_gpu_rows, n, t_gpu_newIm, yc_cpu_expanded->size
                      [0U]);
                  }

                  fb_Omega_outdatedOnGpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (offsetH = 0; offsetH < cpu_lidx; offsetH++) {
                    if (fb_Omega_outdatedOnGpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(o_cpu_newIm, &t_gpu_newIm);
                    }

                    if (omega_tmp2_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += o_cpu_newIm->data[offsetH].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                    fb_Omega_outdatedOnGpu = false;
                    omega_tmp2_outdatedOnCpu = false;
                    cv_im += o_cpu_newIm->data[offsetH].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - offsetH) - 1];
                  }

                  if (fb_Omega_outdatedOnCpu) {
                    gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
                  }

                  fb_Omega_outdatedOnCpu = false;
                  ec_wtcc_kernel667<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, bcoef, nsubs, ab_gpu_w, r_cpu_w->size[0U]);
                }
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          nd_y = nullptr;
          m82 = emlrtCreateCharArray(2, &iv135[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m82, &rfmt[0]);
          emlrtAssign(&nd_y, m82);
          od_y = nullptr;
          m89 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&od_y, m89);
          emlrt_marshallIn(b_sprintf(nd_y, od_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (r_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        wav_outdatedOnCpu = false;
        interval_outdatedOnGpu = false;
        for (itime = 0; itime < 2; itime++) {
          cpu_origSiz[itime] = r_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
          cpu_lshift[itime] = r_cpu_w->size[itime];
          wav_outdatedOnCpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (wav_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel627<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *gpu_lshift);
          }

          checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        cpu_lidx = cpu_lshift[0];
        cpu_lshift[0] = cpu_lshift[1];
        cpu_lshift[1] = cpu_lidx;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_lshift[0] < 1))) {
          ix = 1;
          bcoef = -1;
        } else {
          ix = static_cast<int32_T>(b_m);
          bcoef = cpu_lshift[0] - 1;
        }

        if (interval_outdatedOnGpu) {
          checkCudaError(cudaMemcpy(*gpu_origSiz, cpu_origSiz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel628<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix, bcoef,
          nsubs, *gpu_origSiz);
        i = fc_cpu_w->size[0] * fc_cpu_w->size[1];
        fc_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
        fc_cpu_w->size[1] = cpu_lidx;
        emxEnsureCapacity_creal32_T(fc_cpu_w, i, &nd_emlrtRTEI);
        itime = bcoef / ix;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, itime), &grid,
          &block, 2147483647U);
        if (fb_Omega_outdatedOnCpu) {
          gpuEmxEnsureCapacity_creal32_T(r_cpu_w, &ab_gpu_w, true);
        }

        gpuEmxEnsureCapacity_creal32_T(fc_cpu_w, &bb_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel629<<<grid, block>>>(ab_gpu_w, cpu_lshift[0], ix, itime,
            cpu_lidx - 1, bb_gpu_w, fc_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(cpu_origSiz, *gpu_origSiz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        i = kf_cpu_y->size[0] * kf_cpu_y->size[1];
        kf_cpu_y->size[0] = cpu_origSiz[0];
        kf_cpu_y->size[1] = cpu_origSiz[1];
        emxEnsureCapacity_creal32_T(kf_cpu_y, i, &id_emlrtRTEI);
        n = cpu_origSiz[0] * cpu_origSiz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(kf_cpu_y, &id_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel630<<<grid, block>>>(bb_gpu_w, n, id_gpu_y);
        }

        r = std::ceil(((static_cast<real_T>(b_cpu_xCol->size[0]) - 1.0) * toler
                       + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
        if (!(cpu_origSiz[0] < r)) {
          if (r < 1.0) {
            cpu_lidx = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(r);
          }

          nsubs = gc_cpu_w->size[0] * gc_cpu_w->size[1];
          gc_cpu_w->size[0] = div_s32(bcoef, ix) + 1;
          gc_cpu_w->size[1] = cpu_lshift[1];
          emxEnsureCapacity_creal32_T(gc_cpu_w, nsubs, &nd_emlrtRTEI);
          itime = bcoef / ix;
          mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(gc_cpu_w, &cb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel631<<<grid, block>>>(ab_gpu_w, cpu_lshift[0], ix,
              itime, cpu_lshift[1] - 1, cb_gpu_w, gc_cpu_w->size[0U]);
          }

          nsubs = kf_cpu_y->size[0] * kf_cpu_y->size[1];
          kf_cpu_y->size[0] = cpu_lidx;
          kf_cpu_y->size[1] = cpu_origSiz[1];
          emxEnsureCapacity_creal32_T(kf_cpu_y, nsubs, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(cpu_origSiz[1] - 1, cpu_lidx -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(kf_cpu_y, &id_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel632<<<grid, block>>>(cb_gpu_w, cpu_origSiz[0],
              cpu_lidx - 1, cpu_origSiz[1] - 1, id_gpu_y, kf_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = kf_cpu_y->size[0] * kf_cpu_y->size[1];
          i = jh_cpu_y->size[0] * jh_cpu_y->size[1];
          jh_cpu_y->size[0] = 1;
          jh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(jh_cpu_y, i, &od_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(jh_cpu_y, &jd_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel633<<<grid, block>>>(id_gpu_y, omega_tmp2[0] - 1,
              jd_gpu_y, jh_cpu_y->size[0U]);
          }

          i = kf_cpu_y->size[0] * kf_cpu_y->size[1];
          kf_cpu_y->size[0] = 1;
          kf_cpu_y->size[1] = jh_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(kf_cpu_y, i, &qd_emlrtRTEI);
          n = jh_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(kf_cpu_y, &id_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel634<<<grid, block>>>(jd_gpu_y, n, id_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          i = cg_cpu_y->size[0] * cg_cpu_y->size[1];
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(cg_cpu_y, i, &h_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &kd_gpu_y, true);
          r_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel635<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(kd_gpu_y);
        } else if (tol < 1.0) {
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = 0;
        } else {
          i = cg_cpu_y->size[0] * cg_cpu_y->size[1];
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(cg_cpu_y, i, &h_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &kd_gpu_y, true);
          r_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel637<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              kd_gpu_y);
          }
        }

        cpu_lidx = kf_cpu_y->size[1];
        i = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = cg_cpu_y->size[1];
        b_cpu_y1->size[1] = kf_cpu_y->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, i, &rc_emlrtRTEI);
        n = cg_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, n), &grid, &block,
          2147483647U);
        if (r_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &kd_gpu_y, true);
        }

        r_y_needsGpuEnsureCapacity = false;
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel636<<<grid, block>>>(id_gpu_y, kd_gpu_y, T, n, cpu_lidx
            - 1, b_gpu_y1, b_cpu_y1->size[0U], kf_cpu_y->size[0U]);
        }
      }

      if ((b_cpu_opts_x->size[0] == 1) || (b_cpu_opts_x->size[1] == 1)) {
        N = static_cast<uint32_T>(b_cpu_y1->size[0]);
        i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
        b_cpu_opts_x->size[0] = cpu_crossCFS->size[0];
        b_cpu_opts_x->size[1] = b_cpu_y1->size[0];
        emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &rd_emlrtRTEI);
        n = cpu_crossCFS->size[0] * static_cast<int32_T>(N) - 1;
        mwGetLaunchParameters1D(computeNumIters(n), &grid, &block, 2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel517<<<grid, block>>>(b_gpu_y1, n, b_gpu_opts_x);
        }
      } else {
        i = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
        b_cpu_opts_x->size[0] = b_cpu_y1->size[1];
        b_cpu_opts_x->size[1] = b_cpu_y1->size[0];
        emxEnsureCapacity_creal32_T(b_cpu_opts_x, i, &rd_emlrtRTEI);
        n = b_cpu_y1->size[0] - 1;
        itime = b_cpu_y1->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(n, itime), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &b_gpu_y1, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_opts_x, &b_gpu_opts_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel518<<<grid, block>>>(b_gpu_y1, itime, n, b_gpu_opts_x,
            b_cpu_opts_x->size[0U], b_cpu_y1->size[0U]);
        }
      }
    }

    //  Convert wavelet to phase angle
    // 'ec_wtcc:40' y = angle(y);
    offsetH = b_cpu_opts_x->size[0] * b_cpu_opts_x->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(b_cpu_opts_x->size[itime]);
    }

    i = cpu_fv->size[0] * cpu_fv->size[1];
    cpu_fv->size[0] = static_cast<int32_T>(xSize[0]);
    cpu_fv->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real32_T(cpu_fv, i, &r_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(offsetH - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_fv, &gpu_fv, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel138<<<grid, block>>>(b_gpu_opts_x, offsetH - 1, gpu_fv);
    }

    wav_outdatedOnCpu = true;
    nsubs = xx_data[p].f1->size[0] * xx_data[p].f1->size[1];
    xx_data[p].f1->size[0] = cpu_opts_x->size[0];
    emxEnsureCapacity_real32_T(xx_data[p].f1, nsubs, &sd_emlrtRTEI);
    i = xx_data[p].f1->size[0] * xx_data[p].f1->size[1];
    xx_data[p].f1->size[1] = cpu_opts_x->size[1];
    emxEnsureCapacity_real32_T(xx_data[p].f1, i, &sd_emlrtRTEI);
    for (i = 0; i < cpu_opts_x->size[0] * cpu_opts_x->size[1]; i++) {
      if (opts_x_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real32_T(cpu_opts_x, &gpu_opts_x);
      }

      opts_x_outdatedOnCpu = false;
      xx_data[p].f1->data[i] = cpu_opts_x->data[i];
    }

    nsubs = yy_data[p].f1->size[0] * yy_data[p].f1->size[1];
    yy_data[p].f1->size[0] = cpu_fv->size[0];
    emxEnsureCapacity_real32_T(yy_data[p].f1, nsubs, &td_emlrtRTEI);
    i = yy_data[p].f1->size[0] * yy_data[p].f1->size[1];
    yy_data[p].f1->size[1] = cpu_fv->size[1];
    emxEnsureCapacity_real32_T(yy_data[p].f1, i, &td_emlrtRTEI);
    for (i = 0; i < cpu_fv->size[0] * cpu_fv->size[1]; i++) {
      if (wav_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real32_T(cpu_fv, &gpu_fv);
      }

      wav_outdatedOnCpu = false;
      yy_data[p].f1->data[i] = cpu_fv->data[i];
    }
  }

  emxFree_char_T(&b_tmpStr);
  emxFree_char_T(&tmpStr);
  emxFree_creal32_T(&gc_cpu_w);
  emxFree_creal32_T(&jh_cpu_y);
  emxFree_creal32_T(&fc_cpu_w);
  emxFree_creal32_T(&ec_cpu_w);
  emxFree_creal32_T(&dc_cpu_w);
  emxFree_creal32_T(&cc_cpu_w);
  emxFree_creal32_T(&ih_cpu_y);
  emxFree_creal32_T(&hh_cpu_y);
  emxFree_creal32_T(&gh_cpu_y);
  emxFree_creal32_T(&fh_cpu_y);
  emxFree_creal32_T(&bc_cpu_w);
  emxFree_creal32_T(&ac_cpu_w);
  emxFree_creal32_T(&eh_cpu_y);
  emxFree_creal32_T(&yb_cpu_w);
  emxFree_creal32_T(&xb_cpu_w);
  emxFree_creal32_T(&wb_cpu_w);
  emxFree_creal32_T(&vb_cpu_w);
  emxFree_creal32_T(&ub_cpu_w);
  emxFree_creal32_T(&tb_cpu_w);
  emxFree_creal32_T(&sb_cpu_w);
  emxFree_creal32_T(&rb_cpu_w);
  emxFree_creal32_T(&qb_cpu_w);
  emxFree_creal32_T(&pb_cpu_w);
  emxFree_creal32_T(&ob_cpu_w);
  emxFree_creal32_T(&db_cpu_yCol);
  emxFree_creal32_T(&cb_cpu_yCol);
  emxFree_creal32_T(&bb_cpu_yCol);
  emxFree_creal32_T(&ab_cpu_yCol);
  emxFree_creal32_T(&y_cpu_yCol);
  emxFree_creal32_T(&x_cpu_yCol);
  emxFree_creal32_T(&w_cpu_yCol);
  emxFree_creal32_T(&v_cpu_yCol);
  emxFree_creal32_T(&u_cpu_yCol);
  emxFree_real_T(&b_cpu_b0);
  emxFree_real32_T(&nb_cpu_w);
  emxFree_real32_T(&dh_cpu_y);
  emxFree_real32_T(&mb_cpu_w);
  emxFree_real32_T(&lb_cpu_w);
  emxFree_real32_T(&kb_cpu_w);
  emxFree_real32_T(&jb_cpu_w);
  emxFree_real32_T(&ch_cpu_y);
  emxFree_real32_T(&bh_cpu_y);
  emxFree_real32_T(&ah_cpu_y);
  emxFree_real32_T(&yg_cpu_y);
  emxFree_real32_T(&ib_cpu_w);
  emxFree_real32_T(&hb_cpu_w);
  emxFree_real32_T(&xg_cpu_y);
  emxFree_real32_T(&gb_cpu_w);
  emxFree_real32_T(&fb_cpu_w);
  emxFree_real32_T(&eb_cpu_w);
  emxFree_real32_T(&db_cpu_w);
  emxFree_real32_T(&cb_cpu_w);
  emxFree_real32_T(&bb_cpu_w);
  emxFree_real32_T(&ab_cpu_w);
  emxFree_real32_T(&y_cpu_w);
  emxFree_real32_T(&x_cpu_w);
  emxFree_real32_T(&w_cpu_w);
  emxFree_real32_T(&v_cpu_w);
  emxFree_real_T(&cpu_b0);
  emxFree_creal32_T(&h_cpu_smooth);
  emxFree_creal32_T(&smooth);
  emxFree_real32_T(&g_cpu_smooth);
  emxFree_real32_T(&f_cpu_smooth);
  emxFree_real32_T(&e_cpu_smooth);
  emxFree_real32_T(&d_cpu_smooth);
  emxFree_creal32_T(&w_cpu_newIm);
  emxFree_creal32_T(&v_cpu_newIm);
  emxFree_creal32_T(&u_cpu_newIm);
  emxFree_creal32_T(&t_cpu_newIm);
  emxFree_creal32_T(&s_cpu_newIm);
  emxFree_creal32_T(&r_cpu_newIm);
  emxFree_creal32_T(&q_cpu_newIm);
  emxFree_creal32_T(&p_cpu_newIm);
  emxFree_creal32_T(&o_cpu_newIm);
  emxFree_creal32_T(&n_cpu_newIm);
  emxFree_creal32_T(&m_cpu_newIm);
  emxFree_creal32_T(&l_cpu_newIm);
  emxFree_creal32_T(&k_cpu_newIm);
  emxFree_creal32_T(&j_cpu_newIm);
  emxFree_creal32_T(&i_cpu_newIm);
  emxFree_creal32_T(&h_cpu_newIm);
  emxFree_creal32_T(&g_cpu_newIm);
  emxFree_creal32_T(&f_cpu_newIm);
  emxFree_creal32_T(&e_cpu_newIm);
  emxFree_creal32_T(&d_cpu_newIm);
  emxFree_creal32_T(&c_cpu_newIm);
  emxFree_int32_T(&pd_cpu_rows);
  emxFree_int32_T(&od_cpu_rows);
  emxFree_int32_T(&cpu_iv204);
  emxFree_int32_T(&nd_cpu_rows);
  emxFree_int32_T(&md_cpu_rows);
  emxFree_int32_T(&ld_cpu_rows);
  emxFree_int32_T(&kd_cpu_rows);
  emxFree_int32_T(&cpu_iv203);
  emxFree_int32_T(&jd_cpu_rows);
  emxFree_int32_T(&id_cpu_rows);
  emxFree_int32_T(&hd_cpu_rows);
  emxFree_int32_T(&gd_cpu_rows);
  emxFree_int32_T(&fd_cpu_rows);
  emxFree_int32_T(&ed_cpu_rows);
  emxFree_int32_T(&cpu_iv199);
  emxFree_int32_T(&dd_cpu_rows);
  emxFree_int32_T(&cpu_iv197);
  emxFree_int32_T(&cpu_iv196);
  emxFree_int32_T(&cpu_iv195);
  emxFree_int32_T(&cd_cpu_rows);
  emxFree_int32_T(&bd_cpu_rows);
  emxFree_int32_T(&cpu_iv194);
  emxFree_int32_T(&ad_cpu_rows);
  emxFree_int32_T(&yc_cpu_rows);
  emxFree_int32_T(&cpu_iv193);
  emxFree_int32_T(&xc_cpu_rows);
  emxFree_int32_T(&cpu_iv191);
  emxFree_int32_T(&l_cpu_cols);
  emxFree_int32_T(&cpu_iv190);
  emxFree_int32_T(&wc_cpu_rows);
  emxFree_int32_T(&vc_cpu_rows);
  emxFree_int32_T(&uc_cpu_rows);
  emxFree_int32_T(&tc_cpu_rows);
  emxFree_int32_T(&sc_cpu_rows);
  emxFree_int32_T(&wg_cpu_y);
  emxFree_int32_T(&cpu_iv189);
  emxFree_int32_T(&cpu_iv188);
  emxFree_int32_T(&rc_cpu_rows);
  emxFree_int32_T(&vg_cpu_y);
  emxFree_int32_T(&qc_cpu_rows);
  emxFree_int32_T(&cpu_iv187);
  emxFree_int32_T(&cpu_iv186);
  emxFree_int32_T(&pc_cpu_rows);
  emxFree_int32_T(&cpu_iv185);
  emxFree_int32_T(&cpu_iv184);
  emxFree_int32_T(&oc_cpu_rows);
  emxFree_int32_T(&cpu_iv183);
  emxFree_real32_T(&fe_cpu_expanded);
  emxFree_creal32_T(&ee_cpu_expanded);
  emxFree_int32_T(&nc_cpu_rows);
  emxFree_int32_T(&k_cpu_cols);
  emxFree_int32_T(&cpu_iv181);
  emxFree_int32_T(&mc_cpu_rows);
  emxFree_int32_T(&j_cpu_cols);
  emxFree_int32_T(&cpu_iv179);
  emxFree_int32_T(&i_cpu_cols);
  emxFree_int32_T(&cpu_iv178);
  emxFree_int32_T(&ug_cpu_y);
  emxFree_int32_T(&tg_cpu_y);
  emxFree_int32_T(&sg_cpu_y);
  emxFree_int32_T(&cpu_iv177);
  emxFree_int32_T(&rg_cpu_y);
  emxFree_int32_T(&cpu_iv176);
  emxFree_int32_T(&lc_cpu_rows);
  emxFree_int32_T(&qg_cpu_y);
  emxFree_int32_T(&cpu_iv175);
  emxFree_int32_T(&kc_cpu_rows);
  emxFree_int32_T(&pg_cpu_y);
  emxFree_int32_T(&jc_cpu_rows);
  emxFree_int32_T(&og_cpu_y);
  emxFree_int32_T(&ng_cpu_y);
  emxFree_int32_T(&ic_cpu_rows);
  emxFree_int32_T(&h_cpu_cols);
  emxFree_int32_T(&cpu_iv174);
  emxFree_real32_T(&de_cpu_expanded);
  emxFree_creal32_T(&ce_cpu_expanded);
  emxFree_int32_T(&hc_cpu_rows);
  emxFree_int32_T(&g_cpu_cols);
  emxFree_int32_T(&cpu_iv173);
  emxFree_real32_T(&be_cpu_expanded);
  emxFree_creal32_T(&ae_cpu_expanded);
  emxFree_real32_T(&yd_cpu_expanded);
  emxFree_creal32_T(&xd_cpu_expanded);
  emxFree_real32_T(&wd_cpu_expanded);
  emxFree_creal32_T(&vd_cpu_expanded);
  emxFree_int32_T(&mg_cpu_y);
  emxFree_int32_T(&lg_cpu_y);
  emxFree_int32_T(&gc_cpu_rows);
  emxFree_int32_T(&fc_cpu_rows);
  emxFree_int32_T(&kg_cpu_y);
  emxFree_int32_T(&cpu_iv172);
  emxFree_int32_T(&jg_cpu_y);
  emxFree_int32_T(&ec_cpu_rows);
  emxFree_int32_T(&ig_cpu_y);
  emxFree_int32_T(&cpu_iv171);
  emxFree_int32_T(&hg_cpu_y);
  emxFree_int32_T(&cpu_iv170);
  emxFree_int32_T(&cpu_iv169);
  emxFree_int32_T(&gg_cpu_y);
  emxFree_real32_T(&ud_cpu_expanded);
  emxFree_creal32_T(&td_cpu_expanded);
  emxFree_int32_T(&fg_cpu_y);
  emxFree_real32_T(&sd_cpu_expanded);
  emxFree_creal32_T(&rd_cpu_expanded);
  emxFree_int32_T(&eg_cpu_y);
  emxFree_int32_T(&cpu_iv168);
  emxFree_int32_T(&dg_cpu_y);
  emxFree_real_T(&cg_cpu_y);
  emxFree_real32_T(&qd_cpu_expanded);
  emxFree_creal32_T(&pd_cpu_expanded);
  emxFree_real32_T(&od_cpu_expanded);
  emxFree_creal32_T(&nd_cpu_expanded);
  emxFree_real32_T(&md_cpu_expanded);
  emxFree_creal32_T(&ld_cpu_expanded);
  emxFree_int32_T(&cpu_iv167);
  emxFree_int32_T(&bg_cpu_y);
  emxFree_int32_T(&dc_cpu_rows);
  emxFree_int32_T(&cpu_iv166);
  emxFree_int32_T(&ag_cpu_y);
  emxFree_int32_T(&cc_cpu_rows);
  emxFree_int32_T(&bc_cpu_rows);
  emxFree_int32_T(&cpu_iv164);
  emxFree_int32_T(&yf_cpu_y);
  emxFree_int32_T(&cpu_iv163);
  emxFree_int32_T(&xf_cpu_y);
  emxFree_creal32_T(&wf_cpu_y);
  emxFree_int32_T(&vf_cpu_y);
  emxFree_int32_T(&cpu_iv162);
  emxFree_real32_T(&kd_cpu_expanded);
  emxFree_creal32_T(&jd_cpu_expanded);
  emxFree_real_T(&uf_cpu_y);
  emxFree_int32_T(&cpu_iv161);
  emxFree_real32_T(&id_cpu_expanded);
  emxFree_creal32_T(&hd_cpu_expanded);
  emxFree_real_T(&tf_cpu_y);
  emxFree_creal32_T(&b_cpu_newIm);
  emxFree_int32_T(&cpu_iv160);
  emxFree_int32_T(&ac_cpu_rows);
  emxFree_int32_T(&yb_cpu_rows);
  emxFree_int32_T(&cpu_iv159);
  emxFree_int32_T(&sf_cpu_y);
  emxFree_real_T(&rf_cpu_y);
  emxFree_creal32_T(&qf_cpu_y);
  emxFree_int32_T(&pf_cpu_y);
  emxFree_creal32_T(&of_cpu_y);
  emxFree_int32_T(&nf_cpu_y);
  emxFree_int32_T(&mf_cpu_y);
  emxFree_int32_T(&lf_cpu_y);
  emxFree_int32_T(&cpu_iv156);
  emxFree_int32_T(&cpu_iv155);
  emxFree_int32_T(&cpu_iv154);
  emxFree_real32_T(&gd_cpu_expanded);
  emxFree_creal32_T(&fd_cpu_expanded);
  emxFree_int32_T(&cpu_iv153);
  emxFree_creal32_T(&kf_cpu_y);
  emxFree_real_T(&jf_cpu_y);
  emxFree_int32_T(&cpu_iv152);
  emxFree_real_T(&if_cpu_y);
  emxFree_int32_T(&cpu_iv151);
  emxFree_int32_T(&cpu_iv150);
  emxFree_creal32_T(&l_cpu_result);
  emxFree_int32_T(&hf_cpu_y);
  emxFree_int32_T(&gf_cpu_y);
  emxFree_int32_T(&ff_cpu_y);
  emxFree_int32_T(&ef_cpu_y);
  emxFree_int32_T(&df_cpu_y);
  emxFree_int32_T(&cpu_iv149);
  emxFree_int32_T(&cpu_iv148);
  emxFree_int32_T(&cf_cpu_y);
  emxFree_int32_T(&cpu_iv147);
  emxFree_int32_T(&cpu_iv146);
  emxFree_int32_T(&cpu_iv145);
  emxFree_int32_T(&bf_cpu_y);
  emxFree_real32_T(&ed_cpu_expanded);
  emxFree_creal32_T(&dd_cpu_expanded);
  emxFree_int32_T(&cpu_iv144);
  emxFree_creal32_T(&af_cpu_y);
  emxFree_real32_T(&cd_cpu_expanded);
  emxFree_creal32_T(&bd_cpu_expanded);
  emxFree_int32_T(&cpu_iv143);
  emxFree_creal32_T(&ye_cpu_y);
  emxFree_creal32_T(&xe_cpu_y);
  emxFree_int32_T(&we_cpu_y);
  emxFree_creal32_T(&k_cpu_result);
  emxFree_creal32_T(&j_cpu_result);
  emxFree_creal32_T(&i_cpu_result);
  emxFree_int32_T(&ve_cpu_y);
  emxFree_real32_T(&ad_cpu_expanded);
  emxFree_creal32_T(&yc_cpu_expanded);
  emxFree_int32_T(&cpu_iv142);
  emxFree_int32_T(&cpu_iv141);
  emxFree_creal32_T(&ue_cpu_y);
  emxFree_int32_T(&te_cpu_y);
  emxFree_creal32_T(&se_cpu_y);
  emxFree_int32_T(&re_cpu_y);
  emxFree_int32_T(&qe_cpu_y);
  emxFree_creal32_T(&xc_cpu_expanded);
  emxFree_creal32_T(&h_cpu_result);
  emxFree_int32_T(&pe_cpu_y);
  emxFree_creal32_T(&g_cpu_result);
  emxFree_int32_T(&oe_cpu_y);
  emxFree_int32_T(&ne_cpu_y);
  emxFree_int32_T(&me_cpu_y);
  emxFree_real32_T(&wc_cpu_expanded);
  emxFree_creal32_T(&vc_cpu_expanded);
  emxFree_int32_T(&le_cpu_y);
  emxFree_real32_T(&uc_cpu_expanded);
  emxFree_creal32_T(&tc_cpu_expanded);
  emxFree_int32_T(&xb_cpu_rows);
  emxFree_int32_T(&wb_cpu_rows);
  emxFree_int32_T(&ke_cpu_y);
  emxFree_real32_T(&sc_cpu_expanded);
  emxFree_creal32_T(&rc_cpu_expanded);
  emxFree_int32_T(&je_cpu_y);
  emxFree_int32_T(&ie_cpu_y);
  emxFree_int32_T(&he_cpu_y);
  emxFree_creal32_T(&qc_cpu_expanded);
  emxFree_int32_T(&ge_cpu_y);
  emxFree_creal32_T(&pc_cpu_expanded);
  emxFree_creal32_T(&oc_cpu_expanded);
  emxFree_int32_T(&fe_cpu_y);
  emxFree_real32_T(&nc_cpu_expanded);
  emxFree_creal32_T(&mc_cpu_expanded);
  emxFree_int32_T(&ee_cpu_y);
  emxFree_real32_T(&lc_cpu_expanded);
  emxFree_creal32_T(&kc_cpu_expanded);
  emxFree_int32_T(&cpu_iv140);
  emxFree_int32_T(&cpu_iv139);
  emxFree_creal32_T(&jc_cpu_expanded);
  emxFree_creal32_T(&ic_cpu_expanded);
  emxFree_real_T(&de_cpu_y);
  emxFree_int32_T(&ce_cpu_y);
  emxFree_int32_T(&be_cpu_y);
  emxFree_creal32_T(&u_cpu_a);
  emxFree_creal32_T(&t_cpu_a);
  emxFree_creal32_T(&b_c);
  emxFree_creal32_T(&c);
  emxFree_real32_T(&hc_cpu_expanded);
  emxFree_creal32_T(&gc_cpu_expanded);
  emxFree_creal32_T(&s_cpu_a);
  emxFree_creal32_T(&ae_cpu_y);
  emxFree_creal32_T(&ab_cpu_c);
  emxFree_creal32_T(&r_cpu_a);
  emxFree_creal32_T(&q_cpu_a);
  emxFree_creal32_T(&p_cpu_a);
  emxFree_creal32_T(&y_cpu_c);
  emxFree_creal32_T(&x_cpu_c);
  emxFree_creal32_T(&u_cpu_w);
  emxFree_creal32_T(&w_cpu_c);
  emxFree_creal32_T(&o_cpu_a);
  emxFree_creal32_T(&n_cpu_a);
  emxFree_creal32_T(&v_cpu_c);
  emxFree_creal32_T(&u_cpu_c);
  emxFree_creal32_T(&t_cpu_w);
  emxFree_creal32_T(&s_cpu_w);
  emxFree_creal32_T(&r_cpu_w);
  emxFree_creal32_T(&q_cpu_w);
  emxFree_creal32_T(&p_cpu_w);
  emxFree_creal32_T(&o_cpu_w);
  emxFree_creal32_T(&t_cpu_yCol);
  emxFree_creal32_T(&n_cpu_w);
  emxFree_creal32_T(&m_cpu_w);
  emxFree_creal32_T(&l_cpu_w);
  emxFree_creal32_T(&s_cpu_yCol);
  emxFree_creal32_T(&r_cpu_yCol);
  emxFree_creal32_T(&q_cpu_yCol);
  emxFree_real_T(&yd_cpu_y);
  emxFree_creal32_T(&p_cpu_yCol);
  emxFree_creal32_T(&o_cpu_yCol);
  emxFree_creal32_T(&n_cpu_yCol);
  emxFree_creal32_T(&m_cpu_yCol);
  emxFree_creal32_T(&l_cpu_yCol);
  emxFree_creal32_T(&k_cpu_yCol);
  emxFree_int32_T(&b_cpu_IPIV);
  emxFree_ptrdiff_t(&b_jpvt_t);
  emxFree_real_T(&xd_cpu_y);
  emxFree_real_T(&b_cpu_tau);
  emxFree_creal32_T(&b_cpu_xCol);
  emxFree_real_T(&cpu_dv31);
  emxFree_real32_T(&cpu_fv);
  emxFree_int32_T(&b_cpu_jpvt);
  emxFree_real_T(&r_cpu_x);
  emxFree_real_T(&cpu_dv29);
  emxFree_real_T(&m_cpu_a);
  emxFree_int32_T(&vb_cpu_rows);
  emxFree_int32_T(&ub_cpu_rows);
  emxFree_creal32_T(&b_cpu_y1);
  emxFree_int32_T(&cpu_iv108);
  emxFree_int32_T(&tb_cpu_rows);
  emxFree_int32_T(&sb_cpu_rows);
  emxFree_int32_T(&rb_cpu_rows);
  emxFree_int32_T(&qb_cpu_rows);
  emxFree_int32_T(&cpu_iv107);
  emxFree_int32_T(&pb_cpu_rows);
  emxFree_int32_T(&ob_cpu_rows);
  emxFree_int32_T(&nb_cpu_rows);
  emxFree_int32_T(&mb_cpu_rows);
  emxFree_int32_T(&lb_cpu_rows);
  emxFree_real_T(&b_cpu_b);
  emxFree_int32_T(&kb_cpu_rows);
  emxFree_int32_T(&cpu_iv103);
  emxFree_int32_T(&jb_cpu_rows);
  emxFree_int32_T(&cpu_iv101);
  emxFree_int32_T(&cpu_iv100);
  emxFree_int32_T(&cpu_iv99);
  emxFree_int32_T(&ib_cpu_rows);
  emxFree_int32_T(&hb_cpu_rows);
  emxFree_int32_T(&cpu_iv98);
  emxFree_int32_T(&gb_cpu_rows);
  emxFree_int32_T(&fb_cpu_rows);
  emxFree_int32_T(&cpu_iv97);
  emxFree_int32_T(&eb_cpu_rows);
  emxFree_int32_T(&cpu_iv95);
  emxFree_int32_T(&f_cpu_cols);
  emxFree_int32_T(&cpu_iv94);
  emxFree_int32_T(&db_cpu_rows);
  emxFree_int32_T(&cb_cpu_rows);
  emxFree_int32_T(&cpu_iv93);
  emxFree_int32_T(&bb_cpu_rows);
  emxFree_int32_T(&ab_cpu_rows);
  emxFree_int32_T(&y_cpu_rows);
  emxFree_int32_T(&wd_cpu_y);
  emxFree_int32_T(&cpu_iv92);
  emxFree_int32_T(&cpu_iv91);
  emxFree_int32_T(&x_cpu_rows);
  emxFree_int32_T(&vd_cpu_y);
  emxFree_int32_T(&w_cpu_rows);
  emxFree_int32_T(&cpu_iv90);
  emxFree_int32_T(&cpu_iv89);
  emxFree_real_T(&b_cpu_sinc4A);
  emxFree_int32_T(&v_cpu_rows);
  emxFree_int32_T(&cpu_iv88);
  emxFree_int32_T(&cpu_iv87);
  emxFree_int32_T(&u_cpu_rows);
  emxFree_int32_T(&cpu_iv86);
  emxFree_real32_T(&fc_cpu_expanded);
  emxFree_real32_T(&ec_cpu_expanded);
  emxFree_int32_T(&t_cpu_rows);
  emxFree_int32_T(&e_cpu_cols);
  emxFree_int32_T(&cpu_iv84);
  emxFree_int32_T(&s_cpu_rows);
  emxFree_int32_T(&d_cpu_cols);
  emxFree_int32_T(&cpu_iv82);
  emxFree_int32_T(&c_cpu_cols);
  emxFree_int32_T(&cpu_iv81);
  emxFree_int32_T(&ud_cpu_y);
  emxFree_uint32_T(&td_cpu_y);
  emxFree_real_T(&b_cpu_sinc3A);
  emxFree_int32_T(&sd_cpu_y);
  emxFree_int32_T(&rd_cpu_y);
  emxFree_int32_T(&cpu_iv80);
  emxFree_int32_T(&qd_cpu_y);
  emxFree_int32_T(&cpu_iv79);
  emxFree_int32_T(&r_cpu_rows);
  emxFree_int32_T(&pd_cpu_y);
  emxFree_real32_T(&d_cpu_h);
  emxFree_int32_T(&cpu_iv78);
  emxFree_int32_T(&q_cpu_rows);
  emxFree_int32_T(&od_cpu_y);
  emxFree_int32_T(&p_cpu_rows);
  emxFree_int32_T(&nd_cpu_y);
  emxFree_int32_T(&md_cpu_y);
  emxFree_int32_T(&o_cpu_rows);
  emxFree_int32_T(&b_cpu_cols);
  emxFree_int32_T(&cpu_iv77);
  emxFree_real32_T(&dc_cpu_expanded);
  emxFree_real32_T(&cc_cpu_expanded);
  emxFree_real_T(&b_cpu_sinc2A);
  emxFree_int32_T(&n_cpu_rows);
  emxFree_int32_T(&cpu_cols);
  emxFree_int32_T(&cpu_iv76);
  emxFree_real32_T(&bc_cpu_expanded);
  emxFree_real32_T(&ac_cpu_expanded);
  emxFree_real32_T(&yb_cpu_expanded);
  emxFree_real32_T(&xb_cpu_expanded);
  emxFree_real32_T(&wb_cpu_expanded);
  emxFree_real32_T(&vb_cpu_expanded);
  emxFree_int32_T(&ld_cpu_y);
  emxFree_int32_T(&kd_cpu_y);
  emxFree_int32_T(&m_cpu_rows);
  emxFree_int32_T(&l_cpu_rows);
  emxFree_int32_T(&jd_cpu_y);
  emxFree_int32_T(&cpu_iv75);
  emxFree_int32_T(&id_cpu_y);
  emxFree_real_T(&b_cpu_sinc1A);
  emxFree_int32_T(&k_cpu_rows);
  emxFree_int32_T(&hd_cpu_y);
  emxFree_int32_T(&cpu_iv74);
  emxFree_int32_T(&gd_cpu_y);
  emxFree_int32_T(&cpu_iv73);
  emxFree_int32_T(&cpu_iv72);
  emxFree_int32_T(&fd_cpu_y);
  emxFree_real32_T(&ub_cpu_expanded);
  emxFree_real32_T(&tb_cpu_expanded);
  emxFree_int32_T(&ed_cpu_y);
  emxFree_real32_T(&sb_cpu_expanded);
  emxFree_real32_T(&rb_cpu_expanded);
  emxFree_int32_T(&dd_cpu_y);
  emxFree_int32_T(&cpu_iv71);
  emxFree_int32_T(&cd_cpu_y);
  emxFree_real_T(&bd_cpu_y);
  emxFree_real32_T(&qb_cpu_expanded);
  emxFree_real32_T(&pb_cpu_expanded);
  emxFree_real32_T(&ob_cpu_expanded);
  emxFree_real32_T(&nb_cpu_expanded);
  emxFree_real32_T(&mb_cpu_expanded);
  emxFree_real32_T(&lb_cpu_expanded);
  emxFree_int32_T(&cpu_iv70);
  emxFree_int32_T(&ad_cpu_y);
  emxFree_int32_T(&j_cpu_rows);
  emxFree_real_T(&b_cpu_G);
  emxFree_int32_T(&cpu_iv69);
  emxFree_int32_T(&yc_cpu_y);
  emxFree_int32_T(&i_cpu_rows);
  emxFree_int32_T(&h_cpu_rows);
  emxFree_int32_T(&cpu_iv67);
  emxFree_int32_T(&xc_cpu_y);
  emxFree_int32_T(&cpu_iv66);
  emxFree_int32_T(&wc_cpu_y);
  emxFree_real32_T(&vc_cpu_y);
  emxFree_int32_T(&uc_cpu_y);
  emxFree_int32_T(&cpu_iv65);
  emxFree_real32_T(&kb_cpu_expanded);
  emxFree_real32_T(&jb_cpu_expanded);
  emxFree_real_T(&tc_cpu_y);
  emxFree_int32_T(&cpu_iv64);
  emxFree_real32_T(&ib_cpu_expanded);
  emxFree_real32_T(&hb_cpu_expanded);
  emxFree_real_T(&sc_cpu_y);
  emxFree_int32_T(&cpu_iv63);
  emxFree_int32_T(&g_cpu_rows);
  emxFree_int32_T(&f_cpu_rows);
  emxFree_int32_T(&cpu_iv62);
  emxFree_int32_T(&rc_cpu_y);
  emxFree_real_T(&qc_cpu_y);
  emxFree_real32_T(&pc_cpu_y);
  emxFree_int32_T(&oc_cpu_y);
  emxFree_real32_T(&nc_cpu_y);
  emxFree_int32_T(&mc_cpu_y);
  emxFree_int32_T(&lc_cpu_y);
  emxFree_int32_T(&kc_cpu_y);
  emxFree_int32_T(&cpu_iv59);
  emxFree_int32_T(&cpu_iv58);
  emxFree_real_T(&b_cpu_k);
  emxFree_int32_T(&cpu_iv57);
  emxFree_real32_T(&gb_cpu_expanded);
  emxFree_real32_T(&fb_cpu_expanded);
  emxFree_int32_T(&cpu_iv56);
  emxFree_real32_T(&jc_cpu_y);
  emxFree_real_T(&ic_cpu_y);
  emxFree_int32_T(&cpu_iv55);
  emxFree_real_T(&hc_cpu_y);
  emxFree_int32_T(&cpu_iv54);
  emxFree_int32_T(&cpu_iv53);
  emxFree_real32_T(&f_cpu_result);
  emxFree_int32_T(&gc_cpu_y);
  emxFree_int32_T(&fc_cpu_y);
  emxFree_real_T(&b_cpu_m);
  emxFree_int32_T(&ec_cpu_y);
  emxFree_int32_T(&dc_cpu_y);
  emxFree_int32_T(&cc_cpu_y);
  emxFree_int32_T(&cpu_iv52);
  emxFree_int32_T(&cpu_iv51);
  emxFree_int32_T(&bc_cpu_y);
  emxFree_int32_T(&cpu_iv50);
  emxFree_int32_T(&cpu_iv49);
  emxFree_int32_T(&cpu_iv48);
  emxFree_int32_T(&ac_cpu_y);
  emxFree_real32_T(&eb_cpu_expanded);
  emxFree_real32_T(&db_cpu_expanded);
  emxFree_int32_T(&cpu_iv47);
  emxFree_real32_T(&yb_cpu_y);
  emxFree_real32_T(&cb_cpu_expanded);
  emxFree_real32_T(&bb_cpu_expanded);
  emxFree_int32_T(&cpu_iv46);
  emxFree_real32_T(&xb_cpu_y);
  emxFree_real32_T(&wb_cpu_y);
  emxFree_int32_T(&vb_cpu_y);
  emxFree_real32_T(&e_cpu_result);
  emxFree_real32_T(&d_cpu_result);
  emxFree_real32_T(&t_cpu_c);
  emxFree_real32_T(&c_cpu_result);
  emxFree_int32_T(&ub_cpu_y);
  emxFree_real32_T(&ab_cpu_expanded);
  emxFree_real32_T(&y_cpu_expanded);
  emxFree_int32_T(&cpu_iv45);
  emxFree_int32_T(&cpu_iv44);
  emxFree_real32_T(&tb_cpu_y);
  emxFree_int32_T(&sb_cpu_y);
  emxFree_real32_T(&rb_cpu_y);
  emxFree_int32_T(&qb_cpu_y);
  emxFree_int32_T(&pb_cpu_y);
  emxFree_real32_T(&x_cpu_expanded);
  emxFree_real32_T(&b_cpu_result);
  emxFree_int32_T(&ob_cpu_y);
  emxFree_real_T(&c_cpu_h);
  emxFree_real_T(&b_cpu_h1);
  emxFree_real32_T(&cpu_result);
  emxFree_int32_T(&nb_cpu_y);
  emxFree_int32_T(&mb_cpu_y);
  emxFree_real32_T(&s_cpu_c);
  emxFree_int32_T(&lb_cpu_y);
  emxFree_real32_T(&w_cpu_expanded);
  emxFree_real32_T(&v_cpu_expanded);
  emxFree_real32_T(&r_cpu_c);
  emxFree_int32_T(&kb_cpu_y);
  emxFree_real32_T(&u_cpu_expanded);
  emxFree_real32_T(&t_cpu_expanded);
  emxFree_int32_T(&jb_cpu_y);
  emxFree_real32_T(&s_cpu_expanded);
  emxFree_real32_T(&r_cpu_expanded);
  emxFree_int32_T(&ib_cpu_y);
  emxFree_int32_T(&hb_cpu_y);
  emxFree_int32_T(&e_cpu_rows);
  emxFree_int32_T(&d_cpu_rows);
  emxFree_real32_T(&q_cpu_c);
  emxFree_int32_T(&gb_cpu_y);
  emxFree_real32_T(&q_cpu_expanded);
  emxFree_int32_T(&fb_cpu_y);
  emxFree_real32_T(&p_cpu_expanded);
  emxFree_real32_T(&o_cpu_expanded);
  emxFree_int32_T(&eb_cpu_y);
  emxFree_real32_T(&n_cpu_expanded);
  emxFree_real32_T(&m_cpu_expanded);
  emxFree_int32_T(&db_cpu_y);
  emxFree_real32_T(&l_cpu_expanded);
  emxFree_real32_T(&k_cpu_expanded);
  emxFree_real_T(&cpu_dv27);
  emxFree_int32_T(&cpu_iv43);
  emxFree_int32_T(&cpu_iv42);
  emxFree_real32_T(&j_cpu_expanded);
  emxFree_real32_T(&p_cpu_c);
  emxFree_real32_T(&i_cpu_expanded);
  emxFree_real32_T(&o_cpu_c);
  emxFree_real32_T(&n_cpu_c);
  emxFree_real32_T(&m_cpu_c);
  emxFree_real32_T(&l_cpu_c);
  emxFree_real_T(&cb_cpu_y);
  emxFree_real32_T(&l_cpu_a);
  emxFree_real32_T(&k_cpu_a);
  emxFree_int32_T(&bb_cpu_y);
  emxFree_int32_T(&ab_cpu_y);
  emxFree_real32_T(&k_cpu_c);
  emxFree_real32_T(&j_cpu_c);
  emxFree_real32_T(&j_cpu_a);
  emxFree_real32_T(&h_cpu_expanded);
  emxFree_real32_T(&g_cpu_expanded);
  emxFree_real32_T(&i_cpu_c);
  emxFree_real32_T(&y_cpu_y);
  emxFree_real32_T(&i_cpu_a);
  emxFree_real32_T(&h_cpu_a);
  emxFree_real32_T(&g_cpu_a);
  emxFree_real32_T(&h_cpu_c);
  emxFree_real32_T(&g_cpu_c);
  emxFree_real32_T(&k_cpu_w);
  emxFree_real32_T(&f_cpu_c);
  emxFree_real32_T(&f_cpu_a);
  emxFree_real32_T(&e_cpu_a);
  emxFree_real32_T(&e_cpu_c);
  emxFree_real32_T(&d_cpu_c);
  emxFree_real32_T(&q_cpu_x);
  emxFree_real32_T(&j_cpu_w);
  emxFree_real32_T(&i_cpu_w);
  emxFree_real32_T(&h_cpu_w);
  emxFree_real32_T(&p_cpu_x);
  emxFree_real32_T(&o_cpu_x);
  emxFree_real32_T(&g_cpu_w);
  emxFree_real32_T(&n_cpu_x);
  emxFree_real32_T(&f_cpu_w);
  emxFree_real32_T(&e_cpu_w);
  emxFree_real32_T(&d_cpu_w);
  emxFree_real32_T(&j_cpu_yCol);
  emxFree_real32_T(&c_cpu_w);
  emxFree_real32_T(&m_cpu_x);
  emxFree_real32_T(&b_cpu_w);
  emxFree_real32_T(&l_cpu_x);
  emxFree_real32_T(&k_cpu_x);
  emxFree_real32_T(&i_cpu_yCol);
  emxFree_real32_T(&h_cpu_yCol);
  emxFree_real32_T(&j_cpu_x);
  emxFree_real32_T(&i_cpu_x);
  emxFree_real32_T(&g_cpu_yCol);
  emxFree_real_T(&x_cpu_y);
  emxFree_real32_T(&f_cpu_yCol);
  emxFree_real32_T(&e_cpu_yCol);
  emxFree_real32_T(&d_cpu_yCol);
  emxFree_real32_T(&c_cpu_yCol);
  emxFree_real32_T(&b_cpu_yCol);
  emxFree_real32_T(&cpu_yCol);
  emxFree_int32_T(&cpu_IPIV);
  emxFree_ptrdiff_t(&jpvt_t);
  emxFree_real_T(&w_cpu_y);
  emxFree_real_T(&cpu_tau);
  emxFree_creal32_T(&b_cpu_opts_x);
  emxFree_real32_T(&cpu_xCol);
  emxFree_real32_T(&b_cpu_opts_filter);
  emxFree_real_T(&cpu_dv26);
  emxFree_int32_T(&cpu_jpvt);
  emxFree_real_T(&h_cpu_x);
  emxFree_real_T(&cpu_dv25);
  emxFree_real_T(&d_cpu_a);
  emxFree_real32_T(&cpu_y1);
  emxFree_real_T(&cpu_b);
  emxFree_int32_T(&cpu_iv19);
  emxFree_real_T(&cpu_sinc4A);
  emxFree_uint32_T(&v_cpu_y);
  emxFree_real_T(&cpu_sinc3A);
  emxFree_real32_T(&b_cpu_h);
  emxFree_real_T(&cpu_sinc2A);
  emxFree_real_T(&cpu_sinc1A);
  emxFree_real_T(&cpu_G);
  emxFree_real_T(&cpu_k);
  emxFree_real_T(&cpu_m);
  emxFree_real_T(&cpu_h);
  emxFree_real_T(&cpu_h1);
  emxFree_real_T(&cpu_dv23);
  emxFree_creal32_T(&cpu_newIm);
  emxFree_int32_T(&c_cpu_rows);
  emxFree_int32_T(&cpu_iv18);
  emxFree_real32_T(&cpu_opts_x);
  emxFree_real32_T(&cpu_opts_filter);
  emxFree_int32_T(&u_cpu_y);
  emxFree_int32_T(&cpu_iv17);
  emxFree_int32_T(&cpu_iv16);
  emxFree_real32_T(&cpu_wtc);
  emxFree_int32_T(&t_cpu_y);
  emxFree_creal32_T(&f_cpu_expanded);
  emxFree_int32_T(&s_cpu_y);
  emxFree_real32_T(&r_cpu_y);
  emxFree_creal32_T(&e_cpu_expanded);
  emxFree_creal32_T(&c_cpu_c);
  emxFree_real32_T(&q_cpu_y);
  emxFree_creal32_T(&c_cpu_a);
  emxFree_creal32_T(&c_cpu_smooth);
  emxFree_int32_T(&b_cpu_rows);
  emxFree_creal32_T(&g_cpu_x);
  emxFree_int32_T(&cpu_iv14);
  emxFree_real_T(&c_cpu_Fmat);
  emxFree_creal32_T(&c_cpu_cfsDFT);
  emxFree_int32_T(&p_cpu_y);
  emxFree_int32_T(&cpu_iv13);
  emxFree_int32_T(&cpu_iv12);
  emxFree_real_T(&c_cpu_omega);
  emxFree_int32_T(&o_cpu_y);
  emxFree_real32_T(&d_cpu_expanded);
  emxFree_real_T(&d_cpu_omega_tmp2);
  emxFree_int32_T(&n_cpu_y);
  emxFree_real32_T(&c_cpu_expanded);
  emxFree_int32_T(&d_cpu_omega_tmp1);
  emxFree_real32_T(&b_cpu_c);
  emxFree_real32_T(&b_cpu_a);
  emxFree_creal32_T(&cpu_crossCFS);
  emxFree_real32_T(&b_cpu_smooth);
  emxFree_creal32_T(&f_cpu_x);
  emxFree_creal32_T(&m_cpu_y);
  emxFree_real_T(&b_cpu_Fmat);
  emxFree_creal32_T(&b_cpu_cfsDFT);
  emxFree_int32_T(&cpu_rows);
  emxFree_real_T(&b_cpu_omega);
  emxFree_int32_T(&cpu_iv11);
  emxFree_real_T(&c_cpu_omega_tmp2);
  emxFree_int32_T(&c_cpu_omega_tmp1);
  emxFree_int32_T(&l_cpu_y);
  emxFree_int32_T(&cpu_iv10);
  emxFree_int32_T(&cpu_iv9);
  emxFree_int32_T(&k_cpu_y);
  emxFree_real32_T(&b_cpu_expanded);
  emxFree_int32_T(&j_cpu_y);
  emxFree_real32_T(&cpu_cfs2);
  emxFree_real32_T(&cpu_expanded);
  emxFree_real32_T(&cpu_c);
  emxFree_real32_T(&i_cpu_y);
  emxFree_real32_T(&cpu_a);
  emxFree_real32_T(&cpu_smooth);
  emxFree_creal32_T(&e_cpu_x);
  emxFree_creal32_T(&h_cpu_y);
  emxFree_real_T(&cpu_Fmat);
  emxFree_creal32_T(&cpu_cfsDFT);
  emxFree_real_T(&cpu_omega);
  emxFree_real_T(&b_cpu_omega_tmp2);
  emxFree_int32_T(&b_cpu_omega_tmp1);
  emxFree_real32_T(&cpu_cfs1);
  emxFree_real32_T(&g_cpu_y);
  emxFree_creal32_T(&b_cpu_cfspos);
  emxFree_creal32_T(&b_cpu_cfsposdft);
  emxFree_real32_T(&d_cpu_x);
  emxFree_creal32_T(&b_cpu_xposdft);
  emxFree_real32_T(&b_cpu_xv);
  emxFree_real32_T(&b_cpu_psihat);
  emxFree_creal32_T(&cpu_cfspos);
  emxFree_creal32_T(&cpu_cfsposdft);
  emxFree_real32_T(&c_cpu_x);
  emxFree_creal32_T(&cpu_xposdft);
  emxFree_real32_T(&cpu_xv);
  emxFree_real32_T(&cpu_psihat);
  emxFree_real_T(&f_cpu_y);
  emxFree_real_T(&e_cpu_y);
  emxFree_real_T(&cpu_daughter);
  emxFree_real_T(&d_cpu_y);
  emxFree_real_T(&cpu_expnt);
  emxFree_real_T(&cpu_w);
  emxFree_real_T(&cpu_somega);
  emxFree_real_T(&c_cpu_y);
  emxFree_real_T(&b_cpu_y);
  emxFree_real_T(&cpu_omega_tmp2);
  emxFree_int32_T(&cpu_omega_tmp1);
  emxFree_real_T(&cpu_fb_Omega);
  emxFree_real_T(&cpu_fb_Scales);
  emxFree_real32_T(&cpu_y);
  emxFree_real32_T(&b_cpu_x);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
  gpuEmxFree_real32_T(&gpu_x);
  checkCudaError(mwCudaFree(gpu_dc6), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_dc), __FILE__, __LINE__);
  gpuEmxFree_real32_T(&b_gpu_x);
  gpuEmxFree_real32_T(&gpu_y);
  gpuEmxFree_real_T(&gpu_fb_Scales);
  gpuEmxFree_real_T(&gpu_fb_Omega);
  gpuEmxFree_int32_T(&gpu_omega_tmp1);
  gpuEmxFree_real_T(&gpu_omega_tmp2);
  gpuEmxFree_real_T(&b_gpu_y);
  gpuEmxFree_real_T(&c_gpu_y);
  gpuEmxFree_real_T(&gpu_somega);
  gpuEmxFree_real_T(&gc_gpu_w);
  gpuEmxFree_real_T(&gpu_expnt);
  gpuEmxFree_real_T(&ih_gpu_y);
  gpuEmxFree_real_T(&gpu_daughter);
  gpuEmxFree_real_T(&hh_gpu_y);
  gpuEmxFree_real_T(&jh_gpu_y);
  gpuEmxFree_real32_T(&gpu_psihat);
  gpuEmxFree_real32_T(&gpu_xv);
  gpuEmxFree_creal32_T(&gpu_xposdft);
  gpuEmxFree_real32_T(&c_gpu_x);
  gpuEmxFree_creal32_T(&gpu_cfsposdft);
  gpuEmxFree_creal32_T(&gpu_cfspos);
  gpuEmxFree_real32_T(&b_gpu_psihat);
  gpuEmxFree_real32_T(&b_gpu_xv);
  gpuEmxFree_creal32_T(&b_gpu_xposdft);
  gpuEmxFree_real32_T(&d_gpu_x);
  gpuEmxFree_creal32_T(&b_gpu_cfsposdft);
  gpuEmxFree_creal32_T(&b_gpu_cfspos);
  gpuEmxFree_real32_T(&d_gpu_y);
  gpuEmxFree_real32_T(&gpu_cfs1);
  gpuEmxFree_int32_T(&b_gpu_omega_tmp1);
  gpuEmxFree_real_T(&b_gpu_omega_tmp2);
  gpuEmxFree_real_T(&gpu_omega);
  gpuEmxFree_creal32_T(&gpu_cfsDFT);
  gpuEmxFree_real_T(&gpu_Fmat);
  gpuEmxFree_creal32_T(&e_gpu_y);
  gpuEmxFree_creal32_T(&e_gpu_x);
  gpuEmxFree_real32_T(&gpu_smooth);
  gpuEmxFree_real32_T(&gpu_a);
  gpuEmxFree_real32_T(&f_gpu_y);
  gpuEmxFree_real32_T(&gpu_c);
  gpuEmxFree_real32_T(&fe_gpu_expanded);
  gpuEmxFree_real32_T(&gpu_cfs2);
  gpuEmxFree_int32_T(&fh_gpu_y);
  gpuEmxFree_real32_T(&ee_gpu_expanded);
  gpuEmxFree_int32_T(&eh_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv9);
  gpuEmxFree_int32_T(&gpu_iv10);
  gpuEmxFree_int32_T(&gh_gpu_y);
  gpuEmxFree_int32_T(&c_gpu_omega_tmp1);
  gpuEmxFree_real_T(&c_gpu_omega_tmp2);
  gpuEmxFree_int32_T(&gpu_iv11);
  gpuEmxFree_real_T(&b_gpu_omega);
  gpuEmxFree_int32_T(&pd_gpu_rows);
  gpuEmxFree_creal32_T(&b_gpu_cfsDFT);
  gpuEmxFree_real_T(&b_gpu_Fmat);
  gpuEmxFree_creal32_T(&g_gpu_y);
  gpuEmxFree_creal32_T(&f_gpu_x);
  gpuEmxFree_real32_T(&b_gpu_smooth);
  gpuEmxFree_creal32_T(&gpu_crossCFS);
  gpuEmxFree_real32_T(&b_gpu_a);
  gpuEmxFree_real32_T(&b_gpu_c);
  gpuEmxFree_int32_T(&d_gpu_omega_tmp1);
  gpuEmxFree_real32_T(&de_gpu_expanded);
  gpuEmxFree_int32_T(&ch_gpu_y);
  gpuEmxFree_real_T(&d_gpu_omega_tmp2);
  gpuEmxFree_real32_T(&ce_gpu_expanded);
  gpuEmxFree_int32_T(&bh_gpu_y);
  gpuEmxFree_real_T(&c_gpu_omega);
  gpuEmxFree_int32_T(&gpu_iv12);
  gpuEmxFree_int32_T(&gpu_iv13);
  gpuEmxFree_int32_T(&dh_gpu_y);
  gpuEmxFree_creal32_T(&c_gpu_cfsDFT);
  gpuEmxFree_real_T(&c_gpu_Fmat);
  gpuEmxFree_int32_T(&gpu_iv14);
  gpuEmxFree_creal32_T(&g_gpu_x);
  gpuEmxFree_int32_T(&od_gpu_rows);
  gpuEmxFree_creal32_T(&c_gpu_smooth);
  gpuEmxFree_creal32_T(&c_gpu_a);
  gpuEmxFree_real32_T(&h_gpu_y);
  gpuEmxFree_creal32_T(&c_gpu_c);
  gpuEmxFree_creal32_T(&be_gpu_expanded);
  gpuEmxFree_real32_T(&i_gpu_y);
  gpuEmxFree_int32_T(&yg_gpu_y);
  gpuEmxFree_creal32_T(&ae_gpu_expanded);
  gpuEmxFree_int32_T(&xg_gpu_y);
  gpuEmxFree_real32_T(&gpu_wtc);
  gpuEmxFree_int32_T(&gpu_iv16);
  gpuEmxFree_int32_T(&gpu_iv17);
  gpuEmxFree_int32_T(&ah_gpu_y);
  gpuEmxFree_real32_T(&gpu_opts_filter);
  gpuEmxFree_real32_T(&gpu_opts_x);
  gpuEmxFree_int32_T(&gpu_iv18);
  gpuEmxFree_int32_T(&nd_gpu_rows);
  gpuEmxFree_creal32_T(&w_gpu_newIm);
  gpuEmxFree_real_T(&gpu_dv23);
  gpuEmxFree_real_T(&gpu_h1);
  gpuEmxFree_real_T(&gpu_h);
  gpuEmxFree_real_T(&gpu_m);
  gpuEmxFree_real_T(&gpu_k);
  gpuEmxFree_real_T(&gpu_G);
  gpuEmxFree_real_T(&gpu_sinc1A);
  gpuEmxFree_real_T(&gpu_sinc2A);
  gpuEmxFree_real32_T(&b_gpu_h);
  gpuEmxFree_real_T(&gpu_sinc3A);
  gpuEmxFree_uint32_T(&l_gpu_y);
  gpuEmxFree_real_T(&gpu_sinc4A);
  gpuEmxFree_int32_T(&gpu_iv19);
  gpuEmxFree_real_T(&gpu_b);
  gpuEmxFree_real32_T(&gpu_y1);
  gpuEmxFree_real_T(&d_gpu_a);
  gpuEmxFree_real_T(&gpu_dv25);
  gpuEmxFree_real_T(&r_gpu_x);
  gpuEmxFree_int32_T(&b_gpu_jpvt);
  gpuEmxFree_real_T(&gpu_dv26);
  gpuEmxFree_real32_T(&b_gpu_opts_filter);
  gpuEmxFree_real32_T(&b_gpu_xCol);
  gpuEmxFree_creal32_T(&b_gpu_opts_x);
  gpuEmxFree_real_T(&b_gpu_tau);
  gpuEmxFree_real_T(&j_gpu_y);
  gpuEmxFree_int32_T(&b_gpu_IPIV);
  gpuEmxFree_real32_T(&ab_gpu_yCol);
  gpuEmxFree_real32_T(&x_gpu_yCol);
  gpuEmxFree_real32_T(&u_gpu_yCol);
  gpuEmxFree_real32_T(&cb_gpu_yCol);
  gpuEmxFree_real32_T(&y_gpu_yCol);
  gpuEmxFree_real32_T(&v_gpu_yCol);
  gpuEmxFree_real_T(&k_gpu_y);
  gpuEmxFree_real32_T(&db_gpu_yCol);
  gpuEmxFree_real32_T(&m_gpu_x);
  gpuEmxFree_real32_T(&j_gpu_x);
  gpuEmxFree_real32_T(&w_gpu_yCol);
  gpuEmxFree_real32_T(&t_gpu_yCol);
  gpuEmxFree_real32_T(&p_gpu_x);
  gpuEmxFree_real32_T(&n_gpu_x);
  gpuEmxFree_real32_T(&pb_gpu_w);
  gpuEmxFree_real32_T(&k_gpu_x);
  gpuEmxFree_real32_T(&gb_gpu_w);
  gpuEmxFree_real32_T(&bb_gpu_yCol);
  gpuEmxFree_real32_T(&ac_gpu_w);
  gpuEmxFree_real32_T(&sb_gpu_w);
  gpuEmxFree_real32_T(&jb_gpu_w);
  gpuEmxFree_real32_T(&q_gpu_x);
  gpuEmxFree_real32_T(&vb_gpu_w);
  gpuEmxFree_real32_T(&l_gpu_x);
  gpuEmxFree_real32_T(&i_gpu_x);
  gpuEmxFree_real32_T(&dc_gpu_w);
  gpuEmxFree_real32_T(&mb_gpu_w);
  gpuEmxFree_real32_T(&db_gpu_w);
  gpuEmxFree_real32_T(&o_gpu_x);
  gpuEmxFree_real32_T(&r_gpu_c);
  gpuEmxFree_real32_T(&l_gpu_c);
  gpuEmxFree_real32_T(&r_gpu_a);
  gpuEmxFree_real32_T(&o_gpu_a);
  gpuEmxFree_real32_T(&w_gpu_c);
  gpuEmxFree_real32_T(&wb_gpu_w);
  gpuEmxFree_real32_T(&t_gpu_c);
  gpuEmxFree_real32_T(&n_gpu_c);
  gpuEmxFree_real32_T(&t_gpu_a);
  gpuEmxFree_real32_T(&s_gpu_a);
  gpuEmxFree_real32_T(&p_gpu_a);
  gpuEmxFree_real32_T(&tf_gpu_y);
  gpuEmxFree_real32_T(&y_gpu_c);
  gpuEmxFree_real32_T(&id_gpu_expanded);
  gpuEmxFree_real32_T(&hd_gpu_expanded);
  gpuEmxFree_real32_T(&u_gpu_a);
  gpuEmxFree_real32_T(&p_gpu_c);
  gpuEmxFree_real32_T(&j_gpu_c);
  gpuEmxFree_int32_T(&wf_gpu_y);
  gpuEmxFree_int32_T(&vf_gpu_y);
  gpuEmxFree_real32_T(&q_gpu_a);
  gpuEmxFree_real32_T(&n_gpu_a);
  gpuEmxFree_real_T(&uf_gpu_y);
  gpuEmxFree_real32_T(&s_gpu_c);
  gpuEmxFree_real32_T(&m_gpu_c);
  gpuEmxFree_real32_T(&x_gpu_c);
  gpuEmxFree_real32_T(&u_gpu_c);
  gpuEmxFree_real32_T(&sc_gpu_expanded);
  gpuEmxFree_real32_T(&o_gpu_c);
  gpuEmxFree_real32_T(&cc_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv42);
  gpuEmxFree_int32_T(&gpu_iv43);
  gpuEmxFree_real_T(&gpu_dv27);
  gpuEmxFree_real32_T(&uc_gpu_expanded);
  gpuEmxFree_real32_T(&tc_gpu_expanded);
  gpuEmxFree_int32_T(&af_gpu_y);
  gpuEmxFree_real32_T(&ec_gpu_expanded);
  gpuEmxFree_real32_T(&dc_gpu_expanded);
  gpuEmxFree_int32_T(&ae_gpu_y);
  gpuEmxFree_real32_T(&ld_gpu_expanded);
  gpuEmxFree_real32_T(&ad_gpu_expanded);
  gpuEmxFree_int32_T(&cf_gpu_y);
  gpuEmxFree_real32_T(&jc_gpu_expanded);
  gpuEmxFree_int32_T(&ce_gpu_y);
  gpuEmxFree_real32_T(&ab_gpu_c);
  gpuEmxFree_int32_T(&xc_gpu_rows);
  gpuEmxFree_int32_T(&wc_gpu_rows);
  gpuEmxFree_int32_T(&bf_gpu_y);
  gpuEmxFree_int32_T(&be_gpu_y);
  gpuEmxFree_real32_T(&nd_gpu_expanded);
  gpuEmxFree_real32_T(&md_gpu_expanded);
  gpuEmxFree_int32_T(&eg_gpu_y);
  gpuEmxFree_real32_T(&cd_gpu_expanded);
  gpuEmxFree_real32_T(&bd_gpu_expanded);
  gpuEmxFree_int32_T(&lf_gpu_y);
  gpuEmxFree_real32_T(&q_gpu_c);
  gpuEmxFree_real32_T(&lc_gpu_expanded);
  gpuEmxFree_real32_T(&kc_gpu_expanded);
  gpuEmxFree_int32_T(&le_gpu_y);
  gpuEmxFree_real32_T(&k_gpu_c);
  gpuEmxFree_int32_T(&gg_gpu_y);
  gpuEmxFree_int32_T(&nf_gpu_y);
  gpuEmxFree_real32_T(&i_gpu_result);
  gpuEmxFree_real_T(&b_gpu_h1);
  gpuEmxFree_real_T(&c_gpu_h);
  gpuEmxFree_int32_T(&ne_gpu_y);
  gpuEmxFree_real32_T(&g_gpu_result);
  gpuEmxFree_real32_T(&sd_gpu_expanded);
  gpuEmxFree_int32_T(&fg_gpu_y);
  gpuEmxFree_int32_T(&mf_gpu_y);
  gpuEmxFree_real32_T(&ve_gpu_y);
  gpuEmxFree_int32_T(&me_gpu_y);
  gpuEmxFree_real32_T(&vd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv44);
  gpuEmxFree_int32_T(&gpu_iv45);
  gpuEmxFree_real32_T(&ud_gpu_expanded);
  gpuEmxFree_real32_T(&td_gpu_expanded);
  gpuEmxFree_int32_T(&pg_gpu_y);
  gpuEmxFree_real32_T(&k_gpu_result);
  gpuEmxFree_real32_T(&v_gpu_c);
  gpuEmxFree_real32_T(&j_gpu_result);
  gpuEmxFree_real32_T(&h_gpu_result);
  gpuEmxFree_int32_T(&rg_gpu_y);
  gpuEmxFree_real32_T(&ag_gpu_y);
  gpuEmxFree_real32_T(&if_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv46);
  gpuEmxFree_real32_T(&rc_gpu_expanded);
  gpuEmxFree_real32_T(&qc_gpu_expanded);
  gpuEmxFree_real32_T(&ie_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv47);
  gpuEmxFree_real32_T(&bc_gpu_expanded);
  gpuEmxFree_real32_T(&ac_gpu_expanded);
  gpuEmxFree_int32_T(&qg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv48);
  gpuEmxFree_int32_T(&gpu_iv49);
  gpuEmxFree_int32_T(&gpu_iv50);
  gpuEmxFree_int32_T(&ye_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv51);
  gpuEmxFree_int32_T(&gpu_iv52);
  gpuEmxFree_int32_T(&yd_gpu_y);
  gpuEmxFree_int32_T(&df_gpu_y);
  gpuEmxFree_int32_T(&xe_gpu_y);
  gpuEmxFree_real_T(&b_gpu_m);
  gpuEmxFree_int32_T(&de_gpu_y);
  gpuEmxFree_int32_T(&xd_gpu_y);
  gpuEmxFree_real32_T(&l_gpu_result);
  gpuEmxFree_int32_T(&gpu_iv53);
  gpuEmxFree_int32_T(&gpu_iv54);
  gpuEmxFree_real_T(&we_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv55);
  gpuEmxFree_real_T(&wd_gpu_y);
  gpuEmxFree_real32_T(&mg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv56);
  gpuEmxFree_real32_T(&kd_gpu_expanded);
  gpuEmxFree_real32_T(&jd_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv57);
  gpuEmxFree_real_T(&b_gpu_k);
  gpuEmxFree_int32_T(&gpu_iv58);
  gpuEmxFree_int32_T(&gpu_iv59);
  gpuEmxFree_int32_T(&hg_gpu_y);
  gpuEmxFree_int32_T(&dg_gpu_y);
  gpuEmxFree_int32_T(&of_gpu_y);
  gpuEmxFree_real32_T(&te_gpu_y);
  gpuEmxFree_int32_T(&oe_gpu_y);
  gpuEmxFree_real32_T(&td_gpu_y);
  gpuEmxFree_real_T(&bg_gpu_y);
  gpuEmxFree_int32_T(&cg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv62);
  gpuEmxFree_int32_T(&kc_gpu_rows);
  gpuEmxFree_int32_T(&vb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv63);
  gpuEmxFree_real_T(&kf_gpu_y);
  gpuEmxFree_real32_T(&wc_gpu_expanded);
  gpuEmxFree_real32_T(&vc_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv64);
  gpuEmxFree_real_T(&ke_gpu_y);
  gpuEmxFree_real32_T(&gc_gpu_expanded);
  gpuEmxFree_real32_T(&fc_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv65);
  gpuEmxFree_int32_T(&sg_gpu_y);
  gpuEmxFree_real32_T(&xf_gpu_y);
  gpuEmxFree_int32_T(&ff_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv66);
  gpuEmxFree_int32_T(&fe_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv67);
  gpuEmxFree_int32_T(&bd_gpu_rows);
  gpuEmxFree_int32_T(&qc_gpu_rows);
  gpuEmxFree_int32_T(&ef_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv69);
  gpuEmxFree_real_T(&b_gpu_G);
  gpuEmxFree_int32_T(&cc_gpu_rows);
  gpuEmxFree_int32_T(&ee_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv70);
  gpuEmxFree_real32_T(&pd_gpu_expanded);
  gpuEmxFree_real32_T(&od_gpu_expanded);
  gpuEmxFree_real32_T(&ed_gpu_expanded);
  gpuEmxFree_real32_T(&dd_gpu_expanded);
  gpuEmxFree_real32_T(&nc_gpu_expanded);
  gpuEmxFree_real32_T(&mc_gpu_expanded);
  gpuEmxFree_real_T(&og_gpu_y);
  gpuEmxFree_int32_T(&jg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv71);
  gpuEmxFree_int32_T(&qf_gpu_y);
  gpuEmxFree_real32_T(&yc_gpu_expanded);
  gpuEmxFree_real32_T(&xc_gpu_expanded);
  gpuEmxFree_int32_T(&qe_gpu_y);
  gpuEmxFree_real32_T(&ic_gpu_expanded);
  gpuEmxFree_real32_T(&hc_gpu_expanded);
  gpuEmxFree_int32_T(&ig_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv72);
  gpuEmxFree_int32_T(&gpu_iv73);
  gpuEmxFree_int32_T(&pf_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv74);
  gpuEmxFree_int32_T(&hf_gpu_y);
  gpuEmxFree_int32_T(&lc_gpu_rows);
  gpuEmxFree_real_T(&b_gpu_sinc1A);
  gpuEmxFree_int32_T(&pe_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv75);
  gpuEmxFree_int32_T(&he_gpu_y);
  gpuEmxFree_int32_T(&wb_gpu_rows);
  gpuEmxFree_int32_T(&hd_gpu_rows);
  gpuEmxFree_int32_T(&gf_gpu_y);
  gpuEmxFree_int32_T(&ge_gpu_y);
  gpuEmxFree_real32_T(&wd_gpu_expanded);
  gpuEmxFree_real32_T(&vd_gpu_expanded);
  gpuEmxFree_real32_T(&rd_gpu_expanded);
  gpuEmxFree_real32_T(&qd_gpu_expanded);
  gpuEmxFree_real32_T(&gd_gpu_expanded);
  gpuEmxFree_real32_T(&fd_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv76);
  gpuEmxFree_int32_T(&i_gpu_cols);
  gpuEmxFree_int32_T(&ic_gpu_rows);
  gpuEmxFree_real_T(&b_gpu_sinc2A);
  gpuEmxFree_real32_T(&pc_gpu_expanded);
  gpuEmxFree_real32_T(&oc_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv77);
  gpuEmxFree_int32_T(&g_gpu_cols);
  gpuEmxFree_int32_T(&tb_gpu_rows);
  gpuEmxFree_int32_T(&ug_gpu_y);
  gpuEmxFree_int32_T(&lg_gpu_y);
  gpuEmxFree_int32_T(&cd_gpu_rows);
  gpuEmxFree_int32_T(&sf_gpu_y);
  gpuEmxFree_int32_T(&rc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv78);
  gpuEmxFree_real32_T(&d_gpu_h);
  gpuEmxFree_int32_T(&se_gpu_y);
  gpuEmxFree_int32_T(&dc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv79);
  gpuEmxFree_int32_T(&tg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv80);
  gpuEmxFree_int32_T(&kg_gpu_y);
  gpuEmxFree_int32_T(&rf_gpu_y);
  gpuEmxFree_real_T(&b_gpu_sinc3A);
  gpuEmxFree_uint32_T(&o_gpu_y);
  gpuEmxFree_int32_T(&re_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv81);
  gpuEmxFree_int32_T(&k_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv82);
  gpuEmxFree_int32_T(&j_gpu_cols);
  gpuEmxFree_int32_T(&nc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv84);
  gpuEmxFree_int32_T(&h_gpu_cols);
  gpuEmxFree_int32_T(&yb_gpu_rows);
  gpuEmxFree_real32_T(&yd_gpu_expanded);
  gpuEmxFree_real32_T(&xd_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv86);
  gpuEmxFree_int32_T(&yc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv87);
  gpuEmxFree_int32_T(&gpu_iv88);
  gpuEmxFree_int32_T(&mc_gpu_rows);
  gpuEmxFree_real_T(&b_gpu_sinc4A);
  gpuEmxFree_int32_T(&gpu_iv89);
  gpuEmxFree_int32_T(&gpu_iv90);
  gpuEmxFree_int32_T(&xb_gpu_rows);
  gpuEmxFree_int32_T(&wg_gpu_y);
  gpuEmxFree_int32_T(&id_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv91);
  gpuEmxFree_int32_T(&gpu_iv92);
  gpuEmxFree_int32_T(&vg_gpu_y);
  gpuEmxFree_int32_T(&ed_gpu_rows);
  gpuEmxFree_int32_T(&tc_gpu_rows);
  gpuEmxFree_int32_T(&jc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv93);
  gpuEmxFree_int32_T(&fc_gpu_rows);
  gpuEmxFree_int32_T(&ub_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv94);
  gpuEmxFree_int32_T(&l_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv95);
  gpuEmxFree_int32_T(&dd_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv97);
  gpuEmxFree_int32_T(&sc_gpu_rows);
  gpuEmxFree_int32_T(&pc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv98);
  gpuEmxFree_int32_T(&ec_gpu_rows);
  gpuEmxFree_int32_T(&bc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv99);
  gpuEmxFree_int32_T(&gpu_iv100);
  gpuEmxFree_int32_T(&gpu_iv101);
  gpuEmxFree_int32_T(&oc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv103);
  gpuEmxFree_int32_T(&ac_gpu_rows);
  gpuEmxFree_real_T(&b_gpu_b);
  gpuEmxFree_int32_T(&kd_gpu_rows);
  gpuEmxFree_int32_T(&gd_gpu_rows);
  gpuEmxFree_int32_T(&ad_gpu_rows);
  gpuEmxFree_int32_T(&vc_gpu_rows);
  gpuEmxFree_int32_T(&hc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv107);
  gpuEmxFree_int32_T(&jd_gpu_rows);
  gpuEmxFree_int32_T(&fd_gpu_rows);
  gpuEmxFree_int32_T(&uc_gpu_rows);
  gpuEmxFree_int32_T(&gc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv108);
  gpuEmxFree_creal32_T(&b_gpu_y1);
  gpuEmxFree_int32_T(&md_gpu_rows);
  gpuEmxFree_int32_T(&ld_gpu_rows);
  gpuEmxFree_real_T(&e_gpu_a);
  gpuEmxFree_real_T(&gpu_dv29);
  gpuEmxFree_real_T(&h_gpu_x);
  gpuEmxFree_int32_T(&gpu_jpvt);
  gpuEmxFree_real32_T(&gpu_fv);
  gpuEmxFree_real_T(&gpu_dv31);
  gpuEmxFree_creal32_T(&gpu_xCol);
  gpuEmxFree_real_T(&gpu_tau);
  gpuEmxFree_real_T(&m_gpu_y);
  gpuEmxFree_int32_T(&gpu_IPIV);
  gpuEmxFree_creal32_T(&m_gpu_yCol);
  gpuEmxFree_creal32_T(&i_gpu_yCol);
  gpuEmxFree_creal32_T(&c_gpu_yCol);
  gpuEmxFree_creal32_T(&p_gpu_yCol);
  gpuEmxFree_creal32_T(&k_gpu_yCol);
  gpuEmxFree_creal32_T(&e_gpu_yCol);
  gpuEmxFree_real_T(&n_gpu_y);
  gpuEmxFree_creal32_T(&r_gpu_yCol);
  gpuEmxFree_creal32_T(&g_gpu_yCol);
  gpuEmxFree_creal32_T(&gpu_yCol);
  gpuEmxFree_creal32_T(&m_gpu_w);
  gpuEmxFree_creal32_T(&d_gpu_w);
  gpuEmxFree_creal32_T(&w_gpu_w);
  gpuEmxFree_creal32_T(&n_gpu_yCol);
  gpuEmxFree_creal32_T(&p_gpu_w);
  gpuEmxFree_creal32_T(&g_gpu_w);
  gpuEmxFree_creal32_T(&s_gpu_w);
  gpuEmxFree_creal32_T(&ab_gpu_w);
  gpuEmxFree_creal32_T(&j_gpu_w);
  gpuEmxFree_creal32_T(&gpu_w);
  gpuEmxFree_creal32_T(&f_gpu_c);
  gpuEmxFree_creal32_T(&d_gpu_c);
  gpuEmxFree_creal32_T(&j_gpu_a);
  gpuEmxFree_creal32_T(&g_gpu_a);
  gpuEmxFree_creal32_T(&h_gpu_c);
  gpuEmxFree_creal32_T(&t_gpu_w);
  gpuEmxFree_creal32_T(&g_gpu_c);
  gpuEmxFree_creal32_T(&e_gpu_c);
  gpuEmxFree_creal32_T(&l_gpu_a);
  gpuEmxFree_creal32_T(&k_gpu_a);
  gpuEmxFree_creal32_T(&h_gpu_a);
  gpuEmxFree_creal32_T(&i_gpu_c);
  gpuEmxFree_creal32_T(&pc_gpu_y);
  gpuEmxFree_creal32_T(&m_gpu_a);
  gpuEmxFree_creal32_T(&ib_gpu_expanded);
  gpuEmxFree_real32_T(&hb_gpu_expanded);
  gpuEmxFree_creal32_T(&i_gpu_a);
  gpuEmxFree_creal32_T(&f_gpu_a);
  gpuEmxFree_int32_T(&sc_gpu_y);
  gpuEmxFree_int32_T(&rc_gpu_y);
  gpuEmxFree_real_T(&qc_gpu_y);
  gpuEmxFree_creal32_T(&s_gpu_expanded);
  gpuEmxFree_creal32_T(&c_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv139);
  gpuEmxFree_int32_T(&gpu_iv140);
  gpuEmxFree_creal32_T(&u_gpu_expanded);
  gpuEmxFree_real32_T(&t_gpu_expanded);
  gpuEmxFree_int32_T(&vb_gpu_y);
  gpuEmxFree_creal32_T(&e_gpu_expanded);
  gpuEmxFree_real32_T(&d_gpu_expanded);
  gpuEmxFree_int32_T(&v_gpu_y);
  gpuEmxFree_creal32_T(&lb_gpu_expanded);
  gpuEmxFree_creal32_T(&ab_gpu_expanded);
  gpuEmxFree_int32_T(&xb_gpu_y);
  gpuEmxFree_creal32_T(&j_gpu_expanded);
  gpuEmxFree_int32_T(&x_gpu_y);
  gpuEmxFree_int32_T(&wb_gpu_y);
  gpuEmxFree_int32_T(&w_gpu_y);
  gpuEmxFree_creal32_T(&nb_gpu_expanded);
  gpuEmxFree_real32_T(&mb_gpu_expanded);
  gpuEmxFree_int32_T(&ad_gpu_y);
  gpuEmxFree_int32_T(&eb_gpu_rows);
  gpuEmxFree_int32_T(&db_gpu_rows);
  gpuEmxFree_creal32_T(&cb_gpu_expanded);
  gpuEmxFree_real32_T(&bb_gpu_expanded);
  gpuEmxFree_int32_T(&hc_gpu_y);
  gpuEmxFree_creal32_T(&l_gpu_expanded);
  gpuEmxFree_real32_T(&k_gpu_expanded);
  gpuEmxFree_int32_T(&hb_gpu_y);
  gpuEmxFree_int32_T(&cd_gpu_y);
  gpuEmxFree_int32_T(&jc_gpu_y);
  gpuEmxFree_creal32_T(&c_gpu_result);
  gpuEmxFree_int32_T(&jb_gpu_y);
  gpuEmxFree_creal32_T(&gpu_result);
  gpuEmxFree_creal32_T(&sb_gpu_expanded);
  gpuEmxFree_int32_T(&bd_gpu_y);
  gpuEmxFree_int32_T(&ic_gpu_y);
  gpuEmxFree_creal32_T(&rb_gpu_y);
  gpuEmxFree_int32_T(&ib_gpu_y);
  gpuEmxFree_creal32_T(&r_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv141);
  gpuEmxFree_int32_T(&gpu_iv142);
  gpuEmxFree_creal32_T(&ub_gpu_expanded);
  gpuEmxFree_real32_T(&tb_gpu_expanded);
  gpuEmxFree_int32_T(&ld_gpu_y);
  gpuEmxFree_creal32_T(&e_gpu_result);
  gpuEmxFree_creal32_T(&d_gpu_result);
  gpuEmxFree_creal32_T(&b_gpu_result);
  gpuEmxFree_int32_T(&nd_gpu_y);
  gpuEmxFree_creal32_T(&vc_gpu_y);
  gpuEmxFree_creal32_T(&ec_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv143);
  gpuEmxFree_creal32_T(&r_gpu_expanded);
  gpuEmxFree_real32_T(&q_gpu_expanded);
  gpuEmxFree_creal32_T(&eb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv144);
  gpuEmxFree_creal32_T(&b_gpu_expanded);
  gpuEmxFree_real32_T(&gpu_expanded);
  gpuEmxFree_int32_T(&md_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv145);
  gpuEmxFree_int32_T(&gpu_iv146);
  gpuEmxFree_int32_T(&gpu_iv147);
  gpuEmxFree_int32_T(&ub_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv148);
  gpuEmxFree_int32_T(&gpu_iv149);
  gpuEmxFree_int32_T(&u_gpu_y);
  gpuEmxFree_int32_T(&yb_gpu_y);
  gpuEmxFree_int32_T(&tb_gpu_y);
  gpuEmxFree_int32_T(&y_gpu_y);
  gpuEmxFree_int32_T(&t_gpu_y);
  gpuEmxFree_creal32_T(&f_gpu_result);
  gpuEmxFree_int32_T(&gpu_iv150);
  gpuEmxFree_int32_T(&gpu_iv151);
  gpuEmxFree_real_T(&sb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv152);
  gpuEmxFree_real_T(&s_gpu_y);
  gpuEmxFree_creal32_T(&id_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv153);
  gpuEmxFree_creal32_T(&kb_gpu_expanded);
  gpuEmxFree_real32_T(&jb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv154);
  gpuEmxFree_int32_T(&gpu_iv155);
  gpuEmxFree_int32_T(&gpu_iv156);
  gpuEmxFree_int32_T(&dd_gpu_y);
  gpuEmxFree_int32_T(&yc_gpu_y);
  gpuEmxFree_int32_T(&kc_gpu_y);
  gpuEmxFree_creal32_T(&pb_gpu_y);
  gpuEmxFree_int32_T(&kb_gpu_y);
  gpuEmxFree_creal32_T(&p_gpu_y);
  gpuEmxFree_real_T(&wc_gpu_y);
  gpuEmxFree_int32_T(&xc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv159);
  gpuEmxFree_int32_T(&q_gpu_rows);
  gpuEmxFree_int32_T(&c_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv160);
  gpuEmxFree_creal32_T(&o_gpu_newIm);
  gpuEmxFree_real_T(&gc_gpu_y);
  gpuEmxFree_creal32_T(&w_gpu_expanded);
  gpuEmxFree_real32_T(&v_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv161);
  gpuEmxFree_real_T(&gb_gpu_y);
  gpuEmxFree_creal32_T(&g_gpu_expanded);
  gpuEmxFree_real32_T(&f_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv162);
  gpuEmxFree_int32_T(&od_gpu_y);
  gpuEmxFree_creal32_T(&tc_gpu_y);
  gpuEmxFree_int32_T(&bc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv163);
  gpuEmxFree_int32_T(&bb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv164);
  gpuEmxFree_int32_T(&hb_gpu_rows);
  gpuEmxFree_int32_T(&w_gpu_rows);
  gpuEmxFree_int32_T(&ac_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv166);
  gpuEmxFree_int32_T(&i_gpu_rows);
  gpuEmxFree_int32_T(&ab_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv167);
  gpuEmxFree_creal32_T(&pb_gpu_expanded);
  gpuEmxFree_real32_T(&ob_gpu_expanded);
  gpuEmxFree_creal32_T(&eb_gpu_expanded);
  gpuEmxFree_real32_T(&db_gpu_expanded);
  gpuEmxFree_creal32_T(&n_gpu_expanded);
  gpuEmxFree_real32_T(&m_gpu_expanded);
  gpuEmxFree_real_T(&kd_gpu_y);
  gpuEmxFree_int32_T(&fd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv168);
  gpuEmxFree_int32_T(&mc_gpu_y);
  gpuEmxFree_creal32_T(&y_gpu_expanded);
  gpuEmxFree_real32_T(&x_gpu_expanded);
  gpuEmxFree_int32_T(&mb_gpu_y);
  gpuEmxFree_creal32_T(&i_gpu_expanded);
  gpuEmxFree_real32_T(&h_gpu_expanded);
  gpuEmxFree_int32_T(&ed_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv169);
  gpuEmxFree_int32_T(&gpu_iv170);
  gpuEmxFree_int32_T(&lc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv171);
  gpuEmxFree_int32_T(&dc_gpu_y);
  gpuEmxFree_int32_T(&r_gpu_rows);
  gpuEmxFree_int32_T(&lb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv172);
  gpuEmxFree_int32_T(&db_gpu_y);
  gpuEmxFree_int32_T(&d_gpu_rows);
  gpuEmxFree_int32_T(&nb_gpu_rows);
  gpuEmxFree_int32_T(&cc_gpu_y);
  gpuEmxFree_int32_T(&cb_gpu_y);
  gpuEmxFree_creal32_T(&wb_gpu_expanded);
  gpuEmxFree_real32_T(&vb_gpu_expanded);
  gpuEmxFree_creal32_T(&rb_gpu_expanded);
  gpuEmxFree_real32_T(&qb_gpu_expanded);
  gpuEmxFree_creal32_T(&gb_gpu_expanded);
  gpuEmxFree_real32_T(&fb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv173);
  gpuEmxFree_int32_T(&c_gpu_cols);
  gpuEmxFree_int32_T(&o_gpu_rows);
  gpuEmxFree_creal32_T(&p_gpu_expanded);
  gpuEmxFree_real32_T(&o_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv174);
  gpuEmxFree_int32_T(&gpu_cols);
  gpuEmxFree_int32_T(&gpu_rows);
  gpuEmxFree_int32_T(&qd_gpu_y);
  gpuEmxFree_int32_T(&hd_gpu_y);
  gpuEmxFree_int32_T(&ib_gpu_rows);
  gpuEmxFree_int32_T(&oc_gpu_y);
  gpuEmxFree_int32_T(&x_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv175);
  gpuEmxFree_int32_T(&ob_gpu_y);
  gpuEmxFree_int32_T(&j_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv176);
  gpuEmxFree_int32_T(&pd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv177);
  gpuEmxFree_int32_T(&gd_gpu_y);
  gpuEmxFree_int32_T(&nc_gpu_y);
  gpuEmxFree_int32_T(&nb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv178);
  gpuEmxFree_int32_T(&e_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv179);
  gpuEmxFree_int32_T(&d_gpu_cols);
  gpuEmxFree_int32_T(&t_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv181);
  gpuEmxFree_int32_T(&b_gpu_cols);
  gpuEmxFree_int32_T(&f_gpu_rows);
  gpuEmxFree_creal32_T(&yb_gpu_expanded);
  gpuEmxFree_real32_T(&xb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv183);
  gpuEmxFree_int32_T(&fb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv184);
  gpuEmxFree_int32_T(&gpu_iv185);
  gpuEmxFree_int32_T(&s_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv186);
  gpuEmxFree_int32_T(&gpu_iv187);
  gpuEmxFree_int32_T(&e_gpu_rows);
  gpuEmxFree_int32_T(&sd_gpu_y);
  gpuEmxFree_int32_T(&ob_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv188);
  gpuEmxFree_int32_T(&gpu_iv189);
  gpuEmxFree_int32_T(&rd_gpu_y);
  gpuEmxFree_int32_T(&kb_gpu_rows);
  gpuEmxFree_int32_T(&ab_gpu_rows);
  gpuEmxFree_int32_T(&p_gpu_rows);
  gpuEmxFree_int32_T(&l_gpu_rows);
  gpuEmxFree_int32_T(&b_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv190);
  gpuEmxFree_int32_T(&f_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv191);
  gpuEmxFree_int32_T(&jb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv193);
  gpuEmxFree_int32_T(&y_gpu_rows);
  gpuEmxFree_int32_T(&v_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv194);
  gpuEmxFree_int32_T(&k_gpu_rows);
  gpuEmxFree_int32_T(&h_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv195);
  gpuEmxFree_int32_T(&gpu_iv196);
  gpuEmxFree_int32_T(&gpu_iv197);
  gpuEmxFree_int32_T(&u_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv199);
  gpuEmxFree_int32_T(&g_gpu_rows);
  gpuEmxFree_int32_T(&qb_gpu_rows);
  gpuEmxFree_int32_T(&mb_gpu_rows);
  gpuEmxFree_int32_T(&gb_gpu_rows);
  gpuEmxFree_int32_T(&cb_gpu_rows);
  gpuEmxFree_int32_T(&n_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv203);
  gpuEmxFree_int32_T(&pb_gpu_rows);
  gpuEmxFree_int32_T(&lb_gpu_rows);
  gpuEmxFree_int32_T(&bb_gpu_rows);
  gpuEmxFree_int32_T(&m_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv204);
  gpuEmxFree_int32_T(&sb_gpu_rows);
  gpuEmxFree_int32_T(&rb_gpu_rows);
  gpuEmxFree_creal32_T(&i_gpu_newIm);
  gpuEmxFree_creal32_T(&b_gpu_newIm);
  gpuEmxFree_creal32_T(&j_gpu_newIm);
  gpuEmxFree_creal32_T(&c_gpu_newIm);
  gpuEmxFree_creal32_T(&q_gpu_newIm);
  gpuEmxFree_creal32_T(&l_gpu_newIm);
  gpuEmxFree_creal32_T(&e_gpu_newIm);
  gpuEmxFree_creal32_T(&r_gpu_newIm);
  gpuEmxFree_creal32_T(&m_gpu_newIm);
  gpuEmxFree_creal32_T(&f_gpu_newIm);
  gpuEmxFree_creal32_T(&k_gpu_newIm);
  gpuEmxFree_creal32_T(&d_gpu_newIm);
  gpuEmxFree_creal32_T(&t_gpu_newIm);
  gpuEmxFree_creal32_T(&u_gpu_newIm);
  gpuEmxFree_creal32_T(&s_gpu_newIm);
  gpuEmxFree_creal32_T(&n_gpu_newIm);
  gpuEmxFree_creal32_T(&h_gpu_newIm);
  gpuEmxFree_creal32_T(&g_gpu_newIm);
  gpuEmxFree_creal32_T(&gpu_newIm);
  gpuEmxFree_creal32_T(&v_gpu_newIm);
  gpuEmxFree_creal32_T(&p_gpu_newIm);
  gpuEmxFree_real32_T(&g_gpu_smooth);
  gpuEmxFree_real32_T(&h_gpu_smooth);
  gpuEmxFree_real32_T(&e_gpu_smooth);
  gpuEmxFree_real32_T(&f_gpu_smooth);
  gpuEmxFree_creal32_T(&d_gpu_smooth);
  gpuEmxFree_real_T(&gpu_b0);
  gpuEmxFree_real32_T(&xb_gpu_w);
  gpuEmxFree_real32_T(&qb_gpu_w);
  gpuEmxFree_real32_T(&hb_gpu_w);
  gpuEmxFree_real32_T(&nb_gpu_w);
  gpuEmxFree_real32_T(&eb_gpu_w);
  gpuEmxFree_real32_T(&bc_gpu_w);
  gpuEmxFree_real32_T(&tb_gpu_w);
  gpuEmxFree_real32_T(&kb_gpu_w);
  gpuEmxFree_real32_T(&yb_gpu_w);
  gpuEmxFree_real32_T(&rb_gpu_w);
  gpuEmxFree_real32_T(&ib_gpu_w);
  gpuEmxFree_real32_T(&yf_gpu_y);
  gpuEmxFree_real32_T(&ob_gpu_w);
  gpuEmxFree_real32_T(&fb_gpu_w);
  gpuEmxFree_real32_T(&jf_gpu_y);
  gpuEmxFree_real32_T(&ue_gpu_y);
  gpuEmxFree_real32_T(&je_gpu_y);
  gpuEmxFree_real32_T(&ud_gpu_y);
  gpuEmxFree_real32_T(&cc_gpu_w);
  gpuEmxFree_real32_T(&ub_gpu_w);
  gpuEmxFree_real32_T(&lb_gpu_w);
  gpuEmxFree_real32_T(&ec_gpu_w);
  gpuEmxFree_real32_T(&ng_gpu_y);
  gpuEmxFree_real32_T(&fc_gpu_w);
  gpuEmxFree_real_T(&b_gpu_b0);
  gpuEmxFree_creal32_T(&h_gpu_yCol);
  gpuEmxFree_creal32_T(&b_gpu_yCol);
  gpuEmxFree_creal32_T(&o_gpu_yCol);
  gpuEmxFree_creal32_T(&j_gpu_yCol);
  gpuEmxFree_creal32_T(&d_gpu_yCol);
  gpuEmxFree_creal32_T(&q_gpu_yCol);
  gpuEmxFree_creal32_T(&l_gpu_yCol);
  gpuEmxFree_creal32_T(&f_gpu_yCol);
  gpuEmxFree_creal32_T(&s_gpu_yCol);
  gpuEmxFree_creal32_T(&u_gpu_w);
  gpuEmxFree_creal32_T(&n_gpu_w);
  gpuEmxFree_creal32_T(&e_gpu_w);
  gpuEmxFree_creal32_T(&k_gpu_w);
  gpuEmxFree_creal32_T(&b_gpu_w);
  gpuEmxFree_creal32_T(&x_gpu_w);
  gpuEmxFree_creal32_T(&q_gpu_w);
  gpuEmxFree_creal32_T(&h_gpu_w);
  gpuEmxFree_creal32_T(&v_gpu_w);
  gpuEmxFree_creal32_T(&o_gpu_w);
  gpuEmxFree_creal32_T(&f_gpu_w);
  gpuEmxFree_creal32_T(&uc_gpu_y);
  gpuEmxFree_creal32_T(&l_gpu_w);
  gpuEmxFree_creal32_T(&c_gpu_w);
  gpuEmxFree_creal32_T(&fc_gpu_y);
  gpuEmxFree_creal32_T(&qb_gpu_y);
  gpuEmxFree_creal32_T(&fb_gpu_y);
  gpuEmxFree_creal32_T(&q_gpu_y);
  gpuEmxFree_creal32_T(&y_gpu_w);
  gpuEmxFree_creal32_T(&r_gpu_w);
  gpuEmxFree_creal32_T(&i_gpu_w);
  gpuEmxFree_creal32_T(&bb_gpu_w);
  gpuEmxFree_creal32_T(&jd_gpu_y);
  gpuEmxFree_creal32_T(&cb_gpu_w);
  checkCudaError(mwCudaFree(gpu_lidx), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_wav), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_wname), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_interval), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_subs), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_x_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*b_gpu_x_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_xt_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_y_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*d_gpu_fx_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*c_gpu_a_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv8_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv2_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*c_gpu_fx_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*b_gpu_fx_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*b_gpu_a_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv15_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv9_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_fx_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(c_gpu_cfsposdft), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_a_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_cv_re), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f1), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_origSiz), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_lshift), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f6), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f7), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f8), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f9), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f10), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f11), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f12), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f13), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f14), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f15), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f16), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f17), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f18), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f19), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f20), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f21), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f22), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f23), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f24), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f25), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f26), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f27), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f28), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f29), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f30), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f31), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f32), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f33), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f34), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f35), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f36), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f37), __FILE__, __LINE__);
}

void ec_wtcc_atexit()
{
  mexFunctionCreateRootTLS();
  try {
    emlrtPushHeapReferenceStackR2021a(emlrtRootTLSGlobal, false, nullptr, (void *)
      &emlrtExitTimeCleanupDtorFcn, nullptr, nullptr, nullptr);
    emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
    emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
    emlrtExitTimeCleanup(&emlrtContextGlobal);
  } catch (...) {
    emlrtCleanupOnException((emlrtCTX *)emlrtRootTLSGlobal);
    throw;
  }

  cusolverDestroyWorkspace();
  cusolverEnsureDestruction();
  mwCudaFree(*global_gpu_cv);
  mwCudaFree(*global_gpu_table100);
}

void ec_wtcc_initialize()
{
  emlrtInitGPU(emlrtRootTLSGlobal);
  cudaGetLastError();
  mexFunctionCreateRootTLS();
  emlrtClearAllocCountR2012b(emlrtRootTLSGlobal, false, 0U, nullptr);
  emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "distrib_computing_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "wavelet_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "signal_toolbox", 2);
  cublasEnsureInitialization(CUBLAS_POINTER_MODE_HOST);
  cusolverEnsureInitialization();
  if (emlrtFirstTimeR2012b(emlrtRootTLSGlobal)) {
    ec_wtcc_once();
  }
}

void ec_wtcc_terminate()
{
  cudaError_t errCode;
  errCode = cudaGetLastError();
  if (errCode != cudaSuccess) {
    emlrtThinCUDAError(static_cast<uint32_T>(errCode), (char_T *)
                       cudaGetErrorName(errCode), (char_T *)cudaGetErrorString
                       (errCode), (char_T *)"SafeBuild", emlrtRootTLSGlobal);
  }

  emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
  cublasEnsureDestruction();
}

// End of code generation (ec_wtcc.cu)
