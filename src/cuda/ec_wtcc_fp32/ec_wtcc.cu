//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// ec_wtcc.cu
//
// Code generation for function 'ec_wtcc'
//

// Include files
#include "ec_wtcc.h"
#include "_coder_ec_wtcc_mex.h"
#include "ec_wtcc_types.h"
#include "rt_nonfinite.h"
#include "MWCUBLASUtils.hpp"
#include "MWCUFFTPlanManager.hpp"
#include "MWCUSOLVERUtils.hpp"
#include "MWCudaDimUtility.hpp"
#include "MWCudaMemoryFunctions.hpp"
#include "MWErrorCodeUtils.hpp"
#include "MWLaunchParametersUtilities.hpp"
#include "cufft.h"
#include "lapacke.h"
#include "math_constants.h"
#include "rt_defines.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include <algorithm>
#include <cfloat>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>

// Type Definitions
struct emxArray_real_T
{
  real_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_int32_T
{
  int32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_creal32_T
{
  creal32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_uint32_T
{
  uint32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_ptrdiff_t
{
  ptrdiff_t *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_char_T
{
  char_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

// Variable Definitions
emlrtCTX emlrtRootTLSGlobal{ nullptr };

emlrtContext emlrtContextGlobal{ true, // bFirstTime
  false,                               // bInitialized
  131643U,                             // fVersionInfo
  nullptr,                             // fErrorFunction
  "ec_wtcc",                           // fFunctionName
  nullptr,                             // fRTCallStack
  false,                               // bDebugMode

  { 3334663369U, 2606893378U, 3553281593U, 3751928550U },// fSigWrd
  nullptr                              // fSigMem
};

static emlrtMCInfo emlrtMCI{ 53,       // lineNo
  19,                                  // colNo
  "flt2str",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/flt2str.m"// pName
};

static emlrtMCInfo b_emlrtMCI{ 53,     // lineNo
  14,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo c_emlrtMCI{ 55,     // lineNo
  15,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo d_emlrtMCI{ 14,     // lineNo
  25,                                  // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtMCInfo e_emlrtMCI{ 14,     // lineNo
  9,                                   // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtRTEInfo emlrtRTEI{ 999,    // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo b_emlrtRTEI{ 1000, // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo c_emlrtRTEI{ 1009, // lineNo
  13,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo d_emlrtRTEI{ 28,   // lineNo
  9,                                   // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo e_emlrtRTEI{ 129,  // lineNo
  6,                                   // colNo
  "applyBinaryScalarFunction",         // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyBinaryScalarFunction.m"// pName
};

static emlrtRTEInfo f_emlrtRTEI{ 33,   // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo g_emlrtRTEI{ 18,   // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo h_emlrtRTEI{ 60,   // lineNo
  20,                                  // colNo
  "bsxfun",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/bsxfun.m"// pName
};

static emlrtRTEInfo i_emlrtRTEI{ 31,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo j_emlrtRTEI{ 26,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo k_emlrtRTEI{ 33,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo l_emlrtRTEI{ 27,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo m_emlrtRTEI{ 102,  // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo n_emlrtRTEI{ 30,   // lineNo
  21,                                  // colNo
  "applyScalarFunction",               // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyScalarFunction.m"// pName
};

static emlrtRTEInfo o_emlrtRTEI{ 135,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo p_emlrtRTEI{ 34,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo q_emlrtRTEI{ 143,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo r_emlrtRTEI{ 1,    // lineNo
  1,                                   // colNo
  "cuFFTNDCallback",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/cuFFTNDCallback.p"// pName
};

static emlrtRTEInfo s_emlrtRTEI{ 138,  // lineNo
  19,                                  // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo t_emlrtRTEI{ 138,  // lineNo
  6,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo u_emlrtRTEI{ 161,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo v_emlrtRTEI{ 180,  // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo w_emlrtRTEI{ 15,   // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo x_emlrtRTEI{ 16,   // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo y_emlrtRTEI{ 18,   // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo ab_emlrtRTEI{ 25,  // lineNo
  1,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo bb_emlrtRTEI{ 30,  // lineNo
  27,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo cb_emlrtRTEI{ 47,  // lineNo
  28,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo db_emlrtRTEI{ 83,  // lineNo
  1,                                   // colNo
  "ifft",                              // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/ifft.m"// pName
};

static emlrtRTEInfo eb_emlrtRTEI{ 47,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo fb_emlrtRTEI{ 49,  // lineNo
  31,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo gb_emlrtRTEI{ 216, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo hb_emlrtRTEI{ 75,  // lineNo
  5,                                   // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo ib_emlrtRTEI{ 88,  // lineNo
  13,                                  // colNo
  "eml_mtimes_helper",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static emlrtRTEInfo jb_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "stencil_codegen",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/stencil_codegen.p"// pName
};

static emlrtRTEInfo kb_emlrtRTEI{ 172, // lineNo
  20,                                  // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo lb_emlrtRTEI{ 53,  // lineNo
  7,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo mb_emlrtRTEI{ 217, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo nb_emlrtRTEI{ 218, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ob_emlrtRTEI{ 50,  // lineNo
  23,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo pb_emlrtRTEI{ 50,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo qb_emlrtRTEI{ 219, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo rb_emlrtRTEI{ 220, // lineNo
  1,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo sb_emlrtRTEI{ 154, // lineNo
  1,                                   // colNo
  "resample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/resample.m"// pName
};

static emlrtRTEInfo tb_emlrtRTEI{ 37,  // lineNo
  20,                                  // colNo
  "kaiser",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/kaiser.m"// pName
};

static emlrtRTEInfo ub_emlrtRTEI{ 816, // lineNo
  63,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo vb_emlrtRTEI{ 245, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo wb_emlrtRTEI{ 243, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo xb_emlrtRTEI{ 816, // lineNo
  17,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo yb_emlrtRTEI{ 247, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ac_emlrtRTEI{ 258, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo bc_emlrtRTEI{ 274, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo cc_emlrtRTEI{ 275, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo dc_emlrtRTEI{ 276, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ec_emlrtRTEI{ 777, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo fc_emlrtRTEI{ 277, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo gc_emlrtRTEI{ 286, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo hc_emlrtRTEI{ 778, // lineNo
  15,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ic_emlrtRTEI{ 281, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo jc_emlrtRTEI{ 341, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo kc_emlrtRTEI{ 347, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo lc_emlrtRTEI{ 345, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo mc_emlrtRTEI{ 76,  // lineNo
  9,                                   // colNo
  "eml_mtimes_helper",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static emlrtRTEInfo nc_emlrtRTEI{ 38,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo oc_emlrtRTEI{ 21,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo pc_emlrtRTEI{ 341, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo qc_emlrtRTEI{ 31,  // lineNo
  29,                                  // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo rc_emlrtRTEI{ 61,  // lineNo
  9,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo sc_emlrtRTEI{ 27,  // lineNo
  23,                                  // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo tc_emlrtRTEI{ 49,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo uc_emlrtRTEI{ 47,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo vc_emlrtRTEI{ 1,   // lineNo
  21,                                  // colNo
  "flipud",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/flipud.m"// pName
};

static emlrtRTEInfo wc_emlrtRTEI{ 36,  // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo xc_emlrtRTEI{ 92,  // lineNo
  22,                                  // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo yc_emlrtRTEI{ 91,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo ad_emlrtRTEI{ 105, // lineNo
  1,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo bd_emlrtRTEI{ 68,  // lineNo
  9,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo cd_emlrtRTEI{ 353, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo dd_emlrtRTEI{ 355, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ed_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "upfirdnGPUImpl",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+codegenable/+gpu/upfirdnGPUImpl.p"// pName
};

static emlrtRTEInfo fd_emlrtRTEI{ 119, // lineNo
  5,                                   // colNo
  "qrsolve",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/qrsolve.m"// pName
};

static emlrtRTEInfo gd_emlrtRTEI{ 71,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo hd_emlrtRTEI{ 158, // lineNo
  24,                                  // colNo
  "mtimes",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+blas/mtimes.m"// pName
};

static emlrtRTEInfo jd_emlrtRTEI{ 91,  // lineNo
  14,                                  // colNo
  "downsample",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/downsample.m"// pName
};

static emlrtRTEInfo kd_emlrtRTEI{ 83,  // lineNo
  13,                                  // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo ld_emlrtRTEI{ 17,  // lineNo
  5,                                   // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo md_emlrtRTEI{ 13,  // lineNo
  1,                                   // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo nd_emlrtRTEI{ 37,  // lineNo
  1,                                   // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo od_emlrtRTEI{ 170, // lineNo
  5,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo pd_emlrtRTEI{ 1276,// lineNo
  30,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo qd_emlrtRTEI{ 1276,// lineNo
  25,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo rd_emlrtRTEI{ 16,  // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo sd_emlrtRTEI{ 32,  // lineNo
  18,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo td_emlrtRTEI{ 34,  // lineNo
  42,                                  // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo ud_emlrtRTEI{ 32,  // lineNo
  13,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo vd_emlrtRTEI{ 151, // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo wd_emlrtRTEI{ 216, // lineNo
  39,                                  // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo xd_emlrtRTEI{ 30,  // lineNo
  5,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo yd_emlrtRTEI{ 47,  // lineNo
  23,                                  // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo ae_emlrtRTEI{ 45,  // lineNo
  9,                                   // colNo
  "smoothCFS",                         // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/smoothCFS.m"// pName
};

static emlrtRTEInfo be_emlrtRTEI{ 217, // lineNo
  39,                                  // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ce_emlrtRTEI{ 49,  // lineNo
  13,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo de_emlrtRTEI{ 220, // lineNo
  7,                                   // colNo
  "wcoherence",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/wcoherence.m"// pName
};

static emlrtRTEInfo ee_emlrtRTEI{ 816, // lineNo
  22,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo fe_emlrtRTEI{ 1,   // lineNo
  20,                                  // colNo
  "ec_wtcc",                           // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_wtcc.m"// pName
};

static emlrtRTEInfo ge_emlrtRTEI{ 253, // lineNo
  20,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo he_emlrtRTEI{ 274, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ie_emlrtRTEI{ 275, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo je_emlrtRTEI{ 276, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ke_emlrtRTEI{ 778, // lineNo
  27,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo le_emlrtRTEI{ 277, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo me_emlrtRTEI{ 778, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ne_emlrtRTEI{ 15,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo oe_emlrtRTEI{ 295, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo pe_emlrtRTEI{ 355, // lineNo
  17,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo qe_emlrtRTEI{ 297, // lineNo
  46,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo re_emlrtRTEI{ 27,  // lineNo
  1,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo se_emlrtRTEI{ 88,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo te_emlrtRTEI{ 298, // lineNo
  39,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ue_emlrtRTEI{ 22,  // lineNo
  23,                                  // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo ve_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "gpu_conv2_kernel",                  // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+images/gpu_conv2_kernel.p"// pName
};

static emlrtRTEInfo we_emlrtRTEI{ 14,  // lineNo
  15,                                  // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo xe_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "_coder_ec_wtcc_api",                // fName
  ""                                   // pName
};

static emlrtRTEInfo ye_emlrtRTEI{ 297, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo af_emlrtRTEI{ 297, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo bf_emlrtRTEI{ 295, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo cf_emlrtRTEI{ 295, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static char_T (*global_gpu_cv)[128];
static real_T (*global_gpu_table100)[100];
static boolean_T gpuConstsCopied_ec_wtcc;

// Function Declarations
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23]);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real32_T *ret);
static uint16_T (*b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2];
static uint16_T (*b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
  parentId))[2];
static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location);
static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString);
static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location);
static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5);
static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5);
static void binary_expand_op_10(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2]);
static void binary_expand_op_4(emxArray_real32_T *in1, const emxArray_real32_T
  *in2, const emxArray_real32_T *in3, const emxArray_real32_T *in4);
static void binary_expand_op_5(emxArray_creal32_T *in1, const emxArray_real_T
  *in2, const emxArray_creal32_T *in3);
static void binary_expand_op_6(emxArray_creal32_T *in1, const emxArray_creal32_T
  *in2, const emxArray_creal32_T *in3);
static void binary_expand_op_9(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3);
static real32_T c_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier);
static real32_T c_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId);
static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line);
namespace coder
{
  namespace internal
  {
    static void warning();
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride);
static uint64_T computeNumIters(int64_T ub);
static uint64_T computeNumIters(int32_T ub, int32_T b_ub);
static uint64_T computeNumIters(int32_T ub);
static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line);
static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line);
static real32_T (*d_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
  parentId))[2];
static real32_T (*d_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2];
static int32_T div_s32(int32_T numerator, int32_T denominator);
static
#ifdef __CUDACC__

__device__
#endif

int32_T div_s32_device(int32_T numerator, int32_T denominator);
static real_T e_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId);
static __global__ void ec_wtcc_kernel1(creal_T *dc, creal_T *dc6);
static __global__ void ec_wtcc_kernel10(emxArray_real_T fb_Omega);
static __global__ void ec_wtcc_kernel100(const real_T T, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel101(const emxArray_real_T b, const int32_T
  c, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel1019(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel102(const emxArray_real_T b0, const int32_T
  b_b0, emxArray_real_T b);
static __global__ void ec_wtcc_kernel1020(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1021(const emxArray_real32_T w, const
  int32_T nrefine, const int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1022(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1023(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T nx, const int32_T b,
  emxArray_real32_T b_y1, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel1024(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1025(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1026(const real32_T cv_re, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1027(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1028(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv42);
static __global__ void ec_wtcc_kernel1029(const emxArray_real32_T h, const
  emxArray_int32_T iv42, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel103(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1030(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T toler,
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1031(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1032(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1033(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1034(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv41);
static __global__ void ec_wtcc_kernel1035(const emxArray_real32_T yCol, const
  emxArray_int32_T iv41, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1036(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel1037(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1038(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel1039(const emxArray_real32_T h, const
  emxArray_real32_T yCol, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel104(const emxArray_real_T a, const int32_T
  ix, const int32_T nrefine, const int32_T nx, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1040(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel1041(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel1042(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1043(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1044(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1045(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel1046(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel1047(const emxArray_real32_T y, const
  int32_T xt_size, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel1048(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1049(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel105(const emxArray_real_T a, const int32_T
  ix, const int32_T nrefine, const int32_T lidx, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1050(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1051(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1052(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1053(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1054(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1055(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv70);
static __global__ void ec_wtcc_kernel1056(const emxArray_real32_T h, const
  emxArray_int32_T iv70, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1057(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T toler,
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1058(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1059(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel106(const int32_T b, emxArray_real_T dv23);
static __global__ void ec_wtcc_kernel1060(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1061(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1062(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv72);
static __global__ void ec_wtcc_kernel1063(const emxArray_real32_T yCol, const
  emxArray_int32_T iv72, const int32_T xt_size, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1064(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel1065(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1066(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1067(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel1068(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel1069(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel107(const emxArray_real_T dv23, const
  emxArray_real_T h, const int32_T b_h, emxArray_real_T h1);
static __global__ void ec_wtcc_kernel1070(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel1071(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1072(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel1073(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel1074(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1075(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1076(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1077(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1078(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv47);
static __global__ void ec_wtcc_kernel1079(const emxArray_real32_T a, const
  emxArray_int32_T iv47, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel108(const real_T halfh, const
  emxArray_real_T h1, const real_T toler, const int32_T b_h1, emxArray_real32_T
  opts_filter);
static __global__ void ec_wtcc_kernel1080(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1081(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1082(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1083(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1084(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv52);
static __global__ void ec_wtcc_kernel1085(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv52, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1086(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1087(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1088(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1089(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel109(const int32_T halfh, emxArray_real32_T
  h);
static __global__ void ec_wtcc_kernel1090(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv55);
static __global__ void ec_wtcc_kernel1091(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv71);
static __global__ void ec_wtcc_kernel1092(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv71, const emxArray_int32_T iv55,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1093(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel11(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T fb_Omega);
static __global__ void ec_wtcc_kernel110(const emxArray_uint32_T y, const real_T
  halfh, const int32_T b_y, emxArray_int32_T iv18);
static __global__ void ec_wtcc_kernel111(const emxArray_real32_T opts_filter,
  const emxArray_int32_T iv18, const int32_T b_iv18, emxArray_real32_T h);
static __global__ void ec_wtcc_kernel112(const emxArray_creal32_T crossCFS,
  const int32_T b, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel1122(const int32_T b, emxArray_real32_T
  yCol);
static __global__ void ec_wtcc_kernel1123(const emxArray_real32_T xCol, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel1124(const emxArray_real32_T yCol, const
  int32_T csz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel1125(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1126(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel1127(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel1128(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1129(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel113(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel1130(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1131(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel1132(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel1133(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel1134(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1135(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel1136(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1137(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel1138(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1139(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel114(const emxArray_real_T m, const int32_T
  b_m, emxArray_real_T k);
static __global__ void ec_wtcc_kernel1140(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1141(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1142(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv58);
static __global__ void ec_wtcc_kernel1143(const emxArray_real32_T a, const
  emxArray_int32_T iv58, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1144(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1145(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1146(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1147(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1148(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1149(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv61);
static __global__ void ec_wtcc_kernel115(const int32_T k, emxArray_real_T G);
static __global__ void ec_wtcc_kernel1150(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv61, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1151(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel1152(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1153(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1154(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel1155(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1156(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv62);
static __global__ void ec_wtcc_kernel1157(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv79);
static __global__ void ec_wtcc_kernel1158(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv79, const emxArray_int32_T iv62,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1159(const emxArray_real32_T expanded,
  const emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel116(const int32_T k, emxArray_real_T b);
static __global__ void ec_wtcc_kernel117(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T dv29);
static __global__ void ec_wtcc_kernel118(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T dv31, emxArray_real_T dv29);
static __global__ void ec_wtcc_kernel1188(const int32_T b, emxArray_uint32_T y);
static __global__ void ec_wtcc_kernel1189(const creal_T *dc6, const real_T
  table100[100], const creal_T dc7, const creal_T *dc, const int32_T nsubs,
  const int32_T lidx, const int32_T nrefine, const int32_T i, const int64_T b,
  emxArray_real_T dv23, real_T q1_dim0, real_T q1_dim1, real_T q1_dim2, real_T
  q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6, real_T q1_dim7,
  real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3, real_T p1_dim4,
  real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0, real_T q2_dim1,
  real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5, real_T q2_dim6,
  real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2, real_T p2_dim3,
  real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7, real_T q4_dim0,
  real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4, real_T q4_dim5,
  real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1, real_T p4_dim2,
  real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6, real_T p4_dim7,
  real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3, real_T c_dim4,
  real_T c_dim5, real_T c_dim6);
static __global__ void ec_wtcc_kernel119(const int32_T b, emxArray_real_T dv31);
static __global__ void ec_wtcc_kernel1190(const emxArray_real_T a, const int32_T
  b_a, emxArray_real_T x);
static __global__ void ec_wtcc_kernel1191(const emxArray_real_T x, const int32_T
  b, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1192(const emxArray_real_T a, const int32_T
  b, emxArray_real_T h, int32_T x_dim0);
static __global__ void ec_wtcc_kernel1193(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1194(const int32_T omega_tmp2,
  emxArray_real_T a);
static __global__ void ec_wtcc_kernel1195(const int32_T G, emxArray_int32_T jpvt);
static __global__ void ec_wtcc_kernel1196(const int32_T b, const int32_T ix,
  emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel1197(const int32_T b, emxArray_real_T tau);
static __global__ void ec_wtcc_kernel1198(const int32_T i, const int64_T b,
  emxArray_real_T tau);
static __global__ void ec_wtcc_kernel1199(const int32_T ix, emxArray_int32_T
  jpvt);
static __global__ void ec_wtcc_kernel12(const int32_T nrefine, const int32_T ix,
  const emxArray_real_T omega_tmp2, const int32_T nx, emxArray_real_T fb_Omega,
  int32_T omega_tmp2_dim1);
static __global__ void ec_wtcc_kernel120(const emxArray_real_T k, const
  emxArray_real_T dv31, const emxArray_real_T dv29, const real_T a, const
  int32_T b, emxArray_real_T b_b);
static __global__ void ec_wtcc_kernel1200(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1201(const int32_T omega_tmp2,
  emxArray_real_T b);
static __global__ void ec_wtcc_kernel1202(const emxArray_real_T b, const
  emxArray_int32_T jpvt, const int32_T nsubs, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1203(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1204(emxArray_real_T a);
static __global__ void ec_wtcc_kernel1205(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel1206(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel1207(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv16);
static __global__ void ec_wtcc_kernel1208(const emxArray_creal32_T a, const
  emxArray_int32_T iv16, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel1209(const emxArray_creal32_T expanded,
  const real_T a, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel121(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1210(const int32_T smooth,
  emxArray_creal32_T crossCFS);
static __global__ void ec_wtcc_kernel1211(const int32_T smooth,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel1212(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv15);
static __global__ void ec_wtcc_kernel1213(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv17);
static __global__ void ec_wtcc_kernel1214(const emxArray_creal32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_creal32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1215(const emxArray_creal32_T smooth, const
  int32_T xt_size_dim0, const emxArray_int32_T iv17, const emxArray_int32_T iv15,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1216(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1217(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T crossCFS,
  int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel1218(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1219(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T smooth);
static __global__ void ec_wtcc_kernel122(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T y, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel1220(const int32_T crossCFS,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1221(const emxArray_creal32_T crossCFS,
  const int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T
  cfsDFT_dim0, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel1222(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1223(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1224(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1225(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv12);
static __global__ void ec_wtcc_kernel1226(const emxArray_real32_T a, const
  emxArray_int32_T iv12, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1227(const real_T a, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1228(const int32_T smooth,
  emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel1229(const real_T a, const
  emxArray_real32_T smooth, emxArray_real32_T b_smooth);
static __global__ void ec_wtcc_kernel123(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1230(const emxArray_real32_T smooth,
  emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel1231(const int32_T smooth,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1232(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv11);
static __global__ void ec_wtcc_kernel1233(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv13);
static __global__ void ec_wtcc_kernel1234(const emxArray_real32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_real32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1235(const emxArray_real32_T smooth, const
  int32_T xt_size_dim0, const emxArray_int32_T iv13, const emxArray_int32_T iv11,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1236(const real_T a, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T halfh,
  const int32_T b, const int32_T c, emxArray_real32_T cfs2, int32_T
  expanded_dim0, int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel1237(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1238(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel1239(const int32_T cfs2, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel124(const emxArray_real_T y, const real_T a,
  const emxArray_real_T b_y, const real_T b_a, const int32_T b, emxArray_real_T
  b_b);
static __global__ void ec_wtcc_kernel1240(const emxArray_real32_T cfs2, const
  int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0,
  int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel1241(const emxArray_real32_T cfs2, const
  int32_T b_cfs2, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1242(const int32_T nrefine, const int32_T
  lidx, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1243(const int32_T nrefine, const int32_T
  cfsDFT, const int32_T lidx, emxArray_creal32_T b_cfsDFT, int32_T cfsDFT_dim0);
static __global__ void ec_wtcc_kernel1244(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1245(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel1246(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv9);
static __global__ void ec_wtcc_kernel1247(const emxArray_real32_T a, const
  emxArray_int32_T iv9, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1248(const real_T a, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel1249(const int32_T smooth,
  emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel125(const real_T fa, const real_T r, const
  int32_T nsubs, const int32_T ix, const int32_T b, emxArray_real_T sinc4A,
  emxArray_real_T sinc3A, emxArray_real_T sinc2A, emxArray_real_T sinc1A);
static __global__ void ec_wtcc_kernel1250(const real_T a, const
  emxArray_real32_T smooth, emxArray_real32_T b_smooth);
static __global__ void ec_wtcc_kernel1251(const emxArray_real32_T smooth,
  emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel1252(const int32_T smooth,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel1253(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv8);
static __global__ void ec_wtcc_kernel1254(const emxArray_int32_T y, const
  int32_T b_y, emxArray_int32_T iv10);
static __global__ void ec_wtcc_kernel1255(const emxArray_real32_T smooth, const
  int32_T b_smooth, const int32_T b, emxArray_real32_T c_smooth, int32_T
  smooth_dim0, int32_T b_smooth_dim0);
static __global__ void ec_wtcc_kernel1256(const emxArray_real32_T smooth, const
  int32_T xt_size_dim0, const emxArray_int32_T iv10, const emxArray_int32_T iv8,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel1257(const real_T a, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const real_T halfh,
  const int32_T b, const int32_T c, emxArray_real32_T cfs1, int32_T
  expanded_dim0, int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel1258(creal32_T *cfsposdft, int32_T x_dim1);
static __global__ void ec_wtcc_kernel1259(const creal32_T *cfsposdft, const
  emxArray_creal32_T x, const int32_T b_x, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel126(const emxArray_real_T sinc4A, const
  emxArray_real_T sinc2A, const real_T fa, const emxArray_real_T sinc3A, const
  emxArray_real_T sinc1A, const real_T r, const int32_T nsubs, const int32_T b,
  const int32_T c, emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel1260(const int32_T cfs1, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel1261(const emxArray_real32_T cfs1, const
  int32_T b, const int32_T c, emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0,
  int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel1262(const emxArray_real32_T cfs1, const
  int32_T b_cfs1, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1263(const int32_T nrefine, const int32_T
  lidx, emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel1264(const int32_T nrefine, const int32_T
  cfsDFT, const int32_T lidx, emxArray_creal32_T b_cfsDFT, int32_T cfsDFT_dim0);
static __global__ void ec_wtcc_kernel1265(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1266(creal32_T *cfsposdft, int32_T
  cfsposdft_dim1);
static __global__ void ec_wtcc_kernel1267(const creal32_T *cfsposdft, const
  emxArray_creal32_T b_cfsposdft, const int32_T c_cfsposdft, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel1268(const int32_T b, emxArray_creal32_T
  xposdft, uint32_T xSize_dim1);
static __global__ void ec_wtcc_kernel1269(creal32_T *cfsposdft, int32_T
  cfsposdft_dim1);
static __global__ void ec_wtcc_kernel127(const real_T T, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel1270(const creal32_T *cfsposdft, const
  emxArray_creal32_T b_cfsposdft, const int32_T c_cfsposdft, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel1271(const int32_T b, emxArray_creal32_T
  xposdft, uint32_T xSize_dim1);
static __global__ void ec_wtcc_kernel1272(const emxArray_real_T somega, const
  int32_T b_somega, emxArray_real_T w);
static __global__ void ec_wtcc_kernel1273(const emxArray_real_T w, const int32_T
  b_w, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel1274(const int32_T b, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel1275(const emxArray_real_T w, const int32_T
  b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1276(const emxArray_real_T y, const
  emxArray_real_T expnt, const int32_T b_expnt, emxArray_real_T daughter);
static __global__ void ec_wtcc_kernel1277(const int32_T nrefine, emxArray_real_T
  daughter);
static __global__ void ec_wtcc_kernel1278(const emxArray_real_T fb_Omega, const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T somega, int32_T somega_dim0);
static __global__ void ec_wtcc_kernel1279(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel128(const emxArray_real_T b, const int32_T
  c, emxArray_real_T b0);
static __global__ void ec_wtcc_kernel1280(const char_T cv[128], char_T wav[4],
  char_T wname[4], char_T a_dim0, char_T a_dim1, char_T a_dim2, char_T a_dim3);
static __global__ void ec_wtcc_kernel1281(real_T interval[650]);
static __global__ void ec_wtcc_kernel1282(real_T interval[650]);
static __global__ void ec_wtcc_kernel1283(const int32_T nx, real_T interval[650]);
static __global__ void ec_wtcc_kernel1284(real_T interval[650]);
static __global__ void ec_wtcc_kernel1285(real_T interval[650]);
static __global__ void ec_wtcc_kernel1286(const int32_T nx, real_T interval[650]);
static __global__ void ec_wtcc_kernel1287(emxArray_real_T y);
static __global__ void ec_wtcc_kernel1288(const emxArray_real_T y, const real_T
  fa, const int32_T b, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel1289(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_wtcc_kernel129(const emxArray_real_T b0, const int32_T
  b_b0, emxArray_real_T b);
static __global__ void ec_wtcc_kernel1290(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel1291(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1292(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1293(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1294(const real_T x_data[9735], const
  int32_T b, real_T dv15_data[9735]);
static __global__ void ec_wtcc_kernel1295(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1296(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1297(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv15_data[9735], const int32_T dv15_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1298(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1299(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel13(emxArray_real_T y);
static __global__ void ec_wtcc_kernel130(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel1300(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1301(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1302(const real_T x_data[9735], const
  int32_T b, real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1303(const real_T x_data[9735], const
  real_T y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_wtcc_kernel1304(const real_T a_data[9735], const
  int32_T b, real_T dv9_data[9735]);
static __global__ void ec_wtcc_kernel1305(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1306(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1307(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv9_data[9735], const int32_T dv9_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1308(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_wtcc_kernel1309(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel131(const emxArray_real_T a, const int32_T
  lidx, const int32_T nrefine, const int32_T nx, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1310(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1311(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1312(const real_T x_data[9735], const
  int32_T b, real_T dv8_data[9735]);
static __global__ void ec_wtcc_kernel1313(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1314(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1315(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv8_data[9735], const int32_T dv8_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1316(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_wtcc_kernel1317(const real_T x_data[9735], const
  int32_T b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1318(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel1319(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel132(const emxArray_real_T a, const int32_T
  lidx, const int32_T nrefine, const int32_T pathlen, emxArray_real_T h);
static __global__ void ec_wtcc_kernel1320(const real_T x_data[9735], const
  int32_T b, real_T b_x_data[9735]);
static __global__ void ec_wtcc_kernel1321(const real_T x_data[9735], const
  real_T y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_wtcc_kernel1322(const real_T a_data[9735], const
  int32_T b, real_T dv2_data[9735]);
static __global__ void ec_wtcc_kernel1323(const real_T x_data[9735], const
  int32_T b, real_T y_data[9735]);
static __global__ void ec_wtcc_kernel1324(const real_T y_data[9735], const
  int32_T b, real_T x_data[9735]);
static __global__ void ec_wtcc_kernel1325(const real_T xt_data[9735], const
  real_T x_data[9735], const real_T dv2_data[9735], const int32_T dv2_size,
  real_T fx_data[9735]);
static __global__ void ec_wtcc_kernel133(const int32_T b, emxArray_real_T dv27);
static __global__ void ec_wtcc_kernel134(const emxArray_real_T dv27, const
  emxArray_real_T h, const int32_T b_h, emxArray_real_T h1);
static __global__ void ec_wtcc_kernel135(const real_T halfh, const
  emxArray_real_T h1, const real_T toler, const int32_T b_h1, emxArray_real32_T
  opts_filter);
static __global__ void ec_wtcc_kernel136(const int32_T halfh, emxArray_real32_T
  h);
static __global__ void ec_wtcc_kernel137(const emxArray_uint32_T y, const real_T
  halfh, const int32_T b_y, emxArray_int32_T iv92);
static __global__ void ec_wtcc_kernel138(const emxArray_real32_T opts_filter,
  const emxArray_int32_T iv92, const int32_T b_iv92, emxArray_real32_T h);
static __global__ void ec_wtcc_kernel139(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel14(const emxArray_real_T y, const real_T s,
  const int32_T b, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel140(const emxArray_creal32_T b_y1, const
  int32_T b, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel141(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel142(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel143(const real_T toler, int32_T csz[2]);
static __global__ void ec_wtcc_kernel144(const emxArray_real32_T h, const
  emxArray_creal32_T yCol, real32_T *cv_re, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel145(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel146(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel147(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel148(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel149(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel15(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_wtcc_kernel150(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel151(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel152(const emxArray_creal32_T y, const
  int32_T xt_size, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel153(emxArray_real_T y);
static __global__ void ec_wtcc_kernel154(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel155(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel156(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel157(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel158(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel159(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel16(const emxArray_real_T somega, const
  int32_T b_somega, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel160(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel161(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel162(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv161);
static __global__ void ec_wtcc_kernel163(const emxArray_real32_T h, const
  emxArray_int32_T iv161, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel164(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel165(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel166(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel167(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel168(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel169(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel17(const int32_T b, emxArray_real_T expnt);
static __global__ void ec_wtcc_kernel170(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel171(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel172(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv163);
static __global__ void ec_wtcc_kernel173(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv163, const int32_T xt_size, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel174(const emxArray_creal32_T expanded,
  const int32_T nx, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel175(const real32_T cv_im, const real32_T
  cv_re, const int32_T nx, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel176(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel177(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel178(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel179(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel18(const emxArray_real_T somega, const
  emxArray_real_T expnt, const int32_T b_expnt, emxArray_real_T daughter);
static __global__ void ec_wtcc_kernel180(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel181(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel182(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel183(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel184(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel185(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel186(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel187(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel188(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel189(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel19(const emxArray_real_T daughter, const
  int32_T b_daughter, emxArray_real32_T psihat);
static __global__ void ec_wtcc_kernel190(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel191(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv141);
static __global__ void ec_wtcc_kernel192(const emxArray_creal32_T a, const
  emxArray_int32_T iv141, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel193(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel194(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel195(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel196(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel197(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel198(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel199(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel2(const char_T cv[128], char_T wname[4],
  char_T wav[4], char_T a_dim0, char_T a_dim1, char_T a_dim2, char_T a_dim3);
static __global__ void ec_wtcc_kernel20(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b_x, emxArray_real32_T xv, int32_T x_dim0);
static __global__ void ec_wtcc_kernel200(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv143);
static __global__ void ec_wtcc_kernel201(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv143, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel202(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel203(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel204(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel205(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel206(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel207(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel208(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel209(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel21(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T b_x, int32_T x_dim0);
static __global__ void ec_wtcc_kernel210(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv148);
static __global__ void ec_wtcc_kernel211(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv166);
static __global__ void ec_wtcc_kernel212(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv166, const emxArray_int32_T
  iv148, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel213(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel214(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel22(const int32_T fb_SignalPad, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel23(const emxArray_real32_T x, const int32_T
  b, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel24(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv, int32_T x_dim1,
  int32_T x_dim0);
static __global__ void ec_wtcc_kernel245(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel246(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel247(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel248(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel249(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel25(const int32_T lidx, const int32_T ix,
  const int32_T nsubs, const emxArray_real32_T x, const int32_T nx,
  emxArray_real32_T xv, int32_T x_dim0, int32_T x_dim1);
static __global__ void ec_wtcc_kernel250(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel251(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel252(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel253(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel254(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel255(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel256(emxArray_real_T y);
static __global__ void ec_wtcc_kernel257(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel258(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel259(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel26(const emxArray_real32_T xv, const
  int32_T b_xv, emxArray_creal32_T xposdft);
static __global__ void ec_wtcc_kernel260(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel261(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel262(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel263(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel264(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel265(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv147);
static __global__ void ec_wtcc_kernel266(const emxArray_creal32_T a, const
  emxArray_int32_T iv147, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel267(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel268(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel269(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel27(const emxArray_creal32_T xposdft, const
  emxArray_real32_T psihat, const int32_T ix, const int32_T cfsposdft, const
  int32_T lidx, emxArray_creal32_T b_cfsposdft, int32_T psihat_dim0, int32_T
  cfsposdft_dim0);
static __global__ void ec_wtcc_kernel270(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel271(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel272(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel273(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel274(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv151);
static __global__ void ec_wtcc_kernel275(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv151, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel276(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel277(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel278(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel279(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel28(const int32_T xSize, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel280(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel281(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel282(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel283(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel284(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv154);
static __global__ void ec_wtcc_kernel285(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv171);
static __global__ void ec_wtcc_kernel286(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv171, const emxArray_int32_T
  iv154, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel287(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel288(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel29(const emxArray_real_T daughter, const
  int32_T b_daughter, emxArray_real32_T psihat);
static __global__ void ec_wtcc_kernel3(real_T interval[650]);
static __global__ void ec_wtcc_kernel30(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b_x, emxArray_real32_T xv, int32_T x_dim0);
static __global__ void ec_wtcc_kernel31(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T b_x, int32_T x_dim0);
static __global__ void ec_wtcc_kernel319(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel32(const int32_T fb_SignalPad, const
  int32_T b, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel320(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel321(const real_T toler, int32_T csz[2]);
static __global__ void ec_wtcc_kernel322(const emxArray_real32_T h, const
  emxArray_creal32_T yCol, real32_T *cv_re, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel323(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel324(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel325(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel326(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel327(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel328(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel329(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel33(const emxArray_real32_T x, const int32_T
  b, emxArray_real32_T xv);
static __global__ void ec_wtcc_kernel330(const emxArray_creal32_T y, const
  int32_T xt_size, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel331(emxArray_real_T y);
static __global__ void ec_wtcc_kernel332(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T
  opts_x);
static __global__ void ec_wtcc_kernel333(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel334(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel335(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel336(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel337(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel338(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel339(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel34(const int32_T nrefine, const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv, int32_T x_dim1,
  int32_T x_dim0);
static __global__ void ec_wtcc_kernel340(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv160);
static __global__ void ec_wtcc_kernel341(const emxArray_real32_T h, const
  emxArray_int32_T iv160, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel342(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel343(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel344(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel345(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel346(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel347(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel348(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel349(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel35(const int32_T lidx, const int32_T
  pathlen, const int32_T ix, const emxArray_real32_T x, const int32_T nx,
  emxArray_real32_T xv, int32_T x_dim0, int32_T x_dim1);
static __global__ void ec_wtcc_kernel350(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv162);
static __global__ void ec_wtcc_kernel351(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv162, const int32_T xt_size, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel352(const emxArray_creal32_T expanded,
  const int32_T nx, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel353(const real32_T cv_im, const real32_T
  cv_re, const int32_T nx, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel354(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel355(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel356(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel357(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel358(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel359(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel36(const emxArray_real32_T xv, const
  int32_T b_xv, emxArray_creal32_T xposdft);
static __global__ void ec_wtcc_kernel360(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel361(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel362(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel363(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel364(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel365(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel366(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel367(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel368(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel369(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv140);
static __global__ void ec_wtcc_kernel37(const emxArray_creal32_T xposdft, const
  emxArray_real32_T psihat, const int32_T ix, const int32_T cfsposdft, const
  int32_T lidx, emxArray_creal32_T b_cfsposdft, int32_T psihat_dim0, int32_T
  cfsposdft_dim0);
static __global__ void ec_wtcc_kernel370(const emxArray_creal32_T a, const
  emxArray_int32_T iv140, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel371(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel372(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel373(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel374(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel375(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel376(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel377(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel378(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv142);
static __global__ void ec_wtcc_kernel379(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv142, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel38(const int32_T xSize, emxArray_creal32_T
  cfspos);
static __global__ void ec_wtcc_kernel380(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel381(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel382(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel383(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel384(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel385(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel386(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel387(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel388(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv146);
static __global__ void ec_wtcc_kernel389(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv165);
static __global__ void ec_wtcc_kernel39(const emxArray_creal32_T cfspos, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel390(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv165, const emxArray_int32_T
  iv146, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel391(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel392(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel4(real_T interval[650]);
static __global__ void ec_wtcc_kernel40(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T cfs1);
static __global__ void ec_wtcc_kernel41(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel42(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel423(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel424(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel425(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel426(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel427(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel428(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel429(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel43(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel430(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel431(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel432(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel433(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel434(emxArray_real_T y);
static __global__ void ec_wtcc_kernel435(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel436(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel437(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel438(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel439(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel44(const int32_T pathlen, const int32_T
  nrefine, const emxArray_real_T omega_tmp2, const int32_T nx, emxArray_real_T
  omega, int32_T omega_tmp2_dim1);
static __global__ void ec_wtcc_kernel440(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel441(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel442(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel443(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv145);
static __global__ void ec_wtcc_kernel444(const emxArray_creal32_T a, const
  emxArray_int32_T iv145, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel445(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel446(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel447(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel448(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel449(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel45(const int32_T cfs1, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel450(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel451(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel452(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv150);
static __global__ void ec_wtcc_kernel453(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv150, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel454(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel455(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel456(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel457(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel458(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel459(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel46(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel460(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel461(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel462(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv153);
static __global__ void ec_wtcc_kernel463(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv170);
static __global__ void ec_wtcc_kernel464(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv170, const emxArray_int32_T
  iv153, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel465(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel466(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel47(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel48(const int32_T xSize, emxArray_creal32_T
  y);
static __global__ void ec_wtcc_kernel49(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_real32_T smooth);
static __global__ void ec_wtcc_kernel497(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel498(const emxArray_creal32_T opts_x, const
  int32_T nx, const int32_T i267, const int32_T b, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel499(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel5(const int32_T nx, real_T interval[650]);
static __global__ void ec_wtcc_kernel50(const emxArray_real32_T smooth, const
  int32_T b, emxArray_real32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel500(const emxArray_creal32_T w, const
  int32_T lidx, const int32_T b, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel501(emxArray_real_T y);
static __global__ void ec_wtcc_kernel502(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T nx, const int32_T b,
  emxArray_creal32_T b_y1, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel503(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel504(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel505(const emxArray_creal32_T yCol,
  creal32_T *cfsposdft);
static __global__ void ec_wtcc_kernel506(const creal32_T *cfsposdft, const
  emxArray_real32_T h, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel507(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel508(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel509(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv139);
static __global__ void ec_wtcc_kernel51(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel510(const emxArray_real32_T h, const
  emxArray_int32_T iv139, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel511(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const real_T toler,
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel512(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel513(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel514(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel515(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv138);
static __global__ void ec_wtcc_kernel516(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv138, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel517(const emxArray_creal32_T expanded,
  const int32_T nx, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel518(const real32_T cv_im, const real32_T
  cv_re, const int32_T nx, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel519(const emxArray_creal32_T b_y1, const
  int32_T crossCFS, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel52(const real_T a, const emxArray_real32_T
  b_a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel520(const emxArray_creal32_T b_y1, const
  int32_T c_y1, const int32_T d_y1, emxArray_creal32_T opts_x, int32_T
  opts_x_dim0, int32_T y1_dim0);
static __global__ void ec_wtcc_kernel521(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel522(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel523(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel524(const emxArray_creal32_T yCol, const
  emxArray_real32_T h, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel525(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel526(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel527(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel528(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel529(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel53(const emxArray_real32_T c, const int32_T
  b_c, emxArray_real32_T cfs1, int32_T cfs1_dim0);
static __global__ void ec_wtcc_kernel530(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel531(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel532(const emxArray_creal32_T y, const
  int32_T xt_size, emxArray_creal32_T b_y);
static __global__ void ec_wtcc_kernel533(emxArray_real_T y);
static __global__ void ec_wtcc_kernel534(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_creal32_T b_y1);
static __global__ void ec_wtcc_kernel535(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel536(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel537(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel538(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel539(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel54(const emxArray_creal32_T cfspos, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel540(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel541(const int32_T b, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel542(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv167);
static __global__ void ec_wtcc_kernel543(const emxArray_real32_T h, const
  emxArray_int32_T iv167, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel544(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const real_T toler,
  const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel545(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel546(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel547(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel548(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel549(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel55(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T cfs2);
static __global__ void ec_wtcc_kernel550(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel551(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel552(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv169);
static __global__ void ec_wtcc_kernel553(const emxArray_creal32_T yCol, const
  emxArray_int32_T iv169, const int32_T xt_size, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel554(const emxArray_creal32_T expanded,
  const int32_T nx, const emxArray_int32_T rows, const int32_T b_rows,
  emxArray_creal32_T newIm);
static __global__ void ec_wtcc_kernel555(const real32_T cv_im, const real32_T
  cv_re, const int32_T nx, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel556(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel557(const emxArray_creal32_T opts_x, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel558(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel559(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel56(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel560(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel561(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel562(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel563(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel564(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel565(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel566(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel567(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel568(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel569(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel57(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel570(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel571(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv144);
static __global__ void ec_wtcc_kernel572(const emxArray_creal32_T a, const
  emxArray_int32_T iv144, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel573(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel574(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel575(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel576(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel577(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel578(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel579(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel58(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel580(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv149);
static __global__ void ec_wtcc_kernel581(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv149, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel582(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel583(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel584(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel585(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel586(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel587(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel588(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel589(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel59(const int32_T nrefine, const int32_T
  lidx, const emxArray_real_T omega_tmp2, const int32_T nx, emxArray_real_T
  omega, int32_T omega_tmp2_dim1);
static __global__ void ec_wtcc_kernel590(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv152);
static __global__ void ec_wtcc_kernel591(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv168);
static __global__ void ec_wtcc_kernel592(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv168, const emxArray_int32_T
  iv152, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel593(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel594(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel6(real_T interval[650]);
static __global__ void ec_wtcc_kernel60(const int32_T cfs2, emxArray_creal32_T
  cfsDFT);
static __global__ void ec_wtcc_kernel61(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel62(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel625(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T xCol);
static __global__ void ec_wtcc_kernel626(const int32_T b, emxArray_creal32_T
  yCol);
static __global__ void ec_wtcc_kernel627(const emxArray_creal32_T xCol, const
  int32_T nrefine, const int32_T omega_tmp2, emxArray_creal32_T yCol);
static __global__ void ec_wtcc_kernel628(emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel629(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel63(const int32_T xSize, emxArray_creal32_T
  y);
static __global__ void ec_wtcc_kernel630(const int32_T lidx, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel631(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel632(const emxArray_creal32_T w, const
  int32_T xt_size, emxArray_creal32_T y);
static __global__ void ec_wtcc_kernel633(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_creal32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel634(const emxArray_creal32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_creal32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel635(const emxArray_creal32_T y, const
  int32_T omega_tmp2, emxArray_creal32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel636(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_creal32_T c_y);
static __global__ void ec_wtcc_kernel637(emxArray_real_T y);
static __global__ void ec_wtcc_kernel638(const emxArray_creal32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel639(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel64(const emxArray_creal32_T y, const
  int32_T b_y, emxArray_real32_T smooth);
static __global__ void ec_wtcc_kernel640(const emxArray_creal32_T yCol, const
  int32_T b, emxArray_creal32_T a);
static __global__ void ec_wtcc_kernel641(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel642(const emxArray_creal32_T a, const
  real32_T cv_re, real32_T *f, real32_T *f1);
static __global__ void ec_wtcc_kernel643(const real32_T *f1, const real32_T *f,
  emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel644(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel645(const int32_T a, emxArray_creal32_T
  expanded);
static __global__ void ec_wtcc_kernel646(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv155);
static __global__ void ec_wtcc_kernel647(const emxArray_creal32_T a, const
  emxArray_int32_T iv155, const int32_T omega_tmp2, emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel648(const emxArray_creal32_T expanded,
  const real32_T cv_re, const int32_T b, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel649(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel65(const emxArray_real32_T smooth, const
  int32_T b, emxArray_real32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel650(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel651(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel652(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel653(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel654(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel655(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv158);
static __global__ void ec_wtcc_kernel656(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv158, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel657(const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const emxArray_creal32_T
  yCol, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_creal32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel658(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel659(const int32_T b, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel66(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel660(const emxArray_real32_T h, real32_T *f1);
static __global__ void ec_wtcc_kernel661(const real32_T *f1, creal32_T a_data[1]);
static __global__ void ec_wtcc_kernel662(const emxArray_creal32_T yCol, const
  creal32_T a_data[1], emxArray_creal32_T b_yCol);
static __global__ void ec_wtcc_kernel663(const emxArray_creal32_T yCol, const
  int32_T xt_size, emxArray_creal32_T w);
static __global__ void ec_wtcc_kernel664(const int32_T x_size_idx_1,
  emxArray_creal32_T expanded);
static __global__ void ec_wtcc_kernel665(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv159);
static __global__ void ec_wtcc_kernel666(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv176);
static __global__ void ec_wtcc_kernel667(const emxArray_creal32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv176, const emxArray_int32_T
  iv159, const int32_T xt_size, const int32_T b_xt_size, emxArray_creal32_T
  expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel668(const int32_T nrefine, const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel669(const real32_T cv_im, const real32_T
  cv_re, const int32_T nrefine, const int32_T nx, emxArray_creal32_T w, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel67(const real_T a, const emxArray_real32_T
  b_a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel68(const emxArray_real32_T c, const int32_T
  b_c, emxArray_real32_T cfs2, int32_T cfs2_dim0);
static __global__ void ec_wtcc_kernel69(const emxArray_creal32_T cfspos, const
  emxArray_creal32_T b_cfspos, const int32_T c_cfspos, emxArray_creal32_T
  crossCFS);
static __global__ void ec_wtcc_kernel7(real_T interval[650]);
static __global__ void ec_wtcc_kernel70(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel700(const emxArray_creal32_T opts_x, const
  int32_T b_opts_x, emxArray_creal32_T xCol);
static __global__ void ec_wtcc_kernel701(const int32_T b, emxArray_uint32_T y);
static __global__ void ec_wtcc_kernel702(const creal_T *dc6, const real_T
  table100[100], const creal_T dc7, const creal_T *dc, const int32_T nsubs,
  const int32_T lidx, const int32_T nrefine, const int32_T i, const int64_T b,
  emxArray_real_T dv27, real_T q1_dim0, real_T q1_dim1, real_T q1_dim2, real_T
  q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6, real_T q1_dim7,
  real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3, real_T p1_dim4,
  real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0, real_T q2_dim1,
  real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5, real_T q2_dim6,
  real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2, real_T p2_dim3,
  real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7, real_T q4_dim0,
  real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4, real_T q4_dim5,
  real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1, real_T p4_dim2,
  real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6, real_T p4_dim7,
  real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3, real_T c_dim4,
  real_T c_dim5, real_T c_dim6);
static __global__ void ec_wtcc_kernel703(const emxArray_real_T a, const int32_T
  b_a, emxArray_real_T x);
static __global__ void ec_wtcc_kernel704(const emxArray_real_T x, const int32_T
  b, emxArray_real_T h);
static __global__ void ec_wtcc_kernel705(const emxArray_real_T a, const int32_T
  b, emxArray_real_T h, int32_T x_dim0);
static __global__ void ec_wtcc_kernel706(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel707(const int32_T omega_tmp2,
  emxArray_real_T a);
static __global__ void ec_wtcc_kernel708(const int32_T G, emxArray_int32_T jpvt);
static __global__ void ec_wtcc_kernel709(const int32_T b, const int32_T ix,
  emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel71(emxArray_real_T omega);
static __global__ void ec_wtcc_kernel710(const int32_T b, emxArray_real_T tau);
static __global__ void ec_wtcc_kernel711(const int32_T i, const int64_T b,
  emxArray_real_T tau);
static __global__ void ec_wtcc_kernel712(const int32_T ix, emxArray_int32_T jpvt);
static __global__ void ec_wtcc_kernel713(const int32_T G, emxArray_real_T a);
static __global__ void ec_wtcc_kernel714(const int32_T omega_tmp2,
  emxArray_real_T b);
static __global__ void ec_wtcc_kernel715(const emxArray_real_T b, const
  emxArray_int32_T jpvt, const int32_T nsubs, emxArray_real_T a);
static __global__ void ec_wtcc_kernel716(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_wtcc_kernel717(emxArray_real_T a);
static __global__ void ec_wtcc_kernel718(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel719(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, emxArray_creal32_T opts_x);
static __global__ void ec_wtcc_kernel72(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T omega);
static __global__ void ec_wtcc_kernel720(const emxArray_creal32_T crossCFS,
  const int32_T b_crossCFS, const int32_T c_crossCFS, emxArray_creal32_T opts_x,
  int32_T opts_x_dim0, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel721(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel722(const real_T toler, int32_T csz[2]);
static __global__ void ec_wtcc_kernel723(const emxArray_real32_T yCol, const
  int32_T csz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel724(const emxArray_real32_T h, real32_T
  *cv_re);
static __global__ void ec_wtcc_kernel725(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel726(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel727(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel728(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel729(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel73(const int32_T nsubs, const int32_T lidx,
  const emxArray_real_T omega_tmp2, const int32_T nx, emxArray_real_T omega,
  int32_T omega_tmp2_dim1);
static __global__ void ec_wtcc_kernel730(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel731(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel732(const emxArray_real32_T y, const
  int32_T xt_size, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel733(emxArray_real_T y);
static __global__ void ec_wtcc_kernel734(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T b, emxArray_real32_T b_y1);
static __global__ void ec_wtcc_kernel735(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel736(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel737(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel738(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel739(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel74(const int32_T crossCFS,
  emxArray_creal32_T cfsDFT);
static __global__ void ec_wtcc_kernel740(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv64);
static __global__ void ec_wtcc_kernel741(const emxArray_real32_T h, const
  emxArray_int32_T iv64, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel742(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel743(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel744(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel745(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel746(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel747(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv66);
static __global__ void ec_wtcc_kernel748(const emxArray_real32_T yCol, const
  emxArray_int32_T iv66, const int32_T xt_size, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel749(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel75(const emxArray_real_T fb_Scales, const
  emxArray_real_T omega, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T Fmat, int32_T Fmat_dim0);
static __global__ void ec_wtcc_kernel750(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel751(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel752(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel753(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel754(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel755(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel756(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel757(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel758(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel759(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel76(const emxArray_creal32_T cfsDFT, const
  emxArray_real_T Fmat, const int32_T b_Fmat, emxArray_creal32_T x);
static __global__ void ec_wtcc_kernel760(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel761(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel762(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel763(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv44);
static __global__ void ec_wtcc_kernel764(const emxArray_real32_T a, const
  emxArray_int32_T iv44, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel765(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel766(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel767(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel768(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel769(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv46);
static __global__ void ec_wtcc_kernel77(const int32_T xSize, emxArray_creal32_T
  smooth);
static __global__ void ec_wtcc_kernel770(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv46, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel771(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel772(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel773(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel774(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel775(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv51);
static __global__ void ec_wtcc_kernel776(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv69);
static __global__ void ec_wtcc_kernel777(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv69, const emxArray_int32_T iv51,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel778(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel78(const emxArray_creal32_T smooth, const
  int32_T b, emxArray_creal32_T a, int32_T smooth_dim0);
static __global__ void ec_wtcc_kernel79(const int32_T a, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel8(const int32_T nx, real_T interval[650]);
static __global__ void ec_wtcc_kernel80(const real32_T cv_re, const real32_T
  cv_im, emxArray_creal32_T c);
static __global__ void ec_wtcc_kernel807(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel808(const emxArray_real32_T yCol, const
  int32_T csz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel809(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel81(const emxArray_creal32_T c, const
  int32_T b_c, emxArray_creal32_T crossCFS, int32_T crossCFS_dim0);
static __global__ void ec_wtcc_kernel810(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel811(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel812(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel813(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel814(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel815(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel816(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel817(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel818(emxArray_real_T y);
static __global__ void ec_wtcc_kernel819(const emxArray_real32_T y, const
  emxArray_real_T b_y, const real_T T, const int32_T c_y, const int32_T b,
  emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_wtcc_kernel82(const emxArray_creal32_T crossCFS, const
  int32_T b, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel820(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel821(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel822(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel823(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel824(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel825(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel826(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv50);
static __global__ void ec_wtcc_kernel827(const emxArray_real32_T a, const
  emxArray_int32_T iv50, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel828(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel829(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel83(const emxArray_real32_T y, const int32_T
  b, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel830(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel831(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel832(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel833(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv54);
static __global__ void ec_wtcc_kernel834(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv54, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel835(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel836(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel837(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel838(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel839(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel84(const emxArray_real32_T cfs2, const
  emxArray_real32_T cfs1, const emxArray_real32_T y, const int32_T b_y,
  emxArray_real32_T wtc);
static __global__ void ec_wtcc_kernel840(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv57);
static __global__ void ec_wtcc_kernel841(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv74);
static __global__ void ec_wtcc_kernel842(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv74, const emxArray_int32_T iv57,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel843(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel85(const int32_T nrefine, emxArray_real32_T
  wtc);
static __global__ void ec_wtcc_kernel86(const int32_T b, emxArray_real_T m);
static __global__ void ec_wtcc_kernel87(const emxArray_real_T m, const int32_T
  b_m, emxArray_real_T k);
static __global__ void ec_wtcc_kernel872(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel873(const real_T toler, int32_T csz[2]);
static __global__ void ec_wtcc_kernel874(const emxArray_real32_T yCol, const
  int32_T csz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel875(const emxArray_real32_T h, real32_T
  *cv_re);
static __global__ void ec_wtcc_kernel876(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel877(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel878(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel879(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel88(const int32_T k, emxArray_real_T G);
static __global__ void ec_wtcc_kernel880(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel881(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel882(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel883(const emxArray_real32_T y, const
  int32_T xt_size, emxArray_real32_T b_y);
static __global__ void ec_wtcc_kernel884(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel885(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel886(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel887(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel888(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel889(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv63);
static __global__ void ec_wtcc_kernel89(const int32_T k, emxArray_real_T b);
static __global__ void ec_wtcc_kernel890(const emxArray_real32_T h, const
  emxArray_int32_T iv63, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel891(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel892(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel893(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel894(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel895(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel896(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv65);
static __global__ void ec_wtcc_kernel897(const emxArray_real32_T yCol, const
  emxArray_int32_T iv65, const int32_T xt_size, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel898(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b,
  emxArray_real32_T w, int32_T h_dim0);
static __global__ void ec_wtcc_kernel899(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel9(const real_T s, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_wtcc_kernel90(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T dv25);
static __global__ void ec_wtcc_kernel900(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel901(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel902(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel903(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel904(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel905(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel906(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel907(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel908(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel909(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel91(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T dv26, emxArray_real_T dv25);
static __global__ void ec_wtcc_kernel910(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel911(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel912(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv43);
static __global__ void ec_wtcc_kernel913(const emxArray_real32_T a, const
  emxArray_int32_T iv43, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel914(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel915(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel916(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel917(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel918(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv45);
static __global__ void ec_wtcc_kernel919(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv45, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel92(const int32_T b, emxArray_real_T dv26);
static __global__ void ec_wtcc_kernel920(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel921(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel922(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel923(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel924(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv49);
static __global__ void ec_wtcc_kernel925(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv68);
static __global__ void ec_wtcc_kernel926(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv68, const emxArray_int32_T iv49,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel927(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static __global__ void ec_wtcc_kernel93(const emxArray_real_T k, const
  emxArray_real_T dv26, const emxArray_real_T dv25, const real_T a, const
  int32_T b, emxArray_real_T b_b);
static __global__ void ec_wtcc_kernel94(const real_T tol, const emxArray_real_T
  k, const int32_T b_k, emxArray_real_T y);
static __global__ void ec_wtcc_kernel95(const real_T tol, const emxArray_real_T
  k, const int32_T b, emxArray_real_T y, emxArray_real_T b_y);
static __global__ void ec_wtcc_kernel956(const int32_T b, emxArray_real32_T yCol);
static __global__ void ec_wtcc_kernel957(const emxArray_real32_T yCol, const
  int32_T csz, emxArray_real32_T x);
static __global__ void ec_wtcc_kernel958(emxArray_real32_T w);
static __global__ void ec_wtcc_kernel959(const int32_T ix, const int32_T b,
  int32_T csz[2]);
static __global__ void ec_wtcc_kernel96(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel960(const int32_T nrefine, const int32_T
  pathlen, const int32_T nsubs, int32_T csz[2]);
static __global__ void ec_wtcc_kernel961(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel962(const emxArray_real32_T w, const
  int32_T xt_size, emxArray_real32_T y);
static __global__ void ec_wtcc_kernel963(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T nrefine, const int32_T b, const int32_T c,
  emxArray_real32_T b_w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel964(const emxArray_real32_T w, const
  int32_T xt_size_dim0, const int32_T b, const int32_T c, emxArray_real32_T y,
  int32_T y_dim0);
static __global__ void ec_wtcc_kernel965(const emxArray_real32_T y, const
  int32_T omega_tmp2, emxArray_real32_T b_y, int32_T y_dim0);
static __global__ void ec_wtcc_kernel966(const emxArray_real32_T y, const
  int32_T b_y, emxArray_real32_T c_y);
static __global__ void ec_wtcc_kernel967(const int32_T b, emxArray_real_T y);
static __global__ void ec_wtcc_kernel968(const emxArray_real32_T yCol, const
  int32_T b, emxArray_real32_T a);
static __global__ void ec_wtcc_kernel969(const int32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel97(const emxArray_real_T y, const real_T a,
  const emxArray_real_T b_y, const real_T b_a, const int32_T b, emxArray_real_T
  b_b);
static __global__ void ec_wtcc_kernel970(const real32_T cv_re, const
  emxArray_real32_T a, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel971(const emxArray_real32_T c, const
  int32_T b_c, emxArray_real32_T w, int32_T w_dim0);
static __global__ void ec_wtcc_kernel972(const int32_T a, emxArray_real32_T
  expanded);
static __global__ void ec_wtcc_kernel973(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv48);
static __global__ void ec_wtcc_kernel974(const emxArray_real32_T a, const
  emxArray_int32_T iv48, const int32_T omega_tmp2, emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel975(const real32_T cv_re, const
  emxArray_real32_T expanded, const int32_T b, emxArray_real32_T c);
static __global__ void ec_wtcc_kernel976(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel977(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel978(const emxArray_real32_T yCol, const
  emxArray_real32_T h, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel979(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel98(const real_T fa, const real_T r, const
  int32_T nsubs, const int32_T ix, const int32_T b, emxArray_real_T sinc4A,
  emxArray_real_T sinc3A, emxArray_real_T sinc2A, emxArray_real_T sinc1A);
static __global__ void ec_wtcc_kernel980(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv53);
static __global__ void ec_wtcc_kernel981(const emxArray_real32_T h, const
  int32_T lidx, const emxArray_int32_T iv53, const int32_T omega_tmp2,
  emxArray_real32_T expanded, int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel982(const emxArray_real32_T yCol, const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b, const int32_T c,
  emxArray_real32_T w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_wtcc_kernel983(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel984(const int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel985(const emxArray_real32_T c, const
  int32_T b, emxArray_real32_T w);
static __global__ void ec_wtcc_kernel986(const int32_T x_size_idx_1,
  emxArray_real32_T expanded);
static __global__ void ec_wtcc_kernel987(const int32_T offsetH, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv56);
static __global__ void ec_wtcc_kernel988(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv73);
static __global__ void ec_wtcc_kernel989(const emxArray_real32_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv73, const emxArray_int32_T iv56,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real32_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_wtcc_kernel99(const emxArray_real_T sinc4A, const
  emxArray_real_T sinc2A, const real_T fa, const emxArray_real_T sinc3A, const
  emxArray_real_T sinc1A, const real_T r, const int32_T nsubs, const int32_T b,
  const int32_T c, emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_wtcc_kernel990(const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const emxArray_real32_T h, const int32_T b, const
  int32_T c, emxArray_real32_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T
  w_dim0);
static void ec_wtcc_once();
static void emlrtExitTimeCleanupDtorFcn(const void *r);
static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real32_T *y);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real32_T *y);
static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23]);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23]);
static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId);
static const mxArray *emlrt_marshallOut(const cell_wrap_0 u[1]);
static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_creal32_T(emxArray_creal32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxFreeMatrix_cell_wrap_0(cell_wrap_0 pMatrix[1]);
static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct);
static void emxFree_char_T(emxArray_char_T **pEmxArray);
static void emxFree_creal32_T(emxArray_creal32_T **pEmxArray);
static void emxFree_int32_T(emxArray_int32_T **pEmxArray);
static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray);
static void emxFree_real32_T(emxArray_real32_T **pEmxArray);
static void emxFree_real_T(emxArray_real_T **pEmxArray);
static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray);
static void emxInitMatrix_cell_wrap_0(cell_wrap_0 pMatrix[1], const emlrtRTEInfo
  *srcLocation, boolean_T doPush);
static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush);
static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_creal32_T(emxArray_creal32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_real32_T(emxArray_real32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static uint16_T (*f_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2];
static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
  m3, emlrtMCInfo *location);
static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
  *location);
static real32_T g_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId);
static void gpuEmxEnsureCapacity_creal32_T(const emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_real32_T(const emxArray_real32_T *cpu,
  emxArray_real32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy);
static void gpuEmxFree_creal32_T(emxArray_creal32_T *gpu);
static void gpuEmxFree_int32_T(emxArray_int32_T *gpu);
static void gpuEmxFree_real32_T(emxArray_real32_T *gpu);
static void gpuEmxFree_real_T(emxArray_real_T *gpu);
static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu);
static void gpuEmxMemcpyCpuToGpu_creal32_T(emxArray_creal32_T *gpu, const
  emxArray_creal32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_real32_T(emxArray_real32_T *gpu, const
  emxArray_real32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu);
static void gpuEmxMemcpyGpuToCpu_creal32_T(emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu);
static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu);
static void gpuEmxMemcpyGpuToCpu_real32_T(emxArray_real32_T *cpu,
  emxArray_real32_T *gpu);
static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu);
static void gpuEmxReset_creal32_T(emxArray_creal32_T *gpu);
static void gpuEmxReset_int32_T(emxArray_int32_T *gpu);
static void gpuEmxReset_real32_T(emxArray_real32_T *gpu);
static void gpuEmxReset_real_T(emxArray_real_T *gpu);
static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu);
static real32_T (*h_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2];
static const mxArray *length(const mxArray *m1, emlrtMCInfo *location);
static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString);
static real32_T rt_atan2f_snf(real32_T u0, real32_T u1);
static real_T rt_powd_snf(real_T u0, real_T u1);
static real_T rt_remd_snf(real_T u0, real_T u1);

// Function Definitions
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23])
{
  static const int32_T dims[2]{ 1, 23 };

  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0]);
  emlrtImportCharArrayR2015b(emlrtRootTLSGlobal, src, &ret[0], 23);
  emlrtDestroyArray(&src);
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret)
{
  static const int32_T dims[2]{ 1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ false, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0], &bv[0], &iv[0]);
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_char_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  emlrtImportArrayR2015b(emlrtRootTLSGlobal, src, &ret->data[0], 1, false);
  emlrtDestroyArray(&src);
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real32_T *ret)
{
  static const int32_T dims[2]{ -1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ true, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret->allocatedSize = iv[0] * iv[1];
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_real32_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  ret->data = static_cast<real32_T *>(emlrtMxGetData(src));
  ret->canFreeData = false;
  emlrtDestroyArray(&src);
}

static uint16_T (*b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2]
{
  emlrtMsgIdentifier thisId;
  uint16_T (*y)[2];
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = b_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}
static uint16_T (*b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
parentId))[2]
{
  uint16_T (*y)[2];
  y = f_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = m;
  pArrays[1] = m1;
  emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 0, nullptr, 2, &pArrays[0], "feval",
                        true, location);
}

static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  fn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "sprintf", true, location);
}

static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &ye_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in3->size[0] == 1) {
    b_in1->size[0] = in1->size[0];
  } else {
    b_in1->size[0] = in3->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &ye_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  if (in3->size[0] == 1) {
    b = in1->size[0];
  } else {
    b = in3->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + (in2 * in3->data[i * stride_1_0]
      - in4 * in5->data[i * stride_1_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &af_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  int32_T stride_2_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &bf_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b_in1->size[0] = in1->size[0];
  } else if (in5->size[0] == 1) {
    b_in1->size[0] = in3->size[0];
  } else {
    b_in1->size[0] = in5->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &bf_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_2_0 = (in5->size[0] != 1);
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b = in1->size[0];
  } else if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + in2 * (in3->data[i * stride_1_0]
      - in4->data[i * stride_1_0]) / (in5->data[i * stride_2_0] * in5->data[i *
      stride_2_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &cf_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_10(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2])
{
  int32_T stride_0_1;
  int32_T stride_1_1;
  in1_size[0] = 1;
  in1_size[1] = in4_size[1];
  stride_0_1 = (in2_size[1] != 1);
  stride_1_1 = (in3_size[1] != 1);
  for (int32_T i{0}; i < in4_size[1]; i++) {
    in1_data[i] = in2_data[i * stride_0_1] * in3_data[i * stride_1_1] *
      in4_data[i];
  }
}

static void binary_expand_op_4(emxArray_real32_T *in1, const emxArray_real32_T
  *in2, const emxArray_real32_T *in3, const emxArray_real32_T *in4)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T aux_2_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  int32_T stride_2_0;
  int32_T stride_2_1;
  i = in1->size[0] * in1->size[1];
  if (in4->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in4->size[0];
  }

  if (b == 1) {
    in1->size[0] = in2->size[0];
  } else if (in4->size[0] == 1) {
    in1->size[0] = in3->size[0];
  } else {
    in1->size[0] = in4->size[0];
  }

  if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  if (b == 1) {
    in1->size[1] = in2->size[1];
  } else if (in4->size[1] == 1) {
    in1->size[1] = in3->size[1];
  } else {
    in1->size[1] = in4->size[1];
  }

  emxEnsureCapacity_real32_T(in1, i, &rb_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  stride_2_0 = (in4->size[0] != 1);
  stride_2_1 = (in4->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  aux_2_1 = 0;
  if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  if (b == 1) {
    b = in2->size[1];
  } else if (in4->size[1] == 1) {
    b = in3->size[1];
  } else {
    b = in4->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in4->size[0] == 1) {
      c = in3->size[0];
    } else {
      c = in4->size[0];
    }

    if (c == 1) {
      c = in2->size[0];
    } else if (in4->size[0] == 1) {
      c = in3->size[0];
    } else {
      c = in4->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = in2->data[i1 * stride_0_0 + in2->size[0]
        * aux_0_1] / (in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1] *
                      in4->data[i1 * stride_2_0 + in4->size[0] * aux_2_1]);
    }

    aux_2_1 += stride_2_1;
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_5(emxArray_creal32_T *in1, const emxArray_real_T
  *in2, const emxArray_creal32_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_creal32_T(in1, i, &ob_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i].re = static_cast<real32_T>(in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1]) * in3->data[i1 * stride_1_0 +
        in3->size[0] * aux_1_1].re;
      in1->data[i1 + in1->size[0] * i].im = static_cast<real32_T>(in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1]) * in3->data[i1 * stride_1_0 +
        in3->size[0] * aux_1_1].im;
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_6(emxArray_creal32_T *in1, const emxArray_creal32_T
  *in2, const emxArray_creal32_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_creal32_T(in1, i, &nb_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      real32_T in3_im;
      real32_T in3_re;
      in3_re = in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1].re;
      in3_im = -in3->data[i1 * stride_1_0 + in3->size[0] * aux_1_1].im;
      in1->data[i1 + in1->size[0] * i].re = in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].re * in3_re - in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].im * in3_im;
      in1->data[i1 + in1->size[0] * i].im = in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].re * in3_im + in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1].im * in3_re;
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_9(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_real_T(in1, i, &p_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = 5.43656365691809 * in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1] * static_cast<real_T>(in3->data[i1 *
        stride_1_0 + in3->size[0] * aux_1_1] < 0.99999999999999978);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static real32_T c_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier)
{
  emlrtMsgIdentifier thisId;
  real32_T y;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = c_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}

static real32_T c_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId)
{
  real32_T y;
  y = g_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line)
{
  if (errCode != cudaSuccess) {
    b_raiseCudaError(errCode, file, b_line, cudaGetErrorName(errCode),
                     cudaGetErrorString(errCode));
  }
}

//
//
namespace coder
{
  namespace internal
  {
    static void warning()
    {
      static const int32_T iv[2]{ 1, 7 };

      static const int32_T iv1[2]{ 1, 7 };

      static const int32_T iv2[2]{ 1, 39 };

      static const char_T msgID[39]{ 's', 'i', 'g', 'n', 'a', 'l', ':', 'c', 'h',
        'e', 'c', 'k', '_', 'o', 'r', 'd', 'e', 'r', ':', 'I', 'n', 'v', 'a',
        'l', 'i', 'd', 'O', 'r', 'd', 'e', 'r', 'R', 'o', 'u', 'n', 'd', 'i',
        'n', 'g' };

      static const char_T b_u[7]{ 'm', 'e', 's', 's', 'a', 'g', 'e' };

      static const char_T u[7]{ 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

      const mxArray *b_y;
      const mxArray *c_y;
      const mxArray *m;
      const mxArray *m1;
      const mxArray *m2;
      const mxArray *y;
      y = nullptr;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &u[0]);
      emlrtAssign(&y, m);
      b_y = nullptr;
      m1 = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m1, &b_u[0]);
      emlrtAssign(&b_y, m1);
      c_y = nullptr;
      m2 = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 39, m2, &msgID[0]);
      emlrtAssign(&c_y, m2);
      b_feval(y, feval(b_y, c_y, &d_emlrtMCI), &e_emlrtMCI);
    }
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride)
{
  int64_T newEnd;
  newEnd = -1L;
  if ((stride > 0L) && (start <= end)) {
    newEnd = (end - start) / stride;
  } else if ((stride < 0L) && (end <= start)) {
    newEnd = (start - end) / -stride;
  }

  return newEnd;
}

static uint64_T computeNumIters(int64_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0L) {
    numIters = static_cast<uint64_T>(ub + 1L);
  }

  return numIters;
}

static uint64_T computeNumIters(int32_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0) {
    numIters = static_cast<uint64_T>(ub + 1);
  }

  return numIters;
}

static uint64_T computeNumIters(int32_T ub, int32_T b_ub)
{
  uint64_T n;
  uint64_T numIters;
  n = 0UL;
  if (ub >= 0) {
    n = static_cast<uint64_T>(ub + 1);
  }

  numIters = n;
  n = 0UL;
  if (b_ub >= 0) {
    n = static_cast<uint64_T>(b_ub + 1);
  }

  numIters *= n;
  return numIters;
}

static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUBLAS_STATUS_SUCCESS) {
    cublasGetErrorName(errCode, &errName);
    cublasGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUSOLVER_STATUS_SUCCESS) {
    cusolverGetErrorName(errCode, &errName);
    cusolverGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static real32_T (*d_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier *
  parentId))[2]
{
  real32_T (*y)[2];
  y = h_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}
static real32_T (*d_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
*identifier))[2]
{
  emlrtMsgIdentifier thisId;
  real32_T (*y)[2];
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = d_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}

static int32_T div_s32(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    emlrtDivisionByZeroErrorR2012b(nullptr, emlrtRootTLSGlobal);
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static __device__ int32_T div_s32_device(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if (static_cast<int32_T>(numerator < 0) != static_cast<int32_T>(denominator <
         0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static real_T e_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId)
{
  static const int32_T dims{ 0 };

  real_T ret;
  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "double", false, 0U, (
    const void *)&dims);
  ret = *static_cast<real_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret;
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1(creal_T *dc,
  creal_T *dc6)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    dc6->re = CUDART_INF;
    dc->re = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel10(emxArray_real_T
  fb_Omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    fb_Omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel100(const real_T T,
  emxArray_real_T b0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b0.data[0] = T;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel101(const
  emxArray_real_T b, const int32_T c, emxArray_real_T b0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b0.data[itime + 1] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1019(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel102(const
  emxArray_real_T b0, const int32_T b_b0, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b0);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = b0.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1020(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1021(const
  emxArray_real32_T w, const int32_T nrefine, const int32_T b, emxArray_real32_T
  y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[nrefine * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1022
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1023(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  nx, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime + y1_dim0 * nx] = y.data[static_cast<int32_T>(T +
      b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1024(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1025(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1026(const
  real32_T cv_re, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = h.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1027(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1028(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv42)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv42.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1029(const
  emxArray_real32_T h, const emxArray_int32_T iv42, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv42.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel103(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1030(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const real_T toler, const int32_T b, emxArray_real32_T
  w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    real32_T cv;
    k = static_cast<int32_T>(idx);
    cv = 0.0F;
    itime = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < itime; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * yCol.data[(static_cast<int32_T>(toler)
        - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1031(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1032(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1033(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1034(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv41)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv41.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1035(const
  emxArray_real32_T yCol, const emxArray_int32_T iv41, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv41.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1036(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    real32_T cv;
    k = static_cast<int32_T>(idx);
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1037(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1038(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1039(const
  emxArray_real32_T h, const emxArray_real32_T yCol, emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel104(const
  emxArray_real_T a, const int32_T ix, const int32_T nrefine, const int32_T nx,
  emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = a.data[nrefine + ix * itime] / 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1040(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1041(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1042(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1043(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1044(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1045(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1046(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1047(const
  emxArray_real32_T y, const int32_T xt_size, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1048
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1049(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel105(const
  emxArray_real_T a, const int32_T ix, const int32_T nrefine, const int32_T lidx,
  emxArray_real_T h)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    h.data[div_s32_device(lidx - nrefine, ix) + 1] = a.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1050(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1051(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1052(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1053(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1054(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1055(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv70)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv70.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1056(const
  emxArray_real32_T h, const emxArray_int32_T iv70, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv70.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1057(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const real_T toler, const int32_T b, emxArray_real32_T
  w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T nw;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < nw; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * yCol.data[(static_cast<int32_T>(toler)
        - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1058(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1059(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel106(const
  int32_T b, emxArray_real_T dv23)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv23.data[itime] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1060(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1061(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1062(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv72)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv72.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1063(const
  emxArray_real32_T yCol, const emxArray_int32_T iv72, const int32_T xt_size,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv72.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1064(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1065(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1066
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1067(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1068(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1069(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel107(const
  emxArray_real_T dv23, const emxArray_real_T h, const int32_T b_h,
  emxArray_real_T h1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h1.data[itime] = h.data[itime] * dv23.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1070(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1071(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1072(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1073(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1074(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1075(const
  real32_T cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1076(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1077(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1078(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv47)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv47.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1079(const
  emxArray_real32_T a, const emxArray_int32_T iv47, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv47.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel108(const real_T
  halfh, const emxArray_real_T h1, const real_T toler, const int32_T b_h1,
  emxArray_real32_T opts_filter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_filter.data[itime] = static_cast<real32_T>(toler * h1.data[itime] /
      halfh);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1080(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1081(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1082(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1083(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1084(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv52)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv52.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1085(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv52, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv52.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1086(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1087(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1088(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1089(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel109(const
  int32_T halfh, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(halfh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1090(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv55)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv55.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1091(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv71)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv71.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1092(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv71, const emxArray_int32_T iv55, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv55.data[kk] + expanded_dim0 * iv71.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1093(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel11(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T fb_Omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel110(const
  emxArray_uint32_T y, const real_T halfh, const int32_T b_y, emxArray_int32_T
  iv18)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv18.data[itime] = static_cast<int32_T>(halfh + static_cast<real_T>
      (y.data[itime]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel111(const
  emxArray_real32_T opts_filter, const emxArray_int32_T iv18, const int32_T
  b_iv18, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_iv18);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[iv18.data[itime] - 1] = opts_filter.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel112(const
  emxArray_creal32_T crossCFS, const int32_T b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1122(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1123(const
  emxArray_real32_T xCol, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = xCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1124(const
  emxArray_real32_T yCol, const int32_T csz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1125
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1126(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1127(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1128(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1129(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel113(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime) + 0.5;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1130(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1131(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1132(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1133(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1134
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1135(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1136(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1137(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1138(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1139(const
  real32_T cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel114(const
  emxArray_real_T m, const int32_T b_m, emxArray_real_T k)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_m);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    k.data[itime] = m.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1140(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1141(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1142(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv58)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv58.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1143(const
  emxArray_real32_T a, const emxArray_int32_T iv58, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv58.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1144(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1145(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1146(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1147(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1148(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1149(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv61)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv61.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel115(const
  int32_T k, emxArray_real_T G)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    G.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1150(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv61, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv61.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1151(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1152(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1153(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1154(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1155(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1156(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv62)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv62.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1157(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv79)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv79.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1158(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv79, const emxArray_int32_T iv62, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv62.data[kk] + expanded_dim0 * iv79.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1159(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel116(const
  int32_T k, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel117(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T dv29)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv29.data[itime] = 6.2831853071795862 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel118(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T dv31,
  emxArray_real_T dv29)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    dv29.data[b_k] = cos(dv29.data[b_k]);
    dv31.data[b_k] = 6.2831853071795862 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1188(const
  int32_T b, emxArray_uint32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<uint32_T>(itime) + 1U;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1189(const
  creal_T *dc6, const real_T table100[100], const creal_T dc7, const creal_T *dc,
  const int32_T nsubs, const int32_T lidx, const int32_T nrefine, const int32_T
  i, const int64_T b, emxArray_real_T dv23, real_T q1_dim0, real_T q1_dim1,
  real_T q1_dim2, real_T q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6,
  real_T q1_dim7, real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3,
  real_T p1_dim4, real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0,
  real_T q2_dim1, real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5,
  real_T q2_dim6, real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2,
  real_T p2_dim3, real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7,
  real_T q4_dim0, real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4,
  real_T q4_dim5, real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1,
  real_T p4_dim2, real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6,
  real_T p4_dim7, real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3,
  real_T c_dim4, real_T c_dim5, real_T c_dim6)
{
  __shared__ real_T p1_shared[8];
  __shared__ real_T p2_shared[8];
  __shared__ real_T p4_shared[8];
  __shared__ real_T q1_shared[8];
  __shared__ real_T q2_shared[8];
  __shared__ real_T q4_shared[8];
  __shared__ real_T c_shared[7];
  creal_T z;
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  int32_T itime;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    p1_shared[0] = p1_dim0;
    p1_shared[1] = p1_dim1;
    p1_shared[2] = p1_dim2;
    p1_shared[3] = p1_dim3;
    p1_shared[4] = p1_dim4;
    p1_shared[5] = p1_dim5;
    p1_shared[6] = p1_dim6;
    p1_shared[7] = p1_dim7;
    q1_shared[0] = q1_dim0;
    q1_shared[1] = q1_dim1;
    q1_shared[2] = q1_dim2;
    q1_shared[3] = q1_dim3;
    q1_shared[4] = q1_dim4;
    q1_shared[5] = q1_dim5;
    q1_shared[6] = q1_dim6;
    q1_shared[7] = q1_dim7;
    p2_shared[0] = p2_dim0;
    p2_shared[1] = p2_dim1;
    p2_shared[2] = p2_dim2;
    p2_shared[3] = p2_dim3;
    p2_shared[4] = p2_dim4;
    p2_shared[5] = p2_dim5;
    p2_shared[6] = p2_dim6;
    p2_shared[7] = p2_dim7;
    q2_shared[0] = q2_dim0;
    q2_shared[1] = q2_dim1;
    q2_shared[2] = q2_dim2;
    q2_shared[3] = q2_dim3;
    q2_shared[4] = q2_dim4;
    q2_shared[5] = q2_dim5;
    q2_shared[6] = q2_dim6;
    q2_shared[7] = q2_dim7;
    p4_shared[0] = p4_dim0;
    p4_shared[1] = p4_dim1;
    p4_shared[2] = p4_dim2;
    p4_shared[3] = p4_dim3;
    p4_shared[4] = p4_dim4;
    p4_shared[5] = p4_dim5;
    p4_shared[6] = p4_dim6;
    p4_shared[7] = p4_dim7;
    q4_shared[0] = q4_dim0;
    q4_shared[1] = q4_dim1;
    q4_shared[2] = q4_dim2;
    q4_shared[3] = q4_dim3;
    q4_shared[4] = q4_dim4;
    q4_shared[5] = q4_dim5;
    q4_shared[6] = q4_dim6;
    q4_shared[7] = q4_dim7;
    c_shared[0] = c_dim0;
    c_shared[1] = c_dim1;
    c_shared[2] = c_dim2;
    c_shared[3] = c_dim3;
    c_shared[4] = c_dim4;
    c_shared[5] = c_dim5;
    c_shared[6] = c_dim6;
  }

  __syncthreads();
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal_T tmp;
    creal_T zd;
    int64_T k;
    real_T tkd1mtk;
    k = static_cast<int64_T>(idx);
    tkd1mtk = static_cast<real_T>(nrefine + (((static_cast<int32_T>(static_cast<
      int64_T>(i) + k) - lidx) - 1) << 1)) / (static_cast<real_T>(nsubs) - 1.0);
    zd.re = 5.0 * sqrt((1.0 - tkd1mtk) * (tkd1mtk + 1.0));
    if (isnan(zd.re)) {
      tmp = *dc;
    } else {
      creal_T dk;
      creal_T p1;
      creal_T pt;
      real_T aa;
      real_T ack;
      real_T ak;
      real_T b_atol;
      real_T bb;
      real_T i2Map;
      real_T im;
      real_T re;
      int32_T nw;
      int32_T ocol;
      boolean_T guard1;
      ocol = 0;
      i2Map = hypot(zd.re, 0.0);
      if (i2Map > 1.0737418235E+9) {
        ocol = 4;
      } else if (i2Map > 32767.999992370605) {
        ocol = 3;
      }

      tmp.re = 0.0;
      tmp.im = 0.0;
      bb = hypot(zd.re, 0.0);
      guard1 = false;
      if (bb <= 2.0) {
        nw = 0;
        b_atol = hypot(zd.re, 0.0);
        if (b_atol == 0.0) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else if (b_atol < 2.2250738585072014E-305) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else {
          pt.re = 0.5 * zd.re;
          if (b_atol > 4.7170688552396617E-153) {
            dk.re = pt.re * pt.re;
            ack = hypot(dk.re, 0.0);
          } else {
            dk.re = 0.0;
            ack = 0.0;
          }

          i2Map = pt.re;
          if (log(i2Map) * 0.0 > -700.92179369444591) {
            b_atol = 2.2204460492503131E-16 * ack;
            pt.re = 1.0;
            pt.im = 0.0;
            if (!static_cast<int32_T>(ack < 2.2204460492503131E-16)) {
              p1.re = 1.0;
              p1.im = 0.0;
              ak = 3.0;
              i2Map = 1.0;
              aa = 2.0;
              do {
                tkd1mtk = 1.0 / i2Map;
                re = p1.re * dk.re - p1.im * 0.0;
                im = p1.re * 0.0 + p1.im * dk.re;
                p1.re = tkd1mtk * re;
                p1.im = tkd1mtk * im;
                pt.re += p1.re;
                pt.im += p1.im;
                i2Map += ak;
                ak += 2.0;
                aa = aa * ack * tkd1mtk;
              } while (!!static_cast<int32_T>(aa > b_atol));
            }

            i2Map = pt.re - pt.im * 0.0;
            tkd1mtk = pt.re * 0.0 + pt.im;
            tmp.re = i2Map - tkd1mtk * 0.0;
            tmp.im = i2Map * 0.0 + tkd1mtk;
          } else {
            nw = 1;
            if (ack > 0.0) {
              nw = -1;
            }
          }
        }

        if (nw < 0) {
          itime = 1;
        } else {
          itime = nw;
        }

        if ((1 - itime != 0) && (nw < 0)) {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        if (bb < 21.784271729432426) {
          creal_T ck;
          creal_T cs1;
          creal_T cs2;
          int32_T b_i;
          int32_T kk;
          boolean_T errflag;
          boolean_T exitg1;
          nw = 0;
          b_atol = hypot(zd.re, 0.0);
          aa = floor(b_atol);
          ck.re = (aa + 1.0) / zd.re;
          cs2.re = 2.0 / zd.re;
          p1.re = 0.0;
          p1.im = 0.0;
          cs1.re = 1.0;
          cs1.im = 0.0;
          ack = ((aa + 1.0) + 1.0) / b_atol;
          tkd1mtk = ack + sqrt(ack * ack - 1.0);
          i2Map = tkd1mtk * tkd1mtk;
          bb = (i2Map + i2Map) / ((i2Map - 1.0) * (tkd1mtk - 1.0)) /
            2.2204460492503131E-16;
          ak = aa + 1.0;
          errflag = true;
          kk = 0;
          b_i = 1;
          exitg1 = false;
          while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) && (b_i
                  < 81)) {
            kk++;
            pt = cs1;
            tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
            ack = ck.re * cs1.im + 0.0 * cs1.re;
            cs1.re = p1.re - tkd1mtk;
            cs1.im = p1.im - ack;
            p1 = pt;
            ck.re += cs2.re;
            if (hypot(cs1.re, cs1.im) > bb * ak * ak) {
              errflag = false;
              exitg1 = true;
            } else {
              ak++;
              b_i++;
            }
          }

          if (errflag) {
            nw = -2;
          } else {
            int32_T kcounter;
            boolean_T guard2;
            kk++;
            kcounter = 0;
            guard2 = false;
            if (static_cast<int32_T>(aa) <= 0) {
              p1.re = 0.0;
              p1.im = 0.0;
              cs1.re = 1.0;
              cs1.im = 0.0;
              ck.re = 1.0 / zd.re;
              bb = sqrt(1.0 / b_atol / 2.2204460492503131E-16);
              itime = 1;
              errflag = true;
              b_i = 1;
              exitg1 = false;
              while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                     (b_i < 81)) {
                kcounter++;
                pt = cs1;
                tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
                ack = ck.re * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re - tkd1mtk;
                cs1.im = p1.im - ack;
                p1 = pt;
                ck.re += cs2.re;
                i2Map = hypot(cs1.re, cs1.im);
                if (i2Map >= bb * ak * ak) {
                  if (itime == 2) {
                    errflag = false;
                    exitg1 = true;
                  } else {
                    ack = hypot(ck.re, 0.0);
                    tkd1mtk = fmin(ack + sqrt(ack * ack - 1.0), i2Map / hypot
                                   (pt.re, pt.im));
                    bb *= sqrt(tkd1mtk / (tkd1mtk * tkd1mtk - 1.0));
                    itime = 2;
                    b_i++;
                  }
                } else {
                  b_i++;
                }
              }

              if (errflag) {
                nw = -2;
              } else {
                guard2 = true;
              }
            } else {
              guard2 = true;
            }

            if (guard2) {
              itime = kk + static_cast<int32_T>(aa);
              kk = kcounter + 1;
              if (itime >= kk) {
                kk = itime;
              }

              aa = static_cast<real_T>(kk);
              p1.re = 0.0;
              p1.im = 0.0;
              cs1 = dc7;
              bb = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  bb = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) + (static_cast<real_T>
                    (kk) + 1.0) * ((static_cast<real_T>(kk) + 1.0) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) +
                    (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  bb = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  bb = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((static_cast<
                    real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  bb = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              tkd1mtk = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) +
                    (static_cast<real_T>(kk) + 1.0) * ((static_cast<real_T>(kk)
                    + 1.0) * (i2Map / tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) + (((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  tkd1mtk = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  tkd1mtk = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) *
                    ((((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                      tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((
                    static_cast<real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  tkd1mtk = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              bb = exp(bb - tkd1mtk);
              dk.re = 0.0;
              dk.im = 0.0;
              for (b_i = 0; b_i < kk; b_i++) {
                pt = cs1;
                i2Map = aa * cs2.re;
                tkd1mtk = i2Map * cs1.re - 0.0 * cs1.im;
                i2Map = i2Map * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re + tkd1mtk;
                cs1.im = p1.im + i2Map;
                p1 = pt;
                ack = bb * (1.0 - 0.0 / aa);
                dk.re += (ack + bb) * pt.re;
                dk.im += (ack + bb) * pt.im;
                bb = ack;
                aa--;
              }

              tmp = cs1;
              pt.re = log(cs2.re);
              re = 0.0 * pt.re;
              im = 0.0 * pt.re;
              pt.re = re + zd.re;
              cs1.re += dk.re;
              cs1.im += dk.im;
              p1.re = 1.0 / hypot(cs1.re, cs1.im);
              if (pt.re == 0.0) {
                pt.re = cos(im);
                pt.im = sin(im);
              } else if (im == 0.0) {
                i2Map = pt.re;
                pt.re = exp(i2Map);
                pt.im = 0.0;
              } else {
                pt.re = CUDART_NAN;
                pt.im = CUDART_NAN;
              }

              i2Map = pt.re * p1.re - pt.im * 0.0;
              tkd1mtk = pt.re * 0.0 + pt.im * p1.re;
              bb = cs1.re * p1.re + cs1.im * 0.0;
              ack = cs1.re * 0.0 - cs1.im * p1.re;
              pt.re = i2Map * bb - tkd1mtk * ack;
              pt.im = i2Map * ack + tkd1mtk * bb;
              re = tmp.re * pt.re - tmp.im * pt.im;
              im = tmp.re * pt.im + tmp.im * pt.re;
              tmp.re = re;
              tmp.im = im;
            }
          }

          if (nw < 0) {
            if (nw == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        } else {
          nw = 0;
          i2Map = sqrt(0.15915494309189535 / zd.re);
          if (zd.re > 700.92179369444591) {
            nw = -1;
            tmp = *dc;
          } else {
            creal_T ck;
            creal_T cs1;
            creal_T cs2;
            int32_T b_i;
            boolean_T errflag;
            boolean_T exitg1;
            if (zd.re == 0.0) {
              pt.re = 1.0;
            } else {
              pt.re = exp(zd.re);
            }

            p1.re = i2Map * pt.re;
            p1.im = i2Map * 0.0;
            pt.re = 8.0 * zd.re;
            pt.im = 0.0;
            ack = 8.0 * hypot(zd.re, 0.0);
            i2Map = -1.0;
            b_atol = 2.2204460492503131E-16 / ack;
            tkd1mtk = 1.0;
            cs1.re = 1.0;
            cs1.im = 0.0;
            cs2.re = 1.0;
            cs2.im = 0.0;
            ck.re = 1.0;
            ck.im = 0.0;
            ak = 0.0;
            aa = 1.0;
            bb = ack;
            dk = pt;
            errflag = true;
            b_i = 1;
            exitg1 = false;
            while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                   (b_i < 46)) {
              ck.re *= i2Map;
              ck.im *= i2Map;
              if (ck.im == 0.0) {
                re = ck.re / dk.re;
                im = 0.0;
              } else if (ck.re == 0.0) {
                re = 0.0;
                im = CUDART_NAN;
              } else {
                re = ck.re / dk.re;
                im = CUDART_NAN;
              }

              ck.re = re;
              ck.im = im;
              cs2.re += re;
              cs2.im += im;
              tkd1mtk = -tkd1mtk;
              cs1.re += re * tkd1mtk;
              cs1.im += im * tkd1mtk;
              dk.re += pt.re;
              aa = aa * fabs(i2Map) / bb;
              bb += ack;
              ak += 8.0;
              i2Map -= ak;
              if (aa <= b_atol) {
                errflag = false;
                exitg1 = true;
              } else {
                b_i++;
              }
            }

            if (errflag) {
              nw = -2;
            } else {
              if (zd.re + zd.re < 700.92179369444591) {
                pt.re = -2.0 * zd.re;
                if (pt.re == 0.0) {
                  pt.re = 1.0;
                  pt.im = -0.0;
                } else {
                  i2Map = pt.re;
                  pt.re = exp(i2Map);
                  pt.im = 0.0;
                }

                re = pt.re * cs2.re - pt.im * cs2.im;
                im = pt.re * cs2.im + pt.im * cs2.re;
                cs1.re += re * 0.0 - im * 0.0;
                cs1.im += re * 0.0 + im * 0.0;
              }

              tmp.re = cs1.re * p1.re - cs1.im * p1.im;
              tmp.im = cs1.re * p1.im + cs1.im * p1.re;
            }
          }

          if (nw < 0) {
            if (nw == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        }
      }

      if (itime < 0) {
        if (itime == -2) {
          ocol = 5;
        } else {
          ocol = 2;
        }
      }

      if (ocol == 5) {
        tmp = *dc;
      } else if (ocol == 2) {
        tmp = *dc6;
      }

      if (zd.re > 0.0) {
        i2Map = tmp.re;
        tmp.re = i2Map;
        tmp.im = 0.0;
      }
    }

    if (tmp.im == 0.0) {
      z.re = tmp.re / 27.239871823604449;
      z.im = 0.0;
    } else if (tmp.re == 0.0) {
      z.re = 0.0;
      z.im = CUDART_NAN;
    } else {
      z.re = tmp.re / 27.239871823604449;
      z.im = CUDART_NAN;
    }

    dv23.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = hypot
      (z.re, z.im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel119(const
  int32_T b, emxArray_real_T dv31)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv31.data[k] = cos(dv31.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1190(const
  emxArray_real_T a, const int32_T b_a, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1191(const
  emxArray_real_T x, const int32_T b, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.5 * x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1192(const
  emxArray_real_T a, const int32_T b, emxArray_real_T h, int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime + x_dim0] = 0.5 * a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1193(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1194(const
  int32_T omega_tmp2, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1195(const
  int32_T G, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    jpvt.data[itime] = 0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1196(const
  int32_T b, const int32_T ix, emxArray_real_T G, int32_T G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(ix) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b) + 1UL));
    G.data[kk * G_dim0 + i] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1197(const
  int32_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    tau.data[k] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1198(const
  int32_T i, const int64_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int64_T k;
    k = static_cast<int64_T>(idx);
    tau.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1199(const
  int32_T ix, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(ix);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    jpvt.data[k] = k + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel12(const int32_T
  nrefine, const int32_T ix, const emxArray_real_T omega_tmp2, const int32_T nx,
  emxArray_real_T fb_Omega, int32_T omega_tmp2_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Omega.data[(itime + omega_tmp2_dim1) + 1] = -omega_tmp2.data[ix + nrefine
      * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel120(const
  emxArray_real_T k, const emxArray_real_T dv31, const emxArray_real_T dv29,
  const real_T a, const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * (dv29.data[itime] - dv31.data[itime]) / (k.data[itime]
      * k.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1200(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1201(const
  int32_T omega_tmp2, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1202(const
  emxArray_real_T b, const emxArray_int32_T jpvt, const int32_T nsubs,
  emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    a.data[jpvt.data[i] - 1] = b.data[i];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1203(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 4.0 * b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1204
  (emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] /= 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1205(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1206(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1207(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv16)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv16.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1208(const
  emxArray_creal32_T a, const emxArray_int32_T iv16, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv16.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1209(const
  emxArray_creal32_T expanded, const real_T a, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = static_cast<real32_T>(a) * expanded.data[k].re;
    c.data[k].im = static_cast<real32_T>(a) * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel121(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = 2.0 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1210(const
  int32_T smooth, emxArray_creal32_T crossCFS)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    crossCFS.data[itime].re = 0.0F;
    crossCFS.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1211(const
  int32_T smooth, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1212(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv15)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv15.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1213(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv17)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv17.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1214(const
  emxArray_creal32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_creal32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1215(const
  emxArray_creal32_T smooth, const int32_T xt_size_dim0, const emxArray_int32_T
  iv17, const emxArray_int32_T iv15, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv15.data[kk] + expanded_dim0 * iv17.data[itime]] =
      smooth.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1216(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1217(const
  real32_T cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T crossCFS, int32_T crossCFS_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    crossCFS.data[nx + crossCFS_dim0 * nrefine].re = cv_re;
    crossCFS.data[nx + crossCFS_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1218(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1219(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      smooth.data[itime].re = cv / cfsposdft->re;
      smooth.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      smooth.data[itime].re = 0.0F;
      smooth.data[itime].im = ai / cfsposdft->re;
    } else {
      smooth.data[itime].re = cv / cfsposdft->re;
      smooth.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel122(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T y,
  emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    if (fabs(b_y.data[b_k]) < 1.0020841800044864E-292) {
      b_y.data[b_k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * b_y.data[b_k];
      i2Map = sin(i2Map) / i2Map;
      b_y.data[b_k] = i2Map;
    }

    y.data[b_k] = 2.0 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1220(const
  int32_T crossCFS, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1221(const
  emxArray_creal32_T crossCFS, const int32_T b, const int32_T c,
  emxArray_creal32_T cfsDFT, int32_T cfsDFT_dim0, int32_T crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[kk + cfsDFT_dim0 * itime] = crossCFS.data[kk + crossCFS_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1222(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, emxArray_creal32_T
  cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1223(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1224(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1225(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv12)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv12.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1226(const
  emxArray_real32_T a, const emxArray_int32_T iv12, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv12.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1227(const
  real_T a, const emxArray_real32_T expanded, const int32_T b, emxArray_real32_T
  c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1228(const
  int32_T smooth, emxArray_real32_T cfs2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs2.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1229(const real_T
  a, const emxArray_real32_T smooth, emxArray_real32_T b_smooth)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b_smooth.data[0] = smooth.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel123(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    if (fabs(y.data[k]) < 1.0020841800044864E-292) {
      y.data[k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * y.data[k];
      i2Map = sin(i2Map) / i2Map;
      y.data[k] = i2Map;
    }
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1230(const
  emxArray_real32_T smooth, emxArray_real32_T cfs2)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfs2.data[0] = smooth.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1231(const
  int32_T smooth, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1232(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv11)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv11.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1233(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv13)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv13.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1234(const
  emxArray_real32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_real32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1235(const
  emxArray_real32_T smooth, const int32_T xt_size_dim0, const emxArray_int32_T
  iv13, const emxArray_int32_T iv11, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv11.data[kk] + expanded_dim0 * iv13.data[itime]] =
      smooth.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1236(const
  real_T a, const emxArray_real32_T expanded, const emxArray_int32_T rows, const
  real_T halfh, const int32_T b, const int32_T c, emxArray_real32_T cfs2,
  int32_T expanded_dim0, int32_T cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    kk = static_cast<int32_T>(halfh);
    for (int32_T m{0}; m < kk; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] *
        static_cast<real32_T>(a);
    }

    cfs2.data[k + cfs2_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1237(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1238(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      y.data[itime].re = 0.0F;
      y.data[itime].im = ai / cfsposdft->re;
    } else {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1239(const
  int32_T cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel124(const
  emxArray_real_T y, const real_T a, const emxArray_real_T b_y, const real_T b_a,
  const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += b_a * b_y.data[itime] - a * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1240(const
  emxArray_real32_T cfs2, const int32_T b, const int32_T c, emxArray_creal32_T
  cfsDFT, int32_T cfsDFT_dim0, int32_T cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[kk + cfsDFT_dim0 * itime].re = cfs2.data[kk + cfs2_dim0 * itime];
    cfsDFT.data[kk + cfsDFT_dim0 * itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1241(const
  emxArray_real32_T cfs2, const int32_T b_cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = cfs2.data[itime];
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1242(const
  int32_T nrefine, const int32_T lidx, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    cfsDFT.data[(nrefine - i) - 1].re = cfsDFT.data[i + 1].re;
    cfsDFT.data[(nrefine - i) - 1].im = -cfsDFT.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1243(const
  int32_T nrefine, const int32_T cfsDFT, const int32_T lidx, emxArray_creal32_T
  b_cfsDFT, int32_T cfsDFT_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>(cfsDFT)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsDFT) + 1UL));
    i = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) /
      (static_cast<uint64_T>(cfsDFT) + 1UL));
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((nrefine - i) - 1)].re = b_cfsDFT.data[kk
      + cfsDFT_dim0 * (i + 1)].re;
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((nrefine - i) - 1)].im = -b_cfsDFT.data[kk
      + cfsDFT_dim0 * (i + 1)].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1244(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1245(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1246(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv9)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv9.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1247(const
  emxArray_real32_T a, const emxArray_int32_T iv9, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv9.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1248(const
  real_T a, const emxArray_real32_T expanded, const int32_T b, emxArray_real32_T
  c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1249(const
  int32_T smooth, emxArray_real32_T cfs1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs1.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel125(const real_T
  fa, const real_T r, const int32_T nsubs, const int32_T ix, const int32_T b,
  emxArray_real_T sinc4A, emxArray_real_T sinc3A, emxArray_real_T sinc2A,
  emxArray_real_T sinc1A)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T ack;
    real_T bb;
    real_T i2Map;
    real_T tkd1mtk;
    int32_T itime;
    uint32_T i1Map;
    itime = static_cast<int32_T>(idx);
    i1Map = (static_cast<uint32_T>(itime) + static_cast<uint32_T>(ix)) + 1U;
    tkd1mtk = (static_cast<real_T>(itime) + 1.0) - static_cast<real_T>(nsubs);
    ack = r * static_cast<real_T>(i1Map);
    i2Map = fa * static_cast<real_T>(i1Map);
    bb = r * tkd1mtk;
    tkd1mtk *= fa;
    if (fabs(ack) < 1.0020841800044864E-292) {
      sinc1A.data[itime] = 1.0;
    } else {
      ack *= 3.1415926535897931;
      sinc1A.data[itime] = sin(ack) / ack;
    }

    if (fabs(i2Map) < 1.0020841800044864E-292) {
      sinc2A.data[itime] = 1.0;
    } else {
      i2Map *= 3.1415926535897931;
      sinc2A.data[itime] = sin(i2Map) / i2Map;
    }

    if (fabs(bb) < 1.0020841800044864E-292) {
      sinc3A.data[itime] = 1.0;
    } else {
      bb *= 3.1415926535897931;
      sinc3A.data[itime] = sin(bb) / bb;
    }

    if (fabs(tkd1mtk) < 1.0020841800044864E-292) {
      sinc4A.data[itime] = 1.0;
    } else {
      tkd1mtk *= 3.1415926535897931;
      sinc4A.data[itime] = sin(tkd1mtk) / tkd1mtk;
    }
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1250(const real_T
  a, const emxArray_real32_T smooth, emxArray_real32_T b_smooth)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b_smooth.data[0] = smooth.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1251(const
  emxArray_real32_T smooth, emxArray_real32_T cfs1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfs1.data[0] = smooth.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1252(const
  int32_T smooth, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(smooth);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1253(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv8)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv8.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1254(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv10)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv10.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1255(const
  emxArray_real32_T smooth, const int32_T b_smooth, const int32_T b,
  emxArray_real32_T c_smooth, int32_T smooth_dim0, int32_T b_smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(b_smooth)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_smooth) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_smooth) + 1UL));
    c_smooth.data[kk + smooth_dim0 * itime] = smooth.data[kk + b_smooth_dim0 *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1256(const
  emxArray_real32_T smooth, const int32_T xt_size_dim0, const emxArray_int32_T
  iv10, const emxArray_int32_T iv8, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv8.data[kk] + expanded_dim0 * iv10.data[itime]] =
      smooth.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1257(const
  real_T a, const emxArray_real32_T expanded, const emxArray_int32_T rows, const
  real_T halfh, const int32_T b, const int32_T c, emxArray_real32_T cfs1,
  int32_T expanded_dim0, int32_T cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    kk = static_cast<int32_T>(halfh);
    for (int32_T m{0}; m < kk; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] *
        static_cast<real32_T>(a);
    }

    cfs1.data[k + cfs1_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1258(creal32_T
  *cfsposdft, int32_T x_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(x_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1259(const
  creal32_T *cfsposdft, const emxArray_creal32_T x, const int32_T b_x,
  emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = x.data[itime].re;
    ai = x.data[itime].im;
    if (ai == 0.0F) {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      y.data[itime].re = 0.0F;
      y.data[itime].im = ai / cfsposdft->re;
    } else {
      y.data[itime].re = cv / cfsposdft->re;
      y.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel126(const
  emxArray_real_T sinc4A, const emxArray_real_T sinc2A, const real_T fa, const
  emxArray_real_T sinc3A, const emxArray_real_T sinc1A, const real_T r, const
  int32_T nsubs, const int32_T b, const int32_T c, emxArray_real_T G, int32_T
  G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T itime;
    int32_T kk;
    uint32_T i1Map;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    i1Map = (static_cast<uint32_T>(kk) + static_cast<uint32_T>(itime)) + 1U;
    i2Map = static_cast<real_T>(kk - itime) + static_cast<real_T>(nsubs);
    G.data[kk + G_dim0 * itime] += 0.25 * (r * (sinc1A.data[static_cast<int32_T>
      (i1Map) - 1] + sinc3A.data[static_cast<int32_T>(i2Map) - 1]) - fa *
      (sinc2A.data[static_cast<int32_T>(i1Map) - 1] + sinc4A.data
       [static_cast<int32_T>(i2Map) - 1]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1260(const
  int32_T cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1261(const
  emxArray_real32_T cfs1, const int32_T b, const int32_T c, emxArray_creal32_T
  cfsDFT, int32_T cfsDFT_dim0, int32_T cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    cfsDFT.data[kk + cfsDFT_dim0 * itime].re = cfs1.data[kk + cfs1_dim0 * itime];
    cfsDFT.data[kk + cfsDFT_dim0 * itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1262(const
  emxArray_real32_T cfs1, const int32_T b_cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = cfs1.data[itime];
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1263(const
  int32_T nrefine, const int32_T lidx, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(lidx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    cfsDFT.data[(nrefine - i) - 1].re = cfsDFT.data[i + 1].re;
    cfsDFT.data[(nrefine - i) - 1].im = -cfsDFT.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1264(const
  int32_T nrefine, const int32_T cfsDFT, const int32_T lidx, emxArray_creal32_T
  b_cfsDFT, int32_T cfsDFT_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>(cfsDFT)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsDFT) + 1UL));
    i = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) /
      (static_cast<uint64_T>(cfsDFT) + 1UL));
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((nrefine - i) - 1)].re = b_cfsDFT.data[kk
      + cfsDFT_dim0 * (i + 1)].re;
    b_cfsDFT.data[kk + cfsDFT_dim0 * ((nrefine - i) - 1)].im = -b_cfsDFT.data[kk
      + cfsDFT_dim0 * (i + 1)].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1265(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1266(creal32_T
  *cfsposdft, int32_T cfsposdft_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(cfsposdft_dim1);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1267(const
  creal32_T *cfsposdft, const emxArray_creal32_T b_cfsposdft, const int32_T
  c_cfsposdft, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfsposdft);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfsposdft.data[itime].re;
    ai = b_cfsposdft.data[itime].im;
    if (ai == 0.0F) {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      cfspos.data[itime].re = 0.0F;
      cfspos.data[itime].im = ai / cfsposdft->re;
    } else {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1268(const
  int32_T b, emxArray_creal32_T xposdft, uint32_T xSize_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].re = xposdft.data[i
      + 1].re;
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].im =
      -xposdft.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1269(creal32_T
  *cfsposdft, int32_T cfsposdft_dim1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    cfsposdft->re = static_cast<real32_T>(cfsposdft_dim1);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel127(const real_T T,
  emxArray_real_T b0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b0.data[0] = T;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1270(const
  creal32_T *cfsposdft, const emxArray_creal32_T b_cfsposdft, const int32_T
  c_cfsposdft, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfsposdft);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfsposdft.data[itime].re;
    ai = b_cfsposdft.data[itime].im;
    if (ai == 0.0F) {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = 0.0F;
    } else if (cv == 0.0F) {
      cfspos.data[itime].re = 0.0F;
      cfspos.data[itime].im = ai / cfsposdft->re;
    } else {
      cfspos.data[itime].re = cv / cfsposdft->re;
      cfspos.data[itime].im = ai / cfsposdft->re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1271(const
  int32_T b, emxArray_creal32_T xposdft, uint32_T xSize_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].re = xposdft.data[i
      + 1].re;
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].im =
      -xposdft.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1272(const
  emxArray_real_T somega, const int32_T b_somega, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_somega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = (somega.data[itime] - 5.0) / 0.6;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1273(const
  emxArray_real_T w, const int32_T b_w, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_w);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expnt.data[itime] = -1.0 / (1.0 - w.data[itime] * w.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1274(const
  int32_T b, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    expnt.data[k] = exp(expnt.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1275(const
  emxArray_real_T w, const int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = fabs(w.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1276(const
  emxArray_real_T y, const emxArray_real_T expnt, const int32_T b_expnt,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_expnt);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 5.43656365691809 * expnt.data[itime] *
      static_cast<real_T>(y.data[itime] < 0.99999999999999978);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1277(const
  int32_T nrefine, emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nrefine);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    if (isnan(daughter.data[i])) {
      daughter.data[i] = 0.0;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1278(const
  emxArray_real_T fb_Omega, const emxArray_real_T fb_Scales, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T somega, int32_T somega_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_fb_Scales) + 1UL));
    somega.data[kk + somega_dim0 * itime] = fb_Scales.data[kk] *
      fb_Omega.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1279(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel128(const
  emxArray_real_T b, const int32_T c, emxArray_real_T b0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b0.data[itime + 1] = b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1280(const char_T
  cv[128], char_T wav[4], char_T wname[4], char_T a_dim0, char_T a_dim1, char_T
  a_dim2, char_T a_dim3)
{
  __shared__ char_T a_shared[4];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    a_shared[0] = a_dim0;
    a_shared[1] = a_dim1;
    a_shared[2] = a_dim2;
    a_shared[3] = a_dim3;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 4) {
    wname[k] = cv[static_cast<int32_T>(a_shared[k])];
    wav[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(a_shared[k])])];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1281(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel1282(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1283(const int32_T
  nx, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[nx];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1284(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel1285(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1286(const int32_T
  nx, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[nx];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel1287
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1288(const
  emxArray_real_T y, const real_T fa, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(fa, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1289(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel129(const
  emxArray_real_T b0, const int32_T b_b0, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b0);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = b0.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1290(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1291(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1292(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1293(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1294(const
  real_T x_data[9735], const int32_T b, real_T dv15_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv15_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1295(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1296(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1297(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv15_data[9735],
  const int32_T dv15_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv15_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv15_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1298(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1299(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel13(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel130(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1300(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1301(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1302(const
  real_T x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1303(const
  real_T x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T
  a_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1304(const
  real_T a_data[9735], const int32_T b, real_T dv9_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv9_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1305(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1306(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1307(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv9_data[9735],
  const int32_T dv9_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv9_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv9_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1308(const
  int32_T b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1309(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel131(const
  emxArray_real_T a, const int32_T lidx, const int32_T nrefine, const int32_T nx,
  emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = a.data[nrefine + lidx * itime] / 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1310(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1311(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1312(const
  real_T x_data[9735], const int32_T b, real_T dv8_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv8_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1313(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1314(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1315(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv8_data[9735],
  const int32_T dv8_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv8_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv8_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1316(const
  real_T interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1317(const
  real_T x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1318(const
  int32_T b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1319(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel132(const
  emxArray_real_T a, const int32_T lidx, const int32_T nrefine, const int32_T
  pathlen, emxArray_real_T h)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    h.data[div_s32_device(pathlen - nrefine, lidx) + 1] = a.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1320(const
  real_T x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1321(const
  real_T x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T
  a_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1322(const
  real_T a_data[9735], const int32_T b, real_T dv2_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv2_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1323(const
  real_T x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1324(const
  real_T y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel1325(const
  real_T xt_data[9735], const real_T x_data[9735], const real_T dv2_data[9735],
  const int32_T dv2_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv2_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv2_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel133(const
  int32_T b, emxArray_real_T dv27)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv27.data[itime] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel134(const
  emxArray_real_T dv27, const emxArray_real_T h, const int32_T b_h,
  emxArray_real_T h1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h1.data[itime] = h.data[itime] * dv27.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel135(const real_T
  halfh, const emxArray_real_T h1, const real_T toler, const int32_T b_h1,
  emxArray_real32_T opts_filter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_filter.data[itime] = static_cast<real32_T>(toler * h1.data[itime] /
      halfh);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel136(const
  int32_T halfh, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(halfh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel137(const
  emxArray_uint32_T y, const real_T halfh, const int32_T b_y, emxArray_int32_T
  iv92)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv92.data[itime] = static_cast<int32_T>(halfh + static_cast<real_T>
      (y.data[itime]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel138(const
  emxArray_real32_T opts_filter, const emxArray_int32_T iv92, const int32_T
  b_iv92, emxArray_real32_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_iv92);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[iv92.data[itime] - 1] = opts_filter.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel139(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel14(const
  emxArray_real_T y, const real_T s, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(s, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel140(const
  emxArray_creal32_T b_y1, const int32_T b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel141(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel142(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel143(const real_T
  toler, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel144(const
  emxArray_real32_T h, const emxArray_creal32_T yCol, real32_T *cv_re,
  emxArray_creal32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel145(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel146(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel147(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel148(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel149(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel15(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel150(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel151(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel152(const
  emxArray_creal32_T y, const int32_T xt_size, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel153
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel154(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel155(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel156(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel157(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel158(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel159(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel16(const
  emxArray_real_T somega, const int32_T b_somega, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_somega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expnt.data[itime] = -((somega.data[itime] - 6.0) * (somega.data[itime] - 6.0))
      / 2.0 * static_cast<real_T>(somega.data[itime] > 0.0);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel160(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel161(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel162(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv161)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv161.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel163(const
  emxArray_real32_T h, const emxArray_int32_T iv161, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv161.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel164(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const int32_T csz[2], const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T k;
    int32_T nw;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    for (int32_T m{0}; m < nw; m++) {
      creal32_T b_b;
      int32_T kcounter;
      b_b = yCol.data[(nw - m) - 1];
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.re += expanded.data[kcounter - 1] * b_b.re;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.im += expanded.data[kcounter - 1] * b_b.im;
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel165(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel166(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel167(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel168(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel169(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel17(const int32_T
  b, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    expnt.data[k] = exp(expnt.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel170(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel171(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel172(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv163)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv163.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel173(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv163, const int32_T xt_size,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv163.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel174(const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[kcounter - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel175(const real32_T
  cv_im, const real32_T cv_re, const int32_T nx, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx].re = cv_re;
    w.data[nx].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel176(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel177(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel178
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel179(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel18(const
  emxArray_real_T somega, const emxArray_real_T expnt, const int32_T b_expnt,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_expnt);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 2.0 * expnt.data[itime] * static_cast<real_T>
      (somega.data[itime] > 0.0);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel180(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel181(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel182(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel183(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel184(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel185(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel186(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel187(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel188(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel189(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel19(const
  emxArray_real_T daughter, const int32_T b_daughter, emxArray_real32_T psihat)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_daughter);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    psihat.data[itime] = static_cast<real32_T>(daughter.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel190(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel191(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv141)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv141.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel192(const
  emxArray_creal32_T a, const emxArray_int32_T iv141, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv141.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel193(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel194(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel195(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel196(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel197(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel198(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel199(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel2(const char_T cv
  [128], char_T wname[4], char_T wav[4], char_T a_dim0, char_T a_dim1, char_T
  a_dim2, char_T a_dim3)
{
  __shared__ char_T a_shared[4];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    a_shared[0] = a_dim0;
    a_shared[1] = a_dim1;
    a_shared[2] = a_dim2;
    a_shared[3] = a_dim3;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 4) {
    wav[k] = cv[static_cast<int32_T>(a_shared[k])];
    wname[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(a_shared[k])])];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel20(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b_x, emxArray_real32_T xv,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel200(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv143)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv143.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel201(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv143, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv143.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel202(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel203(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel204(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel205(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel206(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel207(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel208(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel209(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel21(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b, emxArray_real32_T b_x,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_x.data[itime] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel210(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv148)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv148.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel211(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv166)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv166.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel212(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv166, const emxArray_int32_T iv148, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv148.data[kk] + expanded_dim0 * iv166.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel213(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel214(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel22(const int32_T
  fb_SignalPad, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    real32_T cv;
    kk = static_cast<int32_T>(idx);
    itime = (fb_SignalPad - kk) - 1;
    cv = x.data[kk];
    x.data[kk] = x.data[itime];
    x.data[itime] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel23(const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel24(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b, emxArray_real32_T xv,
  int32_T x_dim1, int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime + x_dim1] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel245(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel246(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel247
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel248(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel249(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel25(const int32_T
  lidx, const int32_T ix, const int32_T nsubs, const emxArray_real32_T x, const
  int32_T nx, emxArray_real32_T xv, int32_T x_dim0, int32_T x_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[(itime + x_dim0) + x_dim1] = x.data[(nsubs + ix * itime) + x_dim0 *
      (lidx - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel250(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel251(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel252(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel253(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel254(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel255(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel256
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel257(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel258(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel259(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel26(const
  emxArray_real32_T xv, const int32_T b_xv, emxArray_creal32_T xposdft)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xv);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xposdft.data[itime].re = xv.data[itime];
    xposdft.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel260(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel261(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel262(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel263(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel264(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel265(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv147)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv147.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel266(const
  emxArray_creal32_T a, const emxArray_int32_T iv147, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv147.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel267(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel268(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel269(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel27(const
  emxArray_creal32_T xposdft, const emxArray_real32_T psihat, const int32_T ix,
  const int32_T cfsposdft, const int32_T lidx, emxArray_creal32_T b_cfsposdft,
  int32_T psihat_dim0, int32_T cfsposdft_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>
    (cfsposdft) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    int32_T kcounter;
    int32_T kk;
    kcounter = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsposdft) +
      1UL));
    k = static_cast<int32_T>((idx - static_cast<uint64_T>(kcounter)) / (
      static_cast<uint64_T>(cfsposdft) + 1UL));
    itime = ix * k + 1;
    kk = static_cast<int32_T>(psihat_dim0 != 1);
    b_cfsposdft.data[kcounter + cfsposdft_dim0 * k].re = psihat.data[kk *
      kcounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].re;
    b_cfsposdft.data[kcounter + cfsposdft_dim0 * k].im = psihat.data[kk *
      kcounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel270(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel271(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel272(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel273(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel274(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv151)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv151.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel275(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv151, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv151.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel276(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel277(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel278(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel279(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel28(const int32_T
  xSize, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfspos.data[itime].re = 0.0F;
    cfspos.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel280(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel281(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel282(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel283(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel284(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv154)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv154.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel285(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv171)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv171.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel286(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv171, const emxArray_int32_T iv154, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv154.data[kk] + expanded_dim0 * iv171.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel287(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel288(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel29(const
  emxArray_real_T daughter, const int32_T b_daughter, emxArray_real32_T psihat)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_daughter);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    psihat.data[itime] = static_cast<real32_T>(daughter.data[itime]);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel3(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel30(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b_x, emxArray_real32_T xv,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel31(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b, emxArray_real32_T b_x,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_x.data[itime] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel319(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel32(const int32_T
  fb_SignalPad, const int32_T b, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    real32_T cv;
    kk = static_cast<int32_T>(idx);
    itime = (fb_SignalPad - kk) - 1;
    cv = x.data[kk];
    x.data[kk] = x.data[itime];
    x.data[itime] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel320(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel321(const real_T
  toler, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel322(const
  emxArray_real32_T h, const emxArray_creal32_T yCol, real32_T *cv_re,
  emxArray_creal32_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel323(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel324(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel325(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel326(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel327(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel328(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel329(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel33(const
  emxArray_real32_T x, const int32_T b, emxArray_real32_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel330(const
  emxArray_creal32_T y, const int32_T xt_size, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel331
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel332(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel333(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel334(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel335(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel336(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel337(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel338(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel339(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel34(const int32_T
  nrefine, const emxArray_real32_T x, const int32_T b, emxArray_real32_T xv,
  int32_T x_dim1, int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime + x_dim1] = x.data[itime + x_dim0 * (nrefine - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel340(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv160)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv160.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel341(const
  emxArray_real32_T h, const emxArray_int32_T iv160, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv160.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel342(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const int32_T csz[2], const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T k;
    int32_T nw;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    for (int32_T m{0}; m < nw; m++) {
      creal32_T b_b;
      int32_T kcounter;
      b_b = yCol.data[(nw - m) - 1];
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.re += expanded.data[kcounter - 1] * b_b.re;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.im += expanded.data[kcounter - 1] * b_b.im;
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel343(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel344(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel345(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel346(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel347(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel348(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel349(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel35(const int32_T
  lidx, const int32_T pathlen, const int32_T ix, const emxArray_real32_T x,
  const int32_T nx, emxArray_real32_T xv, int32_T x_dim0, int32_T x_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[(itime + x_dim0) + x_dim1] = x.data[(ix + pathlen * itime) + x_dim0 *
      (lidx - 1)];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel350(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv162)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv162.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel351(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv162, const int32_T xt_size,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv162.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel352(const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[kcounter - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel353(const real32_T
  cv_im, const real32_T cv_re, const int32_T nx, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx].re = cv_re;
    w.data[nx].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel354(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel355(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel356
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel357(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel358(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel359(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel36(const
  emxArray_real32_T xv, const int32_T b_xv, emxArray_creal32_T xposdft)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xv);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xposdft.data[itime].re = xv.data[itime];
    xposdft.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel360(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel361(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel362(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel363(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel364(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel365(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel366(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel367(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel368(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel369(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv140)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv140.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel37(const
  emxArray_creal32_T xposdft, const emxArray_real32_T psihat, const int32_T ix,
  const int32_T cfsposdft, const int32_T lidx, emxArray_creal32_T b_cfsposdft,
  int32_T psihat_dim0, int32_T cfsposdft_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(lidx) + 1UL) * (static_cast<uint64_T>
    (cfsposdft) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T k;
    int32_T kcounter;
    int32_T kk;
    kcounter = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsposdft) +
      1UL));
    k = static_cast<int32_T>((idx - static_cast<uint64_T>(kcounter)) / (
      static_cast<uint64_T>(cfsposdft) + 1UL));
    itime = ix * k + 1;
    kk = static_cast<int32_T>(psihat_dim0 != 1);
    b_cfsposdft.data[kcounter + cfsposdft_dim0 * k].re = psihat.data[kk *
      kcounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].re;
    b_cfsposdft.data[kcounter + cfsposdft_dim0 * k].im = psihat.data[kk *
      kcounter + psihat_dim0 * (itime - 1)] * xposdft.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel370(const
  emxArray_creal32_T a, const emxArray_int32_T iv140, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv140.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel371(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel372(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel373(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel374(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel375(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel376(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel377(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel378(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv142)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv142.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel379(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv142, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv142.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel38(const int32_T
  xSize, emxArray_creal32_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfspos.data[itime].re = 0.0F;
    cfspos.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel380(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel381(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel382(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel383(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel384(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel385(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel386(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel387(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel388(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv146)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv146.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel389(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv165)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv165.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel39(const
  emxArray_creal32_T cfspos, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(cfspos.data[k].re, cfspos.data[k].im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel390(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv165, const emxArray_int32_T iv146, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv146.data[kk] + expanded_dim0 * iv165.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel391(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel392(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel4(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel40(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T cfs1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    cfs1.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel41(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel42(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel423(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel424(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel425
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel426(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel427(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel428(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel429(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel43(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel430(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel431(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel432(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel433(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel434
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel435(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel436(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel437(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel438(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel439(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel44(const int32_T
  pathlen, const int32_T nrefine, const emxArray_real_T omega_tmp2, const
  int32_T nx, emxArray_real_T omega, int32_T omega_tmp2_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[(itime + omega_tmp2_dim1) + 1] = -omega_tmp2.data[nrefine +
      pathlen * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel440(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel441(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel442(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel443(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv145)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv145.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel444(const
  emxArray_creal32_T a, const emxArray_int32_T iv145, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv145.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel445(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel446(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel447(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel448(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel449(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel45(const int32_T
  cfs1, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel450(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel451(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel452(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv150)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv150.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel453(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv150, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv150.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel454(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel455(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel456(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel457(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel458(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel459(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel46(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel460(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel461(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel462(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv153)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv153.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel463(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv170)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv170.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel464(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv170, const emxArray_int32_T iv153, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv153.data[kk] + expanded_dim0 * iv170.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel465(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel466(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel47(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel48(const int32_T
  xSize, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime].re = 0.0F;
    y.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel49(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_real32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime] = y.data[itime].re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel497(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel498(const
  emxArray_creal32_T opts_x, const int32_T nx, const int32_T i267, const int32_T
  b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[i267 * itime] = opts_x.data[nx];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel499(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel5(const int32_T nx,
  real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[nx];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel50(const
  emxArray_real32_T smooth, const int32_T b, emxArray_real32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel500(const
  emxArray_creal32_T w, const int32_T lidx, const int32_T b, emxArray_creal32_T
  y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[lidx * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel501
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel502(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  nx, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime + y1_dim0 * nx] = y.data[static_cast<int32_T>(T +
      b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel503(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel504(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel505(const
  emxArray_creal32_T yCol, creal32_T *cfsposdft)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *cfsposdft = yCol.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel506(const
  creal32_T *cfsposdft, const emxArray_real32_T h, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0] * cfsposdft->re;
    *f = h.data[0] * cfsposdft->im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel507(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = *f;
    w.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel508(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel509(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv139)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv139.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel51(const int32_T
  a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel510(const
  emxArray_real32_T h, const emxArray_int32_T iv139, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv139.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel511(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const real_T toler, const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    k = static_cast<int32_T>(idx);
    cv.re = 0.0F;
    cv.im = 0.0F;
    itime = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < itime; m++) {
      creal32_T b_b;
      int32_T kcounter;
      b_b = yCol.data[(static_cast<int32_T>(toler) - m) - 1];
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.re += expanded.data[kcounter - 1] * b_b.re;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.im += expanded.data[kcounter - 1] * b_b.im;
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel512(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel513(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel514(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel515(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv138)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv138.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel516(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv138, const int32_T
  omega_tmp2, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv138.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel517(const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if ((nx + 1 < 0) && (kcounter < MAX_int32_T - nx)) {
      kcounter = MIN_int32_T;
    } else if ((nx + 1 > 0) && (kcounter > 2147483646 - nx)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[kcounter - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel518(const real32_T
  cv_im, const real32_T cv_re, const int32_T nx, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx].re = cv_re;
    w.data[nx].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel519(const
  emxArray_creal32_T b_y1, const int32_T crossCFS, emxArray_creal32_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel52(const real_T a,
  const emxArray_real32_T b_a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = b_a.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel520(const
  emxArray_creal32_T b_y1, const int32_T c_y1, const int32_T d_y1,
  emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(d_y1) + 1UL) * (static_cast<uint64_T>(c_y1) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y1) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y1) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = b_y1.data[itime + y1_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel521(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel522(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel523(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel524(const
  emxArray_creal32_T yCol, const emxArray_real32_T h, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].re = h.data[0] * yCol.data[0].re;
    w.data[0].im = h.data[0] * yCol.data[0].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel525(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel526(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel527(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel528(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel529(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel53(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T cfs1, int32_T
  cfs1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs1.data[cfs1_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel530(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel531(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel532(const
  emxArray_creal32_T y, const int32_T xt_size, emxArray_creal32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel533
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel534(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_creal32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel535(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel536(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel537(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel538(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel539(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel54(const
  emxArray_creal32_T cfspos, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(cfspos.data[k].re, cfspos.data[k].im);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel540(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel541(const
  int32_T b, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel542(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv167)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv167.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel543(const
  emxArray_real32_T h, const emxArray_int32_T iv167, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv167.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel544(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_creal32_T yCol, const real_T toler, const int32_T b,
  emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T k;
    int32_T nw;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = static_cast<int32_T>(toler);
    for (int32_T m{0}; m < nw; m++) {
      creal32_T b_b;
      int32_T kcounter;
      b_b = yCol.data[(static_cast<int32_T>(toler) - m) - 1];
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.re += expanded.data[kcounter - 1] * b_b.re;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv.im += expanded.data[kcounter - 1] * b_b.im;
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel545(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel546(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel547(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel548(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel549(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel55(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T cfs2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    cfs2.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel550(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel551(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel552(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv169)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv169.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel553(const
  emxArray_creal32_T yCol, const emxArray_int32_T iv169, const int32_T xt_size,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv169.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel554(const
  emxArray_creal32_T expanded, const int32_T nx, const emxArray_int32_T rows,
  const int32_T b_rows, emxArray_creal32_T newIm)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[kcounter - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel555(const real32_T
  cv_im, const real32_T cv_re, const int32_T nx, emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx].re = cv_re;
    w.data[nx].im = cv_im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel556(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel557(const
  emxArray_creal32_T opts_x, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel558
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel559(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel56(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel560(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel561(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel562(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel563(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel564(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel565(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel566(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel567(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel568(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel569(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel57(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel570(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel571(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv144)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv144.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel572(const
  emxArray_creal32_T a, const emxArray_int32_T iv144, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv144.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel573(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel574(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel575(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel576(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel577(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel578(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel579(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel58(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel580(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv149)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv149.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel581(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv149, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv149.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel582(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel583(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel584(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel585(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel586(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel587(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel588(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel589(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel59(const int32_T
  nrefine, const int32_T lidx, const emxArray_real_T omega_tmp2, const int32_T
  nx, emxArray_real_T omega, int32_T omega_tmp2_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[(itime + omega_tmp2_dim1) + 1] = -omega_tmp2.data[lidx + nrefine *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel590(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv152)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv152.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel591(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv168)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv168.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel592(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv168, const emxArray_int32_T iv152, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv152.data[kk] + expanded_dim0 * iv168.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel593(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel594(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel6(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel60(const int32_T
  cfs2, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(cfs2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel61(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel62(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel625(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel626(const
  int32_T b, emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime].re = 0.0F;
    yCol.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel627(const
  emxArray_creal32_T xCol, const int32_T nrefine, const int32_T omega_tmp2,
  emxArray_creal32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nrefine * itime] = xCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel628
  (emxArray_creal32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0].im = 0.0F;
    w.data[0].re = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel629(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel63(const int32_T
  xSize, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime].re = 0.0F;
    y.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel630(const int32_T
  lidx, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel631(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel632(const
  emxArray_creal32_T w, const int32_T xt_size, emxArray_creal32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel633(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_creal32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel634(const
  emxArray_creal32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_creal32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel635(const
  emxArray_creal32_T y, const int32_T omega_tmp2, emxArray_creal32_T b_y,
  int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel636(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_creal32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel637
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel638(const
  emxArray_creal32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_creal32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel639(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel64(const
  emxArray_creal32_T y, const int32_T b_y, emxArray_real32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime] = y.data[itime].re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel640(const
  emxArray_creal32_T yCol, const int32_T b, emxArray_creal32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel641(const
  int32_T a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel642(const
  emxArray_creal32_T a, const real32_T cv_re, real32_T *f, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = cv_re * a.data[0].re;
    *f = cv_re * a.data[0].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel643(const real32_T
  *f1, const real32_T *f, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = *f;
    c.data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel644(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel645(const
  int32_T a, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel646(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv155)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv155.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel647(const
  emxArray_creal32_T a, const emxArray_int32_T iv155, const int32_T omega_tmp2,
  emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv155.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel648(const
  emxArray_creal32_T expanded, const real32_T cv_re, const int32_T b,
  emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k].re = cv_re * expanded.data[k].re;
    c.data[k].im = cv_re * expanded.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel649(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel65(const
  emxArray_real32_T smooth, const int32_T b, emxArray_real32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel650(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel651(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel652(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel653(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    creal32_T b;
    b.re = a_data[0].re * yCol.data[0].re - 0.0F * yCol.data[0].im;
    b.im = a_data[0].re * yCol.data[0].im + 0.0F * yCol.data[0].re;
    w.data[0] = b;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel654(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel655(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv158)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv158.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel656(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv158, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv158.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel657(const
  emxArray_real32_T expanded, const emxArray_int32_T cols, const
  emxArray_int32_T rows, const emxArray_creal32_T yCol, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_creal32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal32_T cv;
    int32_T itime;
    int32_T k;
    int32_T nw;
    int32_T ocol;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv.re = 0.0F;
    cv.im = 0.0F;
    nw = csz[0];
    itime = csz[1];
    for (int32_T n{0}; n < itime; n++) {
      for (int32_T m{0}; m < nw; m++) {
        creal32_T b_b;
        int32_T i;
        int32_T kcounter;
        b_b = yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.re += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.re;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv.im += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          b_b.im;
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel658(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel659(const
  int32_T b, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime].re = 0.0F;
    w.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel66(const int32_T
  a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel660(const
  emxArray_real32_T h, real32_T *f1)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *f1 = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel661(const real32_T
  *f1, creal32_T a_data[1])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a_data[0].re = *f1;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel662(const
  emxArray_creal32_T yCol, const creal32_T a_data[1], emxArray_creal32_T b_yCol)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    b_yCol.data[0].re = 0.0F;
    b_yCol.data[0].im = 0.0F;
    cv = a_data[0].re;
    b_yCol.data[0].re += yCol.data[0].re * cv - yCol.data[0].im * 0.0F;
    b_yCol.data[0].im += yCol.data[0].re * 0.0F + yCol.data[0].im * cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel663(const
  emxArray_creal32_T yCol, const int32_T xt_size, emxArray_creal32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel664(const
  int32_T x_size_idx_1, emxArray_creal32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime].re = 0.0F;
    expanded.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel665(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv159)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv159.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel666(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv176)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv176.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel667(const
  emxArray_creal32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv176, const emxArray_int32_T iv159, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_creal32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv159.data[kk] + expanded_dim0 * iv176.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel668(const
  int32_T nrefine, const emxArray_creal32_T expanded, const int32_T nx, const
  emxArray_int32_T rows, const int32_T b_rows, emxArray_creal32_T newIm, int32_T
  expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_rows);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = rows.data[itime];
    if (kcounter > 2147483646 - nx) {
      kcounter = MAX_int32_T;
    } else {
      kcounter = (nx + kcounter) + 1;
    }

    newIm.data[itime] = expanded.data[(kcounter + expanded_dim0 * nrefine) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel669(const real32_T
  cv_im, const real32_T cv_re, const int32_T nrefine, const int32_T nx,
  emxArray_creal32_T w, int32_T w_dim0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[nx + w_dim0 * nrefine].re = cv_re;
    w.data[nx + w_dim0 * nrefine].im = cv_im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel67(const real_T a,
  const emxArray_real32_T b_a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = b_a.data[0] * static_cast<real32_T>(a);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel68(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T cfs2, int32_T
  cfs2_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfs2.data[cfs2_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel69(const
  emxArray_creal32_T cfspos, const emxArray_creal32_T b_cfspos, const int32_T
  c_cfspos, emxArray_creal32_T crossCFS)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c_cfspos);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    real32_T ai;
    real32_T cv;
    itime = static_cast<int32_T>(idx);
    cv = b_cfspos.data[itime].re;
    ai = -b_cfspos.data[itime].im;
    crossCFS.data[itime].re = cfspos.data[itime].re * cv - cfspos.data[itime].im
      * ai;
    crossCFS.data[itime].im = cfspos.data[itime].re * ai + cfspos.data[itime].im
      * cv;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_wtcc_kernel7(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel70(const real_T
  s, const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1,
  emxArray_real_T omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel700(const
  emxArray_creal32_T opts_x, const int32_T b_opts_x, emxArray_creal32_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel701(const
  int32_T b, emxArray_uint32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<uint32_T>(itime) + 1U;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel702(const
  creal_T *dc6, const real_T table100[100], const creal_T dc7, const creal_T *dc,
  const int32_T nsubs, const int32_T lidx, const int32_T nrefine, const int32_T
  i, const int64_T b, emxArray_real_T dv27, real_T q1_dim0, real_T q1_dim1,
  real_T q1_dim2, real_T q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6,
  real_T q1_dim7, real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3,
  real_T p1_dim4, real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0,
  real_T q2_dim1, real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5,
  real_T q2_dim6, real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2,
  real_T p2_dim3, real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7,
  real_T q4_dim0, real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4,
  real_T q4_dim5, real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1,
  real_T p4_dim2, real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6,
  real_T p4_dim7, real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3,
  real_T c_dim4, real_T c_dim5, real_T c_dim6)
{
  __shared__ real_T p1_shared[8];
  __shared__ real_T p2_shared[8];
  __shared__ real_T p4_shared[8];
  __shared__ real_T q1_shared[8];
  __shared__ real_T q2_shared[8];
  __shared__ real_T q4_shared[8];
  __shared__ real_T c_shared[7];
  creal_T z;
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  int32_T itime;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    p1_shared[0] = p1_dim0;
    p1_shared[1] = p1_dim1;
    p1_shared[2] = p1_dim2;
    p1_shared[3] = p1_dim3;
    p1_shared[4] = p1_dim4;
    p1_shared[5] = p1_dim5;
    p1_shared[6] = p1_dim6;
    p1_shared[7] = p1_dim7;
    q1_shared[0] = q1_dim0;
    q1_shared[1] = q1_dim1;
    q1_shared[2] = q1_dim2;
    q1_shared[3] = q1_dim3;
    q1_shared[4] = q1_dim4;
    q1_shared[5] = q1_dim5;
    q1_shared[6] = q1_dim6;
    q1_shared[7] = q1_dim7;
    p2_shared[0] = p2_dim0;
    p2_shared[1] = p2_dim1;
    p2_shared[2] = p2_dim2;
    p2_shared[3] = p2_dim3;
    p2_shared[4] = p2_dim4;
    p2_shared[5] = p2_dim5;
    p2_shared[6] = p2_dim6;
    p2_shared[7] = p2_dim7;
    q2_shared[0] = q2_dim0;
    q2_shared[1] = q2_dim1;
    q2_shared[2] = q2_dim2;
    q2_shared[3] = q2_dim3;
    q2_shared[4] = q2_dim4;
    q2_shared[5] = q2_dim5;
    q2_shared[6] = q2_dim6;
    q2_shared[7] = q2_dim7;
    p4_shared[0] = p4_dim0;
    p4_shared[1] = p4_dim1;
    p4_shared[2] = p4_dim2;
    p4_shared[3] = p4_dim3;
    p4_shared[4] = p4_dim4;
    p4_shared[5] = p4_dim5;
    p4_shared[6] = p4_dim6;
    p4_shared[7] = p4_dim7;
    q4_shared[0] = q4_dim0;
    q4_shared[1] = q4_dim1;
    q4_shared[2] = q4_dim2;
    q4_shared[3] = q4_dim3;
    q4_shared[4] = q4_dim4;
    q4_shared[5] = q4_dim5;
    q4_shared[6] = q4_dim6;
    q4_shared[7] = q4_dim7;
    c_shared[0] = c_dim0;
    c_shared[1] = c_dim1;
    c_shared[2] = c_dim2;
    c_shared[3] = c_dim3;
    c_shared[4] = c_dim4;
    c_shared[5] = c_dim5;
    c_shared[6] = c_dim6;
  }

  __syncthreads();
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal_T tmp;
    creal_T zd;
    int64_T k;
    real_T tkd1mtk;
    k = static_cast<int64_T>(idx);
    tkd1mtk = static_cast<real_T>(nrefine + (((static_cast<int32_T>(static_cast<
      int64_T>(i) + k) - lidx) - 1) << 1)) / (static_cast<real_T>(nsubs) - 1.0);
    zd.re = 5.0 * sqrt((1.0 - tkd1mtk) * (tkd1mtk + 1.0));
    if (isnan(zd.re)) {
      tmp = *dc;
    } else {
      creal_T dk;
      creal_T p1;
      creal_T pt;
      real_T aa;
      real_T ack;
      real_T ak;
      real_T b_atol;
      real_T bb;
      real_T i2Map;
      real_T im;
      real_T re;
      int32_T nw;
      int32_T ocol;
      boolean_T guard1;
      ocol = 0;
      i2Map = hypot(zd.re, 0.0);
      if (i2Map > 1.0737418235E+9) {
        ocol = 4;
      } else if (i2Map > 32767.999992370605) {
        ocol = 3;
      }

      tmp.re = 0.0;
      tmp.im = 0.0;
      bb = hypot(zd.re, 0.0);
      guard1 = false;
      if (bb <= 2.0) {
        nw = 0;
        b_atol = hypot(zd.re, 0.0);
        if (b_atol == 0.0) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else if (b_atol < 2.2250738585072014E-305) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else {
          pt.re = 0.5 * zd.re;
          if (b_atol > 4.7170688552396617E-153) {
            dk.re = pt.re * pt.re;
            ack = hypot(dk.re, 0.0);
          } else {
            dk.re = 0.0;
            ack = 0.0;
          }

          i2Map = pt.re;
          if (log(i2Map) * 0.0 > -700.92179369444591) {
            b_atol = 2.2204460492503131E-16 * ack;
            pt.re = 1.0;
            pt.im = 0.0;
            if (!static_cast<int32_T>(ack < 2.2204460492503131E-16)) {
              p1.re = 1.0;
              p1.im = 0.0;
              ak = 3.0;
              i2Map = 1.0;
              aa = 2.0;
              do {
                tkd1mtk = 1.0 / i2Map;
                re = p1.re * dk.re - p1.im * 0.0;
                im = p1.re * 0.0 + p1.im * dk.re;
                p1.re = tkd1mtk * re;
                p1.im = tkd1mtk * im;
                pt.re += p1.re;
                pt.im += p1.im;
                i2Map += ak;
                ak += 2.0;
                aa = aa * ack * tkd1mtk;
              } while (!!static_cast<int32_T>(aa > b_atol));
            }

            i2Map = pt.re - pt.im * 0.0;
            tkd1mtk = pt.re * 0.0 + pt.im;
            tmp.re = i2Map - tkd1mtk * 0.0;
            tmp.im = i2Map * 0.0 + tkd1mtk;
          } else {
            nw = 1;
            if (ack > 0.0) {
              nw = -1;
            }
          }
        }

        if (nw < 0) {
          itime = 1;
        } else {
          itime = nw;
        }

        if ((1 - itime != 0) && (nw < 0)) {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        if (bb < 21.784271729432426) {
          creal_T ck;
          creal_T cs1;
          creal_T cs2;
          int32_T b_i;
          int32_T kk;
          boolean_T errflag;
          boolean_T exitg1;
          nw = 0;
          b_atol = hypot(zd.re, 0.0);
          aa = floor(b_atol);
          ck.re = (aa + 1.0) / zd.re;
          cs2.re = 2.0 / zd.re;
          p1.re = 0.0;
          p1.im = 0.0;
          cs1.re = 1.0;
          cs1.im = 0.0;
          ack = ((aa + 1.0) + 1.0) / b_atol;
          tkd1mtk = ack + sqrt(ack * ack - 1.0);
          i2Map = tkd1mtk * tkd1mtk;
          bb = (i2Map + i2Map) / ((i2Map - 1.0) * (tkd1mtk - 1.0)) /
            2.2204460492503131E-16;
          ak = aa + 1.0;
          errflag = true;
          kk = 0;
          b_i = 1;
          exitg1 = false;
          while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) && (b_i
                  < 81)) {
            kk++;
            pt = cs1;
            tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
            ack = ck.re * cs1.im + 0.0 * cs1.re;
            cs1.re = p1.re - tkd1mtk;
            cs1.im = p1.im - ack;
            p1 = pt;
            ck.re += cs2.re;
            if (hypot(cs1.re, cs1.im) > bb * ak * ak) {
              errflag = false;
              exitg1 = true;
            } else {
              ak++;
              b_i++;
            }
          }

          if (errflag) {
            nw = -2;
          } else {
            int32_T kcounter;
            boolean_T guard2;
            kk++;
            kcounter = 0;
            guard2 = false;
            if (static_cast<int32_T>(aa) <= 0) {
              p1.re = 0.0;
              p1.im = 0.0;
              cs1.re = 1.0;
              cs1.im = 0.0;
              ck.re = 1.0 / zd.re;
              bb = sqrt(1.0 / b_atol / 2.2204460492503131E-16);
              itime = 1;
              errflag = true;
              b_i = 1;
              exitg1 = false;
              while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                     (b_i < 81)) {
                kcounter++;
                pt = cs1;
                tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
                ack = ck.re * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re - tkd1mtk;
                cs1.im = p1.im - ack;
                p1 = pt;
                ck.re += cs2.re;
                i2Map = hypot(cs1.re, cs1.im);
                if (i2Map >= bb * ak * ak) {
                  if (itime == 2) {
                    errflag = false;
                    exitg1 = true;
                  } else {
                    ack = hypot(ck.re, 0.0);
                    tkd1mtk = fmin(ack + sqrt(ack * ack - 1.0), i2Map / hypot
                                   (pt.re, pt.im));
                    bb *= sqrt(tkd1mtk / (tkd1mtk * tkd1mtk - 1.0));
                    itime = 2;
                    b_i++;
                  }
                } else {
                  b_i++;
                }
              }

              if (errflag) {
                nw = -2;
              } else {
                guard2 = true;
              }
            } else {
              guard2 = true;
            }

            if (guard2) {
              itime = kk + static_cast<int32_T>(aa);
              kk = kcounter + 1;
              if (itime >= kk) {
                kk = itime;
              }

              aa = static_cast<real_T>(kk);
              p1.re = 0.0;
              p1.im = 0.0;
              cs1 = dc7;
              bb = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  bb = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) + (static_cast<real_T>
                    (kk) + 1.0) * ((static_cast<real_T>(kk) + 1.0) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) +
                    (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  bb = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  bb = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((static_cast<
                    real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  bb = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              tkd1mtk = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) +
                    (static_cast<real_T>(kk) + 1.0) * ((static_cast<real_T>(kk)
                    + 1.0) * (i2Map / tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) + (((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  tkd1mtk = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  tkd1mtk = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) *
                    ((((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                      tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((
                    static_cast<real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  tkd1mtk = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              bb = exp(bb - tkd1mtk);
              dk.re = 0.0;
              dk.im = 0.0;
              for (b_i = 0; b_i < kk; b_i++) {
                pt = cs1;
                i2Map = aa * cs2.re;
                tkd1mtk = i2Map * cs1.re - 0.0 * cs1.im;
                i2Map = i2Map * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re + tkd1mtk;
                cs1.im = p1.im + i2Map;
                p1 = pt;
                ack = bb * (1.0 - 0.0 / aa);
                dk.re += (ack + bb) * pt.re;
                dk.im += (ack + bb) * pt.im;
                bb = ack;
                aa--;
              }

              tmp = cs1;
              pt.re = log(cs2.re);
              re = 0.0 * pt.re;
              im = 0.0 * pt.re;
              pt.re = re + zd.re;
              cs1.re += dk.re;
              cs1.im += dk.im;
              p1.re = 1.0 / hypot(cs1.re, cs1.im);
              if (pt.re == 0.0) {
                pt.re = cos(im);
                pt.im = sin(im);
              } else if (im == 0.0) {
                i2Map = pt.re;
                pt.re = exp(i2Map);
                pt.im = 0.0;
              } else {
                pt.re = CUDART_NAN;
                pt.im = CUDART_NAN;
              }

              i2Map = pt.re * p1.re - pt.im * 0.0;
              tkd1mtk = pt.re * 0.0 + pt.im * p1.re;
              bb = cs1.re * p1.re + cs1.im * 0.0;
              ack = cs1.re * 0.0 - cs1.im * p1.re;
              pt.re = i2Map * bb - tkd1mtk * ack;
              pt.im = i2Map * ack + tkd1mtk * bb;
              re = tmp.re * pt.re - tmp.im * pt.im;
              im = tmp.re * pt.im + tmp.im * pt.re;
              tmp.re = re;
              tmp.im = im;
            }
          }

          if (nw < 0) {
            if (nw == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        } else {
          nw = 0;
          i2Map = sqrt(0.15915494309189535 / zd.re);
          if (zd.re > 700.92179369444591) {
            nw = -1;
            tmp = *dc;
          } else {
            creal_T ck;
            creal_T cs1;
            creal_T cs2;
            int32_T b_i;
            boolean_T errflag;
            boolean_T exitg1;
            if (zd.re == 0.0) {
              pt.re = 1.0;
            } else {
              pt.re = exp(zd.re);
            }

            p1.re = i2Map * pt.re;
            p1.im = i2Map * 0.0;
            pt.re = 8.0 * zd.re;
            pt.im = 0.0;
            ack = 8.0 * hypot(zd.re, 0.0);
            i2Map = -1.0;
            b_atol = 2.2204460492503131E-16 / ack;
            tkd1mtk = 1.0;
            cs1.re = 1.0;
            cs1.im = 0.0;
            cs2.re = 1.0;
            cs2.im = 0.0;
            ck.re = 1.0;
            ck.im = 0.0;
            ak = 0.0;
            aa = 1.0;
            bb = ack;
            dk = pt;
            errflag = true;
            b_i = 1;
            exitg1 = false;
            while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                   (b_i < 46)) {
              ck.re *= i2Map;
              ck.im *= i2Map;
              if (ck.im == 0.0) {
                re = ck.re / dk.re;
                im = 0.0;
              } else if (ck.re == 0.0) {
                re = 0.0;
                im = CUDART_NAN;
              } else {
                re = ck.re / dk.re;
                im = CUDART_NAN;
              }

              ck.re = re;
              ck.im = im;
              cs2.re += re;
              cs2.im += im;
              tkd1mtk = -tkd1mtk;
              cs1.re += re * tkd1mtk;
              cs1.im += im * tkd1mtk;
              dk.re += pt.re;
              aa = aa * fabs(i2Map) / bb;
              bb += ack;
              ak += 8.0;
              i2Map -= ak;
              if (aa <= b_atol) {
                errflag = false;
                exitg1 = true;
              } else {
                b_i++;
              }
            }

            if (errflag) {
              nw = -2;
            } else {
              if (zd.re + zd.re < 700.92179369444591) {
                pt.re = -2.0 * zd.re;
                if (pt.re == 0.0) {
                  pt.re = 1.0;
                  pt.im = -0.0;
                } else {
                  i2Map = pt.re;
                  pt.re = exp(i2Map);
                  pt.im = 0.0;
                }

                re = pt.re * cs2.re - pt.im * cs2.im;
                im = pt.re * cs2.im + pt.im * cs2.re;
                cs1.re += re * 0.0 - im * 0.0;
                cs1.im += re * 0.0 + im * 0.0;
              }

              tmp.re = cs1.re * p1.re - cs1.im * p1.im;
              tmp.im = cs1.re * p1.im + cs1.im * p1.re;
            }
          }

          if (nw < 0) {
            if (nw == -2) {
              itime = -2;
            } else {
              itime = -1;
            }
          } else {
            itime = 0;
          }
        }
      }

      if (itime < 0) {
        if (itime == -2) {
          ocol = 5;
        } else {
          ocol = 2;
        }
      }

      if (ocol == 5) {
        tmp = *dc;
      } else if (ocol == 2) {
        tmp = *dc6;
      }

      if (zd.re > 0.0) {
        i2Map = tmp.re;
        tmp.re = i2Map;
        tmp.im = 0.0;
      }
    }

    if (tmp.im == 0.0) {
      z.re = tmp.re / 27.239871823604449;
      z.im = 0.0;
    } else if (tmp.re == 0.0) {
      z.re = 0.0;
      z.im = CUDART_NAN;
    } else {
      z.re = tmp.re / 27.239871823604449;
      z.im = CUDART_NAN;
    }

    dv27.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = hypot
      (z.re, z.im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel703(const
  emxArray_real_T a, const int32_T b_a, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel704(const
  emxArray_real_T x, const int32_T b, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.5 * x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel705(const
  emxArray_real_T a, const int32_T b, emxArray_real_T h, int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime + x_dim0] = 0.5 * a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel706(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel707(const
  int32_T omega_tmp2, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel708(const
  int32_T G, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    jpvt.data[itime] = 0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel709(const
  int32_T b, const int32_T ix, emxArray_real_T G, int32_T G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(ix) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b) + 1UL));
    G.data[kk * G_dim0 + i] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel71(emxArray_real_T
  omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel710(const
  int32_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    tau.data[k] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel711(const
  int32_T i, const int64_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int64_T k;
    k = static_cast<int64_T>(idx);
    tau.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel712(const
  int32_T ix, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(ix);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    jpvt.data[k] = k + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel713(const
  int32_T G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel714(const
  int32_T omega_tmp2, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel715(const
  emxArray_real_T b, const emxArray_int32_T jpvt, const int32_T nsubs,
  emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    a.data[jpvt.data[i] - 1] = b.data[i];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel716(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 4.0 * b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel717
  (emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] /= 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel718(const
  int32_T b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel719(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, emxArray_creal32_T
  opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = crossCFS.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel72(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel720(const
  emxArray_creal32_T crossCFS, const int32_T b_crossCFS, const int32_T
  c_crossCFS, emxArray_creal32_T opts_x, int32_T opts_x_dim0, int32_T
  crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_crossCFS) + 1UL) * (static_cast<uint64_T>
    (b_crossCFS) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_crossCFS) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_crossCFS) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = crossCFS.data[itime + crossCFS_dim0 *
      kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel721(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel722(const real_T
  toler, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel723(const
  emxArray_real32_T yCol, const int32_T csz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel724(const
  emxArray_real32_T h, real32_T *cv_re)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel725(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel726(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel727(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel728(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel729(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel73(const int32_T
  nsubs, const int32_T lidx, const emxArray_real_T omega_tmp2, const int32_T nx,
  emxArray_real_T omega, int32_T omega_tmp2_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nx);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega.data[(itime + omega_tmp2_dim1) + 1] = -omega_tmp2.data[lidx + nsubs *
      itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel730(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel731(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel732(const
  emxArray_real32_T y, const int32_T xt_size, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel733
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel734(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  b, emxArray_real32_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(T + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel735(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel736(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel737(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel738(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel739(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel74(const int32_T
  crossCFS, emxArray_creal32_T cfsDFT)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(crossCFS);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfsDFT.data[itime].re = 0.0F;
    cfsDFT.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel740(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv64)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv64.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel741(const
  emxArray_real32_T h, const emxArray_int32_T iv64, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv64.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel742(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T nw;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    for (int32_T m{0}; m < nw; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * yCol.data[(nw - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel743(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel744(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel745(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel746(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel747(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv66)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv66.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel748(const
  emxArray_real32_T yCol, const emxArray_int32_T iv66, const int32_T xt_size,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv66.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel749(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel75(const
  emxArray_real_T fb_Scales, const emxArray_real_T omega, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T Fmat, int32_T Fmat_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T i;
    int32_T kk;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    kk = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) /
      (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    i2Map = omega.data[kk] * fb_Scales.data[i];
    Fmat.data[i + Fmat_dim0 * kk] = exp(-0.5 * (i2Map * i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel750(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel751
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel752(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel753(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel754(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel755(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel756(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel757(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel758(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel759(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel76(const
  emxArray_creal32_T cfsDFT, const emxArray_real_T Fmat, const int32_T b_Fmat,
  emxArray_creal32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_Fmat);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime].re = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].re;
    x.data[itime].im = static_cast<real32_T>(Fmat.data[itime]) *
      cfsDFT.data[itime].im;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel760(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel761(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel762(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel763(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv44)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv44.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel764(const
  emxArray_real32_T a, const emxArray_int32_T iv44, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv44.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel765(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel766(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel767(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel768(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel769(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv46)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv46.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel77(const int32_T
  xSize, emxArray_creal32_T smooth)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    smooth.data[itime].re = 0.0F;
    smooth.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel770(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv46, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv46.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel771(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel772(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel773(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel774(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel775(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv51)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv51.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel776(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv69)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv69.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel777(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv69, const emxArray_int32_T iv51, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv51.data[kk] + expanded_dim0 * iv69.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel778(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel78(const
  emxArray_creal32_T smooth, const int32_T b, emxArray_creal32_T a, int32_T
  smooth_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = smooth.data[smooth_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel79(const int32_T
  a, emxArray_creal32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime].re = 0.0F;
    c.data[itime].im = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel8(const int32_T nx,
  real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[nx];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel80(const real32_T
  cv_re, const real32_T cv_im, emxArray_creal32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0].im = cv_im;
    c.data[0].re = cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel807(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel808(const
  emxArray_real32_T yCol, const int32_T csz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel809
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel81(const
  emxArray_creal32_T c, const int32_T b_c, emxArray_creal32_T crossCFS, int32_T
  crossCFS_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    crossCFS.data[crossCFS_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel810(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel811(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel812(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel813(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel814(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel815(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel816(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel817(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel818
  (emxArray_real_T y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel819(const
  emxArray_real32_T y, const emxArray_real_T b_y, const real_T T, const int32_T
  c_y, const int32_T b, emxArray_real32_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(T +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel82(const
  emxArray_creal32_T crossCFS, const int32_T b, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypotf(crossCFS.data[k].re, crossCFS.data[k].im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel820(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel821(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel822(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel823(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel824(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel825(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel826(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv50)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv50.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel827(const
  emxArray_real32_T a, const emxArray_int32_T iv50, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv50.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel828(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel829(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel83(const
  emxArray_real32_T y, const int32_T b, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = y.data[k] * y.data[k];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel830(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel831(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel832(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel833(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv54)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv54.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel834(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv54, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv54.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel835(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel836(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel837(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel838(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel839(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel84(const
  emxArray_real32_T cfs2, const emxArray_real32_T cfs1, const emxArray_real32_T
  y, const int32_T b_y, emxArray_real32_T wtc)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    wtc.data[itime] = y.data[itime] / (cfs1.data[itime] * cfs2.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel840(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv57)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv57.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel841(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv74)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv74.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel842(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv74, const emxArray_int32_T iv57, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv57.data[kk] + expanded_dim0 * iv74.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel843(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel85(const int32_T
  nrefine, emxArray_real32_T wtc)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nrefine);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    if (wtc.data[i] > 1.0F) {
      wtc.data[i] = 1.0F;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel86(const int32_T
  b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime) + 0.5;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel87(const
  emxArray_real_T m, const int32_T b_m, emxArray_real_T k)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_m);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    k.data[itime] = m.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel872(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel873(const real_T
  toler, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(toler);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel874(const
  emxArray_real32_T yCol, const int32_T csz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel875(const
  emxArray_real32_T h, real32_T *cv_re)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *cv_re = h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel876(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel877(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel878(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel879(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel88(const int32_T
  k, emxArray_real_T G)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    G.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel880(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel881(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel882(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel883(const
  emxArray_real32_T y, const int32_T xt_size, emxArray_real32_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel884(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel885(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel886(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel887(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel888(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel889(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv63)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv63.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel89(const int32_T
  k, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel890(const
  emxArray_real32_T h, const emxArray_int32_T iv63, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv63.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel891(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T nw;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    for (int32_T m{0}; m < nw; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
        kcounter = MIN_int32_T;
      } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * yCol.data[(nw - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel892(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel893(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel894(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel895(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel896(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv65)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv65.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel897(const
  emxArray_real32_T yCol, const emxArray_int32_T iv65, const int32_T xt_size,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv65.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel898(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, emxArray_real32_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[kcounter - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[k] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel899(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel9(const real_T s,
  const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T
  omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * s;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel90(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T dv25)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv25.data[itime] = 6.2831853071795862 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel900
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel901(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel902(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel903(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel904(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel905(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel906(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel907(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel908(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel909(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel91(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T dv26,
  emxArray_real_T dv25)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    dv25.data[b_k] = cos(dv25.data[b_k]);
    dv26.data[b_k] = 6.2831853071795862 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel910(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel911(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel912(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv43)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv43.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel913(const
  emxArray_real32_T a, const emxArray_int32_T iv43, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv43.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel914(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel915(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel916(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel917(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel918(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv45)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv45.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel919(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv45, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv45.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel92(const int32_T
  b, emxArray_real_T dv26)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv26.data[k] = cos(dv26.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel920(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if (kcounter > 2147483646 - ocol) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel921(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel922(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel923(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel924(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv49)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv49.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel925(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv68)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv68.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel926(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv68, const emxArray_int32_T iv49, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv49.data[kk] + expanded_dim0 * iv68.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel927(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel93(const
  emxArray_real_T k, const emxArray_real_T dv26, const emxArray_real_T dv25,
  const real_T a, const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * (dv25.data[itime] - dv26.data[itime]) / (k.data[itime]
      * k.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel94(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = 2.0 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel95(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T y,
  emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    if (fabs(b_y.data[b_k]) < 1.0020841800044864E-292) {
      b_y.data[b_k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * b_y.data[b_k];
      i2Map = sin(i2Map) / i2Map;
      b_y.data[b_k] = i2Map;
    }

    y.data[b_k] = 2.0 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel956(const
  int32_T b, emxArray_real32_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel957(const
  emxArray_real32_T yCol, const int32_T csz, emxArray_real32_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel958
  (emxArray_real32_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel959(const
  int32_T ix, const int32_T b, int32_T csz[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = csz[0];
    csz[0] = csz[1 - ix];
    csz[1 - ix] = itime;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel96(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    if (fabs(y.data[k]) < 1.0020841800044864E-292) {
      y.data[k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * y.data[k];
      i2Map = sin(i2Map) / i2Map;
      y.data[k] = i2Map;
    }
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel960(const int32_T
  nrefine, const int32_T pathlen, const int32_T nsubs, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[nsubs - 1] = div_s32_device(pathlen, nrefine) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel961(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel962(const
  emxArray_real32_T w, const int32_T xt_size, emxArray_real32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel963(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T nrefine, const
  int32_T b, const int32_T c, emxArray_real32_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[nrefine * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel964(const
  emxArray_real32_T w, const int32_T xt_size_dim0, const int32_T b, const
  int32_T c, emxArray_real32_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel965(const
  emxArray_real32_T y, const int32_T omega_tmp2, emxArray_real32_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel966(const
  emxArray_real32_T y, const int32_T b_y, emxArray_real32_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel967(const
  int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel968(const
  emxArray_real32_T yCol, const int32_T b, emxArray_real32_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel969(const
  int32_T a, emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel97(const
  emxArray_real_T y, const real_T a, const emxArray_real_T b_y, const real_T b_a,
  const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += b_a * b_y.data[itime] - a * y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel970(const real32_T
  cv_re, const emxArray_real32_T a, emxArray_real32_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel971(const
  emxArray_real32_T c, const int32_T b_c, emxArray_real32_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel972(const
  int32_T a, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel973(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv48)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv48.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel974(const
  emxArray_real32_T a, const emxArray_int32_T iv48, const int32_T omega_tmp2,
  emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv48.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel975(const
  real32_T cv_re, const emxArray_real32_T expanded, const int32_T b,
  emxArray_real32_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    c.data[k] = expanded.data[k] * cv_re;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel976(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel977(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_wtcc_kernel978(const
  emxArray_real32_T yCol, const emxArray_real32_T h, emxArray_real32_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real32_T cv;
    cv = h.data[0] * yCol.data[0];
    w.data[0] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel979(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel98(const real_T
  fa, const real_T r, const int32_T nsubs, const int32_T ix, const int32_T b,
  emxArray_real_T sinc4A, emxArray_real_T sinc3A, emxArray_real_T sinc2A,
  emxArray_real_T sinc1A)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T ack;
    real_T bb;
    real_T i2Map;
    real_T tkd1mtk;
    int32_T itime;
    uint32_T i1Map;
    itime = static_cast<int32_T>(idx);
    i1Map = (static_cast<uint32_T>(itime) + static_cast<uint32_T>(ix)) + 1U;
    tkd1mtk = (static_cast<real_T>(itime) + 1.0) - static_cast<real_T>(nsubs);
    ack = r * static_cast<real_T>(i1Map);
    i2Map = fa * static_cast<real_T>(i1Map);
    bb = r * tkd1mtk;
    tkd1mtk *= fa;
    if (fabs(ack) < 1.0020841800044864E-292) {
      sinc1A.data[itime] = 1.0;
    } else {
      ack *= 3.1415926535897931;
      sinc1A.data[itime] = sin(ack) / ack;
    }

    if (fabs(i2Map) < 1.0020841800044864E-292) {
      sinc2A.data[itime] = 1.0;
    } else {
      i2Map *= 3.1415926535897931;
      sinc2A.data[itime] = sin(i2Map) / i2Map;
    }

    if (fabs(bb) < 1.0020841800044864E-292) {
      sinc3A.data[itime] = 1.0;
    } else {
      bb *= 3.1415926535897931;
      sinc3A.data[itime] = sin(bb) / bb;
    }

    if (fabs(tkd1mtk) < 1.0020841800044864E-292) {
      sinc4A.data[itime] = 1.0;
    } else {
      tkd1mtk *= 3.1415926535897931;
      sinc4A.data[itime] = sin(tkd1mtk) / tkd1mtk;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel980(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv53)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv53.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel981(const
  emxArray_real32_T h, const int32_T lidx, const emxArray_int32_T iv53, const
  int32_T omega_tmp2, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv53.data[itime] + expanded_dim0 * lidx] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel982(const
  emxArray_real32_T yCol, const emxArray_real32_T expanded, const
  emxArray_int32_T cols, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, const int32_T c, emxArray_real32_T w, int32_T expanded_dim0,
  int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T kk;
    int32_T nw;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    nw = csz[0];
    kk = csz[1];
    for (int32_T n{0}; n < kk; n++) {
      for (int32_T m{0}; m < nw; m++) {
        int32_T i;
        int32_T kcounter;
        kcounter = rows.data[m];
        if ((k + 1 < 0) && (kcounter < MAX_int32_T - k)) {
          i = MIN_int32_T;
        } else if ((k + 1 > 0) && (kcounter > 2147483646 - k)) {
          i = MAX_int32_T;
        } else {
          i = (k + kcounter) + 1;
        }

        kcounter = cols.data[n];
        if ((ocol + 1 < 0) && (kcounter < MAX_int32_T - ocol)) {
          kcounter = MIN_int32_T;
        } else if ((ocol + 1 > 0) && (kcounter > 2147483646 - ocol)) {
          kcounter = MAX_int32_T;
        } else {
          kcounter = (ocol + kcounter) + 1;
        }

        cv += expanded.data[(i + expanded_dim0 * (kcounter - 1)) - 1] *
          yCol.data[((nw - m) + csz[0] * ((csz[1] - n) - 1)) - 1];
      }
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel983(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel984(const
  int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel985(const
  emxArray_real32_T c, const int32_T b, emxArray_real32_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel986(const
  int32_T x_size_idx_1, emxArray_real32_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(x_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0F;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel987(const
  int32_T offsetH, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T
  iv56)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kcounter;
    itime = static_cast<int32_T>(idx);
    kcounter = y.data[itime];
    if ((offsetH < 0) && (kcounter < MIN_int32_T - offsetH)) {
      kcounter = MIN_int32_T;
    } else if ((offsetH > 0) && (kcounter > MAX_int32_T - offsetH)) {
      kcounter = MAX_int32_T;
    } else {
      kcounter += offsetH;
    }

    iv56.data[itime] = kcounter - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel988(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv73)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv73.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel989(const
  emxArray_real32_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T
  iv73, const emxArray_int32_T iv56, const int32_T xt_size, const int32_T
  b_xt_size, emxArray_real32_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv56.data[kk] + expanded_dim0 * iv73.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel99(const
  emxArray_real_T sinc4A, const emxArray_real_T sinc2A, const real_T fa, const
  emxArray_real_T sinc3A, const emxArray_real_T sinc1A, const real_T r, const
  int32_T nsubs, const int32_T b, const int32_T c, emxArray_real_T G, int32_T
  G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T itime;
    int32_T kk;
    uint32_T i1Map;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    i1Map = (static_cast<uint32_T>(kk) + static_cast<uint32_T>(itime)) + 1U;
    i2Map = static_cast<real_T>(kk - itime) + static_cast<real_T>(nsubs);
    G.data[kk + G_dim0 * itime] += 0.25 * (r * (sinc1A.data[static_cast<int32_T>
      (i1Map) - 1] + sinc3A.data[static_cast<int32_T>(i2Map) - 1]) - fa *
      (sinc2A.data[static_cast<int32_T>(i1Map) - 1] + sinc4A.data
       [static_cast<int32_T>(i2Map) - 1]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_wtcc_kernel990(const
  emxArray_real32_T expanded, const emxArray_int32_T rows, const
  emxArray_real32_T h, const int32_T b, const int32_T c, emxArray_real32_T w,
  int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    int32_T ocol;
    real32_T cv;
    k = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    ocol = static_cast<int32_T>((idx - static_cast<uint64_T>(k)) / (static_cast<
      uint64_T>(b) + 1UL));
    cv = 0.0F;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kcounter;
      kcounter = rows.data[m];
      if (kcounter > 2147483646 - k) {
        kcounter = MAX_int32_T;
      } else {
        kcounter = (k + kcounter) + 1;
      }

      cv += expanded.data[(kcounter + expanded_dim0 * ocol) - 1] * h.data
        [(h_dim0 - m) - 1];
    }

    w.data[k + w_dim0 * ocol] = cv;
  }
}

static void ec_wtcc_once()
{
  mex_InitInfAndNan();
  checkCudaError(mwCudaMalloc(&global_gpu_cv, sizeof(char_T [128])), __FILE__,
                 __LINE__);
  checkCudaError(mwCudaMalloc(&global_gpu_table100, sizeof(real_T [100])),
                 __FILE__, __LINE__);
}

static void emlrtExitTimeCleanupDtorFcn(const void *r)
{
  emlrtExitTimeCleanup(&emlrtContextGlobal);
}

static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real32_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId, y);
  emlrtDestroyArray(&b_nullptr);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real32_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(tmpStr), &thisId, y);
  emlrtDestroyArray(&tmpStr);
}

static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier)
{
  emlrtMsgIdentifier thisId;
  real_T y;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = emlrt_marshallIn(emlrtAlias(a__output_of_length_), &thisId);
  emlrtDestroyArray(&a__output_of_length_);
  return y;
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId)
{
  real_T y;
  y = e_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23])
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(a__output_of_sprintf_), &thisId, y);
  emlrtDestroyArray(&a__output_of_sprintf_);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23])
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static const mxArray *emlrt_marshallOut(const cell_wrap_0 u[1])
{
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T iv1[2];
  int32_T iv[1];
  int32_T i1;
  int32_T loopUpperBound;
  real32_T *pData;
  y = nullptr;
  iv[0] = 1;
  emlrtAssign(&y, emlrtCreateCellArrayR2014a(1, &iv[0]));
  b_y = nullptr;
  iv1[0] = u[0].f1->size[0];
  iv1[1] = u[0].f1->size[1];
  m = emlrtCreateNumericArray(2, &iv1[0], mxSINGLE_CLASS, mxREAL);
  pData = static_cast<real32_T *>(emlrtMxGetData(m));
  i1 = 0;
  loopUpperBound = u[0].f1->size[1];
  for (int32_T i{0}; i < loopUpperBound; i++) {
    int32_T b_loopUpperBound;
    b_loopUpperBound = u[0].f1->size[0];
    for (int32_T b_i{0}; b_i < b_loopUpperBound; b_i++) {
      pData[i1 + b_i] = u[0].f1->data[b_i + u[0].f1->size[0] * i];
    }

    if (u[0].f1->size[0] - 1 >= 0) {
      i1 += u[0].f1->size[0];
    }
  }

  emlrtAssign(&b_y, m);
  emlrtSetCell(y, 0, b_y);
  return y;
}

static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(char_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<char_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<char_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_creal32_T(emxArray_creal32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(creal32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<creal32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<creal32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(int32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<int32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<int32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(ptrdiff_t));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<ptrdiff_t *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<ptrdiff_t *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(real32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<real32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<real32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(real_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<real_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<real_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(uint32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<uint32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<uint32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxFreeMatrix_cell_wrap_0(cell_wrap_0 pMatrix[1])
{
  emxFreeStruct_cell_wrap_0(&pMatrix[0]);
}

static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct)
{
  emxFree_real32_T(&pStruct->f1);
}

static void emxFree_char_T(emxArray_char_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_char_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_char_T *>(nullptr);
  }
}

static void emxFree_creal32_T(emxArray_creal32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_creal32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<creal32_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_creal32_T *>(nullptr);
  }
}

static void emxFree_int32_T(emxArray_int32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_int32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_int32_T *>(nullptr);
  }
}

static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_ptrdiff_t *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<ptrdiff_t *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_ptrdiff_t *>(nullptr);
  }
}

static void emxFree_real32_T(emxArray_real32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_real32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<real32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_real32_T *>(nullptr);
  }
}

static void emxFree_real_T(emxArray_real_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_real_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_real_T *>(nullptr);
  }
}

static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_uint32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<uint32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_uint32_T *>(nullptr);
  }
}

static void emxInitMatrix_cell_wrap_0(cell_wrap_0 pMatrix[1], const emlrtRTEInfo
  *srcLocation, boolean_T doPush)
{
  emxInitStruct_cell_wrap_0(&pMatrix[0], srcLocation, doPush);
}

static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush)
{
  emxInit_real32_T(&pStruct->f1, 2, srcLocation, doPush);
}

static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_char_T *emxArray;
  *pEmxArray = static_cast<emxArray_char_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_char_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_char_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<char_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_creal32_T(emxArray_creal32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_creal32_T *emxArray;
  *pEmxArray = static_cast<emxArray_creal32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_creal32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_creal32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<creal32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_int32_T *emxArray;
  *pEmxArray = static_cast<emxArray_int32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_int32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_int32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<int32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_ptrdiff_t *emxArray;
  *pEmxArray = static_cast<emxArray_ptrdiff_t *>(emlrtMallocEmxArray(sizeof
    (emxArray_ptrdiff_t)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_ptrdiff_t, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<ptrdiff_t *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_real32_T(emxArray_real32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_real32_T *emxArray;
  *pEmxArray = static_cast<emxArray_real32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_real32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_real32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<real32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_real_T *emxArray;
  *pEmxArray = static_cast<emxArray_real_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_real_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_real_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<real_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_uint32_T *emxArray;
  *pEmxArray = static_cast<emxArray_uint32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_uint32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_uint32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<uint32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static uint16_T (*f_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2]
{
  static const int32_T dims[2]{ 1, 2 };

  int32_T iv[2];
  uint16_T (*ret)[2];
  boolean_T bv[2]{ false, false };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "uint16", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret = (uint16_T (*)[2])emlrtMxGetData(src);
  emlrtDestroyArray(&src);
  return ret;
}
static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 3, &pArrays[0],
    "feval", true, location);
}

static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
  *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "feval", true, location);
}

static real32_T g_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId)
{
  static const int32_T dims{ 0 };

  real32_T ret;
  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 0U, (
    const void *)&dims);
  ret = *static_cast<real32_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret;
}

static void gpuEmxEnsureCapacity_creal32_T(const emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu, boolean_T needsCopy)
{
  creal32_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (creal32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(creal32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  int32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (int32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(int32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_real32_T(const emxArray_real32_T *cpu,
  emxArray_real32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  real32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (real32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(real32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy)
{
  real_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (real_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(real_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  uint32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (uint32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(uint32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxFree_creal32_T(emxArray_creal32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_int32_T(emxArray_int32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_real32_T(emxArray_real32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_real_T(emxArray_real_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxMemcpyCpuToGpu_creal32_T(emxArray_creal32_T *gpu, const
  emxArray_creal32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal32_T), cudaMemcpyHostToDevice), __FILE__,
                 __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_real32_T(emxArray_real32_T *gpu, const
  emxArray_real32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real32_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_creal32_T(emxArray_creal32_T *cpu,
  emxArray_creal32_T *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal32_T), cudaMemcpyDeviceToHost), __FILE__,
                 __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_real32_T(emxArray_real32_T *cpu,
  emxArray_real32_T *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real32_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxReset_creal32_T(emxArray_creal32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_creal32_T));
}

static void gpuEmxReset_int32_T(emxArray_int32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_int32_T));
}

static void gpuEmxReset_real32_T(emxArray_real32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_real32_T));
}

static void gpuEmxReset_real_T(emxArray_real_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_real_T));
}

static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_uint32_T));
}

static real32_T (*h_emlrt_marshallIn(const mxArray *src, const
  emlrtMsgIdentifier *msgId))[2]
{
  static const int32_T dims[2]{ 1, 2 };

  int32_T iv[2];
  real32_T (*ret)[2];
  boolean_T bv[2]{ false, false };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "single", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret = (real32_T (*)[2])emlrtMxGetData(src);
  emlrtDestroyArray(&src);
  return ret;
}
static const mxArray *length(const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 1, &pArray, "length",
    true, location);
}

static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  fn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static real32_T rt_atan2f_snf(real32_T u0, real32_T u1)
{
  real32_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaNF;
  } else if (std::isinf(u0) && std::isinf(u1)) {
    int32_T b;
    int32_T c;
    if (u1 > 0.0F) {
      b = 1;
    } else {
      b = -1;
    }

    if (u0 > 0.0F) {
      c = 1;
    } else {
      c = -1;
    }

    y = std::atan2(static_cast<real32_T>(c), static_cast<real32_T>(b));
  } else if (u1 == 0.0F) {
    if (u0 > 0.0F) {
      y = RT_PIF / 2.0F;
    } else if (u0 < 0.0F) {
      y = -(RT_PIF / 2.0F);
    } else {
      y = 0.0F;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

static real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else {
    real_T b;
    real_T c;
    b = std::abs(u0);
    c = std::abs(u1);
    if (std::isinf(u1)) {
      if (b == 1.0) {
        y = 1.0;
      } else if (b > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (c == 0.0) {
      y = 1.0;
    } else if (c == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }

  return y;
}

static real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
    y = rtNaN;
  } else if (std::isinf(u1)) {
    y = u0;
  } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {
    real_T q;
    q = std::abs(u0 / u1);
    if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {
      y = 0.0 * u0;
    } else {
      y = std::fmod(u0, u1);
    }
  } else {
    y = std::fmod(u0, u1);
  }

  return y;
}

//
// function [xx,yy] = ec_wtcc(x,c,fs,fLims,fVoices,ds)
void ec_wtcc(ec_wtccStackData *SD, const emxArray_real32_T *cpu_x, const
             uint16_T c[2], real32_T fs, const real32_T fLims[2], real32_T
             fVoices, const real32_T ds[2], cell_wrap_0 xx[1], cell_wrap_0 yy[1])
{
  static const creal_T dc7{ 1.0020841800044864E-289,// re
    0.0                                // im
  };

  static creal_T cpu_dc{ 0.0,          // re
    0.0                                // im
  };

  static creal_T cpu_dc6{ 0.0,         // re
    0.0                                // im
  };

  static const real_T cpu_table100[100]{ 0.0, 0.0, 0.69314718055994529,
    1.791759469228055, 3.1780538303479458, 4.7874917427820458,
    6.5792512120101012, 8.5251613610654147, 10.604602902745251,
    12.801827480081469, 15.104412573075516, 17.502307845873887,
    19.987214495661885, 22.552163853123425, 25.19122118273868, 27.89927138384089,
    30.671860106080672, 33.505073450136891, 36.395445208033053,
    39.339884187199495, 42.335616460753485, 45.380138898476908,
    48.471181351835227, 51.606675567764377, 54.784729398112319,
    58.003605222980518, 61.261701761002, 64.557538627006338, 67.88974313718154,
    71.257038967168015, 74.658236348830158, 78.0922235533153, 81.557959456115043,
    85.054467017581516, 88.580827542197682, 92.1361756036871, 95.7196945421432,
    99.330612454787428, 102.96819861451381, 106.63176026064346,
    110.32063971475739, 114.03421178146171, 117.77188139974507,
    121.53308151543864, 125.3172711493569, 129.12393363912722,
    132.95257503561632, 136.80272263732635, 140.67392364823425,
    144.5657439463449, 148.47776695177302, 152.40959258449735, 156.3608363030788,
    160.3311282166309, 164.32011226319517, 168.32744544842765,
    172.35279713916279, 176.39584840699735, 180.45629141754378,
    184.53382886144948, 188.6281734236716, 192.7390472878449, 196.86618167289,
    201.00931639928152, 205.1681994826412, 209.34258675253685,
    213.53224149456327, 217.73693411395422, 221.95644181913033,
    226.1905483237276, 230.43904356577696, 234.70172344281826,
    238.97838956183432, 243.26884900298271, 247.57291409618688,
    251.89040220972319, 256.22113555000954, 260.56494097186322,
    264.92164979855278, 269.29109765101981, 273.67312428569369,
    278.06757344036612, 282.4742926876304, 286.893133295427, 291.32395009427029,
    295.76660135076065, 300.22094864701415, 304.68685676566872,
    309.1641935801469, 313.65282994987905, 318.1526396202093, 322.66349912672615,
    327.1852877037752, 331.71788719692847, 336.26118197919845, 340.815058870799,
    345.37940706226686, 349.95411804077025, 354.53908551944079,
    359.1342053695754 };

  static const real_T NODES[15]{ -0.99145537112081261, -0.94910791234275849,
    -0.8648644233597691, -0.74153118559939435, -0.58608723546769115,
    -0.40584515137739718, -0.20778495500789851, 0.0, 0.20778495500789851,
    0.40584515137739718, 0.58608723546769115, 0.74153118559939435,
    0.8648644233597691, 0.94910791234275849, 0.99145537112081261 };

  static const real_T dv3[15]{ 0.022935322010529221, 0.063092092629978544,
    0.1047900103222502, 0.14065325971552589, 0.16900472663926791,
    0.19035057806478539, 0.20443294007529891, 0.20948214108472779,
    0.20443294007529891, 0.19035057806478539, 0.16900472663926791,
    0.14065325971552589, 0.1047900103222502, 0.063092092629978544,
    0.022935322010529221 };

  static const real_T dv4[15]{ 0.022935322010529221, -0.066392873538891159,
    0.1047900103222502, -0.13905213177375081, 0.16900472663926791,
    -0.19147947244033353, 0.20443294007529891, -0.20847704258874161,
    0.20443294007529891, -0.19147947244033353, 0.16900472663926791,
    -0.13905213177375081, 0.1047900103222502, -0.066392873538891159,
    0.022935322010529221 };

  static const real_T p1[8]{ 4.9452353592967269, 201.8112620856775,
    2290.8383738313464, 11319.672059033808, 28557.246356716354,
    38484.962284437934, 26377.487876241954, 7225.8139797002877 };

  static const real_T p2[8]{ 4.974607845568932, 542.4138599891071,
    15506.938649783649, 184793.29044456323, 1.0882047694688288E+6,
    3.33815296798703E+6, 5.1066616789273527E+6, 3.0741090548505397E+6 };

  static const real_T p4[8]{ 14745.0216605994, 2.4268133694867045E+6,
    1.2147555740450932E+8, 2.6634324496309772E+9, 2.9403789566345539E+10,
    1.7026657377653989E+11, 4.926125793377431E+11, 5.6062518562239514E+11 };

  static const real_T q1[8]{ 67.482125503037778, 1113.3323938571993,
    7738.7570569353984, 27639.870744033407, 54993.102062261576,
    61611.221800660023, 36351.2759150194, 8785.5363024310136 };

  static const real_T q2[8]{ 183.03283993705926, 7765.0493214450062,
    133190.38279660742, 1.1367058213219696E+6, 5.2679641174379466E+6,
    1.3467014543111017E+7, 1.7827365303532742E+7, 9.5330955918443538E+6 };

  static const real_T q4[8]{ 2690.5301758708993, 639388.56543000927,
    4.1355999302413881E+7, 1.120872109616148E+9, 1.4886137286788137E+10,
    1.0168035862724382E+11, 3.4174763455073773E+11, 4.4631581874197131E+11 };

  static const real_T c_c[7]{ -0.001910444077728, 0.00084171387781295,
    -0.00059523799130430121, 0.0007936507935003503, -0.0027777777777776816,
    0.083333333333333329, 0.0057083835261 };

  static const int32_T iv[2]{ 1, 7 };

  static const int32_T iv1[2]{ 1, 7 };

  static const int32_T iv116[2]{ 1, 7 };

  static const int32_T iv117[2]{ 1, 7 };

  static const int32_T iv118[2]{ 1, 7 };

  static const int32_T iv119[2]{ 1, 7 };

  static const int32_T iv121[2]{ 1, 7 };

  static const int32_T iv122[2]{ 1, 7 };

  static const int32_T iv123[2]{ 1, 7 };

  static const int32_T iv124[2]{ 1, 7 };

  static const int32_T iv125[2]{ 1, 7 };

  static const int32_T iv126[2]{ 1, 7 };

  static const int32_T iv128[2]{ 1, 7 };

  static const int32_T iv129[2]{ 1, 7 };

  static const int32_T iv130[2]{ 1, 7 };

  static const int32_T iv131[2]{ 1, 7 };

  static const int32_T iv132[2]{ 1, 7 };

  static const int32_T iv133[2]{ 1, 7 };

  static const int32_T iv134[2]{ 1, 7 };

  static const int32_T iv135[2]{ 1, 7 };

  static const int32_T iv136[2]{ 1, 7 };

  static const int32_T iv137[2]{ 1, 7 };

  static const int32_T iv19[2]{ 1, 7 };

  static const int32_T iv2[2]{ 1, 2 };

  static const int32_T iv20[2]{ 1, 7 };

  static const int32_T iv21[2]{ 1, 7 };

  static const int32_T iv22[2]{ 1, 7 };

  static const int32_T iv24[2]{ 1, 7 };

  static const int32_T iv25[2]{ 1, 7 };

  static const int32_T iv26[2]{ 1, 7 };

  static const int32_T iv27[2]{ 1, 7 };

  static const int32_T iv28[2]{ 1, 7 };

  static const int32_T iv29[2]{ 1, 7 };

  static const int32_T iv3[2]{ 1, 7 };

  static const int32_T iv31[2]{ 1, 7 };

  static const int32_T iv32[2]{ 1, 7 };

  static const int32_T iv33[2]{ 1, 7 };

  static const int32_T iv34[2]{ 1, 7 };

  static const int32_T iv35[2]{ 1, 7 };

  static const int32_T iv36[2]{ 1, 7 };

  static const int32_T iv37[2]{ 1, 7 };

  static const int32_T iv38[2]{ 1, 7 };

  static const int32_T iv39[2]{ 1, 7 };

  static const int32_T iv4[2]{ 1, 5 };

  static const int32_T iv40[2]{ 1, 7 };

  static const int32_T iv7[2]{ 1, 7 };

  static const char_T cpu_cv[128]{ '\x00', '\x01', '\x02', '\x03', '\x04',
    '\x05', '\x06', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\x0e', '\x0f',
    '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18',
    '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '\"', '#',
    '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'a',
    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}',
    '~', '\x7f' };

  static const char_T b[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n' };

  static const char_T cv1[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n'
  };

  static const char_T rfmt[7]{ '%', '2', '3', '.', '1', '5', 'e' };

  static const char_T u[7]{ 's', 'p', 'r', 'i', 'n', 't', 'f' };

  static const char_T b_formatSpec[5]{ '%', '2', '.', '2', 'f' };

  static const char_T b_a[4]{ 'a', 'm', 'o', 'r' };

  static const char_T cv2[4]{ 'b', 'u', 'm', 'p' };

  static const char_T cv3[4]{ 'a', 'm', 'o', 'r' };

  static const char_T formatSpec[2]{ '%', 'f' };

  static const int8_T A[4]{ 1, 1, 0, 0 };

  dim3 block;
  dim3 grid;
  emxArray_char_T *d_tmpStr;
  emxArray_char_T *tmpStr;
  emxArray_creal32_T ab_gpu_expanded;
  emxArray_creal32_T ab_gpu_w;
  emxArray_creal32_T ae_gpu_expanded;
  emxArray_creal32_T b_gpu_cfsDFT;
  emxArray_creal32_T b_gpu_cfspos;
  emxArray_creal32_T b_gpu_cfsposdft;
  emxArray_creal32_T b_gpu_expanded;
  emxArray_creal32_T b_gpu_newIm;
  emxArray_creal32_T b_gpu_result;
  emxArray_creal32_T b_gpu_w;
  emxArray_creal32_T b_gpu_xposdft;
  emxArray_creal32_T b_gpu_yCol;
  emxArray_creal32_T bb_gpu_w;
  emxArray_creal32_T be_gpu_expanded;
  emxArray_creal32_T c_gpu_a;
  emxArray_creal32_T c_gpu_c;
  emxArray_creal32_T c_gpu_cfsDFT;
  emxArray_creal32_T c_gpu_expanded;
  emxArray_creal32_T c_gpu_newIm;
  emxArray_creal32_T c_gpu_result;
  emxArray_creal32_T c_gpu_smooth;
  emxArray_creal32_T c_gpu_w;
  emxArray_creal32_T c_gpu_yCol;
  emxArray_creal32_T cb_gpu_expanded;
  emxArray_creal32_T cb_gpu_w;
  emxArray_creal32_T d_gpu_c;
  emxArray_creal32_T d_gpu_newIm;
  emxArray_creal32_T d_gpu_result;
  emxArray_creal32_T d_gpu_smooth;
  emxArray_creal32_T d_gpu_w;
  emxArray_creal32_T d_gpu_x;
  emxArray_creal32_T d_gpu_y;
  emxArray_creal32_T d_gpu_yCol;
  emxArray_creal32_T db_gpu_y;
  emxArray_creal32_T dc_gpu_y;
  emxArray_creal32_T e_gpu_c;
  emxArray_creal32_T e_gpu_expanded;
  emxArray_creal32_T e_gpu_newIm;
  emxArray_creal32_T e_gpu_result;
  emxArray_creal32_T e_gpu_w;
  emxArray_creal32_T e_gpu_x;
  emxArray_creal32_T e_gpu_yCol;
  emxArray_creal32_T eb_gpu_expanded;
  emxArray_creal32_T eb_gpu_y;
  emxArray_creal32_T ec_gpu_y;
  emxArray_creal32_T f_gpu_a;
  emxArray_creal32_T f_gpu_c;
  emxArray_creal32_T f_gpu_newIm;
  emxArray_creal32_T f_gpu_result;
  emxArray_creal32_T f_gpu_w;
  emxArray_creal32_T f_gpu_x;
  emxArray_creal32_T f_gpu_y;
  emxArray_creal32_T f_gpu_yCol;
  emxArray_creal32_T g_gpu_a;
  emxArray_creal32_T g_gpu_c;
  emxArray_creal32_T g_gpu_expanded;
  emxArray_creal32_T g_gpu_newIm;
  emxArray_creal32_T g_gpu_w;
  emxArray_creal32_T g_gpu_yCol;
  emxArray_creal32_T gb_gpu_expanded;
  emxArray_creal32_T gpu_cfsDFT;
  emxArray_creal32_T gpu_cfspos;
  emxArray_creal32_T gpu_cfsposdft;
  emxArray_creal32_T gpu_crossCFS;
  emxArray_creal32_T gpu_newIm;
  emxArray_creal32_T gpu_opts_x;
  emxArray_creal32_T gpu_result;
  emxArray_creal32_T gpu_w;
  emxArray_creal32_T gpu_xCol;
  emxArray_creal32_T gpu_xposdft;
  emxArray_creal32_T gpu_y1;
  emxArray_creal32_T gpu_yCol;
  emxArray_creal32_T h_gpu_a;
  emxArray_creal32_T h_gpu_c;
  emxArray_creal32_T h_gpu_newIm;
  emxArray_creal32_T h_gpu_w;
  emxArray_creal32_T h_gpu_yCol;
  emxArray_creal32_T hd_gpu_y;
  emxArray_creal32_T i_gpu_a;
  emxArray_creal32_T i_gpu_c;
  emxArray_creal32_T i_gpu_expanded;
  emxArray_creal32_T i_gpu_newIm;
  emxArray_creal32_T i_gpu_w;
  emxArray_creal32_T i_gpu_yCol;
  emxArray_creal32_T ib_gpu_expanded;
  emxArray_creal32_T id_gpu_y;
  emxArray_creal32_T j_gpu_a;
  emxArray_creal32_T j_gpu_expanded;
  emxArray_creal32_T j_gpu_newIm;
  emxArray_creal32_T j_gpu_w;
  emxArray_creal32_T j_gpu_yCol;
  emxArray_creal32_T k_gpu_a;
  emxArray_creal32_T k_gpu_newIm;
  emxArray_creal32_T k_gpu_w;
  emxArray_creal32_T k_gpu_yCol;
  emxArray_creal32_T kb_gpu_expanded;
  emxArray_creal32_T l_gpu_a;
  emxArray_creal32_T l_gpu_expanded;
  emxArray_creal32_T l_gpu_newIm;
  emxArray_creal32_T l_gpu_w;
  emxArray_creal32_T l_gpu_yCol;
  emxArray_creal32_T lb_gpu_expanded;
  emxArray_creal32_T m_gpu_a;
  emxArray_creal32_T m_gpu_newIm;
  emxArray_creal32_T m_gpu_w;
  emxArray_creal32_T m_gpu_yCol;
  emxArray_creal32_T n_gpu_expanded;
  emxArray_creal32_T n_gpu_newIm;
  emxArray_creal32_T n_gpu_w;
  emxArray_creal32_T n_gpu_yCol;
  emxArray_creal32_T nb_gpu_expanded;
  emxArray_creal32_T o_gpu_newIm;
  emxArray_creal32_T o_gpu_w;
  emxArray_creal32_T o_gpu_y;
  emxArray_creal32_T o_gpu_yCol;
  emxArray_creal32_T ob_gpu_y;
  emxArray_creal32_T oc_gpu_y;
  emxArray_creal32_T p_gpu_expanded;
  emxArray_creal32_T p_gpu_newIm;
  emxArray_creal32_T p_gpu_w;
  emxArray_creal32_T p_gpu_y;
  emxArray_creal32_T p_gpu_yCol;
  emxArray_creal32_T pb_gpu_expanded;
  emxArray_creal32_T pb_gpu_y;
  emxArray_creal32_T q_gpu_newIm;
  emxArray_creal32_T q_gpu_w;
  emxArray_creal32_T q_gpu_y;
  emxArray_creal32_T q_gpu_yCol;
  emxArray_creal32_T qb_gpu_y;
  emxArray_creal32_T r_gpu_expanded;
  emxArray_creal32_T r_gpu_newIm;
  emxArray_creal32_T r_gpu_w;
  emxArray_creal32_T r_gpu_yCol;
  emxArray_creal32_T rb_gpu_expanded;
  emxArray_creal32_T s_gpu_expanded;
  emxArray_creal32_T s_gpu_newIm;
  emxArray_creal32_T s_gpu_w;
  emxArray_creal32_T s_gpu_yCol;
  emxArray_creal32_T sb_gpu_expanded;
  emxArray_creal32_T sc_gpu_y;
  emxArray_creal32_T t_gpu_newIm;
  emxArray_creal32_T t_gpu_w;
  emxArray_creal32_T tc_gpu_y;
  emxArray_creal32_T u_gpu_expanded;
  emxArray_creal32_T u_gpu_newIm;
  emxArray_creal32_T u_gpu_w;
  emxArray_creal32_T ub_gpu_expanded;
  emxArray_creal32_T uc_gpu_y;
  emxArray_creal32_T v_gpu_newIm;
  emxArray_creal32_T v_gpu_w;
  emxArray_creal32_T w_gpu_expanded;
  emxArray_creal32_T w_gpu_newIm;
  emxArray_creal32_T w_gpu_w;
  emxArray_creal32_T wb_gpu_expanded;
  emxArray_creal32_T x_gpu_w;
  emxArray_creal32_T y_gpu_expanded;
  emxArray_creal32_T y_gpu_w;
  emxArray_creal32_T yb_gpu_expanded;
  emxArray_creal32_T *ab_cpu_yCol;
  emxArray_creal32_T *ac_cpu_w;
  emxArray_creal32_T *ae_cpu_expanded;
  emxArray_creal32_T *ag_cpu_y;
  emxArray_creal32_T *b_cpu_cfsDFT;
  emxArray_creal32_T *b_cpu_cfspos;
  emxArray_creal32_T *b_cpu_cfsposdft;
  emxArray_creal32_T *b_cpu_newIm;
  emxArray_creal32_T *b_cpu_xCol;
  emxArray_creal32_T *b_cpu_xposdft;
  emxArray_creal32_T *b_cpu_y1;
  emxArray_creal32_T *bb_cpu_yCol;
  emxArray_creal32_T *bc_cpu_w;
  emxArray_creal32_T *bd_cpu_expanded;
  emxArray_creal32_T *be_cpu_expanded;
  emxArray_creal32_T *c_cpu_a;
  emxArray_creal32_T *c_cpu_c;
  emxArray_creal32_T *c_cpu_cfsDFT;
  emxArray_creal32_T *c_cpu_newIm;
  emxArray_creal32_T *cb_cpu_yCol;
  emxArray_creal32_T *cc_cpu_w;
  emxArray_creal32_T *cd_cpu_expanded;
  emxArray_creal32_T *ce_cpu_expanded;
  emxArray_creal32_T *cpu_cfsDFT;
  emxArray_creal32_T *cpu_cfspos;
  emxArray_creal32_T *cpu_cfsposdft;
  emxArray_creal32_T *cpu_crossCFS;
  emxArray_creal32_T *cpu_newIm;
  emxArray_creal32_T *cpu_opts_x;
  emxArray_creal32_T *cpu_xposdft;
  emxArray_creal32_T *d_cpu_newIm;
  emxArray_creal32_T *d_cpu_x;
  emxArray_creal32_T *db_cpu_yCol;
  emxArray_creal32_T *dc_cpu_w;
  emxArray_creal32_T *dd_cpu_expanded;
  emxArray_creal32_T *df_cpu_y;
  emxArray_creal32_T *dh_cpu_y;
  emxArray_creal32_T *e_cpu_expanded;
  emxArray_creal32_T *e_cpu_newIm;
  emxArray_creal32_T *e_cpu_x;
  emxArray_creal32_T *eb_cpu_w;
  emxArray_creal32_T *ec_cpu_w;
  emxArray_creal32_T *ef_cpu_y;
  emxArray_creal32_T *eh_cpu_y;
  emxArray_creal32_T *f_c;
  emxArray_creal32_T *f_cpu_expanded;
  emxArray_creal32_T *f_cpu_newIm;
  emxArray_creal32_T *f_cpu_x;
  emxArray_creal32_T *fb_cpu_w;
  emxArray_creal32_T *fc_cpu_w;
  emxArray_creal32_T *fe_cpu_y;
  emxArray_creal32_T *ff_cpu_y;
  emxArray_creal32_T *fh_cpu_y;
  emxArray_creal32_T *g_c;
  emxArray_creal32_T *g_cpu_newIm;
  emxArray_creal32_T *g_cpu_result;
  emxArray_creal32_T *g_cpu_smooth;
  emxArray_creal32_T *g_cpu_y;
  emxArray_creal32_T *gb_cpu_w;
  emxArray_creal32_T *gc_cpu_expanded;
  emxArray_creal32_T *gc_cpu_w;
  emxArray_creal32_T *gf_cpu_y;
  emxArray_creal32_T *gh_cpu_y;
  emxArray_creal32_T *h_cpu_newIm;
  emxArray_creal32_T *h_cpu_result;
  emxArray_creal32_T *h_cpu_smooth;
  emxArray_creal32_T *hb_cpu_w;
  emxArray_creal32_T *hc_cpu_expanded;
  emxArray_creal32_T *hd_cpu_expanded;
  emxArray_creal32_T *hf_cpu_y;
  emxArray_creal32_T *hh_cpu_y;
  emxArray_creal32_T *i_cpu_newIm;
  emxArray_creal32_T *i_cpu_result;
  emxArray_creal32_T *ib_cpu_w;
  emxArray_creal32_T *ic_cpu_expanded;
  emxArray_creal32_T *ih_cpu_y;
  emxArray_creal32_T *j_cpu_newIm;
  emxArray_creal32_T *j_cpu_result;
  emxArray_creal32_T *jb_cpu_w;
  emxArray_creal32_T *jc_cpu_expanded;
  emxArray_creal32_T *jd_cpu_expanded;
  emxArray_creal32_T *k_cpu_newIm;
  emxArray_creal32_T *k_cpu_result;
  emxArray_creal32_T *k_cpu_yCol;
  emxArray_creal32_T *kb_cpu_w;
  emxArray_creal32_T *kd_cpu_expanded;
  emxArray_creal32_T *l_cpu_a;
  emxArray_creal32_T *l_cpu_newIm;
  emxArray_creal32_T *l_cpu_result;
  emxArray_creal32_T *l_cpu_y;
  emxArray_creal32_T *l_cpu_yCol;
  emxArray_creal32_T *lb_cpu_w;
  emxArray_creal32_T *lc_cpu_expanded;
  emxArray_creal32_T *m_cpu_a;
  emxArray_creal32_T *m_cpu_newIm;
  emxArray_creal32_T *m_cpu_yCol;
  emxArray_creal32_T *mb_cpu_w;
  emxArray_creal32_T *mc_cpu_expanded;
  emxArray_creal32_T *n_cpu_a;
  emxArray_creal32_T *n_cpu_newIm;
  emxArray_creal32_T *n_cpu_yCol;
  emxArray_creal32_T *nb_cpu_w;
  emxArray_creal32_T *nc_cpu_expanded;
  emxArray_creal32_T *nd_cpu_expanded;
  emxArray_creal32_T *o_cpu_a;
  emxArray_creal32_T *o_cpu_newIm;
  emxArray_creal32_T *o_cpu_yCol;
  emxArray_creal32_T *ob_cpu_w;
  emxArray_creal32_T *p_cpu_a;
  emxArray_creal32_T *p_cpu_newIm;
  emxArray_creal32_T *p_cpu_yCol;
  emxArray_creal32_T *pb_cpu_w;
  emxArray_creal32_T *pd_cpu_expanded;
  emxArray_creal32_T *q_cpu_a;
  emxArray_creal32_T *q_cpu_newIm;
  emxArray_creal32_T *q_cpu_yCol;
  emxArray_creal32_T *qb_cpu_w;
  emxArray_creal32_T *qd_cpu_expanded;
  emxArray_creal32_T *r_cpu_a;
  emxArray_creal32_T *r_cpu_newIm;
  emxArray_creal32_T *r_cpu_yCol;
  emxArray_creal32_T *rb_cpu_w;
  emxArray_creal32_T *rc_cpu_expanded;
  emxArray_creal32_T *rd_cpu_expanded;
  emxArray_creal32_T *s_cpu_a;
  emxArray_creal32_T *s_cpu_c;
  emxArray_creal32_T *s_cpu_newIm;
  emxArray_creal32_T *s_cpu_yCol;
  emxArray_creal32_T *sb_cpu_w;
  emxArray_creal32_T *sc_cpu_expanded;
  emxArray_creal32_T *smooth;
  emxArray_creal32_T *t_cpu_c;
  emxArray_creal32_T *t_cpu_newIm;
  emxArray_creal32_T *t_cpu_yCol;
  emxArray_creal32_T *tb_cpu_w;
  emxArray_creal32_T *tc_cpu_expanded;
  emxArray_creal32_T *u_cpu_c;
  emxArray_creal32_T *u_cpu_newIm;
  emxArray_creal32_T *u_cpu_yCol;
  emxArray_creal32_T *ub_cpu_w;
  emxArray_creal32_T *uc_cpu_expanded;
  emxArray_creal32_T *v_cpu_c;
  emxArray_creal32_T *v_cpu_newIm;
  emxArray_creal32_T *v_cpu_yCol;
  emxArray_creal32_T *vb_cpu_w;
  emxArray_creal32_T *vd_cpu_expanded;
  emxArray_creal32_T *vf_cpu_y;
  emxArray_creal32_T *w_cpu_c;
  emxArray_creal32_T *w_cpu_newIm;
  emxArray_creal32_T *w_cpu_yCol;
  emxArray_creal32_T *wb_cpu_w;
  emxArray_creal32_T *wc_cpu_expanded;
  emxArray_creal32_T *wd_cpu_expanded;
  emxArray_creal32_T *x_cpu_c;
  emxArray_creal32_T *x_cpu_yCol;
  emxArray_creal32_T *xb_cpu_w;
  emxArray_creal32_T *xc_cpu_expanded;
  emxArray_creal32_T *y_cpu_yCol;
  emxArray_creal32_T *yb_cpu_w;
  emxArray_creal32_T *ye_cpu_y;
  emxArray_creal32_T *yf_cpu_y;
  emxArray_int32_T ab_gpu_rows;
  emxArray_int32_T ab_gpu_y;
  emxArray_int32_T ac_gpu_rows;
  emxArray_int32_T ac_gpu_y;
  emxArray_int32_T ad_gpu_rows;
  emxArray_int32_T ad_gpu_y;
  emxArray_int32_T ae_gpu_y;
  emxArray_int32_T af_gpu_y;
  emxArray_int32_T ah_gpu_y;
  emxArray_int32_T b_gpu_IPIV;
  emxArray_int32_T b_gpu_cols;
  emxArray_int32_T b_gpu_jpvt;
  emxArray_int32_T b_gpu_omega_tmp1;
  emxArray_int32_T b_gpu_rows;
  emxArray_int32_T bb_gpu_rows;
  emxArray_int32_T bb_gpu_y;
  emxArray_int32_T bc_gpu_rows;
  emxArray_int32_T bc_gpu_y;
  emxArray_int32_T bd_gpu_rows;
  emxArray_int32_T bd_gpu_y;
  emxArray_int32_T be_gpu_y;
  emxArray_int32_T bf_gpu_y;
  emxArray_int32_T bg_gpu_y;
  emxArray_int32_T bh_gpu_y;
  emxArray_int32_T c_gpu_cols;
  emxArray_int32_T c_gpu_omega_tmp1;
  emxArray_int32_T c_gpu_rows;
  emxArray_int32_T cb_gpu_rows;
  emxArray_int32_T cb_gpu_y;
  emxArray_int32_T cc_gpu_rows;
  emxArray_int32_T cc_gpu_y;
  emxArray_int32_T cd_gpu_rows;
  emxArray_int32_T cd_gpu_y;
  emxArray_int32_T ce_gpu_y;
  emxArray_int32_T cf_gpu_y;
  emxArray_int32_T cg_gpu_y;
  emxArray_int32_T ch_gpu_y;
  emxArray_int32_T d_gpu_cols;
  emxArray_int32_T d_gpu_omega_tmp1;
  emxArray_int32_T d_gpu_rows;
  emxArray_int32_T db_gpu_rows;
  emxArray_int32_T dc_gpu_rows;
  emxArray_int32_T dd_gpu_rows;
  emxArray_int32_T dd_gpu_y;
  emxArray_int32_T de_gpu_y;
  emxArray_int32_T df_gpu_y;
  emxArray_int32_T dg_gpu_y;
  emxArray_int32_T dh_gpu_y;
  emxArray_int32_T e_gpu_cols;
  emxArray_int32_T e_gpu_rows;
  emxArray_int32_T eb_gpu_rows;
  emxArray_int32_T ec_gpu_rows;
  emxArray_int32_T ed_gpu_rows;
  emxArray_int32_T ed_gpu_y;
  emxArray_int32_T ee_gpu_y;
  emxArray_int32_T ef_gpu_y;
  emxArray_int32_T eg_gpu_y;
  emxArray_int32_T eh_gpu_y;
  emxArray_int32_T f_gpu_cols;
  emxArray_int32_T f_gpu_rows;
  emxArray_int32_T fb_gpu_rows;
  emxArray_int32_T fc_gpu_rows;
  emxArray_int32_T fd_gpu_rows;
  emxArray_int32_T fd_gpu_y;
  emxArray_int32_T fe_gpu_y;
  emxArray_int32_T ff_gpu_y;
  emxArray_int32_T fg_gpu_y;
  emxArray_int32_T fh_gpu_y;
  emxArray_int32_T g_gpu_cols;
  emxArray_int32_T g_gpu_rows;
  emxArray_int32_T gb_gpu_rows;
  emxArray_int32_T gb_gpu_y;
  emxArray_int32_T gc_gpu_rows;
  emxArray_int32_T gc_gpu_y;
  emxArray_int32_T gd_gpu_rows;
  emxArray_int32_T gd_gpu_y;
  emxArray_int32_T ge_gpu_y;
  emxArray_int32_T gf_gpu_y;
  emxArray_int32_T gg_gpu_y;
  emxArray_int32_T gpu_IPIV;
  emxArray_int32_T gpu_cols;
  emxArray_int32_T gpu_iv10;
  emxArray_int32_T gpu_iv100;
  emxArray_int32_T gpu_iv102;
  emxArray_int32_T gpu_iv106;
  emxArray_int32_T gpu_iv107;
  emxArray_int32_T gpu_iv11;
  emxArray_int32_T gpu_iv12;
  emxArray_int32_T gpu_iv13;
  emxArray_int32_T gpu_iv138;
  emxArray_int32_T gpu_iv139;
  emxArray_int32_T gpu_iv140;
  emxArray_int32_T gpu_iv141;
  emxArray_int32_T gpu_iv142;
  emxArray_int32_T gpu_iv143;
  emxArray_int32_T gpu_iv144;
  emxArray_int32_T gpu_iv145;
  emxArray_int32_T gpu_iv146;
  emxArray_int32_T gpu_iv147;
  emxArray_int32_T gpu_iv148;
  emxArray_int32_T gpu_iv149;
  emxArray_int32_T gpu_iv15;
  emxArray_int32_T gpu_iv150;
  emxArray_int32_T gpu_iv151;
  emxArray_int32_T gpu_iv152;
  emxArray_int32_T gpu_iv153;
  emxArray_int32_T gpu_iv154;
  emxArray_int32_T gpu_iv155;
  emxArray_int32_T gpu_iv158;
  emxArray_int32_T gpu_iv159;
  emxArray_int32_T gpu_iv16;
  emxArray_int32_T gpu_iv160;
  emxArray_int32_T gpu_iv161;
  emxArray_int32_T gpu_iv162;
  emxArray_int32_T gpu_iv163;
  emxArray_int32_T gpu_iv165;
  emxArray_int32_T gpu_iv166;
  emxArray_int32_T gpu_iv167;
  emxArray_int32_T gpu_iv168;
  emxArray_int32_T gpu_iv169;
  emxArray_int32_T gpu_iv17;
  emxArray_int32_T gpu_iv170;
  emxArray_int32_T gpu_iv171;
  emxArray_int32_T gpu_iv172;
  emxArray_int32_T gpu_iv173;
  emxArray_int32_T gpu_iv174;
  emxArray_int32_T gpu_iv175;
  emxArray_int32_T gpu_iv176;
  emxArray_int32_T gpu_iv177;
  emxArray_int32_T gpu_iv178;
  emxArray_int32_T gpu_iv18;
  emxArray_int32_T gpu_iv180;
  emxArray_int32_T gpu_iv182;
  emxArray_int32_T gpu_iv183;
  emxArray_int32_T gpu_iv184;
  emxArray_int32_T gpu_iv185;
  emxArray_int32_T gpu_iv186;
  emxArray_int32_T gpu_iv187;
  emxArray_int32_T gpu_iv188;
  emxArray_int32_T gpu_iv189;
  emxArray_int32_T gpu_iv190;
  emxArray_int32_T gpu_iv192;
  emxArray_int32_T gpu_iv193;
  emxArray_int32_T gpu_iv194;
  emxArray_int32_T gpu_iv195;
  emxArray_int32_T gpu_iv196;
  emxArray_int32_T gpu_iv198;
  emxArray_int32_T gpu_iv202;
  emxArray_int32_T gpu_iv203;
  emxArray_int32_T gpu_iv41;
  emxArray_int32_T gpu_iv42;
  emxArray_int32_T gpu_iv43;
  emxArray_int32_T gpu_iv44;
  emxArray_int32_T gpu_iv45;
  emxArray_int32_T gpu_iv46;
  emxArray_int32_T gpu_iv47;
  emxArray_int32_T gpu_iv48;
  emxArray_int32_T gpu_iv49;
  emxArray_int32_T gpu_iv50;
  emxArray_int32_T gpu_iv51;
  emxArray_int32_T gpu_iv52;
  emxArray_int32_T gpu_iv53;
  emxArray_int32_T gpu_iv54;
  emxArray_int32_T gpu_iv55;
  emxArray_int32_T gpu_iv56;
  emxArray_int32_T gpu_iv57;
  emxArray_int32_T gpu_iv58;
  emxArray_int32_T gpu_iv61;
  emxArray_int32_T gpu_iv62;
  emxArray_int32_T gpu_iv63;
  emxArray_int32_T gpu_iv64;
  emxArray_int32_T gpu_iv65;
  emxArray_int32_T gpu_iv66;
  emxArray_int32_T gpu_iv68;
  emxArray_int32_T gpu_iv69;
  emxArray_int32_T gpu_iv70;
  emxArray_int32_T gpu_iv71;
  emxArray_int32_T gpu_iv72;
  emxArray_int32_T gpu_iv73;
  emxArray_int32_T gpu_iv74;
  emxArray_int32_T gpu_iv75;
  emxArray_int32_T gpu_iv76;
  emxArray_int32_T gpu_iv77;
  emxArray_int32_T gpu_iv78;
  emxArray_int32_T gpu_iv79;
  emxArray_int32_T gpu_iv8;
  emxArray_int32_T gpu_iv80;
  emxArray_int32_T gpu_iv81;
  emxArray_int32_T gpu_iv83;
  emxArray_int32_T gpu_iv85;
  emxArray_int32_T gpu_iv86;
  emxArray_int32_T gpu_iv87;
  emxArray_int32_T gpu_iv88;
  emxArray_int32_T gpu_iv89;
  emxArray_int32_T gpu_iv9;
  emxArray_int32_T gpu_iv90;
  emxArray_int32_T gpu_iv91;
  emxArray_int32_T gpu_iv92;
  emxArray_int32_T gpu_iv93;
  emxArray_int32_T gpu_iv94;
  emxArray_int32_T gpu_iv96;
  emxArray_int32_T gpu_iv97;
  emxArray_int32_T gpu_iv98;
  emxArray_int32_T gpu_iv99;
  emxArray_int32_T gpu_jpvt;
  emxArray_int32_T gpu_omega_tmp1;
  emxArray_int32_T gpu_rows;
  emxArray_int32_T h_gpu_cols;
  emxArray_int32_T h_gpu_rows;
  emxArray_int32_T hb_gpu_rows;
  emxArray_int32_T hb_gpu_y;
  emxArray_int32_T hc_gpu_rows;
  emxArray_int32_T hc_gpu_y;
  emxArray_int32_T hd_gpu_rows;
  emxArray_int32_T hg_gpu_y;
  emxArray_int32_T i_gpu_cols;
  emxArray_int32_T i_gpu_rows;
  emxArray_int32_T ib_gpu_rows;
  emxArray_int32_T ib_gpu_y;
  emxArray_int32_T ic_gpu_rows;
  emxArray_int32_T ic_gpu_y;
  emxArray_int32_T id_gpu_rows;
  emxArray_int32_T ig_gpu_y;
  emxArray_int32_T j_gpu_cols;
  emxArray_int32_T j_gpu_rows;
  emxArray_int32_T jb_gpu_rows;
  emxArray_int32_T jb_gpu_y;
  emxArray_int32_T jc_gpu_rows;
  emxArray_int32_T jc_gpu_y;
  emxArray_int32_T jd_gpu_rows;
  emxArray_int32_T jg_gpu_y;
  emxArray_int32_T k_gpu_cols;
  emxArray_int32_T k_gpu_rows;
  emxArray_int32_T kb_gpu_rows;
  emxArray_int32_T kb_gpu_y;
  emxArray_int32_T kc_gpu_rows;
  emxArray_int32_T kc_gpu_y;
  emxArray_int32_T kd_gpu_rows;
  emxArray_int32_T kd_gpu_y;
  emxArray_int32_T ke_gpu_y;
  emxArray_int32_T kf_gpu_y;
  emxArray_int32_T kg_gpu_y;
  emxArray_int32_T l_gpu_cols;
  emxArray_int32_T l_gpu_rows;
  emxArray_int32_T lb_gpu_rows;
  emxArray_int32_T lb_gpu_y;
  emxArray_int32_T lc_gpu_rows;
  emxArray_int32_T lc_gpu_y;
  emxArray_int32_T ld_gpu_rows;
  emxArray_int32_T ld_gpu_y;
  emxArray_int32_T le_gpu_y;
  emxArray_int32_T lf_gpu_y;
  emxArray_int32_T m_gpu_rows;
  emxArray_int32_T mb_gpu_rows;
  emxArray_int32_T mb_gpu_y;
  emxArray_int32_T mc_gpu_rows;
  emxArray_int32_T mc_gpu_y;
  emxArray_int32_T md_gpu_rows;
  emxArray_int32_T md_gpu_y;
  emxArray_int32_T me_gpu_y;
  emxArray_int32_T mf_gpu_y;
  emxArray_int32_T n_gpu_rows;
  emxArray_int32_T nb_gpu_rows;
  emxArray_int32_T nb_gpu_y;
  emxArray_int32_T nc_gpu_rows;
  emxArray_int32_T nc_gpu_y;
  emxArray_int32_T nd_gpu_rows;
  emxArray_int32_T nd_gpu_y;
  emxArray_int32_T ne_gpu_y;
  emxArray_int32_T nf_gpu_y;
  emxArray_int32_T o_gpu_rows;
  emxArray_int32_T ob_gpu_rows;
  emxArray_int32_T oc_gpu_rows;
  emxArray_int32_T od_gpu_rows;
  emxArray_int32_T od_gpu_y;
  emxArray_int32_T oe_gpu_y;
  emxArray_int32_T of_gpu_y;
  emxArray_int32_T og_gpu_y;
  emxArray_int32_T p_gpu_rows;
  emxArray_int32_T pb_gpu_rows;
  emxArray_int32_T pc_gpu_rows;
  emxArray_int32_T pd_gpu_rows;
  emxArray_int32_T pd_gpu_y;
  emxArray_int32_T pe_gpu_y;
  emxArray_int32_T pf_gpu_y;
  emxArray_int32_T pg_gpu_y;
  emxArray_int32_T q_gpu_rows;
  emxArray_int32_T qb_gpu_rows;
  emxArray_int32_T qc_gpu_rows;
  emxArray_int32_T qc_gpu_y;
  emxArray_int32_T qd_gpu_y;
  emxArray_int32_T qe_gpu_y;
  emxArray_int32_T qf_gpu_y;
  emxArray_int32_T qg_gpu_y;
  emxArray_int32_T r_gpu_rows;
  emxArray_int32_T rb_gpu_rows;
  emxArray_int32_T rc_gpu_rows;
  emxArray_int32_T rc_gpu_y;
  emxArray_int32_T rd_gpu_y;
  emxArray_int32_T re_gpu_y;
  emxArray_int32_T rf_gpu_y;
  emxArray_int32_T rg_gpu_y;
  emxArray_int32_T s_gpu_rows;
  emxArray_int32_T s_gpu_y;
  emxArray_int32_T sb_gpu_rows;
  emxArray_int32_T sb_gpu_y;
  emxArray_int32_T sc_gpu_rows;
  emxArray_int32_T sg_gpu_y;
  emxArray_int32_T t_gpu_rows;
  emxArray_int32_T t_gpu_y;
  emxArray_int32_T tb_gpu_rows;
  emxArray_int32_T tb_gpu_y;
  emxArray_int32_T tc_gpu_rows;
  emxArray_int32_T tg_gpu_y;
  emxArray_int32_T u_gpu_rows;
  emxArray_int32_T u_gpu_y;
  emxArray_int32_T ub_gpu_rows;
  emxArray_int32_T ub_gpu_y;
  emxArray_int32_T uc_gpu_rows;
  emxArray_int32_T uf_gpu_y;
  emxArray_int32_T ug_gpu_y;
  emxArray_int32_T v_gpu_rows;
  emxArray_int32_T v_gpu_y;
  emxArray_int32_T vb_gpu_rows;
  emxArray_int32_T vb_gpu_y;
  emxArray_int32_T vc_gpu_rows;
  emxArray_int32_T vf_gpu_y;
  emxArray_int32_T vg_gpu_y;
  emxArray_int32_T w_gpu_rows;
  emxArray_int32_T w_gpu_y;
  emxArray_int32_T wb_gpu_rows;
  emxArray_int32_T wb_gpu_y;
  emxArray_int32_T wc_gpu_rows;
  emxArray_int32_T wc_gpu_y;
  emxArray_int32_T wd_gpu_y;
  emxArray_int32_T we_gpu_y;
  emxArray_int32_T wg_gpu_y;
  emxArray_int32_T x_gpu_rows;
  emxArray_int32_T x_gpu_y;
  emxArray_int32_T xb_gpu_rows;
  emxArray_int32_T xb_gpu_y;
  emxArray_int32_T xc_gpu_rows;
  emxArray_int32_T xc_gpu_y;
  emxArray_int32_T xd_gpu_y;
  emxArray_int32_T xe_gpu_y;
  emxArray_int32_T xg_gpu_y;
  emxArray_int32_T y_gpu_rows;
  emxArray_int32_T y_gpu_y;
  emxArray_int32_T yb_gpu_rows;
  emxArray_int32_T yb_gpu_y;
  emxArray_int32_T yc_gpu_rows;
  emxArray_int32_T yc_gpu_y;
  emxArray_int32_T yd_gpu_y;
  emxArray_int32_T ye_gpu_y;
  emxArray_int32_T yg_gpu_y;
  emxArray_int32_T *ab_cpu_rows;
  emxArray_int32_T *ab_cpu_y;
  emxArray_int32_T *ac_cpu_rows;
  emxArray_int32_T *ad_cpu_rows;
  emxArray_int32_T *ad_cpu_y;
  emxArray_int32_T *af_cpu_y;
  emxArray_int32_T *ah_cpu_y;
  emxArray_int32_T *b_cpu_IPIV;
  emxArray_int32_T *b_cpu_cols;
  emxArray_int32_T *b_cpu_jpvt;
  emxArray_int32_T *b_cpu_omega_tmp1;
  emxArray_int32_T *b_cpu_rows;
  emxArray_int32_T *bb_cpu_rows;
  emxArray_int32_T *bc_cpu_rows;
  emxArray_int32_T *bc_cpu_y;
  emxArray_int32_T *bd_cpu_rows;
  emxArray_int32_T *bd_cpu_y;
  emxArray_int32_T *bf_cpu_y;
  emxArray_int32_T *bh_cpu_y;
  emxArray_int32_T *c_cpu_cols;
  emxArray_int32_T *c_cpu_omega_tmp1;
  emxArray_int32_T *c_cpu_rows;
  emxArray_int32_T *cb_cpu_rows;
  emxArray_int32_T *cb_cpu_y;
  emxArray_int32_T *cc_cpu_rows;
  emxArray_int32_T *cc_cpu_y;
  emxArray_int32_T *cd_cpu_rows;
  emxArray_int32_T *cd_cpu_y;
  emxArray_int32_T *cf_cpu_y;
  emxArray_int32_T *ch_cpu_y;
  emxArray_int32_T *cpu_IPIV;
  emxArray_int32_T *cpu_cols;
  emxArray_int32_T *cpu_iv10;
  emxArray_int32_T *cpu_iv100;
  emxArray_int32_T *cpu_iv102;
  emxArray_int32_T *cpu_iv106;
  emxArray_int32_T *cpu_iv107;
  emxArray_int32_T *cpu_iv11;
  emxArray_int32_T *cpu_iv12;
  emxArray_int32_T *cpu_iv13;
  emxArray_int32_T *cpu_iv138;
  emxArray_int32_T *cpu_iv139;
  emxArray_int32_T *cpu_iv140;
  emxArray_int32_T *cpu_iv141;
  emxArray_int32_T *cpu_iv142;
  emxArray_int32_T *cpu_iv143;
  emxArray_int32_T *cpu_iv144;
  emxArray_int32_T *cpu_iv145;
  emxArray_int32_T *cpu_iv146;
  emxArray_int32_T *cpu_iv147;
  emxArray_int32_T *cpu_iv148;
  emxArray_int32_T *cpu_iv149;
  emxArray_int32_T *cpu_iv15;
  emxArray_int32_T *cpu_iv150;
  emxArray_int32_T *cpu_iv151;
  emxArray_int32_T *cpu_iv152;
  emxArray_int32_T *cpu_iv153;
  emxArray_int32_T *cpu_iv154;
  emxArray_int32_T *cpu_iv155;
  emxArray_int32_T *cpu_iv158;
  emxArray_int32_T *cpu_iv159;
  emxArray_int32_T *cpu_iv16;
  emxArray_int32_T *cpu_iv160;
  emxArray_int32_T *cpu_iv161;
  emxArray_int32_T *cpu_iv162;
  emxArray_int32_T *cpu_iv163;
  emxArray_int32_T *cpu_iv165;
  emxArray_int32_T *cpu_iv166;
  emxArray_int32_T *cpu_iv167;
  emxArray_int32_T *cpu_iv168;
  emxArray_int32_T *cpu_iv169;
  emxArray_int32_T *cpu_iv17;
  emxArray_int32_T *cpu_iv170;
  emxArray_int32_T *cpu_iv171;
  emxArray_int32_T *cpu_iv172;
  emxArray_int32_T *cpu_iv173;
  emxArray_int32_T *cpu_iv174;
  emxArray_int32_T *cpu_iv175;
  emxArray_int32_T *cpu_iv176;
  emxArray_int32_T *cpu_iv177;
  emxArray_int32_T *cpu_iv178;
  emxArray_int32_T *cpu_iv18;
  emxArray_int32_T *cpu_iv180;
  emxArray_int32_T *cpu_iv182;
  emxArray_int32_T *cpu_iv183;
  emxArray_int32_T *cpu_iv184;
  emxArray_int32_T *cpu_iv185;
  emxArray_int32_T *cpu_iv186;
  emxArray_int32_T *cpu_iv187;
  emxArray_int32_T *cpu_iv188;
  emxArray_int32_T *cpu_iv189;
  emxArray_int32_T *cpu_iv190;
  emxArray_int32_T *cpu_iv192;
  emxArray_int32_T *cpu_iv193;
  emxArray_int32_T *cpu_iv194;
  emxArray_int32_T *cpu_iv195;
  emxArray_int32_T *cpu_iv196;
  emxArray_int32_T *cpu_iv198;
  emxArray_int32_T *cpu_iv202;
  emxArray_int32_T *cpu_iv203;
  emxArray_int32_T *cpu_iv41;
  emxArray_int32_T *cpu_iv42;
  emxArray_int32_T *cpu_iv43;
  emxArray_int32_T *cpu_iv44;
  emxArray_int32_T *cpu_iv45;
  emxArray_int32_T *cpu_iv46;
  emxArray_int32_T *cpu_iv47;
  emxArray_int32_T *cpu_iv48;
  emxArray_int32_T *cpu_iv49;
  emxArray_int32_T *cpu_iv50;
  emxArray_int32_T *cpu_iv51;
  emxArray_int32_T *cpu_iv52;
  emxArray_int32_T *cpu_iv53;
  emxArray_int32_T *cpu_iv54;
  emxArray_int32_T *cpu_iv55;
  emxArray_int32_T *cpu_iv56;
  emxArray_int32_T *cpu_iv57;
  emxArray_int32_T *cpu_iv58;
  emxArray_int32_T *cpu_iv61;
  emxArray_int32_T *cpu_iv62;
  emxArray_int32_T *cpu_iv63;
  emxArray_int32_T *cpu_iv64;
  emxArray_int32_T *cpu_iv65;
  emxArray_int32_T *cpu_iv66;
  emxArray_int32_T *cpu_iv68;
  emxArray_int32_T *cpu_iv69;
  emxArray_int32_T *cpu_iv70;
  emxArray_int32_T *cpu_iv71;
  emxArray_int32_T *cpu_iv72;
  emxArray_int32_T *cpu_iv73;
  emxArray_int32_T *cpu_iv74;
  emxArray_int32_T *cpu_iv75;
  emxArray_int32_T *cpu_iv76;
  emxArray_int32_T *cpu_iv77;
  emxArray_int32_T *cpu_iv78;
  emxArray_int32_T *cpu_iv79;
  emxArray_int32_T *cpu_iv8;
  emxArray_int32_T *cpu_iv80;
  emxArray_int32_T *cpu_iv81;
  emxArray_int32_T *cpu_iv83;
  emxArray_int32_T *cpu_iv85;
  emxArray_int32_T *cpu_iv86;
  emxArray_int32_T *cpu_iv87;
  emxArray_int32_T *cpu_iv88;
  emxArray_int32_T *cpu_iv89;
  emxArray_int32_T *cpu_iv9;
  emxArray_int32_T *cpu_iv90;
  emxArray_int32_T *cpu_iv91;
  emxArray_int32_T *cpu_iv92;
  emxArray_int32_T *cpu_iv93;
  emxArray_int32_T *cpu_iv94;
  emxArray_int32_T *cpu_iv96;
  emxArray_int32_T *cpu_iv97;
  emxArray_int32_T *cpu_iv98;
  emxArray_int32_T *cpu_iv99;
  emxArray_int32_T *cpu_jpvt;
  emxArray_int32_T *cpu_omega_tmp1;
  emxArray_int32_T *cpu_rows;
  emxArray_int32_T *d_cpu_cols;
  emxArray_int32_T *d_cpu_omega_tmp1;
  emxArray_int32_T *d_cpu_rows;
  emxArray_int32_T *db_cpu_rows;
  emxArray_int32_T *db_cpu_y;
  emxArray_int32_T *dc_cpu_rows;
  emxArray_int32_T *dc_cpu_y;
  emxArray_int32_T *dd_cpu_rows;
  emxArray_int32_T *dd_cpu_y;
  emxArray_int32_T *e_cpu_cols;
  emxArray_int32_T *e_cpu_rows;
  emxArray_int32_T *eb_cpu_rows;
  emxArray_int32_T *eb_cpu_y;
  emxArray_int32_T *ec_cpu_rows;
  emxArray_int32_T *ec_cpu_y;
  emxArray_int32_T *ed_cpu_rows;
  emxArray_int32_T *ed_cpu_y;
  emxArray_int32_T *eg_cpu_y;
  emxArray_int32_T *f_cpu_cols;
  emxArray_int32_T *f_cpu_rows;
  emxArray_int32_T *fb_cpu_rows;
  emxArray_int32_T *fb_cpu_y;
  emxArray_int32_T *fc_cpu_rows;
  emxArray_int32_T *fd_cpu_rows;
  emxArray_int32_T *fd_cpu_y;
  emxArray_int32_T *fg_cpu_y;
  emxArray_int32_T *g_cpu_cols;
  emxArray_int32_T *g_cpu_rows;
  emxArray_int32_T *gb_cpu_rows;
  emxArray_int32_T *gb_cpu_y;
  emxArray_int32_T *gc_cpu_rows;
  emxArray_int32_T *gc_cpu_y;
  emxArray_int32_T *gd_cpu_rows;
  emxArray_int32_T *gd_cpu_y;
  emxArray_int32_T *ge_cpu_y;
  emxArray_int32_T *gg_cpu_y;
  emxArray_int32_T *h_cpu_cols;
  emxArray_int32_T *h_cpu_rows;
  emxArray_int32_T *h_cpu_y;
  emxArray_int32_T *hb_cpu_rows;
  emxArray_int32_T *hb_cpu_y;
  emxArray_int32_T *hc_cpu_rows;
  emxArray_int32_T *hc_cpu_y;
  emxArray_int32_T *hd_cpu_rows;
  emxArray_int32_T *hd_cpu_y;
  emxArray_int32_T *he_cpu_y;
  emxArray_int32_T *hg_cpu_y;
  emxArray_int32_T *i_cpu_cols;
  emxArray_int32_T *i_cpu_rows;
  emxArray_int32_T *i_cpu_y;
  emxArray_int32_T *ib_cpu_rows;
  emxArray_int32_T *ib_cpu_y;
  emxArray_int32_T *ic_cpu_rows;
  emxArray_int32_T *ic_cpu_y;
  emxArray_int32_T *id_cpu_rows;
  emxArray_int32_T *id_cpu_y;
  emxArray_int32_T *ie_cpu_y;
  emxArray_int32_T *if_cpu_y;
  emxArray_int32_T *ig_cpu_y;
  emxArray_int32_T *j_cpu_cols;
  emxArray_int32_T *j_cpu_rows;
  emxArray_int32_T *j_cpu_y;
  emxArray_int32_T *jb_cpu_rows;
  emxArray_int32_T *jb_cpu_y;
  emxArray_int32_T *jc_cpu_rows;
  emxArray_int32_T *jc_cpu_y;
  emxArray_int32_T *jd_cpu_rows;
  emxArray_int32_T *jd_cpu_y;
  emxArray_int32_T *je_cpu_y;
  emxArray_int32_T *jf_cpu_y;
  emxArray_int32_T *jg_cpu_y;
  emxArray_int32_T *k_cpu_cols;
  emxArray_int32_T *k_cpu_rows;
  emxArray_int32_T *kb_cpu_rows;
  emxArray_int32_T *kb_cpu_y;
  emxArray_int32_T *kc_cpu_rows;
  emxArray_int32_T *kc_cpu_y;
  emxArray_int32_T *kd_cpu_rows;
  emxArray_int32_T *kd_cpu_y;
  emxArray_int32_T *ke_cpu_y;
  emxArray_int32_T *kf_cpu_y;
  emxArray_int32_T *kg_cpu_y;
  emxArray_int32_T *l_cpu_cols;
  emxArray_int32_T *l_cpu_rows;
  emxArray_int32_T *lb_cpu_rows;
  emxArray_int32_T *lb_cpu_y;
  emxArray_int32_T *lc_cpu_rows;
  emxArray_int32_T *ld_cpu_rows;
  emxArray_int32_T *ld_cpu_y;
  emxArray_int32_T *le_cpu_y;
  emxArray_int32_T *lf_cpu_y;
  emxArray_int32_T *lg_cpu_y;
  emxArray_int32_T *m_cpu_rows;
  emxArray_int32_T *m_cpu_y;
  emxArray_int32_T *mb_cpu_rows;
  emxArray_int32_T *mb_cpu_y;
  emxArray_int32_T *mc_cpu_rows;
  emxArray_int32_T *md_cpu_rows;
  emxArray_int32_T *md_cpu_y;
  emxArray_int32_T *me_cpu_y;
  emxArray_int32_T *mg_cpu_y;
  emxArray_int32_T *n_cpu_rows;
  emxArray_int32_T *n_cpu_y;
  emxArray_int32_T *nb_cpu_rows;
  emxArray_int32_T *nb_cpu_y;
  emxArray_int32_T *nc_cpu_rows;
  emxArray_int32_T *nc_cpu_y;
  emxArray_int32_T *nd_cpu_rows;
  emxArray_int32_T *nd_cpu_y;
  emxArray_int32_T *nf_cpu_y;
  emxArray_int32_T *ng_cpu_y;
  emxArray_int32_T *o_cpu_rows;
  emxArray_int32_T *o_cpu_y;
  emxArray_int32_T *ob_cpu_rows;
  emxArray_int32_T *ob_cpu_y;
  emxArray_int32_T *oc_cpu_rows;
  emxArray_int32_T *od_cpu_rows;
  emxArray_int32_T *od_cpu_y;
  emxArray_int32_T *oe_cpu_y;
  emxArray_int32_T *of_cpu_y;
  emxArray_int32_T *og_cpu_y;
  emxArray_int32_T *p_cpu_rows;
  emxArray_int32_T *p_cpu_y;
  emxArray_int32_T *pb_cpu_rows;
  emxArray_int32_T *pb_cpu_y;
  emxArray_int32_T *pc_cpu_rows;
  emxArray_int32_T *pc_cpu_y;
  emxArray_int32_T *pd_cpu_rows;
  emxArray_int32_T *pd_cpu_y;
  emxArray_int32_T *pe_cpu_y;
  emxArray_int32_T *pf_cpu_y;
  emxArray_int32_T *pg_cpu_y;
  emxArray_int32_T *q_cpu_rows;
  emxArray_int32_T *q_cpu_y;
  emxArray_int32_T *qb_cpu_rows;
  emxArray_int32_T *qb_cpu_y;
  emxArray_int32_T *qc_cpu_rows;
  emxArray_int32_T *qc_cpu_y;
  emxArray_int32_T *qd_cpu_y;
  emxArray_int32_T *qe_cpu_y;
  emxArray_int32_T *qf_cpu_y;
  emxArray_int32_T *qg_cpu_y;
  emxArray_int32_T *r_cpu_rows;
  emxArray_int32_T *r_cpu_y;
  emxArray_int32_T *rb_cpu_rows;
  emxArray_int32_T *rc_cpu_rows;
  emxArray_int32_T *rd_cpu_y;
  emxArray_int32_T *re_cpu_y;
  emxArray_int32_T *rf_cpu_y;
  emxArray_int32_T *rg_cpu_y;
  emxArray_int32_T *s_cpu_rows;
  emxArray_int32_T *sb_cpu_rows;
  emxArray_int32_T *sb_cpu_y;
  emxArray_int32_T *sc_cpu_rows;
  emxArray_int32_T *sd_cpu_y;
  emxArray_int32_T *se_cpu_y;
  emxArray_int32_T *sg_cpu_y;
  emxArray_int32_T *t_cpu_rows;
  emxArray_int32_T *tb_cpu_rows;
  emxArray_int32_T *tb_cpu_y;
  emxArray_int32_T *tc_cpu_rows;
  emxArray_int32_T *td_cpu_y;
  emxArray_int32_T *te_cpu_y;
  emxArray_int32_T *tg_cpu_y;
  emxArray_int32_T *u_cpu_rows;
  emxArray_int32_T *ub_cpu_rows;
  emxArray_int32_T *ub_cpu_y;
  emxArray_int32_T *uc_cpu_rows;
  emxArray_int32_T *ud_cpu_y;
  emxArray_int32_T *ue_cpu_y;
  emxArray_int32_T *uf_cpu_y;
  emxArray_int32_T *ug_cpu_y;
  emxArray_int32_T *v_cpu_rows;
  emxArray_int32_T *vb_cpu_rows;
  emxArray_int32_T *vc_cpu_rows;
  emxArray_int32_T *ve_cpu_y;
  emxArray_int32_T *vg_cpu_y;
  emxArray_int32_T *w_cpu_rows;
  emxArray_int32_T *wb_cpu_rows;
  emxArray_int32_T *wc_cpu_rows;
  emxArray_int32_T *wc_cpu_y;
  emxArray_int32_T *we_cpu_y;
  emxArray_int32_T *wf_cpu_y;
  emxArray_int32_T *wg_cpu_y;
  emxArray_int32_T *x_cpu_rows;
  emxArray_int32_T *xb_cpu_rows;
  emxArray_int32_T *xc_cpu_rows;
  emxArray_int32_T *xc_cpu_y;
  emxArray_int32_T *xe_cpu_y;
  emxArray_int32_T *xf_cpu_y;
  emxArray_int32_T *xg_cpu_y;
  emxArray_int32_T *y_cpu_rows;
  emxArray_int32_T *y_cpu_y;
  emxArray_int32_T *yb_cpu_rows;
  emxArray_int32_T *yc_cpu_rows;
  emxArray_int32_T *yc_cpu_y;
  emxArray_int32_T *yg_cpu_y;
  emxArray_ptrdiff_t *b_jpvt_t;
  emxArray_ptrdiff_t *jpvt_t;
  emxArray_real32_T ab_gpu_yCol;
  emxArray_real32_T ac_gpu_expanded;
  emxArray_real32_T ac_gpu_w;
  emxArray_real32_T ad_gpu_expanded;
  emxArray_real32_T b_gpu_a;
  emxArray_real32_T b_gpu_c;
  emxArray_real32_T b_gpu_h;
  emxArray_real32_T b_gpu_opts_filter;
  emxArray_real32_T b_gpu_psihat;
  emxArray_real32_T b_gpu_smooth;
  emxArray_real32_T b_gpu_x;
  emxArray_real32_T b_gpu_xCol;
  emxArray_real32_T b_gpu_xv;
  emxArray_real32_T b_gpu_y1;
  emxArray_real32_T bb_gpu_expanded;
  emxArray_real32_T bb_gpu_yCol;
  emxArray_real32_T bc_gpu_expanded;
  emxArray_real32_T bc_gpu_w;
  emxArray_real32_T bd_gpu_expanded;
  emxArray_real32_T c_gpu_x;
  emxArray_real32_T c_gpu_y;
  emxArray_real32_T cb_gpu_yCol;
  emxArray_real32_T cc_gpu_expanded;
  emxArray_real32_T cc_gpu_w;
  emxArray_real32_T cd_gpu_expanded;
  emxArray_real32_T ce_gpu_expanded;
  emxArray_real32_T d_gpu_expanded;
  emxArray_real32_T d_gpu_h;
  emxArray_real32_T db_gpu_expanded;
  emxArray_real32_T db_gpu_w;
  emxArray_real32_T db_gpu_yCol;
  emxArray_real32_T dc_gpu_expanded;
  emxArray_real32_T dc_gpu_w;
  emxArray_real32_T dd_gpu_expanded;
  emxArray_real32_T de_gpu_expanded;
  emxArray_real32_T e_gpu_smooth;
  emxArray_real32_T e_gpu_y;
  emxArray_real32_T eb_gpu_w;
  emxArray_real32_T ec_gpu_expanded;
  emxArray_real32_T ec_gpu_w;
  emxArray_real32_T ed_gpu_expanded;
  emxArray_real32_T ee_gpu_expanded;
  emxArray_real32_T f_gpu_expanded;
  emxArray_real32_T f_gpu_smooth;
  emxArray_real32_T fb_gpu_expanded;
  emxArray_real32_T fb_gpu_w;
  emxArray_real32_T fc_gpu_expanded;
  emxArray_real32_T fc_gpu_w;
  emxArray_real32_T fd_gpu_expanded;
  emxArray_real32_T fe_gpu_expanded;
  emxArray_real32_T g_gpu_result;
  emxArray_real32_T g_gpu_smooth;
  emxArray_real32_T g_gpu_y;
  emxArray_real32_T gb_gpu_w;
  emxArray_real32_T gc_gpu_expanded;
  emxArray_real32_T gd_gpu_expanded;
  emxArray_real32_T gpu_a;
  emxArray_real32_T gpu_c;
  emxArray_real32_T gpu_cfs1;
  emxArray_real32_T gpu_cfs2;
  emxArray_real32_T gpu_expanded;
  emxArray_real32_T gpu_opts_filter;
  emxArray_real32_T gpu_psihat;
  emxArray_real32_T gpu_smooth;
  emxArray_real32_T gpu_wtc;
  emxArray_real32_T gpu_x;
  emxArray_real32_T gpu_xv;
  emxArray_real32_T h_gpu_expanded;
  emxArray_real32_T h_gpu_result;
  emxArray_real32_T h_gpu_smooth;
  emxArray_real32_T h_gpu_x;
  emxArray_real32_T h_gpu_y;
  emxArray_real32_T hb_gpu_expanded;
  emxArray_real32_T hb_gpu_w;
  emxArray_real32_T hc_gpu_expanded;
  emxArray_real32_T hd_gpu_expanded;
  emxArray_real32_T he_gpu_y;
  emxArray_real32_T hf_gpu_y;
  emxArray_real32_T i_gpu_result;
  emxArray_real32_T i_gpu_x;
  emxArray_real32_T ib_gpu_w;
  emxArray_real32_T ic_gpu_expanded;
  emxArray_real32_T id_gpu_expanded;
  emxArray_real32_T ie_gpu_y;
  emxArray_real32_T if_gpu_y;
  emxArray_real32_T j_gpu_c;
  emxArray_real32_T j_gpu_result;
  emxArray_real32_T j_gpu_x;
  emxArray_real32_T jb_gpu_expanded;
  emxArray_real32_T jb_gpu_w;
  emxArray_real32_T jc_gpu_expanded;
  emxArray_real32_T jd_gpu_expanded;
  emxArray_real32_T k_gpu_c;
  emxArray_real32_T k_gpu_expanded;
  emxArray_real32_T k_gpu_result;
  emxArray_real32_T k_gpu_x;
  emxArray_real32_T kb_gpu_w;
  emxArray_real32_T kc_gpu_expanded;
  emxArray_real32_T kd_gpu_expanded;
  emxArray_real32_T l_gpu_c;
  emxArray_real32_T l_gpu_result;
  emxArray_real32_T l_gpu_x;
  emxArray_real32_T lb_gpu_w;
  emxArray_real32_T lc_gpu_expanded;
  emxArray_real32_T ld_gpu_expanded;
  emxArray_real32_T lg_gpu_y;
  emxArray_real32_T m_gpu_c;
  emxArray_real32_T m_gpu_expanded;
  emxArray_real32_T m_gpu_x;
  emxArray_real32_T mb_gpu_expanded;
  emxArray_real32_T mb_gpu_w;
  emxArray_real32_T mc_gpu_expanded;
  emxArray_real32_T md_gpu_expanded;
  emxArray_real32_T mg_gpu_y;
  emxArray_real32_T n_gpu_a;
  emxArray_real32_T n_gpu_c;
  emxArray_real32_T n_gpu_x;
  emxArray_real32_T nb_gpu_w;
  emxArray_real32_T nc_gpu_expanded;
  emxArray_real32_T nd_gpu_expanded;
  emxArray_real32_T o_gpu_a;
  emxArray_real32_T o_gpu_c;
  emxArray_real32_T o_gpu_expanded;
  emxArray_real32_T o_gpu_x;
  emxArray_real32_T ob_gpu_expanded;
  emxArray_real32_T ob_gpu_w;
  emxArray_real32_T oc_gpu_expanded;
  emxArray_real32_T od_gpu_expanded;
  emxArray_real32_T p_gpu_a;
  emxArray_real32_T p_gpu_c;
  emxArray_real32_T p_gpu_x;
  emxArray_real32_T pb_gpu_w;
  emxArray_real32_T pc_gpu_expanded;
  emxArray_real32_T pd_gpu_expanded;
  emxArray_real32_T q_gpu_a;
  emxArray_real32_T q_gpu_c;
  emxArray_real32_T q_gpu_expanded;
  emxArray_real32_T qb_gpu_expanded;
  emxArray_real32_T qb_gpu_w;
  emxArray_real32_T qc_gpu_expanded;
  emxArray_real32_T qd_gpu_expanded;
  emxArray_real32_T r_gpu_a;
  emxArray_real32_T r_gpu_c;
  emxArray_real32_T rb_gpu_w;
  emxArray_real32_T rc_gpu_expanded;
  emxArray_real32_T rd_gpu_expanded;
  emxArray_real32_T s_gpu_a;
  emxArray_real32_T s_gpu_c;
  emxArray_real32_T sb_gpu_w;
  emxArray_real32_T sc_gpu_expanded;
  emxArray_real32_T sd_gpu_expanded;
  emxArray_real32_T sd_gpu_y;
  emxArray_real32_T se_gpu_y;
  emxArray_real32_T sf_gpu_y;
  emxArray_real32_T t_gpu_c;
  emxArray_real32_T t_gpu_expanded;
  emxArray_real32_T t_gpu_yCol;
  emxArray_real32_T tb_gpu_expanded;
  emxArray_real32_T tb_gpu_w;
  emxArray_real32_T tc_gpu_expanded;
  emxArray_real32_T td_gpu_expanded;
  emxArray_real32_T td_gpu_y;
  emxArray_real32_T te_gpu_y;
  emxArray_real32_T u_gpu_c;
  emxArray_real32_T u_gpu_yCol;
  emxArray_real32_T ub_gpu_w;
  emxArray_real32_T uc_gpu_expanded;
  emxArray_real32_T ud_gpu_expanded;
  emxArray_real32_T ud_gpu_y;
  emxArray_real32_T ue_gpu_y;
  emxArray_real32_T v_gpu_c;
  emxArray_real32_T v_gpu_expanded;
  emxArray_real32_T v_gpu_yCol;
  emxArray_real32_T vb_gpu_expanded;
  emxArray_real32_T vb_gpu_w;
  emxArray_real32_T vc_gpu_expanded;
  emxArray_real32_T vd_gpu_expanded;
  emxArray_real32_T w_gpu_c;
  emxArray_real32_T w_gpu_yCol;
  emxArray_real32_T wb_gpu_w;
  emxArray_real32_T wc_gpu_expanded;
  emxArray_real32_T wd_gpu_expanded;
  emxArray_real32_T wf_gpu_y;
  emxArray_real32_T x_gpu_c;
  emxArray_real32_T x_gpu_expanded;
  emxArray_real32_T x_gpu_yCol;
  emxArray_real32_T xb_gpu_expanded;
  emxArray_real32_T xb_gpu_w;
  emxArray_real32_T xc_gpu_expanded;
  emxArray_real32_T xd_gpu_expanded;
  emxArray_real32_T xf_gpu_y;
  emxArray_real32_T y_gpu_yCol;
  emxArray_real32_T yb_gpu_w;
  emxArray_real32_T yc_gpu_expanded;
  emxArray_real32_T yd_gpu_expanded;
  emxArray_real32_T yf_gpu_y;
  emxArray_real32_T *ab_cpu_expanded;
  emxArray_real32_T *ab_cpu_w;
  emxArray_real32_T *ac_cpu_expanded;
  emxArray_real32_T *ac_cpu_y;
  emxArray_real32_T *ad_cpu_expanded;
  emxArray_real32_T *ae_cpu_y;
  emxArray_real32_T *b_cpu_a;
  emxArray_real32_T *b_cpu_c;
  emxArray_real32_T *b_cpu_expanded;
  emxArray_real32_T *b_cpu_h;
  emxArray_real32_T *b_cpu_opts_filter;
  emxArray_real32_T *b_cpu_psihat;
  emxArray_real32_T *b_cpu_result;
  emxArray_real32_T *b_cpu_smooth;
  emxArray_real32_T *b_cpu_w;
  emxArray_real32_T *b_cpu_x;
  emxArray_real32_T *b_cpu_xv;
  emxArray_real32_T *b_cpu_yCol;
  emxArray_real32_T *bb_cpu_expanded;
  emxArray_real32_T *bb_cpu_w;
  emxArray_real32_T *bc_cpu_expanded;
  emxArray_real32_T *be_cpu_y;
  emxArray_real32_T *c_cpu_expanded;
  emxArray_real32_T *c_cpu_result;
  emxArray_real32_T *c_cpu_smooth;
  emxArray_real32_T *c_cpu_w;
  emxArray_real32_T *c_cpu_x;
  emxArray_real32_T *c_cpu_yCol;
  emxArray_real32_T *cb_cpu_expanded;
  emxArray_real32_T *cb_cpu_w;
  emxArray_real32_T *cc_cpu_expanded;
  emxArray_real32_T *cpu_a;
  emxArray_real32_T *cpu_c;
  emxArray_real32_T *cpu_cfs1;
  emxArray_real32_T *cpu_cfs2;
  emxArray_real32_T *cpu_expanded;
  emxArray_real32_T *cpu_opts_filter;
  emxArray_real32_T *cpu_psihat;
  emxArray_real32_T *cpu_result;
  emxArray_real32_T *cpu_smooth;
  emxArray_real32_T *cpu_wtc;
  emxArray_real32_T *cpu_xCol;
  emxArray_real32_T *cpu_xv;
  emxArray_real32_T *cpu_y1;
  emxArray_real32_T *cpu_yCol;
  emxArray_real32_T *d_a;
  emxArray_real32_T *d_c;
  emxArray_real32_T *d_cpu_c;
  emxArray_real32_T *d_cpu_expanded;
  emxArray_real32_T *d_cpu_h;
  emxArray_real32_T *d_cpu_result;
  emxArray_real32_T *d_cpu_smooth;
  emxArray_real32_T *d_cpu_w;
  emxArray_real32_T *d_cpu_yCol;
  emxArray_real32_T *db_cpu_expanded;
  emxArray_real32_T *db_cpu_w;
  emxArray_real32_T *dc_cpu_expanded;
  emxArray_real32_T *de_cpu_expanded;
  emxArray_real32_T *e_a;
  emxArray_real32_T *e_c;
  emxArray_real32_T *e_cpu_a;
  emxArray_real32_T *e_cpu_c;
  emxArray_real32_T *e_cpu_result;
  emxArray_real32_T *e_cpu_smooth;
  emxArray_real32_T *e_cpu_w;
  emxArray_real32_T *e_cpu_yCol;
  emxArray_real32_T *eb_cpu_expanded;
  emxArray_real32_T *ec_cpu_expanded;
  emxArray_real32_T *ed_cpu_expanded;
  emxArray_real32_T *ee_cpu_expanded;
  emxArray_real32_T *f_cpu_a;
  emxArray_real32_T *f_cpu_c;
  emxArray_real32_T *f_cpu_result;
  emxArray_real32_T *f_cpu_smooth;
  emxArray_real32_T *f_cpu_w;
  emxArray_real32_T *f_cpu_y;
  emxArray_real32_T *f_cpu_yCol;
  emxArray_real32_T *fb_cpu_expanded;
  emxArray_real32_T *fc_cpu_expanded;
  emxArray_real32_T *fd_cpu_expanded;
  emxArray_real32_T *fe_cpu_expanded;
  emxArray_real32_T *g_cpu_a;
  emxArray_real32_T *g_cpu_c;
  emxArray_real32_T *g_cpu_expanded;
  emxArray_real32_T *g_cpu_w;
  emxArray_real32_T *g_cpu_x;
  emxArray_real32_T *g_cpu_yCol;
  emxArray_real32_T *gb_cpu_expanded;
  emxArray_real32_T *gd_cpu_expanded;
  emxArray_real32_T *h_cpu_a;
  emxArray_real32_T *h_cpu_c;
  emxArray_real32_T *h_cpu_expanded;
  emxArray_real32_T *h_cpu_w;
  emxArray_real32_T *h_cpu_x;
  emxArray_real32_T *h_cpu_yCol;
  emxArray_real32_T *hb_cpu_expanded;
  emxArray_real32_T *i_cpu_a;
  emxArray_real32_T *i_cpu_c;
  emxArray_real32_T *i_cpu_expanded;
  emxArray_real32_T *i_cpu_w;
  emxArray_real32_T *i_cpu_x;
  emxArray_real32_T *i_cpu_yCol;
  emxArray_real32_T *ib_cpu_expanded;
  emxArray_real32_T *id_cpu_expanded;
  emxArray_real32_T *j_cpu_a;
  emxArray_real32_T *j_cpu_c;
  emxArray_real32_T *j_cpu_expanded;
  emxArray_real32_T *j_cpu_w;
  emxArray_real32_T *j_cpu_x;
  emxArray_real32_T *j_cpu_yCol;
  emxArray_real32_T *jb_cpu_expanded;
  emxArray_real32_T *k_cpu_c;
  emxArray_real32_T *k_cpu_expanded;
  emxArray_real32_T *k_cpu_w;
  emxArray_real32_T *k_cpu_x;
  emxArray_real32_T *k_cpu_y;
  emxArray_real32_T *kb_cpu_expanded;
  emxArray_real32_T *kc_cpu_expanded;
  emxArray_real32_T *l_cpu_c;
  emxArray_real32_T *l_cpu_expanded;
  emxArray_real32_T *l_cpu_w;
  emxArray_real32_T *l_cpu_x;
  emxArray_real32_T *lb_cpu_expanded;
  emxArray_real32_T *ld_cpu_expanded;
  emxArray_real32_T *m_cpu_c;
  emxArray_real32_T *m_cpu_expanded;
  emxArray_real32_T *m_cpu_w;
  emxArray_real32_T *m_cpu_x;
  emxArray_real32_T *mb_cpu_expanded;
  emxArray_real32_T *md_cpu_expanded;
  emxArray_real32_T *n_cpu_c;
  emxArray_real32_T *n_cpu_expanded;
  emxArray_real32_T *n_cpu_w;
  emxArray_real32_T *n_cpu_x;
  emxArray_real32_T *nb_cpu_expanded;
  emxArray_real32_T *o_cpu_c;
  emxArray_real32_T *o_cpu_expanded;
  emxArray_real32_T *o_cpu_w;
  emxArray_real32_T *o_cpu_x;
  emxArray_real32_T *ob_cpu_expanded;
  emxArray_real32_T *oc_cpu_expanded;
  emxArray_real32_T *oc_cpu_y;
  emxArray_real32_T *od_cpu_expanded;
  emxArray_real32_T *p_cpu_c;
  emxArray_real32_T *p_cpu_expanded;
  emxArray_real32_T *p_cpu_w;
  emxArray_real32_T *pb_cpu_expanded;
  emxArray_real32_T *pc_cpu_expanded;
  emxArray_real32_T *q_cpu_c;
  emxArray_real32_T *q_cpu_expanded;
  emxArray_real32_T *q_cpu_w;
  emxArray_real32_T *qb_cpu_expanded;
  emxArray_real32_T *qc_cpu_expanded;
  emxArray_real32_T *r_cpu_c;
  emxArray_real32_T *r_cpu_expanded;
  emxArray_real32_T *r_cpu_w;
  emxArray_real32_T *rb_cpu_expanded;
  emxArray_real32_T *rb_cpu_y;
  emxArray_real32_T *rc_cpu_y;
  emxArray_real32_T *s_cpu_expanded;
  emxArray_real32_T *s_cpu_w;
  emxArray_real32_T *s_cpu_y;
  emxArray_real32_T *sb_cpu_expanded;
  emxArray_real32_T *sc_cpu_y;
  emxArray_real32_T *sd_cpu_expanded;
  emxArray_real32_T *t_cpu_expanded;
  emxArray_real32_T *t_cpu_w;
  emxArray_real32_T *t_cpu_y;
  emxArray_real32_T *tb_cpu_expanded;
  emxArray_real32_T *td_cpu_expanded;
  emxArray_real32_T *u_cpu_expanded;
  emxArray_real32_T *u_cpu_w;
  emxArray_real32_T *ub_cpu_expanded;
  emxArray_real32_T *ud_cpu_expanded;
  emxArray_real32_T *v_cpu_expanded;
  emxArray_real32_T *v_cpu_w;
  emxArray_real32_T *vb_cpu_expanded;
  emxArray_real32_T *vb_cpu_y;
  emxArray_real32_T *vc_cpu_expanded;
  emxArray_real32_T *vd_cpu_y;
  emxArray_real32_T *w_cpu_expanded;
  emxArray_real32_T *w_cpu_w;
  emxArray_real32_T *wb_cpu_expanded;
  emxArray_real32_T *wb_cpu_y;
  emxArray_real32_T *wd_cpu_y;
  emxArray_real32_T *x_cpu_expanded;
  emxArray_real32_T *x_cpu_w;
  emxArray_real32_T *x_cpu_y;
  emxArray_real32_T *xb_cpu_expanded;
  emxArray_real32_T *xb_cpu_y;
  emxArray_real32_T *xd_cpu_expanded;
  emxArray_real32_T *xd_cpu_y;
  emxArray_real32_T *y_cpu_expanded;
  emxArray_real32_T *y_cpu_w;
  emxArray_real32_T *yb_cpu_expanded;
  emxArray_real32_T *yb_cpu_y;
  emxArray_real32_T *yc_cpu_expanded;
  emxArray_real32_T *yd_cpu_expanded;
  emxArray_real32_T *yd_cpu_y;
  emxArray_real_T ag_gpu_y;
  emxArray_real_T b_gpu_Fmat;
  emxArray_real_T b_gpu_G;
  emxArray_real_T b_gpu_b;
  emxArray_real_T b_gpu_b0;
  emxArray_real_T b_gpu_h1;
  emxArray_real_T b_gpu_k;
  emxArray_real_T b_gpu_m;
  emxArray_real_T b_gpu_omega;
  emxArray_real_T b_gpu_omega_tmp2;
  emxArray_real_T b_gpu_sinc1A;
  emxArray_real_T b_gpu_sinc2A;
  emxArray_real_T b_gpu_sinc3A;
  emxArray_real_T b_gpu_sinc4A;
  emxArray_real_T b_gpu_tau;
  emxArray_real_T b_gpu_y;
  emxArray_real_T c_gpu_Fmat;
  emxArray_real_T c_gpu_h;
  emxArray_real_T c_gpu_omega;
  emxArray_real_T c_gpu_omega_tmp2;
  emxArray_real_T d_gpu_a;
  emxArray_real_T d_gpu_omega_tmp2;
  emxArray_real_T e_gpu_a;
  emxArray_real_T fb_gpu_y;
  emxArray_real_T fc_gpu_y;
  emxArray_real_T g_gpu_x;
  emxArray_real_T gc_gpu_w;
  emxArray_real_T gh_gpu_y;
  emxArray_real_T gpu_Fmat;
  emxArray_real_T gpu_G;
  emxArray_real_T gpu_b;
  emxArray_real_T gpu_b0;
  emxArray_real_T gpu_daughter;
  emxArray_real_T gpu_dv23;
  emxArray_real_T gpu_dv25;
  emxArray_real_T gpu_dv26;
  emxArray_real_T gpu_dv27;
  emxArray_real_T gpu_dv29;
  emxArray_real_T gpu_dv31;
  emxArray_real_T gpu_expnt;
  emxArray_real_T gpu_fb_Omega;
  emxArray_real_T gpu_fb_Scales;
  emxArray_real_T gpu_h;
  emxArray_real_T gpu_h1;
  emxArray_real_T gpu_k;
  emxArray_real_T gpu_m;
  emxArray_real_T gpu_omega;
  emxArray_real_T gpu_omega_tmp2;
  emxArray_real_T gpu_sinc1A;
  emxArray_real_T gpu_sinc2A;
  emxArray_real_T gpu_sinc3A;
  emxArray_real_T gpu_sinc4A;
  emxArray_real_T gpu_somega;
  emxArray_real_T gpu_tau;
  emxArray_real_T gpu_y;
  emxArray_real_T hh_gpu_y;
  emxArray_real_T i_gpu_y;
  emxArray_real_T ih_gpu_y;
  emxArray_real_T j_gpu_y;
  emxArray_real_T jd_gpu_y;
  emxArray_real_T je_gpu_y;
  emxArray_real_T jf_gpu_y;
  emxArray_real_T l_gpu_y;
  emxArray_real_T m_gpu_y;
  emxArray_real_T ng_gpu_y;
  emxArray_real_T pc_gpu_y;
  emxArray_real_T q_gpu_x;
  emxArray_real_T r_gpu_y;
  emxArray_real_T rb_gpu_y;
  emxArray_real_T tf_gpu_y;
  emxArray_real_T vc_gpu_y;
  emxArray_real_T vd_gpu_y;
  emxArray_real_T ve_gpu_y;
  emxArray_real_T *b_cpu_Fmat;
  emxArray_real_T *b_cpu_G;
  emxArray_real_T *b_cpu_b;
  emxArray_real_T *b_cpu_b0;
  emxArray_real_T *b_cpu_h1;
  emxArray_real_T *b_cpu_k;
  emxArray_real_T *b_cpu_m;
  emxArray_real_T *b_cpu_omega;
  emxArray_real_T *b_cpu_omega_tmp2;
  emxArray_real_T *b_cpu_sinc1A;
  emxArray_real_T *b_cpu_sinc2A;
  emxArray_real_T *b_cpu_sinc3A;
  emxArray_real_T *b_cpu_sinc4A;
  emxArray_real_T *b_cpu_tau;
  emxArray_real_T *b_cpu_y;
  emxArray_real_T *bb_cpu_y;
  emxArray_real_T *bg_cpu_y;
  emxArray_real_T *c_cpu_Fmat;
  emxArray_real_T *c_cpu_h;
  emxArray_real_T *c_cpu_omega;
  emxArray_real_T *c_cpu_omega_tmp2;
  emxArray_real_T *c_cpu_y;
  emxArray_real_T *cg_cpu_y;
  emxArray_real_T *cpu_Fmat;
  emxArray_real_T *cpu_G;
  emxArray_real_T *cpu_b;
  emxArray_real_T *cpu_b0;
  emxArray_real_T *cpu_daughter;
  emxArray_real_T *cpu_dv23;
  emxArray_real_T *cpu_dv25;
  emxArray_real_T *cpu_dv26;
  emxArray_real_T *cpu_dv27;
  emxArray_real_T *cpu_dv29;
  emxArray_real_T *cpu_dv31;
  emxArray_real_T *cpu_expnt;
  emxArray_real_T *cpu_fb_Omega;
  emxArray_real_T *cpu_fb_Scales;
  emxArray_real_T *cpu_h;
  emxArray_real_T *cpu_h1;
  emxArray_real_T *cpu_k;
  emxArray_real_T *cpu_m;
  emxArray_real_T *cpu_omega;
  emxArray_real_T *cpu_omega_tmp2;
  emxArray_real_T *cpu_sinc1A;
  emxArray_real_T *cpu_sinc2A;
  emxArray_real_T *cpu_sinc3A;
  emxArray_real_T *cpu_sinc4A;
  emxArray_real_T *cpu_somega;
  emxArray_real_T *cpu_tau;
  emxArray_real_T *cpu_w;
  emxArray_real_T *cpu_y;
  emxArray_real_T *d_cpu_a;
  emxArray_real_T *d_cpu_omega_tmp2;
  emxArray_real_T *d_cpu_y;
  emxArray_real_T *de_cpu_y;
  emxArray_real_T *dg_cpu_y;
  emxArray_real_T *e_cpu_y;
  emxArray_real_T *ee_cpu_y;
  emxArray_real_T *fc_cpu_y;
  emxArray_real_T *k_cpu_a;
  emxArray_real_T *lc_cpu_y;
  emxArray_real_T *mc_cpu_y;
  emxArray_real_T *mf_cpu_y;
  emxArray_real_T *ne_cpu_y;
  emxArray_real_T *p_cpu_x;
  emxArray_real_T *q_cpu_x;
  emxArray_real_T *sf_cpu_y;
  emxArray_real_T *tc_cpu_y;
  emxArray_real_T *tf_cpu_y;
  emxArray_real_T *uc_cpu_y;
  emxArray_real_T *v_cpu_y;
  emxArray_real_T *vc_cpu_y;
  emxArray_real_T *w_cpu_y;
  emxArray_uint32_T k_gpu_y;
  emxArray_uint32_T n_gpu_y;
  emxArray_uint32_T *ce_cpu_y;
  emxArray_uint32_T *u_cpu_y;
  const mxArray *ab_y;
  const mxArray *ac_y;
  const mxArray *ad_y;
  const mxArray *b_tmpStr;
  const mxArray *b_y;
  const mxArray *bb_y;
  const mxArray *bc_y;
  const mxArray *bd_y;
  const mxArray *c_tmpStr;
  const mxArray *c_y;
  const mxArray *cb_y;
  const mxArray *cc_y;
  const mxArray *cd_y;
  const mxArray *d_y;
  const mxArray *db_y;
  const mxArray *dc_y;
  const mxArray *dd_y;
  const mxArray *e_y;
  const mxArray *eb_y;
  const mxArray *ec_y;
  const mxArray *ed_y;
  const mxArray *f_y;
  const mxArray *fb_y;
  const mxArray *fc_y;
  const mxArray *fd_y;
  const mxArray *g_y;
  const mxArray *gb_y;
  const mxArray *gc_y;
  const mxArray *gd_y;
  const mxArray *h_y;
  const mxArray *hb_y;
  const mxArray *hc_y;
  const mxArray *hd_y;
  const mxArray *i_y;
  const mxArray *ib_y;
  const mxArray *ic_y;
  const mxArray *id_y;
  const mxArray *j_y;
  const mxArray *jb_y;
  const mxArray *jc_y;
  const mxArray *jd_y;
  const mxArray *k_y;
  const mxArray *kb_y;
  const mxArray *kc_y;
  const mxArray *kd_y;
  const mxArray *l_y;
  const mxArray *lb_y;
  const mxArray *lc_y;
  const mxArray *ld_y;
  const mxArray *m;
  const mxArray *m1;
  const mxArray *m10;
  const mxArray *m11;
  const mxArray *m12;
  const mxArray *m13;
  const mxArray *m15;
  const mxArray *m16;
  const mxArray *m17;
  const mxArray *m18;
  const mxArray *m19;
  const mxArray *m2;
  const mxArray *m20;
  const mxArray *m21;
  const mxArray *m22;
  const mxArray *m23;
  const mxArray *m24;
  const mxArray *m25;
  const mxArray *m26;
  const mxArray *m27;
  const mxArray *m28;
  const mxArray *m29;
  const mxArray *m3;
  const mxArray *m31;
  const mxArray *m32;
  const mxArray *m33;
  const mxArray *m34;
  const mxArray *m35;
  const mxArray *m36;
  const mxArray *m37;
  const mxArray *m38;
  const mxArray *m39;
  const mxArray *m4;
  const mxArray *m40;
  const mxArray *m41;
  const mxArray *m42;
  const mxArray *m43;
  const mxArray *m44;
  const mxArray *m45;
  const mxArray *m46;
  const mxArray *m47;
  const mxArray *m48;
  const mxArray *m49;
  const mxArray *m5;
  const mxArray *m50;
  const mxArray *m51;
  const mxArray *m52;
  const mxArray *m53;
  const mxArray *m54;
  const mxArray *m55;
  const mxArray *m57;
  const mxArray *m58;
  const mxArray *m59;
  const mxArray *m6;
  const mxArray *m60;
  const mxArray *m61;
  const mxArray *m62;
  const mxArray *m63;
  const mxArray *m64;
  const mxArray *m65;
  const mxArray *m66;
  const mxArray *m67;
  const mxArray *m68;
  const mxArray *m69;
  const mxArray *m7;
  const mxArray *m70;
  const mxArray *m71;
  const mxArray *m73;
  const mxArray *m74;
  const mxArray *m75;
  const mxArray *m76;
  const mxArray *m77;
  const mxArray *m78;
  const mxArray *m79;
  const mxArray *m8;
  const mxArray *m80;
  const mxArray *m81;
  const mxArray *m82;
  const mxArray *m83;
  const mxArray *m84;
  const mxArray *m85;
  const mxArray *m86;
  const mxArray *m87;
  const mxArray *m88;
  const mxArray *m89;
  const mxArray *m9;
  const mxArray *m90;
  const mxArray *m91;
  const mxArray *m92;
  const mxArray *m93;
  const mxArray *m_y;
  const mxArray *mb_y;
  const mxArray *mc_y;
  const mxArray *md_y;
  const mxArray *n_y;
  const mxArray *nb_y;
  const mxArray *nc_y;
  const mxArray *nd_y;
  const mxArray *o_y;
  const mxArray *ob_y;
  const mxArray *oc_y;
  const mxArray *od_y;
  const mxArray *p_y;
  const mxArray *pb_y;
  const mxArray *pc_y;
  const mxArray *q_y;
  const mxArray *qb_y;
  const mxArray *qc_y;
  const mxArray *r_y;
  const mxArray *rb_y;
  const mxArray *rc_y;
  const mxArray *s_y;
  const mxArray *sb_y;
  const mxArray *sc_y;
  const mxArray *t_y;
  const mxArray *tb_y;
  const mxArray *tc_y;
  const mxArray *u_y;
  const mxArray *ub_y;
  const mxArray *uc_y;
  const mxArray *v_y;
  const mxArray *vb_y;
  const mxArray *vc_y;
  const mxArray *w_y;
  const mxArray *wb_y;
  const mxArray *wc_y;
  const mxArray *x_y;
  const mxArray *xb_y;
  const mxArray *xc_y;
  const mxArray *y;
  const mxArray *y_y;
  const mxArray *yb_y;
  const mxArray *yc_y;
  creal_T *gpu_dc;
  creal_T *gpu_dc6;
  creal32_T (*gpu_a_data)[1];
  creal32_T *c_gpu_cfsposdft;
  int64_T f;
  real_T cpu_dv9_data[9735];
  real_T (*b_gpu_a_data)[9735];
  real_T (*b_gpu_fx_data)[9735];
  real_T (*b_gpu_x_data)[9735];
  real_T (*c_gpu_a_data)[9735];
  real_T (*c_gpu_fx_data)[9735];
  real_T (*d_gpu_fx_data)[9735];
  real_T (*gpu_dv15_data)[9735];
  real_T (*gpu_dv2_data)[9735];
  real_T (*gpu_dv8_data)[9735];
  real_T (*gpu_dv9_data)[9735];
  real_T (*gpu_fx_data)[9735];
  real_T (*gpu_x_data)[9735];
  real_T (*gpu_xt_data)[9735];
  real_T (*gpu_y_data)[9735];
  real_T cpu_subs[1298];
  real_T (*gpu_subs)[1298];
  real_T cpu_interval[650];
  real_T (*gpu_interval)[650];
  real_T errsub[649];
  real_T qsub[649];
  real_T F[4];
  real_T varargin_2[4];
  real_T c_blockDims[3];
  real_T FreqLimits[2];
  real_T NyquistRange[2];
  real_T Ly;
  real_T T;
  real_T a;
  real_T b_Ly;
  real_T b_c;
  real_T b_m;
  real_T b_r;
  real_T c_a;
  real_T d;
  real_T e;
  real_T fa;
  real_T fb;
  real_T fc;
  real_T halfh;
  real_T omegac;
  real_T p;
  real_T r;
  real_T s;
  real_T tol;
  real_T toler;
  int32_T b_blockDims[3];
  int32_T a_size[2];
  int32_T b_a_size[2];
  int32_T b_cpu_csz[2];
  int32_T b_xt_size[2];
  int32_T cpu_csz[2];
  int32_T dv13_size[2];
  int32_T dv2_size[2];
  int32_T dv6_size[2];
  int32_T dv9_size[2];
  int32_T fx_size[2];
  int32_T xt_size[2];
  int32_T (*b_gpu_csz)[2];
  int32_T (*gpu_csz)[2];
  int32_T omega_tmp2[1];
  int32_T b_eint;
  int32_T b_exponent;
  int32_T b_nx;
  int32_T c_eint;
  int32_T cpu_lidx;
  int32_T d_eint;
  int32_T eint;
  int32_T exitg2;
  int32_T exponent;
  int32_T i267;
  int32_T i273;
  int32_T i390;
  int32_T i69;
  int32_T i72;
  int32_T itime;
  int32_T ix;
  int32_T k;
  int32_T n;
  int32_T nrefine;
  int32_T nsubs;
  int32_T nx;
  int32_T offsetH;
  int32_T pathlen;
  int32_T x_size_idx_1;
  int32_T *gpu_lidx;
  real32_T cpu_cv_re;
  real32_T cv_im;
  real32_T *gpu_cv_re;
  real32_T *gpu_f;
  real32_T *gpu_f1;
  uint32_T blockDims[3];
  uint32_T xSize[2];
  uint32_T N;
  uint32_T b_u;
  char_T unusedExpr[23];
  char_T cpu_wav[4];
  char_T cpu_wname[4];
  char_T (*gpu_wav)[4];
  char_T (*gpu_wname)[4];
  int8_T threadDims[3];
  int8_T n_idx_0;
  boolean_T b_b[2];
  boolean_T G_needsGpuEnsureCapacity;
  boolean_T Nodd;
  boolean_T a_data_outdatedOnGpu;
  boolean_T b_G_needsGpuEnsureCapacity;
  boolean_T b_fx_data_outdatedOnCpu;
  boolean_T b_guard1;
  boolean_T b_h_needsGpuEnsureCapacity;
  boolean_T b_h_outdatedOnGpu;
  boolean_T b_p;
  boolean_T b_y_needsGpuEnsureCapacity;
  boolean_T c_omega_tmp1_needsGpuEnsureCapa;
  boolean_T c_p;
  boolean_T c_y_needsGpuEnsureCapacity;
  boolean_T d_omega_tmp1_needsGpuEnsureCapa;
  boolean_T d_y_needsGpuEnsureCapacity;
  boolean_T e_omega_tmp1_needsGpuEnsureCapa;
  boolean_T e_y_needsGpuEnsureCapacity;
  boolean_T exitg1;
  boolean_T exitg3;
  boolean_T exitg4;
  boolean_T f_omega_tmp1_needsGpuEnsureCapa;
  boolean_T f_y_needsGpuEnsureCapacity;
  boolean_T first_iteration;
  boolean_T fx_data_outdatedOnCpu;
  boolean_T g_y_needsGpuEnsureCapacity;
  boolean_T guard1;
  boolean_T h_needsGpuEnsureCapacity;
  boolean_T h_outdatedOnGpu;
  boolean_T h_y_needsGpuEnsureCapacity;
  boolean_T i_y_needsGpuEnsureCapacity;
  boolean_T interval_outdatedOnGpu;
  boolean_T j_y_needsGpuEnsureCapacity;
  boolean_T k_y_needsGpuEnsureCapacity;
  boolean_T l_y_needsGpuEnsureCapacity;
  boolean_T m_y_needsGpuEnsureCapacity;
  boolean_T n_y_needsGpuEnsureCapacity;
  boolean_T o_y_needsGpuEnsureCapacity;
  boolean_T opts_isRowVectorInput;
  boolean_T p_y_needsGpuEnsureCapacity;
  boolean_T validLaunchParams;
  boolean_T wav_outdatedOnCpu;
  boolean_T x_data_outdatedOnGpu;
  boolean_T y_needsGpuEnsureCapacity;
  if (!gpuConstsCopied_ec_wtcc) {
    gpuConstsCopied_ec_wtcc = true;
    checkCudaError(cudaMemcpy(*global_gpu_cv, cpu_cv, sizeof(char_T [128]),
      cudaMemcpyHostToDevice), __FILE__, __LINE__);
    checkCudaError(cudaMemcpy(*global_gpu_table100, cpu_table100, sizeof(real_T
      [100]), cudaMemcpyHostToDevice), __FILE__, __LINE__);
  }

  gpuEmxReset_creal32_T(&i_gpu_w);
  gpuEmxReset_creal32_T(&r_gpu_w);
  gpuEmxReset_creal32_T(&p_gpu_y);
  gpuEmxReset_creal32_T(&pb_gpu_y);
  gpuEmxReset_creal32_T(&cb_gpu_w);
  gpuEmxReset_creal32_T(&eb_gpu_y);
  gpuEmxReset_creal32_T(&ec_gpu_y);
  gpuEmxReset_creal32_T(&id_gpu_y);
  gpuEmxReset_creal32_T(&c_gpu_w);
  gpuEmxReset_creal32_T(&l_gpu_w);
  gpuEmxReset_creal32_T(&bb_gpu_w);
  gpuEmxReset_creal32_T(&f_gpu_w);
  gpuEmxReset_creal32_T(&o_gpu_w);
  gpuEmxReset_creal32_T(&y_gpu_w);
  gpuEmxReset_creal32_T(&h_gpu_w);
  gpuEmxReset_creal32_T(&q_gpu_w);
  gpuEmxReset_creal32_T(&tc_gpu_y);
  gpuEmxReset_creal32_T(&b_gpu_w);
  gpuEmxReset_creal32_T(&k_gpu_w);
  gpuEmxReset_creal32_T(&v_gpu_w);
  gpuEmxReset_creal32_T(&e_gpu_w);
  gpuEmxReset_creal32_T(&n_gpu_w);
  gpuEmxReset_creal32_T(&x_gpu_w);
  gpuEmxReset_creal32_T(&f_gpu_yCol);
  gpuEmxReset_creal32_T(&l_gpu_yCol);
  gpuEmxReset_creal32_T(&u_gpu_w);
  gpuEmxReset_creal32_T(&d_gpu_yCol);
  gpuEmxReset_creal32_T(&j_gpu_yCol);
  gpuEmxReset_creal32_T(&s_gpu_yCol);
  gpuEmxReset_creal32_T(&b_gpu_yCol);
  gpuEmxReset_creal32_T(&h_gpu_yCol);
  gpuEmxReset_creal32_T(&q_gpu_yCol);
  gpuEmxReset_creal32_T(&gpu_newIm);
  gpuEmxReset_creal32_T(&h_gpu_newIm);
  gpuEmxReset_creal32_T(&o_gpu_yCol);
  gpuEmxReset_creal32_T(&g_gpu_newIm);
  gpuEmxReset_creal32_T(&n_gpu_newIm);
  gpuEmxReset_creal32_T(&p_gpu_newIm);
  gpuEmxReset_creal32_T(&d_gpu_newIm);
  gpuEmxReset_creal32_T(&k_gpu_newIm);
  gpuEmxReset_creal32_T(&v_gpu_newIm);
  gpuEmxReset_creal32_T(&f_gpu_newIm);
  gpuEmxReset_creal32_T(&m_gpu_newIm);
  gpuEmxReset_creal32_T(&s_gpu_newIm);
  gpuEmxReset_creal32_T(&e_gpu_newIm);
  gpuEmxReset_creal32_T(&l_gpu_newIm);
  gpuEmxReset_creal32_T(&u_gpu_newIm);
  gpuEmxReset_creal32_T(&c_gpu_newIm);
  gpuEmxReset_creal32_T(&j_gpu_newIm);
  gpuEmxReset_creal32_T(&t_gpu_newIm);
  gpuEmxReset_creal32_T(&b_gpu_newIm);
  gpuEmxReset_creal32_T(&i_gpu_newIm);
  gpuEmxReset_creal32_T(&r_gpu_newIm);
  gpuEmxReset_int32_T(&m_gpu_rows);
  gpuEmxReset_int32_T(&bb_gpu_rows);
  gpuEmxReset_creal32_T(&q_gpu_newIm);
  gpuEmxReset_int32_T(&n_gpu_rows);
  gpuEmxReset_int32_T(&cb_gpu_rows);
  gpuEmxReset_int32_T(&rb_gpu_rows);
  gpuEmxReset_int32_T(&g_gpu_rows);
  gpuEmxReset_int32_T(&u_gpu_rows);
  gpuEmxReset_int32_T(&sb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv198);
  gpuEmxReset_int32_T(&gpu_iv196);
  gpuEmxReset_int32_T(&gpu_iv203);
  gpuEmxReset_int32_T(&h_gpu_rows);
  gpuEmxReset_int32_T(&v_gpu_rows);
  gpuEmxReset_int32_T(&lb_gpu_rows);
  gpuEmxReset_int32_T(&k_gpu_rows);
  gpuEmxReset_int32_T(&y_gpu_rows);
  gpuEmxReset_int32_T(&pb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv193);
  gpuEmxReset_int32_T(&gpu_iv192);
  gpuEmxReset_int32_T(&gpu_iv202);
  gpuEmxReset_int32_T(&b_gpu_rows);
  gpuEmxReset_int32_T(&p_gpu_rows);
  gpuEmxReset_int32_T(&gb_gpu_rows);
  gpuEmxReset_int32_T(&l_gpu_rows);
  gpuEmxReset_int32_T(&ab_gpu_rows);
  gpuEmxReset_int32_T(&mb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv188);
  gpuEmxReset_int32_T(&gpu_iv187);
  gpuEmxReset_int32_T(&qb_gpu_rows);
  gpuEmxReset_int32_T(&e_gpu_rows);
  gpuEmxReset_int32_T(&s_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv195);
  gpuEmxReset_int32_T(&gpu_iv186);
  gpuEmxReset_int32_T(&gpu_iv184);
  gpuEmxReset_int32_T(&gpu_iv194);
  gpuEmxReset_int32_T(&gpu_iv185);
  gpuEmxReset_int32_T(&gpu_iv183);
  gpuEmxReset_int32_T(&jb_gpu_rows);
  gpuEmxReset_int32_T(&f_gpu_rows);
  gpuEmxReset_int32_T(&t_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv190);
  gpuEmxReset_int32_T(&b_gpu_cols);
  gpuEmxReset_int32_T(&d_gpu_cols);
  gpuEmxReset_int32_T(&f_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv180);
  gpuEmxReset_int32_T(&gpu_iv178);
  gpuEmxReset_int32_T(&gpu_iv189);
  gpuEmxReset_int32_T(&mb_gpu_y);
  gpuEmxReset_int32_T(&mc_gpu_y);
  gpuEmxReset_int32_T(&kb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv175);
  gpuEmxReset_int32_T(&gpu_iv174);
  gpuEmxReset_int32_T(&qd_gpu_y);
  gpuEmxReset_int32_T(&j_gpu_rows);
  gpuEmxReset_int32_T(&x_gpu_rows);
  gpuEmxReset_int32_T(&ob_gpu_rows);
  gpuEmxReset_int32_T(&nb_gpu_y);
  gpuEmxReset_int32_T(&nc_gpu_y);
  gpuEmxReset_int32_T(&rd_gpu_y);
  gpuEmxReset_int32_T(&gpu_rows);
  gpuEmxReset_int32_T(&o_gpu_rows);
  gpuEmxReset_int32_T(&fb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_cols);
  gpuEmxReset_int32_T(&c_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv182);
  gpuEmxReset_int32_T(&gpu_iv173);
  gpuEmxReset_int32_T(&gpu_iv172);
  gpuEmxReset_real32_T(&xb_gpu_expanded);
  gpuEmxReset_real32_T(&o_gpu_expanded);
  gpuEmxReset_real32_T(&fb_gpu_expanded);
  gpuEmxReset_creal32_T(&yb_gpu_expanded);
  gpuEmxReset_creal32_T(&p_gpu_expanded);
  gpuEmxReset_creal32_T(&gb_gpu_expanded);
  checkCudaError(mwCudaMalloc(&gpu_f1, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_f, 4UL), __FILE__, __LINE__);
  gpuEmxReset_int32_T(&e_gpu_cols);
  gpuEmxReset_int32_T(&bb_gpu_y);
  gpuEmxReset_int32_T(&bc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv177);
  gpuEmxReset_int32_T(&d_gpu_rows);
  gpuEmxReset_int32_T(&r_gpu_rows);
  gpuEmxReset_int32_T(&fd_gpu_y);
  gpuEmxReset_int32_T(&cb_gpu_y);
  gpuEmxReset_int32_T(&cc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv176);
  gpuEmxReset_int32_T(&gpu_iv171);
  gpuEmxReset_int32_T(&gpu_iv170);
  gpuEmxReset_int32_T(&od_gpu_y);
  gpuEmxReset_int32_T(&kb_gpu_y);
  gpuEmxReset_int32_T(&kc_gpu_y);
  gpuEmxReset_int32_T(&ib_gpu_rows);
  gpuEmxReset_real32_T(&h_gpu_expanded);
  gpuEmxReset_real32_T(&x_gpu_expanded);
  gpuEmxReset_int32_T(&gd_gpu_y);
  gpuEmxReset_creal32_T(&i_gpu_expanded);
  gpuEmxReset_creal32_T(&y_gpu_expanded);
  gpuEmxReset_int32_T(&pd_gpu_y);
  gpuEmxReset_int32_T(&lb_gpu_y);
  gpuEmxReset_int32_T(&lc_gpu_y);
  gpuEmxReset_real32_T(&qb_gpu_expanded);
  gpuEmxReset_real32_T(&m_gpu_expanded);
  gpuEmxReset_real32_T(&db_gpu_expanded);
  gpuEmxReset_creal32_T(&rb_gpu_expanded);
  gpuEmxReset_creal32_T(&n_gpu_expanded);
  gpuEmxReset_creal32_T(&eb_gpu_expanded);
  gpuEmxReset_real32_T(&vb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv166);
  gpuEmxReset_int32_T(&gpu_iv165);
  gpuEmxReset_creal32_T(&wb_gpu_expanded);
  gpuEmxReset_int32_T(&y_gpu_y);
  gpuEmxReset_int32_T(&yb_gpu_y);
  gpuEmxReset_int32_T(&nb_gpu_rows);
  gpuEmxReset_int32_T(&i_gpu_rows);
  gpuEmxReset_int32_T(&w_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv169);
  gpuEmxReset_int32_T(&gpu_iv163);
  gpuEmxReset_int32_T(&gpu_iv162);
  gpuEmxReset_int32_T(&gpu_iv168);
  gpuEmxReset_int32_T(&ab_gpu_y);
  gpuEmxReset_int32_T(&ac_gpu_y);
  gpuEmxReset_int32_T(&dd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv161);
  gpuEmxReset_int32_T(&gpu_iv160);
  gpuEmxReset_int32_T(&gpu_iv167);
  gpuEmxReset_real32_T(&f_gpu_expanded);
  gpuEmxReset_real32_T(&v_gpu_expanded);
  gpuEmxReset_int32_T(&ed_gpu_y);
  gpuEmxReset_creal32_T(&g_gpu_expanded);
  gpuEmxReset_creal32_T(&w_gpu_expanded);
  gpuEmxReset_real_T(&jd_gpu_y);
  gpuEmxReset_real_T(&fb_gpu_y);
  gpuEmxReset_real_T(&fc_gpu_y);
  gpuEmxReset_real32_T(&ob_gpu_expanded);
  gpuEmxReset_int32_T(&c_gpu_rows);
  gpuEmxReset_int32_T(&q_gpu_rows);
  gpuEmxReset_creal32_T(&pb_gpu_expanded);
  gpuEmxReset_creal32_T(&o_gpu_y);
  gpuEmxReset_creal32_T(&ob_gpu_y);
  gpuEmxReset_int32_T(&hb_gpu_rows);
  gpuEmxReset_int32_T(&jb_gpu_y);
  gpuEmxReset_int32_T(&jc_gpu_y);
  gpuEmxReset_creal32_T(&sc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv154);
  gpuEmxReset_int32_T(&gpu_iv153);
  gpuEmxReset_int32_T(&nd_gpu_y);
  gpuEmxReset_real_T(&r_gpu_y);
  gpuEmxReset_real_T(&rb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv159);
  gpuEmxReset_int32_T(&gpu_iv151);
  gpuEmxReset_int32_T(&gpu_iv150);
  gpuEmxReset_int32_T(&gpu_iv158);
  gpuEmxReset_int32_T(&s_gpu_y);
  gpuEmxReset_int32_T(&sb_gpu_y);
  gpuEmxReset_int32_T(&wc_gpu_y);
  gpuEmxReset_int32_T(&x_gpu_y);
  gpuEmxReset_int32_T(&xb_gpu_y);
  gpuEmxReset_real_T(&vc_gpu_y);
  gpuEmxReset_int32_T(&t_gpu_y);
  gpuEmxReset_int32_T(&tb_gpu_y);
  gpuEmxReset_int32_T(&xc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv148);
  gpuEmxReset_int32_T(&gpu_iv146);
  gpuEmxReset_int32_T(&cd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv147);
  gpuEmxReset_int32_T(&gpu_iv145);
  gpuEmxReset_int32_T(&gpu_iv155);
  gpuEmxReset_real32_T(&gpu_expanded);
  gpuEmxReset_real32_T(&q_gpu_expanded);
  gpuEmxReset_real32_T(&jb_gpu_expanded);
  gpuEmxReset_creal32_T(&b_gpu_expanded);
  gpuEmxReset_creal32_T(&r_gpu_expanded);
  gpuEmxReset_creal32_T(&kb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv143);
  gpuEmxReset_int32_T(&gpu_iv142);
  gpuEmxReset_int32_T(&gpu_iv152);
  gpuEmxReset_creal32_T(&db_gpu_y);
  gpuEmxReset_creal32_T(&dc_gpu_y);
  gpuEmxReset_creal32_T(&hd_gpu_y);
  gpuEmxReset_creal32_T(&b_gpu_result);
  gpuEmxReset_creal32_T(&d_gpu_result);
  gpuEmxReset_int32_T(&gpu_iv149);
  gpuEmxReset_int32_T(&gpu_iv141);
  gpuEmxReset_int32_T(&gpu_iv140);
  gpuEmxReset_creal32_T(&f_gpu_result);
  gpuEmxReset_creal32_T(&q_gpu_y);
  gpuEmxReset_creal32_T(&qb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv144);
  gpuEmxReset_int32_T(&hb_gpu_y);
  gpuEmxReset_int32_T(&hc_gpu_y);
  gpuEmxReset_int32_T(&ld_gpu_y);
  gpuEmxReset_creal32_T(&gpu_result);
  gpuEmxReset_creal32_T(&c_gpu_result);
  gpuEmxReset_creal32_T(&uc_gpu_y);
  gpuEmxReset_int32_T(&ib_gpu_y);
  gpuEmxReset_int32_T(&ic_gpu_y);
  gpuEmxReset_creal32_T(&o_gpu_newIm);
  gpuEmxReset_int32_T(&md_gpu_y);
  gpuEmxReset_int32_T(&gb_gpu_y);
  gpuEmxReset_int32_T(&gc_gpu_y);
  gpuEmxReset_int32_T(&db_gpu_rows);
  gpuEmxReset_creal32_T(&e_gpu_result);
  gpuEmxReset_real_T(&g_gpu_x);
  gpuEmxReset_real32_T(&k_gpu_expanded);
  gpuEmxReset_real32_T(&bb_gpu_expanded);
  gpuEmxReset_int32_T(&eb_gpu_rows);
  gpuEmxReset_int32_T(&kd_gpu_y);
  gpuEmxReset_creal32_T(&l_gpu_expanded);
  gpuEmxReset_creal32_T(&cb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv139);
  gpuEmxReset_real32_T(&tb_gpu_expanded);
  gpuEmxReset_int32_T(&v_gpu_y);
  gpuEmxReset_int32_T(&vb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv138);
  gpuEmxReset_creal32_T(&ub_gpu_expanded);
  gpuEmxReset_int32_T(&w_gpu_y);
  gpuEmxReset_int32_T(&wb_gpu_y);
  gpuEmxReset_real_T(&pc_gpu_y);
  gpuEmxReset_int32_T(&ad_gpu_y);
  gpuEmxReset_creal32_T(&j_gpu_expanded);
  gpuEmxReset_creal32_T(&ab_gpu_expanded);
  gpuEmxReset_int32_T(&qc_gpu_y);
  gpuEmxReset_creal32_T(&sb_gpu_expanded);
  gpuEmxReset_int32_T(&u_gpu_y);
  gpuEmxReset_int32_T(&ub_gpu_y);
  gpuEmxReset_int32_T(&rc_gpu_y);
  gpuEmxReset_int32_T(&bd_gpu_y);
  gpuEmxReset_real32_T(&d_gpu_expanded);
  gpuEmxReset_real32_T(&t_gpu_expanded);
  gpuEmxReset_real32_T(&hb_gpu_expanded);
  gpuEmxReset_int32_T(&yc_gpu_y);
  gpuEmxReset_creal32_T(&e_gpu_expanded);
  gpuEmxReset_creal32_T(&u_gpu_expanded);
  gpuEmxReset_creal32_T(&ib_gpu_expanded);
  gpuEmxReset_real32_T(&mb_gpu_expanded);
  gpuEmxReset_creal32_T(&c_gpu_expanded);
  gpuEmxReset_creal32_T(&s_gpu_expanded);
  gpuEmxReset_creal32_T(&oc_gpu_y);
  gpuEmxReset_creal32_T(&nb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_IPIV);
  gpuEmxReset_creal32_T(&f_gpu_a);
  gpuEmxReset_creal32_T(&i_gpu_a);
  gpuEmxReset_creal32_T(&s_gpu_w);
  gpuEmxReset_creal32_T(&lb_gpu_expanded);
  gpuEmxReset_creal32_T(&m_gpu_yCol);
  gpuEmxReset_creal32_T(&m_gpu_a);
  gpuEmxReset_real_T(&gpu_tau);
  gpuEmxReset_creal32_T(&h_gpu_a);
  gpuEmxReset_creal32_T(&k_gpu_a);
  gpuEmxReset_creal32_T(&i_gpu_c);
  gpuEmxReset_int32_T(&gpu_jpvt);
  gpuEmxReset_creal32_T(&e_gpu_c);
  gpuEmxReset_creal32_T(&g_gpu_c);
  gpuEmxReset_creal32_T(&l_gpu_a);
  gpuEmxReset_creal32_T(&g_gpu_a);
  gpuEmxReset_creal32_T(&j_gpu_a);
  gpuEmxReset_creal32_T(&t_gpu_w);
  gpuEmxReset_real_T(&e_gpu_a);
  gpuEmxReset_creal32_T(&d_gpu_c);
  gpuEmxReset_creal32_T(&f_gpu_c);
  gpuEmxReset_creal32_T(&h_gpu_c);
  gpuEmxReset_real_T(&b_gpu_b0);
  gpuEmxReset_creal32_T(&gpu_w);
  gpuEmxReset_creal32_T(&j_gpu_w);
  gpuEmxReset_creal32_T(&ab_gpu_w);
  gpuEmxReset_creal32_T(&g_gpu_w);
  gpuEmxReset_creal32_T(&p_gpu_w);
  gpuEmxReset_creal32_T(&n_gpu_yCol);
  gpuEmxReset_creal32_T(&d_gpu_w);
  gpuEmxReset_creal32_T(&m_gpu_w);
  gpuEmxReset_creal32_T(&w_gpu_w);
  gpuEmxReset_creal32_T(&gpu_yCol);
  gpuEmxReset_creal32_T(&g_gpu_yCol);
  gpuEmxReset_creal32_T(&r_gpu_yCol);
  gpuEmxReset_creal32_T(&e_gpu_yCol);
  gpuEmxReset_creal32_T(&k_gpu_yCol);
  gpuEmxReset_creal32_T(&p_gpu_yCol);
  gpuEmxReset_creal32_T(&c_gpu_yCol);
  gpuEmxReset_creal32_T(&i_gpu_yCol);
  gpuEmxReset_creal32_T(&gpu_xCol);
  gpuEmxReset_creal32_T(&gpu_y1);
  gpuEmxReset_real_T(&m_gpu_y);
  gpuEmxReset_real_T(&l_gpu_y);
  gpuEmxReset_real_T(&gpu_dv31);
  gpuEmxReset_real_T(&gpu_dv29);
  gpuEmxReset_int32_T(&gpu_iv92);
  gpuEmxReset_real_T(&b_gpu_b);
  gpuEmxReset_uint32_T(&n_gpu_y);
  gpuEmxReset_real_T(&b_gpu_sinc4A);
  gpuEmxReset_real32_T(&d_gpu_h);
  gpuEmxReset_real_T(&b_gpu_sinc3A);
  gpuEmxReset_real_T(&b_gpu_sinc2A);
  gpuEmxReset_real_T(&b_gpu_sinc1A);
  gpuEmxReset_real32_T(&b_gpu_opts_filter);
  gpuEmxReset_real_T(&b_gpu_G);
  gpuEmxReset_real_T(&b_gpu_k);
  gpuEmxReset_real_T(&b_gpu_h1);
  gpuEmxReset_real_T(&b_gpu_m);
  gpuEmxReset_real_T(&gpu_dv27);
  gpuEmxReset_real_T(&c_gpu_h);
  checkCudaError(mwCudaMalloc(&gpu_csz, 8UL), __FILE__, __LINE__);
  gpuEmxReset_real32_T(&lb_gpu_w);
  gpuEmxReset_real32_T(&ub_gpu_w);
  gpuEmxReset_real32_T(&td_gpu_y);
  gpuEmxReset_real32_T(&te_gpu_y);
  gpuEmxReset_real32_T(&fc_gpu_w);
  gpuEmxReset_real32_T(&ie_gpu_y);
  gpuEmxReset_real32_T(&if_gpu_y);
  gpuEmxReset_real32_T(&mg_gpu_y);
  gpuEmxReset_real32_T(&fb_gpu_w);
  gpuEmxReset_real32_T(&ob_gpu_w);
  gpuEmxReset_real32_T(&ec_gpu_w);
  gpuEmxReset_real32_T(&ib_gpu_w);
  gpuEmxReset_real32_T(&rb_gpu_w);
  gpuEmxReset_real32_T(&cc_gpu_w);
  gpuEmxReset_real32_T(&kb_gpu_w);
  gpuEmxReset_real32_T(&tb_gpu_w);
  gpuEmxReset_real32_T(&xf_gpu_y);
  gpuEmxReset_real32_T(&eb_gpu_w);
  gpuEmxReset_real32_T(&nb_gpu_w);
  gpuEmxReset_real32_T(&yb_gpu_w);
  gpuEmxReset_real32_T(&hb_gpu_w);
  gpuEmxReset_real32_T(&qb_gpu_w);
  gpuEmxReset_real32_T(&bc_gpu_w);
  gpuEmxReset_int32_T(&gc_gpu_rows);
  gpuEmxReset_int32_T(&uc_gpu_rows);
  gpuEmxReset_real32_T(&xb_gpu_w);
  gpuEmxReset_int32_T(&hc_gpu_rows);
  gpuEmxReset_int32_T(&vc_gpu_rows);
  gpuEmxReset_int32_T(&ld_gpu_rows);
  gpuEmxReset_int32_T(&ac_gpu_rows);
  gpuEmxReset_int32_T(&oc_gpu_rows);
  gpuEmxReset_int32_T(&md_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv102);
  gpuEmxReset_int32_T(&gpu_iv100);
  gpuEmxReset_int32_T(&gpu_iv107);
  gpuEmxReset_int32_T(&bc_gpu_rows);
  gpuEmxReset_int32_T(&pc_gpu_rows);
  gpuEmxReset_int32_T(&fd_gpu_rows);
  gpuEmxReset_int32_T(&ec_gpu_rows);
  gpuEmxReset_int32_T(&sc_gpu_rows);
  gpuEmxReset_int32_T(&jd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv97);
  gpuEmxReset_int32_T(&gpu_iv96);
  gpuEmxReset_int32_T(&gpu_iv106);
  gpuEmxReset_int32_T(&ub_gpu_rows);
  gpuEmxReset_int32_T(&jc_gpu_rows);
  gpuEmxReset_int32_T(&ad_gpu_rows);
  gpuEmxReset_int32_T(&fc_gpu_rows);
  gpuEmxReset_int32_T(&tc_gpu_rows);
  gpuEmxReset_int32_T(&gd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv91);
  gpuEmxReset_int32_T(&gpu_iv90);
  gpuEmxReset_int32_T(&kd_gpu_rows);
  gpuEmxReset_int32_T(&xb_gpu_rows);
  gpuEmxReset_int32_T(&mc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv99);
  gpuEmxReset_int32_T(&gpu_iv89);
  gpuEmxReset_int32_T(&gpu_iv87);
  gpuEmxReset_int32_T(&gpu_iv98);
  gpuEmxReset_int32_T(&gpu_iv88);
  gpuEmxReset_int32_T(&gpu_iv86);
  gpuEmxReset_int32_T(&dd_gpu_rows);
  gpuEmxReset_int32_T(&yb_gpu_rows);
  gpuEmxReset_int32_T(&nc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv94);
  gpuEmxReset_int32_T(&h_gpu_cols);
  gpuEmxReset_int32_T(&j_gpu_cols);
  gpuEmxReset_int32_T(&l_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv83);
  gpuEmxReset_int32_T(&gpu_iv81);
  gpuEmxReset_int32_T(&gpu_iv93);
  gpuEmxReset_int32_T(&qe_gpu_y);
  gpuEmxReset_int32_T(&qf_gpu_y);
  gpuEmxReset_int32_T(&ed_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv78);
  gpuEmxReset_int32_T(&gpu_iv77);
  gpuEmxReset_int32_T(&ug_gpu_y);
  gpuEmxReset_int32_T(&dc_gpu_rows);
  gpuEmxReset_int32_T(&rc_gpu_rows);
  gpuEmxReset_int32_T(&id_gpu_rows);
  gpuEmxReset_int32_T(&re_gpu_y);
  gpuEmxReset_int32_T(&rf_gpu_y);
  gpuEmxReset_int32_T(&vg_gpu_y);
  gpuEmxReset_int32_T(&tb_gpu_rows);
  gpuEmxReset_int32_T(&ic_gpu_rows);
  gpuEmxReset_int32_T(&yc_gpu_rows);
  gpuEmxReset_int32_T(&g_gpu_cols);
  gpuEmxReset_int32_T(&i_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv85);
  gpuEmxReset_int32_T(&gpu_iv76);
  gpuEmxReset_int32_T(&gpu_iv75);
  gpuEmxReset_real32_T(&xd_gpu_expanded);
  gpuEmxReset_real32_T(&oc_gpu_expanded);
  gpuEmxReset_real32_T(&fd_gpu_expanded);
  gpuEmxReset_real32_T(&yd_gpu_expanded);
  gpuEmxReset_real32_T(&pc_gpu_expanded);
  gpuEmxReset_real32_T(&gd_gpu_expanded);
  gpuEmxReset_int32_T(&k_gpu_cols);
  gpuEmxReset_int32_T(&fe_gpu_y);
  gpuEmxReset_int32_T(&ff_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv80);
  gpuEmxReset_int32_T(&wb_gpu_rows);
  gpuEmxReset_int32_T(&lc_gpu_rows);
  gpuEmxReset_int32_T(&jg_gpu_y);
  gpuEmxReset_int32_T(&ge_gpu_y);
  gpuEmxReset_int32_T(&gf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv79);
  gpuEmxReset_int32_T(&gpu_iv74);
  gpuEmxReset_int32_T(&gpu_iv73);
  gpuEmxReset_int32_T(&sg_gpu_y);
  gpuEmxReset_int32_T(&oe_gpu_y);
  gpuEmxReset_int32_T(&of_gpu_y);
  gpuEmxReset_int32_T(&cd_gpu_rows);
  gpuEmxReset_real32_T(&hc_gpu_expanded);
  gpuEmxReset_real32_T(&xc_gpu_expanded);
  gpuEmxReset_int32_T(&kg_gpu_y);
  gpuEmxReset_real32_T(&ic_gpu_expanded);
  gpuEmxReset_real32_T(&yc_gpu_expanded);
  gpuEmxReset_int32_T(&tg_gpu_y);
  gpuEmxReset_int32_T(&pe_gpu_y);
  gpuEmxReset_int32_T(&pf_gpu_y);
  gpuEmxReset_real32_T(&qd_gpu_expanded);
  gpuEmxReset_real32_T(&mc_gpu_expanded);
  gpuEmxReset_real32_T(&dd_gpu_expanded);
  gpuEmxReset_real32_T(&rd_gpu_expanded);
  gpuEmxReset_real32_T(&nc_gpu_expanded);
  gpuEmxReset_real32_T(&ed_gpu_expanded);
  gpuEmxReset_real32_T(&vd_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv69);
  gpuEmxReset_int32_T(&gpu_iv68);
  gpuEmxReset_real32_T(&wd_gpu_expanded);
  gpuEmxReset_int32_T(&de_gpu_y);
  gpuEmxReset_int32_T(&df_gpu_y);
  gpuEmxReset_int32_T(&hd_gpu_rows);
  gpuEmxReset_int32_T(&cc_gpu_rows);
  gpuEmxReset_int32_T(&qc_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv72);
  gpuEmxReset_int32_T(&gpu_iv66);
  gpuEmxReset_int32_T(&gpu_iv65);
  gpuEmxReset_int32_T(&gpu_iv71);
  gpuEmxReset_int32_T(&ee_gpu_y);
  gpuEmxReset_int32_T(&ef_gpu_y);
  gpuEmxReset_int32_T(&hg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv64);
  gpuEmxReset_int32_T(&gpu_iv63);
  gpuEmxReset_creal32_T(&gpu_opts_x);
  gpuEmxReset_int32_T(&gpu_iv70);
  gpuEmxReset_real32_T(&fc_gpu_expanded);
  gpuEmxReset_real32_T(&vc_gpu_expanded);
  gpuEmxReset_int32_T(&ig_gpu_y);
  gpuEmxReset_real32_T(&gc_gpu_expanded);
  gpuEmxReset_real32_T(&wc_gpu_expanded);
  gpuEmxReset_real_T(&ng_gpu_y);
  gpuEmxReset_real_T(&je_gpu_y);
  gpuEmxReset_real_T(&jf_gpu_y);
  gpuEmxReset_real32_T(&od_gpu_expanded);
  gpuEmxReset_int32_T(&vb_gpu_rows);
  gpuEmxReset_int32_T(&kc_gpu_rows);
  gpuEmxReset_real32_T(&pd_gpu_expanded);
  gpuEmxReset_real32_T(&sd_gpu_y);
  gpuEmxReset_real32_T(&se_gpu_y);
  gpuEmxReset_int32_T(&bd_gpu_rows);
  gpuEmxReset_int32_T(&ne_gpu_y);
  gpuEmxReset_int32_T(&nf_gpu_y);
  gpuEmxReset_real32_T(&wf_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv57);
  gpuEmxReset_int32_T(&gpu_iv56);
  gpuEmxReset_int32_T(&rg_gpu_y);
  gpuEmxReset_real_T(&vd_gpu_y);
  gpuEmxReset_real_T(&ve_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv62);
  gpuEmxReset_int32_T(&gpu_iv54);
  gpuEmxReset_int32_T(&gpu_iv53);
  gpuEmxReset_int32_T(&gpu_iv61);
  gpuEmxReset_int32_T(&wd_gpu_y);
  gpuEmxReset_int32_T(&we_gpu_y);
  gpuEmxReset_int32_T(&bg_gpu_y);
  gpuEmxReset_int32_T(&ce_gpu_y);
  gpuEmxReset_int32_T(&cf_gpu_y);
  gpuEmxReset_real_T(&ag_gpu_y);
  gpuEmxReset_int32_T(&xd_gpu_y);
  gpuEmxReset_int32_T(&xe_gpu_y);
  gpuEmxReset_int32_T(&cg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv51);
  gpuEmxReset_int32_T(&gpu_iv49);
  gpuEmxReset_int32_T(&gg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv50);
  gpuEmxReset_int32_T(&gpu_iv48);
  gpuEmxReset_int32_T(&gpu_iv58);
  gpuEmxReset_real32_T(&ac_gpu_expanded);
  gpuEmxReset_real32_T(&qc_gpu_expanded);
  gpuEmxReset_real32_T(&jd_gpu_expanded);
  gpuEmxReset_real32_T(&bc_gpu_expanded);
  gpuEmxReset_real32_T(&rc_gpu_expanded);
  gpuEmxReset_real32_T(&kd_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv46);
  gpuEmxReset_int32_T(&gpu_iv45);
  gpuEmxReset_int32_T(&gpu_iv55);
  gpuEmxReset_real32_T(&he_gpu_y);
  gpuEmxReset_real32_T(&hf_gpu_y);
  gpuEmxReset_real32_T(&lg_gpu_y);
  gpuEmxReset_real32_T(&h_gpu_result);
  gpuEmxReset_real32_T(&j_gpu_result);
  gpuEmxReset_int32_T(&gpu_iv52);
  gpuEmxReset_int32_T(&gpu_iv44);
  gpuEmxReset_int32_T(&gpu_iv43);
  gpuEmxReset_real32_T(&l_gpu_result);
  gpuEmxReset_real32_T(&ud_gpu_y);
  gpuEmxReset_real32_T(&ue_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv47);
  gpuEmxReset_int32_T(&le_gpu_y);
  gpuEmxReset_int32_T(&lf_gpu_y);
  gpuEmxReset_int32_T(&pg_gpu_y);
  gpuEmxReset_real32_T(&g_gpu_result);
  gpuEmxReset_real32_T(&i_gpu_result);
  gpuEmxReset_real32_T(&yf_gpu_y);
  gpuEmxReset_int32_T(&me_gpu_y);
  gpuEmxReset_int32_T(&mf_gpu_y);
  gpuEmxReset_int32_T(&qg_gpu_y);
  gpuEmxReset_real32_T(&j_gpu_c);
  gpuEmxReset_real32_T(&o_gpu_c);
  gpuEmxReset_real32_T(&t_gpu_c);
  gpuEmxReset_int32_T(&ke_gpu_y);
  gpuEmxReset_int32_T(&kf_gpu_y);
  gpuEmxReset_real32_T(&k_gpu_result);
  gpuEmxReset_real32_T(&kc_gpu_expanded);
  gpuEmxReset_real32_T(&bd_gpu_expanded);
  gpuEmxReset_int32_T(&og_gpu_y);
  gpuEmxReset_real32_T(&lc_gpu_expanded);
  gpuEmxReset_real32_T(&cd_gpu_expanded);
  gpuEmxReset_real32_T(&td_gpu_expanded);
  gpuEmxReset_int32_T(&ae_gpu_y);
  gpuEmxReset_int32_T(&af_gpu_y);
  gpuEmxReset_real32_T(&ud_gpu_expanded);
  gpuEmxReset_int32_T(&be_gpu_y);
  gpuEmxReset_int32_T(&bf_gpu_y);
  gpuEmxReset_int32_T(&eg_gpu_y);
  gpuEmxReset_real32_T(&jc_gpu_expanded);
  gpuEmxReset_real32_T(&ad_gpu_expanded);
  gpuEmxReset_int32_T(&wc_gpu_rows);
  gpuEmxReset_real32_T(&sd_gpu_expanded);
  gpuEmxReset_real_T(&q_gpu_x);
  gpuEmxReset_int32_T(&yd_gpu_y);
  gpuEmxReset_int32_T(&ye_gpu_y);
  gpuEmxReset_int32_T(&xc_gpu_rows);
  gpuEmxReset_int32_T(&fg_gpu_y);
  gpuEmxReset_real32_T(&dc_gpu_expanded);
  gpuEmxReset_real32_T(&tc_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv42);
  gpuEmxReset_int32_T(&dg_gpu_y);
  gpuEmxReset_real32_T(&ec_gpu_expanded);
  gpuEmxReset_real32_T(&uc_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv41);
  gpuEmxReset_real32_T(&md_gpu_expanded);
  gpuEmxReset_real32_T(&cc_gpu_expanded);
  gpuEmxReset_real32_T(&sc_gpu_expanded);
  gpuEmxReset_real_T(&tf_gpu_y);
  gpuEmxReset_real32_T(&nd_gpu_expanded);
  gpuEmxReset_real32_T(&n_gpu_c);
  gpuEmxReset_real32_T(&s_gpu_c);
  gpuEmxReset_int32_T(&uf_gpu_y);
  gpuEmxReset_real32_T(&x_gpu_c);
  gpuEmxReset_real32_T(&l_gpu_c);
  gpuEmxReset_real32_T(&q_gpu_c);
  gpuEmxReset_int32_T(&vf_gpu_y);
  gpuEmxReset_real32_T(&ld_gpu_expanded);
  gpuEmxReset_real32_T(&hd_gpu_expanded);
  gpuEmxReset_real32_T(&v_gpu_c);
  gpuEmxReset_real32_T(&id_gpu_expanded);
  gpuEmxReset_real32_T(&s_gpu_a);
  gpuEmxReset_real32_T(&o_gpu_a);
  gpuEmxReset_real32_T(&q_gpu_a);
  gpuEmxReset_real32_T(&sf_gpu_y);
  gpuEmxReset_real32_T(&w_gpu_c);
  gpuEmxReset_int32_T(&b_gpu_IPIV);
  gpuEmxReset_real32_T(&m_gpu_c);
  gpuEmxReset_real32_T(&r_gpu_c);
  gpuEmxReset_real32_T(&vb_gpu_w);
  gpuEmxReset_real32_T(&r_gpu_a);
  gpuEmxReset_real32_T(&n_gpu_a);
  gpuEmxReset_real32_T(&p_gpu_a);
  gpuEmxReset_real32_T(&ab_gpu_yCol);
  gpuEmxReset_real32_T(&wb_gpu_w);
  gpuEmxReset_real_T(&b_gpu_tau);
  gpuEmxReset_real32_T(&k_gpu_c);
  gpuEmxReset_real32_T(&p_gpu_c);
  gpuEmxReset_real32_T(&u_gpu_c);
  gpuEmxReset_int32_T(&b_gpu_jpvt);
  gpuEmxReset_real32_T(&db_gpu_w);
  gpuEmxReset_real32_T(&mb_gpu_w);
  gpuEmxReset_real32_T(&n_gpu_x);
  gpuEmxReset_real32_T(&h_gpu_x);
  gpuEmxReset_real32_T(&k_gpu_x);
  gpuEmxReset_real32_T(&dc_gpu_w);
  gpuEmxReset_real_T(&d_gpu_a);
  gpuEmxReset_real32_T(&jb_gpu_w);
  gpuEmxReset_real32_T(&sb_gpu_w);
  gpuEmxReset_real32_T(&p_gpu_x);
  gpuEmxReset_real_T(&gpu_b0);
  gpuEmxReset_real32_T(&gb_gpu_w);
  gpuEmxReset_real32_T(&pb_gpu_w);
  gpuEmxReset_real32_T(&ac_gpu_w);
  gpuEmxReset_real32_T(&j_gpu_x);
  gpuEmxReset_real32_T(&m_gpu_x);
  gpuEmxReset_real32_T(&bb_gpu_yCol);
  gpuEmxReset_real32_T(&t_gpu_yCol);
  gpuEmxReset_real32_T(&w_gpu_yCol);
  gpuEmxReset_real32_T(&o_gpu_x);
  gpuEmxReset_real32_T(&i_gpu_x);
  gpuEmxReset_real32_T(&l_gpu_x);
  gpuEmxReset_real32_T(&db_gpu_yCol);
  gpuEmxReset_real32_T(&v_gpu_yCol);
  gpuEmxReset_real32_T(&y_gpu_yCol);
  gpuEmxReset_real32_T(&cb_gpu_yCol);
  gpuEmxReset_real32_T(&u_gpu_yCol);
  gpuEmxReset_real32_T(&x_gpu_yCol);
  gpuEmxReset_real32_T(&b_gpu_xCol);
  gpuEmxReset_real32_T(&b_gpu_y1);
  gpuEmxReset_real_T(&j_gpu_y);
  gpuEmxReset_real_T(&i_gpu_y);
  gpuEmxReset_real_T(&gpu_dv26);
  gpuEmxReset_real_T(&gpu_dv25);
  gpuEmxReset_int32_T(&gpu_iv18);
  gpuEmxReset_real_T(&gpu_b);
  gpuEmxReset_uint32_T(&k_gpu_y);
  gpuEmxReset_real_T(&gpu_sinc4A);
  gpuEmxReset_real32_T(&b_gpu_h);
  gpuEmxReset_real_T(&gpu_sinc3A);
  gpuEmxReset_real_T(&gpu_sinc2A);
  gpuEmxReset_real_T(&gpu_sinc1A);
  gpuEmxReset_real32_T(&gpu_opts_filter);
  gpuEmxReset_real_T(&gpu_G);
  gpuEmxReset_real_T(&gpu_k);
  gpuEmxReset_real_T(&gpu_h1);
  gpuEmxReset_real_T(&gpu_m);
  gpuEmxReset_real_T(&gpu_dv23);
  gpuEmxReset_real_T(&gpu_h);
  gpuEmxReset_real32_T(&gpu_wtc);
  gpuEmxReset_real32_T(&h_gpu_y);
  gpuEmxReset_real32_T(&g_gpu_y);
  checkCudaError(mwCudaMalloc(&gpu_cv_re, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_a_data, 8UL), __FILE__, __LINE__);
  gpuEmxReset_creal32_T(&d_gpu_smooth);
  gpuEmxReset_creal32_T(&w_gpu_newIm);
  gpuEmxReset_int32_T(&nd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv17);
  gpuEmxReset_int32_T(&yg_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv16);
  gpuEmxReset_int32_T(&gpu_iv15);
  gpuEmxReset_int32_T(&wg_gpu_y);
  gpuEmxReset_creal32_T(&ae_gpu_expanded);
  gpuEmxReset_int32_T(&xg_gpu_y);
  gpuEmxReset_creal32_T(&be_gpu_expanded);
  gpuEmxReset_creal32_T(&c_gpu_c);
  gpuEmxReset_creal32_T(&c_gpu_a);
  gpuEmxReset_creal32_T(&c_gpu_smooth);
  gpuEmxReset_creal32_T(&f_gpu_x);
  gpuEmxReset_real_T(&c_gpu_Fmat);
  gpuEmxReset_creal32_T(&c_gpu_cfsDFT);
  gpuEmxReset_real_T(&c_gpu_omega);
  gpuEmxReset_real_T(&d_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&d_gpu_omega_tmp1);
  gpuEmxReset_creal32_T(&gpu_crossCFS);
  gpuEmxReset_real32_T(&f_gpu_smooth);
  gpuEmxReset_real32_T(&e_gpu_smooth);
  gpuEmxReset_int32_T(&od_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv13);
  gpuEmxReset_int32_T(&ch_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv12);
  gpuEmxReset_int32_T(&gpu_iv11);
  gpuEmxReset_int32_T(&ah_gpu_y);
  gpuEmxReset_real32_T(&ce_gpu_expanded);
  gpuEmxReset_int32_T(&bh_gpu_y);
  gpuEmxReset_real32_T(&de_gpu_expanded);
  gpuEmxReset_real32_T(&b_gpu_c);
  gpuEmxReset_real32_T(&b_gpu_a);
  gpuEmxReset_real32_T(&b_gpu_smooth);
  gpuEmxReset_creal32_T(&f_gpu_y);
  gpuEmxReset_creal32_T(&e_gpu_x);
  gpuEmxReset_real_T(&b_gpu_Fmat);
  gpuEmxReset_creal32_T(&b_gpu_cfsDFT);
  gpuEmxReset_real_T(&b_gpu_omega);
  gpuEmxReset_real_T(&c_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&c_gpu_omega_tmp1);
  gpuEmxReset_real32_T(&gpu_cfs2);
  gpuEmxReset_real32_T(&e_gpu_y);
  gpuEmxReset_real32_T(&h_gpu_smooth);
  gpuEmxReset_real32_T(&g_gpu_smooth);
  gpuEmxReset_int32_T(&pd_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv10);
  gpuEmxReset_int32_T(&fh_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv9);
  gpuEmxReset_int32_T(&gpu_iv8);
  gpuEmxReset_int32_T(&dh_gpu_y);
  gpuEmxReset_real32_T(&ee_gpu_expanded);
  gpuEmxReset_int32_T(&eh_gpu_y);
  gpuEmxReset_real32_T(&fe_gpu_expanded);
  gpuEmxReset_real32_T(&gpu_c);
  gpuEmxReset_real32_T(&gpu_a);
  gpuEmxReset_real32_T(&gpu_smooth);
  gpuEmxReset_creal32_T(&d_gpu_y);
  gpuEmxReset_creal32_T(&d_gpu_x);
  gpuEmxReset_real_T(&gpu_Fmat);
  gpuEmxReset_creal32_T(&gpu_cfsDFT);
  gpuEmxReset_real_T(&gpu_omega);
  gpuEmxReset_real_T(&b_gpu_omega_tmp2);
  gpuEmxReset_int32_T(&b_gpu_omega_tmp1);
  gpuEmxReset_real32_T(&gpu_cfs1);
  gpuEmxReset_real32_T(&c_gpu_y);
  gpuEmxReset_creal32_T(&b_gpu_cfspos);
  gpuEmxReset_creal32_T(&b_gpu_cfsposdft);
  gpuEmxReset_real32_T(&c_gpu_x);
  gpuEmxReset_creal32_T(&b_gpu_xposdft);
  gpuEmxReset_real32_T(&b_gpu_xv);
  gpuEmxReset_real32_T(&b_gpu_psihat);
  checkCudaError(mwCudaMalloc(&c_gpu_cfsposdft, 8UL), __FILE__, __LINE__);
  gpuEmxReset_creal32_T(&gpu_cfspos);
  gpuEmxReset_creal32_T(&gpu_cfsposdft);
  checkCudaError(mwCudaMalloc(&b_gpu_csz, 8UL), __FILE__, __LINE__);
  gpuEmxReset_real32_T(&b_gpu_x);
  gpuEmxReset_creal32_T(&gpu_xposdft);
  checkCudaError(mwCudaMalloc(&gpu_fx_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real32_T(&gpu_xv);
  checkCudaError(mwCudaMalloc(&gpu_dv9_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv15_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gh_gpu_y);
  gpuEmxReset_real32_T(&gpu_psihat);
  checkCudaError(mwCudaMalloc(&b_gpu_a_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gc_gpu_w);
  gpuEmxReset_real_T(&gpu_daughter);
  gpuEmxReset_real_T(&gpu_expnt);
  checkCudaError(mwCudaMalloc(&c_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv2_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv8_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_somega);
  checkCudaError(mwCudaMalloc(&c_gpu_a_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&ih_gpu_y);
  checkCudaError(mwCudaMalloc(&d_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&hh_gpu_y);
  checkCudaError(mwCudaMalloc(&gpu_y_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&b_gpu_y);
  gpuEmxReset_real_T(&gpu_y);
  checkCudaError(mwCudaMalloc(&gpu_xt_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_x_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_x_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_fb_Scales);
  checkCudaError(mwCudaMalloc(&gpu_subs, 10384UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_interval, 5200UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_fb_Omega);
  checkCudaError(mwCudaMalloc(&gpu_wname, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_wav, 4UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_omega_tmp2);
  gpuEmxReset_int32_T(&gpu_omega_tmp1);
  checkCudaError(mwCudaMalloc(&gpu_lidx, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dc, 16UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dc6, 16UL), __FILE__, __LINE__);
  gpuEmxReset_real32_T(&gpu_x);
  b_h_outdatedOnGpu = false;
  h_outdatedOnGpu = false;
  b_fx_data_outdatedOnCpu = false;
  fx_data_outdatedOnCpu = false;
  p_y_needsGpuEnsureCapacity = true;
  o_y_needsGpuEnsureCapacity = true;
  n_y_needsGpuEnsureCapacity = true;
  m_y_needsGpuEnsureCapacity = true;
  l_y_needsGpuEnsureCapacity = true;
  k_y_needsGpuEnsureCapacity = true;
  j_y_needsGpuEnsureCapacity = true;
  i_y_needsGpuEnsureCapacity = true;
  b_G_needsGpuEnsureCapacity = true;
  b_h_needsGpuEnsureCapacity = true;
  h_y_needsGpuEnsureCapacity = true;
  g_y_needsGpuEnsureCapacity = true;
  f_y_needsGpuEnsureCapacity = true;
  e_y_needsGpuEnsureCapacity = true;
  d_y_needsGpuEnsureCapacity = true;
  c_y_needsGpuEnsureCapacity = true;
  G_needsGpuEnsureCapacity = true;
  h_needsGpuEnsureCapacity = true;
  f_omega_tmp1_needsGpuEnsureCapa = true;
  e_omega_tmp1_needsGpuEnsureCapa = true;
  d_omega_tmp1_needsGpuEnsureCapa = true;
  b_y_needsGpuEnsureCapacity = true;
  y_needsGpuEnsureCapacity = true;
  c_omega_tmp1_needsGpuEnsureCapa = true;
  checkCudaError(cudaMemcpy(gpu_dc, &cpu_dc, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  checkCudaError(cudaMemcpy(gpu_dc6, &cpu_dc6, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  ec_wtcc_kernel1<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_dc, gpu_dc6);
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  //  Wavelet coherence & resample
  // 'ec_wtcc:4' x (:,:){mustBeFloat}
  // 'ec_wtcc:5' c (:,2){uint16}
  // 'ec_wtcc:6' fs (1,1){mustBeFloat}
  // 'ec_wtcc:7' fLims (1,2){mustBeFloat}
  // 'ec_wtcc:8' fVoices (1,1){mustBeFloat} = 12
  // 'ec_wtcc:9' ds (1,2){mustBeFloat} = [1,1]
  //  Trigger kernel creation
  // 'ec_wtcc:13' coder.gpu.kernelfun;
  //  Make vars
  // 'ec_wtcc:16' nPairs = height(c);
  // 'ec_wtcc:17' tmp = cell(1,nPairs);
  // 'ec_wtcc:18' xx = coder.nullcopy(tmp);
  //  Fix define array error
  // 'ec_wtcc:19' yy = coder.nullcopy(tmp);
  //  Loop across pairs
  // 'ec_wtcc:22' for p = 1:nPairs
  // 'ec_wtcc:23' [xx{p},yy{p}] = wtc_lfn(x(:,c(p,1)),x(:,c(p,2)),fs,fLims,fVoices,ds);
  //  Wavelet coherence - local function
  //  Calculate wavelet coherence
  // 'ec_wtcc:33' [x,y] = wcoherence(x,y,fs,FrequencyLimits=fLims,VoicesPerOctave=fVoices);
  r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &nrefine);
  if (r == 0.5) {
    halfh = static_cast<real_T>(nrefine) - 1.0;
  } else {
    halfh = std::log(r) / 0.69314718055994529 + static_cast<real_T>(nrefine);
  }

  halfh = std::trunc(halfh);
  for (itime = 0; itime < 2; itime++) {
    FreqLimits[itime] = fLims[itime];
  }

  r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &cpu_lidx);
  if (r == 0.5) {
    r = static_cast<real_T>(cpu_lidx) - 1.0;
  } else {
    r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(cpu_lidx);
  }

  r = std::trunc(r);
  if (!(halfh - 1.0 <= r - 1.0)) {
    y = nullptr;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &rfmt[0]);
    emlrtAssign(&y, m);
    b_y = nullptr;
    m1 = emlrtCreateDoubleScalar(r - 1.0);
    emlrtAssign(&b_y, m1);
    emlrt_marshallIn(b_sprintf(y, b_y, &emlrtMCI), "<output of sprintf>",
                     unusedExpr);
  }

  guard1 = false;
  if ((fs == 0.0F) || std::isnan(static_cast<real_T>(fs))) {
    Nodd = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 2)) {
      if (!(FreqLimits[k] == 0.0)) {
        Nodd = false;
        exitg1 = true;
      } else {
        k++;
      }
    }

    if (Nodd) {
      a = 6.0;
      omegac = 44.729833462074168;
      fa = -1.8;
      fb = 0.2;
      fc = 0.2;
      b_c = 44.729833462074168;
      e = 0.0;
      d = 0.0;
      exitg1 = false;
      while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
        if ((fb > 0.0) == (fc > 0.0)) {
          b_c = a;
          fc = fa;
          d = omegac - a;
          e = d;
        }

        if (std::abs(fc) < std::abs(fb)) {
          a = omegac;
          omegac = b_c;
          b_c = a;
          fa = fb;
          fb = fc;
          fc = fa;
        }

        b_m = 0.5 * (b_c - omegac);
        toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
        if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
          exitg1 = true;
        } else {
          if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
            d = b_m;
            e = b_m;
          } else {
            s = fb / fa;
            if (a == b_c) {
              p = 2.0 * b_m * s;
              fa = 1.0 - s;
            } else {
              fa /= fc;
              b_r = fb / fc;
              p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r - 1.0));
              fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
            }

            if (p > 0.0) {
              fa = -fa;
            } else {
              p = -p;
            }

            if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p < std::
                 abs(0.5 * e * fa))) {
              e = d;
              d = p / fa;
            } else {
              d = b_m;
              e = b_m;
            }
          }

          a = omegac;
          fa = fb;
          if (std::abs(d) > toler) {
            omegac += d;
          } else if (omegac > b_c) {
            omegac -= toler;
          } else {
            omegac += toler;
          }

          fb = 0.2 - 2.0 * std::exp(-((omegac - 6.0) * (omegac - 6.0)) / 2.0);
        }
      }

      r = omegac / 3.1415926535897931;
      fa = 1.0 / (r * 1.0471975511965976);
      if ((fa > 0.5) || (r * 1.0471975511965976 < 2.0)) {
        fa = 0.5;
      }

      FreqLimits[0] = rt_powd_snf(2.0, -(halfh - 1.0)) * fa;
      FreqLimits[1] = fa;
    } else {
      guard1 = true;
    }
  } else {
    guard1 = true;
  }

  if (guard1 && ((!(fs == 0.0F)) && (!std::isnan(static_cast<real_T>(fs))))) {
    Nodd = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 2)) {
      if (!(FreqLimits[k] == 0.0)) {
        Nodd = false;
        exitg1 = true;
      } else {
        k++;
      }
    }

    if (Nodd) {
      T = 1.0 / fs;
      a = 6.0;
      omegac = 44.729833462074168;
      fa = -1.8;
      fb = 0.2;
      fc = 0.2;
      b_c = 44.729833462074168;
      e = 0.0;
      d = 0.0;
      exitg1 = false;
      while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
        if ((fb > 0.0) == (fc > 0.0)) {
          b_c = a;
          fc = fa;
          d = omegac - a;
          e = d;
        }

        if (std::abs(fc) < std::abs(fb)) {
          a = omegac;
          omegac = b_c;
          b_c = a;
          fa = fb;
          fb = fc;
          fc = fa;
        }

        b_m = 0.5 * (b_c - omegac);
        toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
        if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
          exitg1 = true;
        } else {
          if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
            d = b_m;
            e = b_m;
          } else {
            s = fb / fa;
            if (a == b_c) {
              p = 2.0 * b_m * s;
              fa = 1.0 - s;
            } else {
              fa /= fc;
              b_r = fb / fc;
              p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r - 1.0));
              fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
            }

            if (p > 0.0) {
              fa = -fa;
            } else {
              p = -p;
            }

            if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p < std::
                 abs(0.5 * e * fa))) {
              e = d;
              d = p / fa;
            } else {
              d = b_m;
              e = b_m;
            }
          }

          a = omegac;
          fa = fb;
          if (std::abs(d) > toler) {
            omegac += d;
          } else if (omegac > b_c) {
            omegac -= toler;
          } else {
            omegac += toler;
          }

          fb = 0.2 - 2.0 * std::exp(-((omegac - 6.0) * (omegac - 6.0)) / 2.0);
        }
      }

      r = omegac / 3.1415926535897931;
      fa = 1.0 / (r * 1.0471975511965976) * fs;
      if ((fa > fs / 2.0) || (r * 1.0471975511965976 * T < 2.0 * T)) {
        fa = fs / 2.0;
      }

      FreqLimits[0] = rt_powd_snf(2.0, -(halfh - 1.0)) * fa;
      FreqLimits[1] = fa;
    }
  }

  first_iteration = false;
  nrefine = 0;
  do {
    exitg2 = 0;
    if (nrefine + 1 < 11) {
      if (cpu_cv[static_cast<int32_T>(b[nrefine])] != cpu_cv[static_cast<int32_T>
          (cv1[nrefine])]) {
        exitg2 = 1;
      } else {
        nrefine++;
      }
    } else {
      first_iteration = true;
      exitg2 = 1;
    }
  } while (exitg2 == 0);

  if (first_iteration) {
    if (cpu_x->size[0] <= 100000) {
      b_nx = static_cast<int32_T>(std::floor(static_cast<real_T>(cpu_x->size[0])
        / 2.0));
    } else {
      r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &ix);
      if (r == 0.5) {
        halfh = static_cast<real_T>(ix) - 1.0;
      } else {
        halfh = std::log(r) / 0.69314718055994529 + static_cast<real_T>(ix);
      }

      halfh = std::ceil(halfh);
      b_nx = static_cast<int32_T>(halfh);
    }
  } else {
    b_nx = 0;
  }

  for (itime = 0; itime < 2; itime++) {
    b_b[itime] = std::isnan(FreqLimits[itime]);
  }

  first_iteration = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 2)) {
    if (!b_b[k]) {
      first_iteration = false;
      exitg1 = true;
    } else {
      k++;
    }
  }

  if (!first_iteration) {
    real_T freqrange[2];
    real_T cf;
    for (itime = 0; itime < 2; itime++) {
      freqrange[itime] = FreqLimits[itime];
    }

    NyquistRange[1] = fs / 2.0;
    emxInit_char_T(&tmpStr, 2, &fe_emlrtRTEI, true);
    if ((FreqLimits[1] <= 0.0) || (FreqLimits[0] >= NyquistRange[1])) {
      b_tmpStr = nullptr;
      c_y = nullptr;
      m2 = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m2, &u[0]);
      emlrtAssign(&c_y, m2);
      d_y = nullptr;
      m3 = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 2, m3, &formatSpec[0]);
      emlrtAssign(&d_y, m3);
      e_y = nullptr;
      m4 = emlrtCreateDoubleScalar(NyquistRange[1]);
      emlrtAssign(&e_y, m4);
      emlrtAssign(&b_tmpStr, feval(c_y, d_y, e_y, &b_emlrtMCI));
      emlrt_marshallIn(length(emlrtAlias(b_tmpStr), &c_emlrtMCI),
                       "<output of length>");
      emlrt_marshallIn(emlrtAlias(b_tmpStr), "tmpStr", tmpStr);
      emlrtDestroyArray(&b_tmpStr);
    }

    emxFree_char_T(&tmpStr);
    omegac = 3.1415926535897931;
    ec_wtcc_kernel2<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv,
      *gpu_wname, *gpu_wav, b_a[0], b_a[1], b_a[2], b_a[3]);
    wav_outdatedOnCpu = true;
    checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL, cudaMemcpyDeviceToHost),
                   __FILE__, __LINE__);
    if (cpu_wname[0] == 'm') {
      cf = 1.8820720577620569;
      b_r = 0.0057083835261;
      r = 0.0057083835261;
      fa = 0.0057083835261;
      for (ix = 0; ix < 6; ix++) {
        s = c_c[ix];
        b_r = b_r * 0.005353955978584176 + s;
        r = r * 0.005353955978584176 + s;
        fa = fa * 0.005353955978584176 + s;
      }

      b_r /= 13.666666666666666;
      r /= 13.666666666666666;
      fa /= 13.666666666666666;
      r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((b_r +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) + std::
                     exp((cpu_table100[14] + 2.5377749931802178) - (((r +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) - std::
                    exp((cpu_table100[13] + 5.8211893391859881) - (((fa +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703)));
      if (std::isinf(r) || std::isnan(r)) {
        ec_wtcc_kernel3<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_wtcc_kernel4<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        toler = 0.0;
        nx = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        pathlen = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (pathlen > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            cpu_lidx = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (nx = 0; nx < cpu_lidx; nx++) {
              cpu_interval[n_idx_0 - nx] = cpu_interval[0] + static_cast<real_T>
                (n_idx_0 - nx) * r;
            }
          }

          nx = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        cpu_lidx = 0;
        for (nrefine = 0; nrefine < nx; nrefine++) {
          if (std::abs(cpu_interval[nrefine + 1] - cpu_interval[cpu_lidx]) > 0.0)
          {
            cpu_lidx++;
            cpu_interval[cpu_lidx] = cpu_interval[nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel5<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nx,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (pathlen <= 0) {
          toler = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1316<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          T = 0.0;
          p = 0.0;
          first_iteration = true;
          do {
            exitg2 = 0;
            x_data_outdatedOnGpu = false;
            itime = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              s = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              fa = cpu_subs[(k << 1) + 1];
              r = (s + fa) / 2.0;
              halfh = (fa - s) / 2.0;
              for (nx = 0; nx < 15; nx++) {
                SD->f0.cpu_x_data[(ix + nx) + 1] = NODES[nx] * halfh + r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            xt_size[0] = 1;
            xt_size[1] = itime;
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1317<<<grid, block>>>(*gpu_x_data, itime - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            b_guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              halfh = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= itime - 2)) {
                s = halfh;
                halfh = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, halfh)) {
                  Nodd = true;
                  exitg1 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1318<<<grid, block>>>(itime - 1, *d_gpu_fx_data);
                }

                exitg2 = 1;
              } else {
                b_guard1 = true;
              }
            } else {
              b_guard1 = true;
            }

            if (b_guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1319<<<grid, block>>>(*b_gpu_x_data, itime - 1,
                  *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1320<<<grid, block>>>(*b_gpu_x_data, itime - 1,
                  *gpu_x_data);
              }

              a_size[1] = itime;
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1321<<<grid, block>>>(*gpu_x_data, *gpu_y_data,
                  itime - 1, *c_gpu_a_data);
              }

              dv2_size[0] = 1;
              dv2_size[1] = a_size[1];
              mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1322<<<grid, block>>>(*c_gpu_a_data, a_size[1] - 1,
                  *gpu_dv2_data);
              }

              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1323<<<grid, block>>>(*b_gpu_x_data, itime - 1,
                  *gpu_y_data);
              }

              dv6_size[0] = 1;
              dv6_size[1] = itime;
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1324<<<grid, block>>>(*gpu_y_data, itime - 1,
                  *gpu_x_data);
              }

              if (a_size[1] == itime) {
                fx_size[0] = 1;
                fx_size[1] = a_size[1];
                mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1325<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv2_data, a_size[1] - 1, *d_gpu_fx_data);
                }

                fx_data_outdatedOnCpu = true;
              } else {
                if (fx_data_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *d_gpu_fx_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                checkCudaError(cudaMemcpy(SD->f0.cpu_dv2_data, *gpu_dv2_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                binary_expand_op_10(SD->f0.cpu_fx_data, fx_size,
                                    SD->f0.cpu_dv2_data, dv2_size,
                                    SD->f0.cpu_x_data, dv6_size,
                                    SD->f0.cpu_xt_data, xt_size);
                fx_data_outdatedOnCpu = false;
              }

              r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                s = 0.0;
                fa = 0.0;
                for (nx = 0; nx < 15; nx++) {
                  if (fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *d_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  s += dv3[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                  fx_data_outdatedOnCpu = false;
                  fa += dv4[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                s *= halfh;
                qsub[k] = s;
                r += s;
                errsub[k] = fa * halfh;
              }

              toler = r + T;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(toler));
              fb = 2.0 * tol;
              r = 0.0;
              nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                s = errsub[k];
                fa = std::abs(s);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (fa <= fb * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) /
                                2.0)) {
                  p += s;
                  T += qsub[k];
                } else {
                  r += fa;
                  nrefine++;
                  cpu_subs[(nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              r += std::abs(p);
              if ((!std::isinf(toler)) && (!std::isnan(toler)) && ((!std::isinf
                    (r)) && (!std::isnan(r))) && (nrefine != 0) && (!(r <= tol)))
              {
                nsubs = nrefine << 1;
                if (nsubs > 650) {
                  exitg2 = 1;
                } else {
                  for (k = 0; k < nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((nrefine - k) << 1) - 1) << 1) + 1] = cpu_subs
                      [(((nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((nrefine - k) - 1) << 1] + cpu_subs[(((nrefine - k) - 1)
                      << 1) + 1]) / 2.0;
                    cpu_subs[((((nrefine - k) << 1) - 2) << 1) + 1] = cpu_subs
                      [(((nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg2 = 1;
              }
            }
          } while (exitg2 == 0);
        }

        ec_wtcc_kernel6<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_wtcc_kernel7<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        b_m = 0.0;
        nx = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        pathlen = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (pathlen > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            nrefine = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (nx = 0; nx < nrefine; nx++) {
              cpu_interval[n_idx_0 - nx] = cpu_interval[0] + static_cast<real_T>
                (n_idx_0 - nx) * r;
            }
          }

          nx = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        cpu_lidx = 0;
        for (nrefine = 0; nrefine < nx; nrefine++) {
          if (std::abs(cpu_interval[nrefine + 1] - cpu_interval[cpu_lidx]) > 0.0)
          {
            cpu_lidx++;
            cpu_interval[cpu_lidx] = cpu_interval[nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel8<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nx,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (pathlen <= 0) {
          b_m = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1309<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          T = 0.0;
          p = 0.0;
          first_iteration = true;
          do {
            exitg2 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              s = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              fa = cpu_subs[(k << 1) + 1];
              r = (s + fa) / 2.0;
              halfh = (fa - s) / 2.0;
              for (nx = 0; nx < 15; nx++) {
                SD->f0.cpu_x_data[(ix + nx) + 1] = NODES[nx] * halfh + r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1310<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            b_guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              halfh = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= x_size_idx_1 - 2)) {
                s = halfh;
                halfh = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, halfh)) {
                  Nodd = true;
                  exitg1 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1311<<<grid, block>>>(x_size_idx_1 - 1,
                    *c_gpu_fx_data);
                }

                exitg2 = 1;
              } else {
                b_guard1 = true;
              }
            } else {
              b_guard1 = true;
            }

            if (b_guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1312<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_dv8_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1313<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1314<<<grid, block>>>(*gpu_y_data, x_size_idx_1 -
                  1, *gpu_x_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1315<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                  *gpu_dv8_data, x_size_idx_1 - 1, *c_gpu_fx_data);
              }

              fx_data_outdatedOnCpu = true;
              r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                s = 0.0;
                fa = 0.0;
                for (nx = 0; nx < 15; nx++) {
                  if (fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *c_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  s += dv3[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                  fx_data_outdatedOnCpu = false;
                  fa += dv4[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                s *= halfh;
                qsub[k] = s;
                r += s;
                errsub[k] = fa * halfh;
              }

              b_m = r + T;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(b_m));
              fb = 2.0 * tol;
              r = 0.0;
              nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                s = errsub[k];
                fa = std::abs(s);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (fa <= fb * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) /
                                2.0)) {
                  p += s;
                  T += qsub[k];
                } else {
                  r += fa;
                  nrefine++;
                  cpu_subs[(nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              r += std::abs(p);
              if ((!std::isinf(b_m)) && (!std::isnan(b_m)) && ((!std::isinf(r)) &&
                   (!std::isnan(r))) && (nrefine != 0) && (!(r <= tol))) {
                nsubs = nrefine << 1;
                if (nsubs > 650) {
                  exitg2 = 1;
                } else {
                  for (k = 0; k < nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((nrefine - k) << 1) - 1) << 1) + 1] = cpu_subs
                      [(((nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((nrefine - k) - 1) << 1] + cpu_subs[(((nrefine - k) - 1)
                      << 1) + 1]) / 2.0;
                    cpu_subs[((((nrefine - k) << 1) - 2) << 1) + 1] = cpu_subs
                      [(((nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg2 = 1;
              }
            }
          } while (exitg2 == 0);
        }

        r = std::sqrt(3.5421952306087032 * (toler / b_m));
      }
    } else if (cpu_wname[0] == 'a') {
      cf = 6.0;
      r = 1.4142135623730951;
    } else {
      cf = 5.0;
      r = 5.847705;
    }

    halfh = static_cast<real_T>(cpu_x->size[0]) / (r * 2.0);
    first_iteration = false;
    nrefine = 0;
    do {
      exitg2 = 0;
      if (nrefine + 1 < 5) {
        if (wav_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        wav_outdatedOnCpu = false;
        if (cv2[nrefine] != cpu_wav[nrefine]) {
          exitg2 = 1;
        } else {
          nrefine++;
        }
      } else {
        first_iteration = true;
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    if (first_iteration) {
      nrefine = 1;
    } else {
      nrefine = 0;
      do {
        exitg2 = 0;
        if (nrefine + 1 < 5) {
          if (wav_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          wav_outdatedOnCpu = false;
          if (cv3[nrefine] != cpu_wav[nrefine]) {
            exitg2 = 1;
          } else {
            nrefine++;
          }
        } else {
          first_iteration = true;
          exitg2 = 1;
        }
      } while (exitg2 == 0);

      if (first_iteration) {
        nrefine = 2;
      } else {
        nrefine = -1;
      }
    }

    switch (nrefine) {
     case 0:
      if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
          (-rt_powd_snf(cf, 3.0)) >= 0.0) {
        if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
            (-rt_powd_snf(cf, 3.0)) == 1.0) {
          omegac = 9.0856029641606977;
        } else {
          omegac = cf;
        }
      } else {
        a = cf;
        omegac = 9.0856029641606977;
        fa = 1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
          (-rt_powd_snf(cf, 3.0));
        fb = 1.0;
        if (fa == 0.0) {
          omegac = cf;
        } else {
          fc = 1.0;
          b_c = 9.0856029641606977;
          e = 0.0;
          d = 0.0;
          exitg1 = false;
          while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
            if ((fb > 0.0) == (fc > 0.0)) {
              b_c = a;
              fc = fa;
              d = omegac - a;
              e = d;
            }

            if (std::abs(fc) < std::abs(fb)) {
              a = omegac;
              omegac = b_c;
              b_c = a;
              fa = fb;
              fb = fc;
              fc = fa;
            }

            b_m = 0.5 * (b_c - omegac);
            toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
              exitg1 = true;
            } else {
              if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                d = b_m;
                e = b_m;
              } else {
                s = fb / fa;
                if (a == b_c) {
                  p = 2.0 * b_m * s;
                  fa = 1.0 - s;
                } else {
                  fa /= fc;
                  b_r = fb / fc;
                  p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r -
                            1.0));
                  fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                }

                if (p > 0.0) {
                  fa = -fa;
                } else {
                  p = -p;
                }

                if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p <
                     std::abs(0.5 * e * fa))) {
                  e = d;
                  d = p / fa;
                } else {
                  d = b_m;
                  e = b_m;
                }
              }

              a = omegac;
              fa = fb;
              if (std::abs(d) > toler) {
                omegac += d;
              } else if (omegac > b_c) {
                omegac -= toler;
              } else {
                omegac += toler;
              }

              fb = 1.0 - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0) * std::
                exp(-rt_powd_snf(omegac, 3.0));
            }
          }
        }
      }
      break;

     case 1:
      a = 4.94065645841247E-324;
      r = 0.99999999999999978;
      fa = -0.69314718055994529;
      fb = 2.2517998136852462E+15;
      fc = 2.2517998136852462E+15;
      b_c = 0.99999999999999978;
      e = 0.0;
      d = 0.0;
      exitg4 = false;
      while ((!exitg4) && ((fb != 0.0) && (a != r))) {
        if ((fb > 0.0) == (fc > 0.0)) {
          b_c = a;
          fc = fa;
          d = r - a;
          e = d;
        }

        if (std::abs(fc) < std::abs(fb)) {
          a = r;
          r = b_c;
          b_c = a;
          fa = fb;
          fb = fc;
          fc = fa;
        }

        b_m = 0.5 * (b_c - r);
        toler = 4.4408920985006262E-16 * std::fmax(std::abs(r), 1.0);
        if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
          exitg4 = true;
        } else {
          if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
            d = b_m;
            e = b_m;
          } else {
            s = fb / fa;
            if (a == b_c) {
              p = 2.0 * b_m * s;
              fa = 1.0 - s;
            } else {
              fa /= fc;
              b_r = fb / fc;
              p = s * (2.0 * b_m * fa * (fa - b_r) - (r - a) * (b_r - 1.0));
              fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
            }

            if (p > 0.0) {
              fa = -fa;
            } else {
              p = -p;
            }

            if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p < std::
                 abs(0.5 * e * fa))) {
              e = d;
              d = p / fa;
            } else {
              d = b_m;
              e = b_m;
            }
          }

          a = r;
          fa = fb;
          if (std::abs(d) > toler) {
            r += d;
          } else if (r > b_c) {
            r -= toler;
          } else {
            r += toler;
          }

          fb = (1.0 / (1.0 - r * r) - 0.69314718055994529) - 1.0;
        }
      }

      omegac = 0.6 * r + cf;
      break;

     case 2:
      a = cf - cf;
      if (1.0 - 2.0 * std::exp(-(a * a) / 2.0) > 0.0) {
        omegac = cf + 38.729833462074168;
      } else {
        a = cf;
        omegac = cf + 38.729833462074168;
        c_a = cf - cf;
        fa = 1.0 - 2.0 * std::exp(-(c_a * c_a) / 2.0);
        fb = 1.0;
        if (fa == 0.0) {
          omegac = cf;
        } else {
          fc = 1.0;
          b_c = cf + 38.729833462074168;
          e = 0.0;
          d = 0.0;
          exitg3 = false;
          while ((!exitg3) && ((fb != 0.0) && (a != omegac))) {
            if ((fb > 0.0) == (fc > 0.0)) {
              b_c = a;
              fc = fa;
              d = omegac - a;
              e = d;
            }

            if (std::abs(fc) < std::abs(fb)) {
              a = omegac;
              omegac = b_c;
              b_c = a;
              fa = fb;
              fb = fc;
              fc = fa;
            }

            b_m = 0.5 * (b_c - omegac);
            toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
              exitg3 = true;
            } else {
              if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                d = b_m;
                e = b_m;
              } else {
                s = fb / fa;
                if (a == b_c) {
                  p = 2.0 * b_m * s;
                  fa = 1.0 - s;
                } else {
                  fa /= fc;
                  b_r = fb / fc;
                  p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r -
                            1.0));
                  fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                }

                if (p > 0.0) {
                  fa = -fa;
                } else {
                  p = -p;
                }

                if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p <
                     std::abs(0.5 * e * fa))) {
                  e = d;
                  d = p / fa;
                } else {
                  d = b_m;
                  e = b_m;
                }
              }

              a = omegac;
              fa = fb;
              if (std::abs(d) > toler) {
                omegac += d;
              } else if (omegac > b_c) {
                omegac -= toler;
              } else {
                omegac += toler;
              }

              c_a = omegac - cf;
              fb = 1.0 - 2.0 * std::exp(-(c_a * c_a) / 2.0);
            }
          }
        }
      }
      break;
    }

    r = omegac / 3.1415926535897931;
    if (halfh < r * rt_powd_snf(2.0, 1.0 / fVoices)) {
      halfh = r * rt_powd_snf(2.0, 1.0 / fVoices);
    }

    r = 1.0 / (halfh * (6.2831853071795862 / cf)) * fs;
    if (FreqLimits[0] < r) {
      FreqLimits[0] = r;
      freqrange[0] = r;
    }

    if (FreqLimits[1] > fs / 2.0) {
      FreqLimits[1] = fs / 2.0;
      freqrange[1] = FreqLimits[1];
    }

    if (freqrange[1] == 0.0) {
      fa = rtMinusInf;
    } else if (freqrange[1] < 0.0) {
      fa = rtNaN;
    } else if ((!std::isinf(freqrange[1])) && (!std::isnan(freqrange[1]))) {
      r = std::frexp(freqrange[1], &n);
      if (r == 0.5) {
        fa = static_cast<real_T>(n) - 1.0;
      } else if ((n == 1) && (r < 0.75)) {
        fa = std::log(2.0 * r) / 0.69314718055994529;
      } else {
        fa = std::log(r) / 0.69314718055994529 + static_cast<real_T>(n);
      }
    } else {
      fa = freqrange[1];
    }

    if (freqrange[0] == 0.0) {
      r = rtMinusInf;
    } else if (freqrange[0] < 0.0) {
      r = rtNaN;
    } else if ((!std::isinf(freqrange[0])) && (!std::isnan(freqrange[0]))) {
      r = std::frexp(freqrange[0], &eint);
      if (r == 0.5) {
        r = static_cast<real_T>(eint) - 1.0;
      } else if ((eint == 1) && (r < 0.75)) {
        r = std::log(2.0 * r) / 0.69314718055994529;
      } else {
        r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(eint);
      }
    } else {
      r = freqrange[0];
    }

    if (!(fa - r >= 1.0 / fVoices)) {
      c_tmpStr = nullptr;
      f_y = nullptr;
      m5 = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m5, &u[0]);
      emlrtAssign(&f_y, m5);
      g_y = nullptr;
      m6 = emlrtCreateCharArray(2, &iv4[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 5, m6, &b_formatSpec[0]);
      emlrtAssign(&g_y, m6);
      h_y = nullptr;
      m7 = emlrtCreateDoubleScalar(1.0 / fVoices);
      emlrtAssign(&h_y, m7);
      emlrtAssign(&c_tmpStr, feval(f_y, g_y, h_y, &b_emlrtMCI));
      emlrt_marshallIn(length(emlrtAlias(c_tmpStr), &c_emlrtMCI),
                       "<output of length>");
      emxInit_char_T(&d_tmpStr, 2, &fe_emlrtRTEI, true);
      emlrt_marshallIn(emlrtAlias(c_tmpStr), "tmpStr", d_tmpStr);
      emxFree_char_T(&d_tmpStr);
      emlrtDestroyArray(&c_tmpStr);
    }
  }

  N = static_cast<uint32_T>(cpu_x->size[0]) + static_cast<uint32_T>(b_nx << 1);
  nrefine = static_cast<int32_T>(std::trunc(static_cast<real_T>(N) / 2.0));
  emxInit_int32_T(&cpu_omega_tmp1, 2, &emlrtRTEI, true);
  if (nrefine < 1) {
    cpu_omega_tmp1->size[0] = 1;
    cpu_omega_tmp1->size[1] = 0;
  } else {
    eint = cpu_omega_tmp1->size[0] * cpu_omega_tmp1->size[1];
    cpu_omega_tmp1->size[0] = 1;
    cpu_omega_tmp1->size[1] = nrefine;
    emxEnsureCapacity_int32_T(cpu_omega_tmp1, eint, &emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1308<<<grid, block>>>(nrefine - 1, gpu_omega_tmp1);
    }
  }

  emxInit_real_T(&cpu_omega_tmp2, 2, &b_emlrtRTEI, true);
  eint = cpu_omega_tmp2->size[0] * cpu_omega_tmp2->size[1];
  cpu_omega_tmp2->size[0] = 1;
  cpu_omega_tmp2->size[1] = cpu_omega_tmp1->size[1];
  emxEnsureCapacity_real_T(cpu_omega_tmp2, eint, &b_emlrtRTEI);
  eint = cpu_omega_tmp1->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (c_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
  }

  gpuEmxEnsureCapacity_real_T(cpu_omega_tmp2, &gpu_omega_tmp2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel9<<<grid, block>>>(6.2831853071795862 / static_cast<real_T>(N),
      gpu_omega_tmp1, eint, gpu_omega_tmp2);
  }

  emxFree_int32_T(&cpu_omega_tmp1);
  cpu_lidx = static_cast<int32_T>(std::trunc((static_cast<real_T>(N) - 1.0) /
    2.0));
  if (cpu_lidx < 1) {
    ix = 0;
    nrefine = 1;
    cpu_lidx = -1;
  } else {
    ix = cpu_lidx - 1;
    nrefine = -1;
    cpu_lidx = 0;
  }

  emxInit_real_T(&cpu_fb_Omega, 2, &od_emlrtRTEI, true);
  eint = cpu_fb_Omega->size[0] * cpu_fb_Omega->size[1];
  cpu_fb_Omega->size[0] = 1;
  cpu_fb_Omega->size[1] = (cpu_omega_tmp2->size[1] + div_s32(cpu_lidx - ix,
    nrefine)) + 2;
  emxEnsureCapacity_real_T(cpu_fb_Omega, eint, &c_emlrtRTEI);
  gpuEmxEnsureCapacity_real_T(cpu_fb_Omega, &gpu_fb_Omega, true);
  ec_wtcc_kernel10<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_fb_Omega);
  nx = cpu_omega_tmp2->size[1];
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel11<<<grid, block>>>(gpu_omega_tmp2, nx - 1, gpu_fb_Omega);
  }

  nx = div_s32(cpu_lidx - ix, nrefine);
  mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel12<<<grid, block>>>(nrefine, ix, gpu_omega_tmp2, nx,
      gpu_fb_Omega, cpu_omega_tmp2->size[1U]);
  }

  c_omega_tmp1_needsGpuEnsureCapa = true;
  emxFree_real_T(&cpu_omega_tmp2);
  for (itime = 0; itime < 2; itime++) {
    b_b[itime] = std::isnan(FreqLimits[itime]);
  }

  first_iteration = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 2)) {
    if (!b_b[k]) {
      first_iteration = false;
      exitg1 = true;
    } else {
      k++;
    }
  }

  emxInit_real_T(&cpu_fb_Scales, 2, &od_emlrtRTEI, true);
  if (!first_iteration) {
    for (itime = 0; itime < 2; itime++) {
      NyquistRange[itime] = FreqLimits[itime] / fs * 2.0 * 3.1415926535897931;
    }

    for (k = 0; k < 4; k++) {
      cpu_wname[k] = cpu_cv[static_cast<int32_T>(b_a[k])];
    }

    if (cpu_wname[0] == 'm') {
      r = 1.8820720577620569;
    } else {
      nx = 1;
      if (cpu_wname[0] == 'a') {
        nx = 2;
      }

      if (nx > 1) {
        r = 6.0;
      } else {
        r = 5.0;
      }
    }

    halfh = r / NyquistRange[1];
    r = r / NyquistRange[0] / halfh;
    if (r == 0.0) {
      r = rtMinusInf;
    } else if (r < 0.0) {
      r = rtNaN;
    } else if ((!std::isinf(r)) && (!std::isnan(r))) {
      r = std::frexp(r, &offsetH);
      if (r == 0.5) {
        r = static_cast<real_T>(offsetH) - 1.0;
      } else if ((offsetH == 1) && (r < 0.75)) {
        r = std::log(2.0 * r) / 0.69314718055994529;
      } else {
        r = std::log(r) / 0.69314718055994529 + static_cast<real_T>(offsetH);
      }
    }

    emxInit_real_T(&cpu_y, 2, &pd_emlrtRTEI, true);
    tol = fVoices * r;
    if (std::isnan(tol)) {
      eint = cpu_y->size[0] * cpu_y->size[1];
      cpu_y->size[0] = 1;
      cpu_y->size[1] = 1;
      emxEnsureCapacity_real_T(cpu_y, eint, &d_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
      y_needsGpuEnsureCapacity = false;
      ec_wtcc_kernel13<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_y);
    } else if (tol < 0.0) {
      cpu_y->size[0] = 1;
      cpu_y->size[1] = 0;
    } else {
      eint = cpu_y->size[0] * cpu_y->size[1];
      cpu_y->size[0] = 1;
      cpu_y->size[1] = static_cast<int32_T>(tol) + 1;
      emxEnsureCapacity_real_T(cpu_y, eint, &d_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol)), &grid,
        &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
      y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1279<<<grid, block>>>(static_cast<int32_T>(tol), gpu_y);
      }
    }

    emxInit_real_T(&b_cpu_y, 2, &qd_emlrtRTEI, true);
    eint = b_cpu_y->size[0] * b_cpu_y->size[1];
    b_cpu_y->size[0] = 1;
    b_cpu_y->size[1] = cpu_y->size[1];
    emxEnsureCapacity_real_T(b_cpu_y, eint, &e_emlrtRTEI);
    nx = cpu_y->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    if (y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
    }

    gpuEmxEnsureCapacity_real_T(b_cpu_y, &b_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel14<<<grid, block>>>(gpu_y, rt_powd_snf(2.0, 1.0 / fVoices),
        nx - 1, b_gpu_y);
    }

    emxFree_real_T(&cpu_y);
    eint = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
    cpu_fb_Scales->size[0] = 1;
    cpu_fb_Scales->size[1] = b_cpu_y->size[1];
    emxEnsureCapacity_real_T(cpu_fb_Scales, eint, &f_emlrtRTEI);
    eint = b_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    b_fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel15<<<grid, block>>>(b_gpu_y, halfh, eint, gpu_fb_Scales);
    }

    interval_outdatedOnGpu = true;
    emxFree_real_T(&b_cpu_y);
  } else {
    omegac = 3.1415926535897931;
    ec_wtcc_kernel1280<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv, *
      gpu_wav, *gpu_wname, b_a[0], b_a[1], b_a[2], b_a[3]);
    fx_data_outdatedOnCpu = true;
    checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 4UL, cudaMemcpyDeviceToHost),
                   __FILE__, __LINE__);
    if (cpu_wav[0] == 'm') {
      a = 1.8820720577620569;
      b_r = 0.0057083835261;
      r = 0.0057083835261;
      fa = 0.0057083835261;
      for (ix = 0; ix < 6; ix++) {
        s = c_c[ix];
        b_r = b_r * 0.005353955978584176 + s;
        r = r * 0.005353955978584176 + s;
        fa = fa * 0.005353955978584176 + s;
      }

      b_r /= 13.666666666666666;
      r /= 13.666666666666666;
      fa /= 13.666666666666666;
      r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((b_r +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) + std::
                     exp((cpu_table100[14] + 2.5377749931802178) - (((r +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) - std::
                    exp((cpu_table100[13] + 5.8211893391859881) - (((fa +
        0.91893853320467278) - 1.307479889018099) + 22.071116966494703)));
      if (std::isinf(r) || std::isnan(r)) {
        ec_wtcc_kernel1281<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
          (*gpu_interval);
        ec_wtcc_kernel1282<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
          (*gpu_interval);
        interval_outdatedOnGpu = false;
        toler = 0.0;
        nx = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        pathlen = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (pathlen > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            nrefine = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (nx = 0; nx < nrefine; nx++) {
              cpu_interval[n_idx_0 - nx] = cpu_interval[0] + static_cast<real_T>
                (n_idx_0 - nx) * r;
            }
          }

          nx = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        cpu_lidx = 0;
        for (nrefine = 0; nrefine < nx; nrefine++) {
          if (std::abs(cpu_interval[nrefine + 1] - cpu_interval[cpu_lidx]) > 0.0)
          {
            cpu_lidx++;
            cpu_interval[cpu_lidx] = cpu_interval[nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1283<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nx,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (pathlen <= 0) {
          toler = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1298<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          T = 0.0;
          p = 0.0;
          do {
            exitg2 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              s = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              fa = cpu_subs[(k << 1) + 1];
              r = (s + fa) / 2.0;
              halfh = (fa - s) / 2.0;
              for (nx = 0; nx < 15; nx++) {
                SD->f0.cpu_x_data[(ix + nx) + 1] = NODES[nx] * halfh + r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            b_xt_size[0] = 1;
            b_xt_size[1] = x_size_idx_1;
            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1299<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            b_guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              halfh = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= x_size_idx_1 - 2)) {
                s = halfh;
                halfh = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, halfh)) {
                  Nodd = true;
                  exitg1 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1300<<<grid, block>>>(x_size_idx_1 - 1,
                    *b_gpu_fx_data);
                }

                exitg2 = 1;
              } else {
                b_guard1 = true;
              }
            } else {
              b_guard1 = true;
            }

            if (b_guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1301<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1302<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_x_data);
              }

              b_a_size[1] = x_size_idx_1;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1303<<<grid, block>>>(*gpu_x_data, *gpu_y_data,
                  x_size_idx_1 - 1, *b_gpu_a_data);
              }

              dv9_size[0] = 1;
              dv9_size[1] = b_a_size[1];
              mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1304<<<grid, block>>>(*b_gpu_a_data, b_a_size[1] -
                  1, *gpu_dv9_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1305<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_y_data);
              }

              dv13_size[0] = 1;
              dv13_size[1] = x_size_idx_1;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1306<<<grid, block>>>(*gpu_y_data, x_size_idx_1 -
                  1, *gpu_x_data);
              }

              if (b_a_size[1] == x_size_idx_1) {
                fx_size[0] = 1;
                fx_size[1] = b_a_size[1];
                mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1307<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv9_data, b_a_size[1] - 1, *b_gpu_fx_data);
                }

                b_fx_data_outdatedOnCpu = true;
              } else {
                if (b_fx_data_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(SD->f0.b_cpu_fx_data, *b_gpu_fx_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                checkCudaError(cudaMemcpy(cpu_dv9_data, *gpu_dv9_data, 77880UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                binary_expand_op_10(SD->f0.b_cpu_fx_data, fx_size, cpu_dv9_data,
                                    dv9_size, SD->f0.cpu_x_data, dv13_size,
                                    SD->f0.cpu_xt_data, b_xt_size);
                b_fx_data_outdatedOnCpu = false;
              }

              r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                s = 0.0;
                fa = 0.0;
                for (nx = 0; nx < 15; nx++) {
                  if (b_fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.b_cpu_fx_data,
                      *b_gpu_fx_data, 77880UL, cudaMemcpyDeviceToHost), __FILE__,
                                   __LINE__);
                  }

                  s += dv3[nx] * SD->f0.b_cpu_fx_data[(ix + nx) + 1];
                  b_fx_data_outdatedOnCpu = false;
                  fa += dv4[nx] * SD->f0.b_cpu_fx_data[(ix + nx) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                s *= halfh;
                qsub[k] = s;
                r += s;
                errsub[k] = fa * halfh;
              }

              toler = r + T;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(toler));
              fb = 2.0 * tol;
              r = 0.0;
              nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                s = errsub[k];
                fa = std::abs(s);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (fa <= fb * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) /
                                2.0)) {
                  p += s;
                  T += qsub[k];
                } else {
                  r += fa;
                  nrefine++;
                  cpu_subs[(nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              r += std::abs(p);
              if ((!std::isinf(toler)) && (!std::isnan(toler)) && ((!std::isinf
                    (r)) && (!std::isnan(r))) && (nrefine != 0) && (!(r <= tol)))
              {
                nsubs = nrefine << 1;
                if (nsubs > 650) {
                  exitg2 = 1;
                } else {
                  for (k = 0; k < nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((nrefine - k) << 1) - 1) << 1) + 1] = cpu_subs
                      [(((nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((nrefine - k) - 1) << 1] + cpu_subs[(((nrefine - k) - 1)
                      << 1) + 1]) / 2.0;
                    cpu_subs[((((nrefine - k) << 1) - 2) << 1) + 1] = cpu_subs
                      [(((nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg2 = 1;
              }
            }
          } while (exitg2 == 0);
        }

        ec_wtcc_kernel1284<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
          (*gpu_interval);
        ec_wtcc_kernel1285<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>
          (*gpu_interval);
        interval_outdatedOnGpu = false;
        b_m = 0.0;
        nx = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        pathlen = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (pathlen > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            cpu_lidx = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (nx = 0; nx < cpu_lidx; nx++) {
              cpu_interval[n_idx_0 - nx] = cpu_interval[0] + static_cast<real_T>
                (n_idx_0 - nx) * r;
            }
          }

          nx = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        cpu_lidx = 0;
        for (nrefine = 0; nrefine < nx; nrefine++) {
          if (std::abs(cpu_interval[nrefine + 1] - cpu_interval[cpu_lidx]) > 0.0)
          {
            cpu_lidx++;
            cpu_interval[cpu_lidx] = cpu_interval[nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1286<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nx,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (pathlen <= 0) {
          b_m = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1291<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          T = 0.0;
          p = 0.0;
          first_iteration = true;
          do {
            exitg2 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              s = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              fa = cpu_subs[(k << 1) + 1];
              r = (s + fa) / 2.0;
              halfh = (fa - s) / 2.0;
              for (nx = 0; nx < 15; nx++) {
                SD->f0.cpu_x_data[(ix + nx) + 1] = NODES[nx] * halfh + r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1292<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            b_guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              halfh = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= x_size_idx_1 - 2)) {
                s = halfh;
                halfh = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, halfh)) {
                  Nodd = true;
                  exitg1 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1293<<<grid, block>>>(x_size_idx_1 - 1,
                    *gpu_fx_data);
                }

                exitg2 = 1;
              } else {
                b_guard1 = true;
              }
            } else {
              b_guard1 = true;
            }

            if (b_guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1294<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_dv15_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1295<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1
                  - 1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1296<<<grid, block>>>(*gpu_y_data, x_size_idx_1 -
                  1, *gpu_x_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1297<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                  *gpu_dv15_data, x_size_idx_1 - 1, *gpu_fx_data);
              }

              b_fx_data_outdatedOnCpu = true;
              r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                s = 0.0;
                fa = 0.0;
                for (nx = 0; nx < 15; nx++) {
                  if (b_fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  s += dv3[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                  b_fx_data_outdatedOnCpu = false;
                  fa += dv4[nx] * SD->f0.cpu_fx_data[(ix + nx) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                s *= halfh;
                qsub[k] = s;
                r += s;
                errsub[k] = fa * halfh;
              }

              b_m = r + T;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(b_m));
              fb = 2.0 * tol;
              r = 0.0;
              nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                s = errsub[k];
                fa = std::abs(s);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (fa <= fb * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) /
                                2.0)) {
                  p += s;
                  T += qsub[k];
                } else {
                  r += fa;
                  nrefine++;
                  cpu_subs[(nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              r += std::abs(p);
              if ((!std::isinf(b_m)) && (!std::isnan(b_m)) && ((!std::isinf(r)) &&
                   (!std::isnan(r))) && (nrefine != 0) && (!(r <= tol))) {
                nsubs = nrefine << 1;
                if (nsubs > 650) {
                  exitg2 = 1;
                } else {
                  for (k = 0; k < nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((nrefine - k) << 1) - 1) << 1) + 1] = cpu_subs
                      [(((nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((nrefine - k) - 1) << 1] + cpu_subs[(((nrefine - k) - 1)
                      << 1) + 1]) / 2.0;
                    cpu_subs[((((nrefine - k) << 1) - 2) << 1) + 1] = cpu_subs
                      [(((nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg2 = 1;
              }
            }
          } while (exitg2 == 0);
        }

        r = std::sqrt(3.5421952306087032 * (toler / b_m));
      }
    } else if (cpu_wav[0] == 'a') {
      a = 6.0;
      r = 1.4142135623730951;
    } else {
      a = 5.0;
      r = 5.847705;
    }

    tol = static_cast<real_T>(cpu_x->size[0]) / (r * 2.0);
    first_iteration = false;
    nrefine = 0;
    do {
      exitg2 = 0;
      if (nrefine + 1 < 5) {
        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        fx_data_outdatedOnCpu = false;
        if (cv2[nrefine] != cpu_wname[nrefine]) {
          exitg2 = 1;
        } else {
          nrefine++;
        }
      } else {
        first_iteration = true;
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    if (first_iteration) {
      nrefine = 1;
    } else {
      nrefine = 0;
      do {
        exitg2 = 0;
        if (nrefine + 1 < 5) {
          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          fx_data_outdatedOnCpu = false;
          if (cv3[nrefine] != cpu_wname[nrefine]) {
            exitg2 = 1;
          } else {
            nrefine++;
          }
        } else {
          first_iteration = true;
          exitg2 = 1;
        }
      } while (exitg2 == 0);

      if (first_iteration) {
        nrefine = 2;
      } else {
        nrefine = -1;
      }
    }

    switch (nrefine) {
     case 0:
      if (0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
          (-rt_powd_snf(a, 3.0)) >= 0.0) {
        if (0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
            (-rt_powd_snf(a, 3.0)) == 0.2) {
          omegac = 9.0856029641606977;
        } else {
          omegac = a;
        }
      } else {
        omegac = 9.0856029641606977;
        fa = 0.2 - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
          (-rt_powd_snf(a, 3.0));
        fb = 0.2;
        if (fa == 0.0) {
          omegac = a;
        } else {
          fc = 0.2;
          b_c = 9.0856029641606977;
          e = 0.0;
          d = 0.0;
          exitg1 = false;
          while ((!exitg1) && ((fb != 0.0) && (a != omegac))) {
            if ((fb > 0.0) == (fc > 0.0)) {
              b_c = a;
              fc = fa;
              d = omegac - a;
              e = d;
            }

            if (std::abs(fc) < std::abs(fb)) {
              a = omegac;
              omegac = b_c;
              b_c = a;
              fa = fb;
              fb = fc;
              fc = fa;
            }

            b_m = 0.5 * (b_c - omegac);
            toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
              exitg1 = true;
            } else {
              if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                d = b_m;
                e = b_m;
              } else {
                s = fb / fa;
                if (a == b_c) {
                  p = 2.0 * b_m * s;
                  fa = 1.0 - s;
                } else {
                  fa /= fc;
                  b_r = fb / fc;
                  p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - a) * (b_r -
                            1.0));
                  fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                }

                if (p > 0.0) {
                  fa = -fa;
                } else {
                  p = -p;
                }

                if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p <
                     std::abs(0.5 * e * fa))) {
                  e = d;
                  d = p / fa;
                } else {
                  d = b_m;
                  e = b_m;
                }
              }

              a = omegac;
              fa = fb;
              if (std::abs(d) > toler) {
                omegac += d;
              } else if (omegac > b_c) {
                omegac -= toler;
              } else {
                omegac += toler;
              }

              fb = 0.2 - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0) * std::
                exp(-rt_powd_snf(omegac, 3.0));
            }
          }
        }
      }
      break;

     case 1:
      c_a = 4.94065645841247E-324;
      r = 0.99999999999999978;
      fa = -2.3025850929940455;
      fb = 2.2517998136852448E+15;
      fc = 2.2517998136852448E+15;
      b_c = 0.99999999999999978;
      e = 0.0;
      d = 0.0;
      exitg4 = false;
      while ((!exitg4) && ((fb != 0.0) && (c_a != r))) {
        if ((fb > 0.0) == (fc > 0.0)) {
          b_c = c_a;
          fc = fa;
          d = r - c_a;
          e = d;
        }

        if (std::abs(fc) < std::abs(fb)) {
          c_a = r;
          r = b_c;
          b_c = c_a;
          fa = fb;
          fb = fc;
          fc = fa;
        }

        b_m = 0.5 * (b_c - r);
        toler = 4.4408920985006262E-16 * std::fmax(std::abs(r), 1.0);
        if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
          exitg4 = true;
        } else {
          if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
            d = b_m;
            e = b_m;
          } else {
            s = fb / fa;
            if (c_a == b_c) {
              p = 2.0 * b_m * s;
              fa = 1.0 - s;
            } else {
              fa /= fc;
              b_r = fb / fc;
              p = s * (2.0 * b_m * fa * (fa - b_r) - (r - c_a) * (b_r - 1.0));
              fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
            }

            if (p > 0.0) {
              fa = -fa;
            } else {
              p = -p;
            }

            if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p < std::
                 abs(0.5 * e * fa))) {
              e = d;
              d = p / fa;
            } else {
              d = b_m;
              e = b_m;
            }
          }

          c_a = r;
          fa = fb;
          if (std::abs(d) > toler) {
            r += d;
          } else if (r > b_c) {
            r -= toler;
          } else {
            r += toler;
          }

          fb = ((1.0 / (1.0 - r * r) - 1.6094379124341003) - 0.69314718055994529)
            - 1.0;
        }
      }

      omegac = 0.6 * r + a;
      break;

     case 2:
      c_a = a - a;
      if (0.2 - 2.0 * std::exp(-(c_a * c_a) / 2.0) > 0.0) {
        omegac = a + 38.729833462074168;
      } else {
        c_a = a;
        omegac = a + 38.729833462074168;
        r = a - a;
        fa = 0.2 - 2.0 * std::exp(-(r * r) / 2.0);
        fb = 0.2;
        if (fa == 0.0) {
          omegac = a;
        } else {
          fc = 0.2;
          b_c = a + 38.729833462074168;
          e = 0.0;
          d = 0.0;
          exitg3 = false;
          while ((!exitg3) && ((fb != 0.0) && (c_a != omegac))) {
            if ((fb > 0.0) == (fc > 0.0)) {
              b_c = c_a;
              fc = fa;
              d = omegac - c_a;
              e = d;
            }

            if (std::abs(fc) < std::abs(fb)) {
              c_a = omegac;
              omegac = b_c;
              b_c = c_a;
              fa = fb;
              fb = fc;
              fc = fa;
            }

            b_m = 0.5 * (b_c - omegac);
            toler = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(b_m) <= toler) || (fb == 0.0)) {
              exitg3 = true;
            } else {
              if ((std::abs(e) < toler) || (std::abs(fa) <= std::abs(fb))) {
                d = b_m;
                e = b_m;
              } else {
                s = fb / fa;
                if (c_a == b_c) {
                  p = 2.0 * b_m * s;
                  fa = 1.0 - s;
                } else {
                  fa /= fc;
                  b_r = fb / fc;
                  p = s * (2.0 * b_m * fa * (fa - b_r) - (omegac - c_a) * (b_r -
                            1.0));
                  fa = (fa - 1.0) * (b_r - 1.0) * (s - 1.0);
                }

                if (p > 0.0) {
                  fa = -fa;
                } else {
                  p = -p;
                }

                if ((2.0 * p < 3.0 * b_m * fa - std::abs(toler * fa)) && (p <
                     std::abs(0.5 * e * fa))) {
                  e = d;
                  d = p / fa;
                } else {
                  d = b_m;
                  e = b_m;
                }
              }

              c_a = omegac;
              fa = fb;
              if (std::abs(d) > toler) {
                omegac += d;
              } else if (omegac > b_c) {
                omegac -= toler;
              } else {
                omegac += toler;
              }

              r = omegac - a;
              fb = 0.2 - 2.0 * std::exp(-(r * r) / 2.0);
            }
          }
        }
      }
      break;
    }

    halfh = omegac / 3.1415926535897931;
    if (tol < halfh * rt_powd_snf(2.0, 1.0 / fVoices)) {
      tol = halfh * rt_powd_snf(2.0, 1.0 / fVoices);
    }

    s = tol / halfh;
    if (s == 0.0) {
      s = rtMinusInf;
    } else if (s < 0.0) {
      s = rtNaN;
    } else if ((!std::isinf(s)) && (!std::isnan(s))) {
      s = std::frexp(s, &offsetH);
      if (s == 0.5) {
        s = static_cast<real_T>(offsetH) - 1.0;
      } else if ((offsetH == 1) && (s < 0.75)) {
        s = std::log(2.0 * s) / 0.69314718055994529;
      } else {
        s = std::log(s) / 0.69314718055994529 + static_cast<real_T>(offsetH);
      }
    }

    emxInit_real_T(&c_cpu_y, 2, &sd_emlrtRTEI, true);
    tol = std::fmax(s, 1.0 / fVoices) * fVoices;
    if (std::isnan(tol)) {
      eint = c_cpu_y->size[0] * c_cpu_y->size[1];
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = 1;
      emxEnsureCapacity_real_T(c_cpu_y, eint, &d_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &hh_gpu_y, true);
      b_y_needsGpuEnsureCapacity = false;
      ec_wtcc_kernel1287<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(hh_gpu_y);
    } else if (tol < 0.0) {
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = 0;
    } else {
      eint = c_cpu_y->size[0] * c_cpu_y->size[1];
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = static_cast<int32_T>(tol) + 1;
      emxEnsureCapacity_real_T(c_cpu_y, eint, &d_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol)), &grid,
        &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &hh_gpu_y, true);
      b_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1290<<<grid, block>>>(static_cast<int32_T>(tol), hh_gpu_y);
      }
    }

    emxInit_real_T(&d_cpu_y, 2, &ud_emlrtRTEI, true);
    eint = d_cpu_y->size[0] * d_cpu_y->size[1];
    d_cpu_y->size[0] = 1;
    d_cpu_y->size[1] = c_cpu_y->size[1];
    emxEnsureCapacity_real_T(d_cpu_y, eint, &e_emlrtRTEI);
    nx = c_cpu_y->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    if (b_y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &hh_gpu_y, true);
    }

    gpuEmxEnsureCapacity_real_T(d_cpu_y, &ih_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1288<<<grid, block>>>(hh_gpu_y, rt_powd_snf(2.0, 1.0 /
        fVoices), nx - 1, ih_gpu_y);
    }

    emxFree_real_T(&c_cpu_y);
    eint = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
    cpu_fb_Scales->size[0] = 1;
    cpu_fb_Scales->size[1] = d_cpu_y->size[1];
    emxEnsureCapacity_real_T(cpu_fb_Scales, eint, &f_emlrtRTEI);
    eint = d_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    b_fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1289<<<grid, block>>>(ih_gpu_y, halfh, eint, gpu_fb_Scales);
    }

    interval_outdatedOnGpu = true;
    emxFree_real_T(&d_cpu_y);
  }

  emxInit_real_T(&cpu_somega, 2, &rd_emlrtRTEI, true);
  if (cpu_fb_Scales->size[1] == 1) {
    x_data_outdatedOnGpu = false;
    eint = cpu_somega->size[0] * cpu_somega->size[1];
    cpu_somega->size[0] = 1;
    if (cpu_fb_Omega->size[1] == 1) {
      cpu_somega->size[1] = 1;
    } else {
      cpu_somega->size[1] = cpu_fb_Omega->size[1];
    }

    emxEnsureCapacity_real_T(cpu_somega, eint, &h_emlrtRTEI);
    fx_data_outdatedOnCpu = true;
    ix = (cpu_fb_Omega->size[1] != 1);
    cpu_lidx = cpu_somega->size[1] - 1;
    for (k = 0; k <= cpu_lidx; k++) {
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Scales, &gpu_fb_Scales);
      }

      interval_outdatedOnGpu = false;
      if (c_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Omega, &gpu_fb_Omega);
      }

      c_omega_tmp1_needsGpuEnsureCapa = false;
      cpu_somega->data[k] = cpu_fb_Scales->data[0] * cpu_fb_Omega->data[ix * k];
      x_data_outdatedOnGpu = true;
      b_fx_data_outdatedOnCpu = true;
    }
  } else {
    eint = cpu_somega->size[0] * cpu_somega->size[1];
    cpu_somega->size[0] = cpu_fb_Scales->size[1];
    cpu_somega->size[1] = cpu_fb_Omega->size[1];
    emxEnsureCapacity_real_T(cpu_somega, eint, &g_emlrtRTEI);
    nx = cpu_fb_Omega->size[1];
    offsetH = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(nx - 1, offsetH), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1278<<<grid, block>>>(gpu_fb_Omega, gpu_fb_Scales, offsetH,
        nx - 1, gpu_somega, cpu_somega->size[0U]);
    }

    x_data_outdatedOnGpu = false;
  }

  emxFree_real_T(&cpu_fb_Omega);
  first_iteration = false;
  nrefine = 0;
  do {
    exitg2 = 0;
    if (nrefine + 1 < 5) {
      if (cv3[nrefine] != b_a[nrefine]) {
        exitg2 = 1;
      } else {
        nrefine++;
      }
    } else {
      first_iteration = true;
      exitg2 = 1;
    }
  } while (exitg2 == 0);

  emxInit_real_T(&cpu_expnt, 2, &j_emlrtRTEI, true);
  emxInit_real_T(&cpu_daughter, 2, &p_emlrtRTEI, true);
  if (first_iteration) {
    eint = 0;
  } else {
    eint = -1;
  }

  if (eint == 0) {
    eint = cpu_expnt->size[0] * cpu_expnt->size[1];
    cpu_expnt->size[0] = cpu_somega->size[0];
    cpu_expnt->size[1] = cpu_somega->size[1];
    emxEnsureCapacity_real_T(cpu_expnt, eint, &j_emlrtRTEI);
    eint = cpu_somega->size[0] * cpu_somega->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    if (fx_data_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, !x_data_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real_T(cpu_expnt, &gpu_expnt, true);
    if (x_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_somega, cpu_somega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel16<<<grid, block>>>(gpu_somega, eint, gpu_expnt);
    }

    nx = cpu_expnt->size[0] * cpu_expnt->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel17<<<grid, block>>>(nx - 1, gpu_expnt);
    }

    eint = cpu_daughter->size[0] * cpu_daughter->size[1];
    cpu_daughter->size[0] = cpu_expnt->size[0];
    cpu_daughter->size[1] = cpu_expnt->size[1];
    emxEnsureCapacity_real_T(cpu_daughter, eint, &l_emlrtRTEI);
    eint = cpu_expnt->size[0] * cpu_expnt->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel18<<<grid, block>>>(gpu_somega, gpu_expnt, eint,
        gpu_daughter);
    }
  } else {
    emxInit_real_T(&cpu_w, 2, &i_emlrtRTEI, true);
    eint = cpu_w->size[0] * cpu_w->size[1];
    cpu_w->size[0] = cpu_somega->size[0];
    cpu_w->size[1] = cpu_somega->size[1];
    emxEnsureCapacity_real_T(cpu_w, eint, &i_emlrtRTEI);
    eint = cpu_somega->size[0] * cpu_somega->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    if (fx_data_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_somega, &gpu_somega, !x_data_outdatedOnGpu);
    }

    gpuEmxEnsureCapacity_real_T(cpu_w, &gc_gpu_w, true);
    if (x_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_somega, cpu_somega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1272<<<grid, block>>>(gpu_somega, eint, gc_gpu_w);
    }

    eint = cpu_expnt->size[0] * cpu_expnt->size[1];
    cpu_expnt->size[0] = cpu_w->size[0];
    cpu_expnt->size[1] = cpu_w->size[1];
    emxEnsureCapacity_real_T(cpu_expnt, eint, &k_emlrtRTEI);
    offsetH = cpu_w->size[0] * cpu_w->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_expnt, &gpu_expnt, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1273<<<grid, block>>>(gc_gpu_w, offsetH, gpu_expnt);
    }

    nx = cpu_expnt->size[0] * cpu_expnt->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1274<<<grid, block>>>(nx - 1, gpu_expnt);
    }

    nx = cpu_w->size[0] * cpu_w->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_w->size[itime]);
    }

    emxInit_real_T(&e_cpu_y, 2, &td_emlrtRTEI, true);
    eint = e_cpu_y->size[0] * e_cpu_y->size[1];
    e_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    e_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real_T(e_cpu_y, eint, &n_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(e_cpu_y, &gh_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1275<<<grid, block>>>(gc_gpu_w, nx - 1, gh_gpu_y);
    }

    emxFree_real_T(&cpu_w);
    if ((cpu_expnt->size[0] == e_cpu_y->size[0]) && (cpu_expnt->size[1] ==
         e_cpu_y->size[1])) {
      eint = cpu_daughter->size[0] * cpu_daughter->size[1];
      cpu_daughter->size[0] = cpu_expnt->size[0];
      cpu_daughter->size[1] = cpu_expnt->size[1];
      emxEnsureCapacity_real_T(cpu_daughter, eint, &p_emlrtRTEI);
      eint = cpu_expnt->size[0] * cpu_expnt->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
      fx_data_outdatedOnCpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1276<<<grid, block>>>(gh_gpu_y, gpu_expnt, eint,
          gpu_daughter);
      }

      interval_outdatedOnGpu = false;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(cpu_expnt, &gpu_expnt);
      gpuEmxMemcpyGpuToCpu_real_T(e_cpu_y, &gh_gpu_y);
      binary_expand_op_9(cpu_daughter, cpu_expnt, e_cpu_y);
      interval_outdatedOnGpu = true;
      fx_data_outdatedOnCpu = true;
    }

    emxFree_real_T(&e_cpu_y);
    nrefine = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(nrefine), &grid, &block, 2147483647U);
    if (fx_data_outdatedOnCpu) {
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter,
        !interval_outdatedOnGpu);
    }

    if (interval_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_daughter, cpu_daughter);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1277<<<grid, block>>>(nrefine, gpu_daughter);
    }
  }

  emxFree_real_T(&cpu_expnt);
  emxFree_real_T(&cpu_somega);
  halfh = std::fmin(std::floor(static_cast<real_T>(cpu_fb_Scales->size[1]) / 2.0),
                    static_cast<real_T>(fVoices));
  emxInit_real32_T(&cpu_psihat, 2, &m_emlrtRTEI, true);
  eint = cpu_psihat->size[0] * cpu_psihat->size[1];
  cpu_psihat->size[0] = cpu_daughter->size[0];
  cpu_psihat->size[1] = cpu_daughter->size[1];
  emxEnsureCapacity_real32_T(cpu_psihat, eint, &m_emlrtRTEI);
  eint = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(cpu_psihat, &gpu_psihat, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel19<<<grid, block>>>(gpu_daughter, eint, gpu_psihat);
  }

  emxInit_real32_T(&cpu_xv, 2, &o_emlrtRTEI, true);
  eint = cpu_xv->size[0] * cpu_xv->size[1];
  cpu_xv->size[0] = 1;
  cpu_xv->size[1] = cpu_x->size[0];
  emxEnsureCapacity_real32_T(cpu_xv, eint, &o_emlrtRTEI);
  eint = cpu_x->size[0] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(cpu_x, &gpu_x, false);
  gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, true);
  gpuEmxMemcpyCpuToGpu_real32_T(&gpu_x, cpu_x);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel20<<<grid, block>>>(static_cast<int32_T>(c[0]), gpu_x, eint,
      gpu_xv, cpu_x->size[0U]);
  }

  if (b_nx > 0) {
    pathlen = cpu_x->size[0] - b_nx;
    if (pathlen + 1 > cpu_x->size[0]) {
      nsubs = 0;
      ix = 1;
      pathlen = -1;
    } else {
      nsubs = cpu_x->size[0] - 1;
      ix = -1;
    }

    emxInit_real32_T(&b_cpu_x, 2, &s_emlrtRTEI, true);
    eint = b_cpu_x->size[0] * b_cpu_x->size[1];
    b_cpu_x->size[0] = 1;
    b_cpu_x->size[1] = b_nx;
    emxEnsureCapacity_real32_T(b_cpu_x, eint, &s_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(b_nx - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_x, &b_gpu_x, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel21<<<grid, block>>>(static_cast<int32_T>(c[0]), gpu_x, b_nx
        - 1, b_gpu_x, cpu_x->size[0U]);
    }

    cpu_lidx = b_nx >> 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
      2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel22<<<grid, block>>>(b_nx, cpu_lidx - 1, b_gpu_x);
    }

    eint = cpu_xv->size[0] * cpu_xv->size[1];
    cpu_xv->size[0] = 1;
    cpu_xv->size[1] = ((cpu_x->size[0] + b_cpu_x->size[1]) + div_s32(pathlen -
      nsubs, ix)) + 1;
    emxEnsureCapacity_real32_T(cpu_xv, eint, &t_emlrtRTEI);
    nx = b_cpu_x->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_xv, &gpu_xv, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel23<<<grid, block>>>(b_gpu_x, nx - 1, gpu_xv);
    }

    nx = cpu_x->size[0];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel24<<<grid, block>>>(static_cast<int32_T>(c[0]), gpu_x, nx -
        1, gpu_xv, b_cpu_x->size[1U], cpu_x->size[0U]);
    }

    nx = div_s32(pathlen - nsubs, ix);
    mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel25<<<grid, block>>>(static_cast<int32_T>(c[0]), ix, nsubs,
        gpu_x, nx, gpu_xv, cpu_x->size[0U], b_cpu_x->size[1U]);
    }

    emxFree_real32_T(&b_cpu_x);
  }

  emxInit_creal32_T(&cpu_xposdft, 2, &q_emlrtRTEI, true);
  if (cpu_xv->size[1] - (static_cast<int32_T>(static_cast<uint32_T>(cpu_xv->
         size[1]) >> 1) << 1) == 1) {
    cufftHandle fftPlanHandle;
    eint = cpu_xposdft->size[0] * cpu_xposdft->size[1];
    cpu_xposdft->size[0] = 1;
    cpu_xposdft->size[1] = cpu_xv->size[1];
    emxEnsureCapacity_creal32_T(cpu_xposdft, eint, &q_emlrtRTEI);
    eint = cpu_xv->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_xposdft, &gpu_xposdft, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel26<<<grid, block>>>(gpu_xv, eint, gpu_xposdft);
    }

    cpu_lidx = cpu_xposdft->size[1];
    fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, 1, 1, CUFFT_C2C, 1);
    cufftExecC2C(fftPlanHandle, (cufftComplex *)&gpu_xposdft.data[0],
                 (cufftComplex *)&gpu_xposdft.data[0], CUFFT_FORWARD);
  } else {
    cpu_lidx = cpu_xv->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_xv->size[itime]);
    }

    cufftHandle b_fftPlanHandle;
    eint = cpu_xposdft->size[0] * cpu_xposdft->size[1];
    cpu_xposdft->size[0] = 1;
    cpu_xposdft->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_creal32_T(cpu_xposdft, eint, &r_emlrtRTEI);
    b_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, 1, 1, CUFFT_R2C,
      1);
    gpuEmxEnsureCapacity_creal32_T(cpu_xposdft, &gpu_xposdft, true);
    cufftExecR2C(b_fftPlanHandle, (cufftReal *)&gpu_xv.data[0], (cufftComplex *)
                 &gpu_xposdft.data[0]);
    cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
      (xSize[1]) + 1) / 2.0);
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 2), &grid, &block,
      2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1271<<<grid, block>>>(cpu_lidx - 2, gpu_xposdft, xSize[1]);
    }
  }

  emxFree_real32_T(&cpu_xv);
  itime = cpu_psihat->size[1];
  pathlen = cpu_xposdft->size[1];
  if (itime <= pathlen) {
    pathlen = itime;
  }

  if (cpu_psihat->size[1] == 1) {
    cpu_csz[1] = cpu_xposdft->size[1];
  } else if (cpu_xposdft->size[1] == cpu_psihat->size[1]) {
    cpu_csz[1] = cpu_xposdft->size[1];
  } else {
    cpu_csz[1] = pathlen;
  }

  emxInit_creal32_T(&cpu_cfsposdft, 2, &vd_emlrtRTEI, true);
  eint = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1];
  cpu_cfsposdft->size[0] = cpu_psihat->size[0];
  itime = cpu_psihat->size[1];
  pathlen = cpu_xposdft->size[1];
  if (itime <= pathlen) {
    pathlen = itime;
  }

  if (cpu_psihat->size[1] == 1) {
    cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
  } else if (cpu_xposdft->size[1] == cpu_psihat->size[1]) {
    cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
  } else {
    cpu_cfsposdft->size[1] = pathlen;
  }

  emxEnsureCapacity_creal32_T(cpu_cfsposdft, eint, &h_emlrtRTEI);
  fx_data_outdatedOnCpu = true;
  if ((cpu_psihat->size[0] != 0) && (cpu_csz[1] != 0)) {
    ix = (cpu_psihat->size[1] != 1);
    offsetH = cpu_cfsposdft->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, offsetH), &grid,
      &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_cfsposdft, &gpu_cfsposdft, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel27<<<grid, block>>>(gpu_xposdft, gpu_psihat, ix, offsetH,
        cpu_csz[1] - 1, gpu_cfsposdft, cpu_psihat->size[0U], cpu_cfsposdft->
        size[0U]);
    }
  }

  emxFree_creal32_T(&cpu_xposdft);
  emxFree_real32_T(&cpu_psihat);
  emxInit_creal32_T(&cpu_cfspos, 2, &u_emlrtRTEI, true);
  if ((cpu_cfsposdft->size[0] == 0) || (cpu_cfsposdft->size[1] == 0)) {
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_cfsposdft->size[itime]);
    }

    xSize[1] = static_cast<uint32_T>(cpu_cfsposdft->size[1]);
    eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
    cpu_cfspos->size[0] = static_cast<int32_T>(xSize[0]);
    cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
    emxEnsureCapacity_creal32_T(cpu_cfspos, eint, &u_emlrtRTEI);
    eint = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel28<<<grid, block>>>(eint, gpu_cfspos);
    }

    x_data_outdatedOnGpu = false;
    y_needsGpuEnsureCapacity = true;
  } else {
    cufftHandle c_fftPlanHandle;
    cpu_lidx = cpu_cfsposdft->size[1];
    c_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
      cpu_cfsposdft->size[0], 1, CUFFT_C2C, cpu_cfsposdft->size[0]);
    if (fx_data_outdatedOnCpu) {
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsposdft, &gpu_cfsposdft, true);
    }

    cufftExecC2C(c_fftPlanHandle, (cufftComplex *)&gpu_cfsposdft.data[0],
                 (cufftComplex *)&gpu_cfsposdft.data[0], CUFFT_INVERSE);
    eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
    cpu_cfspos->size[0] = cpu_cfsposdft->size[0];
    cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
    emxEnsureCapacity_creal32_T(cpu_cfspos, eint, &u_emlrtRTEI);
    ec_wtcc_kernel1269<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_cfsposdft,
      cpu_cfsposdft->size[1U]);
    offsetH = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1270<<<grid, block>>>(c_gpu_cfsposdft, gpu_cfsposdft,
        offsetH, gpu_cfspos);
    }

    x_data_outdatedOnGpu = false;
    y_needsGpuEnsureCapacity = true;
  }

  emxFree_creal32_T(&cpu_cfsposdft);
  if (b_nx > 0) {
    N = static_cast<uint32_T>(b_nx) + static_cast<uint32_T>(cpu_x->size[0]);
    if (static_cast<uint32_T>(b_nx + 1) > N) {
      cpu_lidx = 0;
      pathlen = 0;
    } else {
      cpu_lidx = b_nx;
      pathlen = static_cast<int32_T>(N);
    }

    nsubs = cpu_cfspos->size[0];
    nx = pathlen - cpu_lidx;
    for (eint = 0; eint < nx; eint++) {
      for (n = 0; n < nsubs; n++) {
        if (y_needsGpuEnsureCapacity) {
          gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfspos, &gpu_cfspos);
        }

        cpu_cfspos->data[n + nsubs * eint] = cpu_cfspos->data[n +
          cpu_cfspos->size[0] * (cpu_lidx + eint)];
        y_needsGpuEnsureCapacity = false;
        x_data_outdatedOnGpu = true;
      }
    }

    eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
    cpu_cfspos->size[1] = pathlen - cpu_lidx;
    emxEnsureCapacity_creal32_T(cpu_cfspos, eint, &v_emlrtRTEI);
    interval_outdatedOnGpu = true;
  }

  emxInit_real32_T(&b_cpu_psihat, 2, &m_emlrtRTEI, true);
  eint = b_cpu_psihat->size[0] * b_cpu_psihat->size[1];
  b_cpu_psihat->size[0] = cpu_daughter->size[0];
  b_cpu_psihat->size[1] = cpu_daughter->size[1];
  emxEnsureCapacity_real32_T(b_cpu_psihat, eint, &m_emlrtRTEI);
  eint = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(b_cpu_psihat, &b_gpu_psihat, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel29<<<grid, block>>>(gpu_daughter, eint, b_gpu_psihat);
  }

  emxFree_real_T(&cpu_daughter);
  emxInit_real32_T(&b_cpu_xv, 2, &o_emlrtRTEI, true);
  eint = b_cpu_xv->size[0] * b_cpu_xv->size[1];
  b_cpu_xv->size[0] = 1;
  b_cpu_xv->size[1] = cpu_x->size[0];
  emxEnsureCapacity_real32_T(b_cpu_xv, eint, &o_emlrtRTEI);
  eint = cpu_x->size[0] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel30<<<grid, block>>>(static_cast<int32_T>(c[1]), gpu_x, eint,
      b_gpu_xv, cpu_x->size[0U]);
  }

  if (b_nx > 0) {
    nsubs = cpu_x->size[0] - b_nx;
    if (nsubs + 1 > cpu_x->size[0]) {
      ix = 0;
      pathlen = 1;
      nsubs = -1;
    } else {
      ix = cpu_x->size[0] - 1;
      pathlen = -1;
    }

    emxInit_real32_T(&c_cpu_x, 2, &s_emlrtRTEI, true);
    eint = c_cpu_x->size[0] * c_cpu_x->size[1];
    c_cpu_x->size[0] = 1;
    c_cpu_x->size[1] = b_nx;
    emxEnsureCapacity_real32_T(c_cpu_x, eint, &s_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(b_nx - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real32_T(c_cpu_x, &c_gpu_x, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel31<<<grid, block>>>(static_cast<int32_T>(c[1]), gpu_x, b_nx
        - 1, c_gpu_x, cpu_x->size[0U]);
    }

    cpu_lidx = b_nx >> 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
      2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel32<<<grid, block>>>(b_nx, cpu_lidx - 1, c_gpu_x);
    }

    eint = b_cpu_xv->size[0] * b_cpu_xv->size[1];
    b_cpu_xv->size[0] = 1;
    b_cpu_xv->size[1] = ((cpu_x->size[0] + c_cpu_x->size[1]) + div_s32(nsubs -
      ix, pathlen)) + 1;
    emxEnsureCapacity_real32_T(b_cpu_xv, eint, &t_emlrtRTEI);
    nx = c_cpu_x->size[1];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_xv, &b_gpu_xv, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel33<<<grid, block>>>(c_gpu_x, nx - 1, b_gpu_xv);
    }

    nx = cpu_x->size[0];
    mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel34<<<grid, block>>>(static_cast<int32_T>(c[1]), gpu_x, nx -
        1, b_gpu_xv, c_cpu_x->size[1U], cpu_x->size[0U]);
    }

    nx = div_s32(nsubs - ix, pathlen);
    mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel35<<<grid, block>>>(static_cast<int32_T>(c[1]), pathlen, ix,
        gpu_x, nx, b_gpu_xv, cpu_x->size[0U], c_cpu_x->size[1U]);
    }

    emxFree_real32_T(&c_cpu_x);
  }

  emxInit_creal32_T(&b_cpu_xposdft, 2, &q_emlrtRTEI, true);
  if (b_cpu_xv->size[1] - (static_cast<int32_T>(static_cast<uint32_T>
        (b_cpu_xv->size[1]) >> 1) << 1) == 1) {
    cufftHandle d_fftPlanHandle;
    eint = b_cpu_xposdft->size[0] * b_cpu_xposdft->size[1];
    b_cpu_xposdft->size[0] = 1;
    b_cpu_xposdft->size[1] = b_cpu_xv->size[1];
    emxEnsureCapacity_creal32_T(b_cpu_xposdft, eint, &q_emlrtRTEI);
    eint = b_cpu_xv->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_xposdft, &b_gpu_xposdft, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel36<<<grid, block>>>(b_gpu_xv, eint, b_gpu_xposdft);
    }

    cpu_lidx = b_cpu_xposdft->size[1];
    d_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, 1, 1, CUFFT_C2C,
      1);
    cufftExecC2C(d_fftPlanHandle, (cufftComplex *)&b_gpu_xposdft.data[0],
                 (cufftComplex *)&b_gpu_xposdft.data[0], CUFFT_FORWARD);
  } else {
    cpu_lidx = b_cpu_xv->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(b_cpu_xv->size[itime]);
    }

    cufftHandle e_fftPlanHandle;
    eint = b_cpu_xposdft->size[0] * b_cpu_xposdft->size[1];
    b_cpu_xposdft->size[0] = 1;
    b_cpu_xposdft->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_creal32_T(b_cpu_xposdft, eint, &r_emlrtRTEI);
    e_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, 1, 1, CUFFT_R2C,
      1);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_xposdft, &b_gpu_xposdft, true);
    cufftExecR2C(e_fftPlanHandle, (cufftReal *)&b_gpu_xv.data[0], (cufftComplex *)
                 &b_gpu_xposdft.data[0]);
    cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
      (xSize[1]) + 1) / 2.0);
    mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 2), &grid, &block,
      2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1268<<<grid, block>>>(cpu_lidx - 2, b_gpu_xposdft, xSize[1]);
    }
  }

  emxFree_real32_T(&b_cpu_xv);
  itime = b_cpu_psihat->size[1];
  pathlen = b_cpu_xposdft->size[1];
  if (itime <= pathlen) {
    pathlen = itime;
  }

  if (b_cpu_psihat->size[1] == 1) {
    nrefine = b_cpu_xposdft->size[1];
  } else if (b_cpu_xposdft->size[1] == b_cpu_psihat->size[1]) {
    nrefine = b_cpu_xposdft->size[1];
  } else {
    nrefine = pathlen;
  }

  emxInit_creal32_T(&b_cpu_cfsposdft, 2, &vd_emlrtRTEI, true);
  eint = b_cpu_cfsposdft->size[0] * b_cpu_cfsposdft->size[1];
  b_cpu_cfsposdft->size[0] = b_cpu_psihat->size[0];
  itime = b_cpu_psihat->size[1];
  pathlen = b_cpu_xposdft->size[1];
  if (itime <= pathlen) {
    pathlen = itime;
  }

  if (b_cpu_psihat->size[1] == 1) {
    b_cpu_cfsposdft->size[1] = b_cpu_xposdft->size[1];
  } else if (b_cpu_xposdft->size[1] == b_cpu_psihat->size[1]) {
    b_cpu_cfsposdft->size[1] = b_cpu_xposdft->size[1];
  } else {
    b_cpu_cfsposdft->size[1] = pathlen;
  }

  emxEnsureCapacity_creal32_T(b_cpu_cfsposdft, eint, &h_emlrtRTEI);
  fx_data_outdatedOnCpu = true;
  if ((b_cpu_psihat->size[0] != 0) && (nrefine != 0)) {
    ix = (b_cpu_psihat->size[1] != 1);
    offsetH = b_cpu_cfsposdft->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(nrefine - 1, offsetH), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsposdft, &b_gpu_cfsposdft, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel37<<<grid, block>>>(b_gpu_xposdft, b_gpu_psihat, ix, offsetH,
        nrefine - 1, b_gpu_cfsposdft, b_cpu_psihat->size[0U],
        b_cpu_cfsposdft->size[0U]);
    }
  }

  emxFree_creal32_T(&b_cpu_xposdft);
  emxFree_real32_T(&b_cpu_psihat);
  emxInit_creal32_T(&b_cpu_cfspos, 2, &u_emlrtRTEI, true);
  if ((b_cpu_cfsposdft->size[0] == 0) || (b_cpu_cfsposdft->size[1] == 0)) {
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(b_cpu_cfsposdft->size[itime]);
    }

    xSize[1] = static_cast<uint32_T>(b_cpu_cfsposdft->size[1]);
    eint = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
    b_cpu_cfspos->size[0] = static_cast<int32_T>(xSize[0]);
    b_cpu_cfspos->size[1] = b_cpu_cfsposdft->size[1];
    emxEnsureCapacity_creal32_T(b_cpu_cfspos, eint, &u_emlrtRTEI);
    eint = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel38<<<grid, block>>>(eint, b_gpu_cfspos);
    }

    wav_outdatedOnCpu = false;
    fx_data_outdatedOnCpu = true;
  } else {
    cufftHandle f_fftPlanHandle;
    cpu_lidx = b_cpu_cfsposdft->size[1];
    f_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
      b_cpu_cfsposdft->size[0], 1, CUFFT_C2C, b_cpu_cfsposdft->size[0]);
    if (fx_data_outdatedOnCpu) {
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsposdft, &b_gpu_cfsposdft, true);
    }

    cufftExecC2C(f_fftPlanHandle, (cufftComplex *)&b_gpu_cfsposdft.data[0],
                 (cufftComplex *)&b_gpu_cfsposdft.data[0], CUFFT_INVERSE);
    eint = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
    b_cpu_cfspos->size[0] = b_cpu_cfsposdft->size[0];
    b_cpu_cfspos->size[1] = b_cpu_cfsposdft->size[1];
    emxEnsureCapacity_creal32_T(b_cpu_cfspos, eint, &u_emlrtRTEI);
    ec_wtcc_kernel1266<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_cfsposdft,
      b_cpu_cfsposdft->size[1U]);
    offsetH = b_cpu_cfsposdft->size[0] * b_cpu_cfsposdft->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1267<<<grid, block>>>(c_gpu_cfsposdft, b_gpu_cfsposdft,
        offsetH, b_gpu_cfspos);
    }

    wav_outdatedOnCpu = false;
    fx_data_outdatedOnCpu = true;
  }

  emxFree_creal32_T(&b_cpu_cfsposdft);
  if (b_nx > 0) {
    N = static_cast<uint32_T>(b_nx) + static_cast<uint32_T>(cpu_x->size[0]);
    if (static_cast<uint32_T>(b_nx + 1) > N) {
      b_nx = 0;
      ix = 0;
    } else {
      ix = static_cast<int32_T>(N);
    }

    nsubs = b_cpu_cfspos->size[0];
    nx = ix - b_nx;
    for (eint = 0; eint < nx; eint++) {
      for (n = 0; n < nsubs; n++) {
        if (fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfspos, &b_gpu_cfspos);
        }

        b_cpu_cfspos->data[n + nsubs * eint] = b_cpu_cfspos->data[n +
          b_cpu_cfspos->size[0] * (b_nx + eint)];
        fx_data_outdatedOnCpu = false;
        wav_outdatedOnCpu = true;
      }
    }

    eint = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
    b_cpu_cfspos->size[1] = ix - b_nx;
    emxEnsureCapacity_creal32_T(b_cpu_cfspos, eint, &v_emlrtRTEI);
    c_omega_tmp1_needsGpuEnsureCapa = true;
  }

  cpu_lidx = static_cast<int32_T>(std::trunc(static_cast<real_T>
    (cpu_cfspos->size[0]) / 2.0));
  if (!(halfh <= cpu_lidx)) {
    i_y = nullptr;
    m8 = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m8, &rfmt[0]);
    emlrtAssign(&i_y, m8);
    j_y = nullptr;
    m9 = emlrtCreateDoubleScalar(static_cast<real_T>(cpu_lidx));
    emlrtAssign(&j_y, m9);
    emlrt_marshallIn(b_sprintf(i_y, j_y, &emlrtMCI), "<output of sprintf>",
                     unusedExpr);
  }

  nx = cpu_cfspos->size[0] * cpu_cfspos->size[1];
  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(cpu_cfspos->size[itime]);
  }

  emxInit_real32_T(&f_cpu_y, 2, &wd_emlrtRTEI, true);
  eint = f_cpu_y->size[0] * f_cpu_y->size[1];
  f_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
  f_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(f_cpu_y, eint, &n_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  if (interval_outdatedOnGpu) {
    gpuEmxEnsureCapacity_creal32_T(cpu_cfspos, &gpu_cfspos,
      !x_data_outdatedOnGpu);
  }

  gpuEmxEnsureCapacity_real32_T(f_cpu_y, &c_gpu_y, true);
  if (x_data_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_cfspos, cpu_cfspos);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel39<<<grid, block>>>(gpu_cfspos, nx - 1, c_gpu_y);
  }

  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(f_cpu_y->size[itime]);
  }

  emxInit_real32_T(&cpu_cfs1, 2, &gb_emlrtRTEI, true);
  eint = cpu_cfs1->size[0] * cpu_cfs1->size[1];
  cpu_cfs1->size[0] = static_cast<int32_T>(xSize[0]);
  cpu_cfs1->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(cpu_cfs1, eint, &e_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
    static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel40<<<grid, block>>>(c_gpu_y, static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1, gpu_cfs1);
  }

  emxFree_real32_T(&f_cpu_y);
  fa = std::frexp(static_cast<real_T>(cpu_cfs1->size[1]), &b_eint);
  if (fa == 0.5) {
    b_eint--;
  }

  r = rt_powd_snf(2.0, static_cast<real_T>(b_eint));
  nrefine = static_cast<int32_T>(std::trunc(r / 2.0));
  emxInit_int32_T(&b_cpu_omega_tmp1, 2, &w_emlrtRTEI, true);
  if (nrefine < 1) {
    b_cpu_omega_tmp1->size[0] = 1;
    b_cpu_omega_tmp1->size[1] = 0;
  } else {
    eint = b_cpu_omega_tmp1->size[0] * b_cpu_omega_tmp1->size[1];
    b_cpu_omega_tmp1->size[0] = 1;
    b_cpu_omega_tmp1->size[1] = nrefine;
    emxEnsureCapacity_int32_T(b_cpu_omega_tmp1, eint, &w_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_int32_T(b_cpu_omega_tmp1, &b_gpu_omega_tmp1, true);
    d_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1265<<<grid, block>>>(nrefine - 1, b_gpu_omega_tmp1);
    }
  }

  emxInit_real_T(&b_cpu_omega_tmp2, 2, &x_emlrtRTEI, true);
  eint = b_cpu_omega_tmp2->size[0] * b_cpu_omega_tmp2->size[1];
  b_cpu_omega_tmp2->size[0] = 1;
  b_cpu_omega_tmp2->size[1] = b_cpu_omega_tmp1->size[1];
  emxEnsureCapacity_real_T(b_cpu_omega_tmp2, eint, &x_emlrtRTEI);
  eint = b_cpu_omega_tmp1->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (d_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_int32_T(b_cpu_omega_tmp1, &b_gpu_omega_tmp1, true);
  }

  gpuEmxEnsureCapacity_real_T(b_cpu_omega_tmp2, &b_gpu_omega_tmp2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel41<<<grid, block>>>(6.2831853071795862 / r, b_gpu_omega_tmp1,
      eint, b_gpu_omega_tmp2);
  }

  emxFree_int32_T(&b_cpu_omega_tmp1);
  cpu_lidx = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
  if (cpu_lidx < 1) {
    nrefine = 0;
    pathlen = 1;
    nsubs = -1;
  } else {
    nrefine = cpu_lidx - 1;
    pathlen = -1;
    nsubs = 0;
  }

  emxInit_real_T(&cpu_omega, 2, &y_emlrtRTEI, true);
  eint = cpu_omega->size[0] * cpu_omega->size[1];
  cpu_omega->size[0] = 1;
  cpu_omega->size[1] = (b_cpu_omega_tmp2->size[1] + div_s32(nsubs - nrefine,
    pathlen)) + 2;
  emxEnsureCapacity_real_T(cpu_omega, eint, &y_emlrtRTEI);
  gpuEmxEnsureCapacity_real_T(cpu_omega, &gpu_omega, true);
  ec_wtcc_kernel42<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_omega);
  nx = b_cpu_omega_tmp2->size[1];
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel43<<<grid, block>>>(b_gpu_omega_tmp2, nx - 1, gpu_omega);
  }

  nx = div_s32(nsubs - nrefine, pathlen);
  mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel44<<<grid, block>>>(pathlen, nrefine, b_gpu_omega_tmp2, nx,
      gpu_omega, b_cpu_omega_tmp2->size[1U]);
  }

  emxFree_real_T(&b_cpu_omega_tmp2);
  emxInit_creal32_T(&cpu_cfsDFT, 2, &ab_emlrtRTEI, true);
  if ((cpu_cfs1->size[0] == 0) || (cpu_cfs1->size[1] == 0) ||
      (static_cast<int32_T>(r) == 0)) {
    eint = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
    cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
    cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
    emxEnsureCapacity_creal32_T(cpu_cfsDFT, eint, &ab_emlrtRTEI);
    offsetH = cpu_cfs1->size[0] * static_cast<int32_T>(r) - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel45<<<grid, block>>>(offsetH, gpu_cfsDFT);
    }
  } else if (cpu_cfs1->size[1] != static_cast<int32_T>(r)) {
    cufftHandle i_fftPlanHandle;
    if (cpu_cfs1->size[1] < static_cast<int32_T>(r)) {
      eint = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
      cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
      cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(cpu_cfsDFT, eint, &ab_emlrtRTEI);
      offsetH = cpu_cfs1->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
      a_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1260<<<grid, block>>>(offsetH, gpu_cfsDFT);
      }
    } else {
      eint = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
      cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
      cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(cpu_cfsDFT, eint, &r_emlrtRTEI);
      a_data_outdatedOnGpu = true;
    }

    cpu_lidx = cpu_cfs1->size[0];
    if (cpu_cfs1->size[1] > static_cast<int32_T>(r)) {
      pathlen = static_cast<int32_T>(r);
    } else {
      pathlen = cpu_cfs1->size[1];
    }

    mwGetLaunchParameters1D(computeNumIters(pathlen - 1, cpu_lidx - 1), &grid,
      &block, 2147483647U);
    if (a_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1261<<<grid, block>>>(gpu_cfs1, cpu_lidx - 1, pathlen - 1,
        gpu_cfsDFT, cpu_cfsDFT->size[0U], cpu_cfs1->size[0U]);
    }

    cpu_lidx = cpu_cfsDFT->size[1];
    i_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, cpu_cfsDFT->
      size[0], 1, CUFFT_C2C, cpu_cfsDFT->size[0]);
    cufftExecC2C(i_fftPlanHandle, (cufftComplex *)&gpu_cfsDFT.data[0],
                 (cufftComplex *)&gpu_cfsDFT.data[0], CUFFT_FORWARD);
  } else {
    itime = cpu_cfs1->size[0] * cpu_cfs1->size[1];
    if (itime - (static_cast<int32_T>(static_cast<uint32_T>(itime) >> 1) << 1) ==
        1) {
      cufftHandle g_fftPlanHandle;
      eint = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
      cpu_cfsDFT->size[0] = cpu_cfs1->size[0];
      cpu_cfsDFT->size[1] = cpu_cfs1->size[1];
      emxEnsureCapacity_creal32_T(cpu_cfsDFT, eint, &ab_emlrtRTEI);
      offsetH = cpu_cfs1->size[0] * cpu_cfs1->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1262<<<grid, block>>>(gpu_cfs1, offsetH, gpu_cfsDFT);
      }

      cpu_lidx = cpu_cfsDFT->size[1];
      g_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
        cpu_cfsDFT->size[0], 1, CUFFT_C2C, cpu_cfsDFT->size[0]);
      cufftExecC2C(g_fftPlanHandle, (cufftComplex *)&gpu_cfsDFT.data[0],
                   (cufftComplex *)&gpu_cfsDFT.data[0], CUFFT_FORWARD);
    } else {
      cpu_lidx = cpu_cfs1->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_cfs1->size[itime]);
      }

      cufftHandle h_fftPlanHandle;
      eint = cpu_cfsDFT->size[0] * cpu_cfsDFT->size[1];
      cpu_cfsDFT->size[0] = static_cast<int32_T>(xSize[0]);
      cpu_cfsDFT->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_creal32_T(cpu_cfsDFT, eint, &r_emlrtRTEI);
      h_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, cpu_cfs1->
        size[0], 1, CUFFT_R2C, cpu_cfs1->size[0]);
      gpuEmxEnsureCapacity_creal32_T(cpu_cfsDFT, &gpu_cfsDFT, true);
      cufftExecR2C(h_fftPlanHandle, (cufftReal *)&gpu_cfs1.data[0],
                   (cufftComplex *)&gpu_cfsDFT.data[0]);
      cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
        (xSize[1]) + 1) / 2.0) - 2;
      if ((cpu_cfsDFT->size[0] == 1) || (cpu_cfsDFT->size[1] == 1)) {
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1263<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
            cpu_lidx, gpu_cfsDFT);
        }
      } else {
        offsetH = cpu_cfsDFT->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx, offsetH), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1264<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
            offsetH, cpu_lidx, gpu_cfsDFT, cpu_cfsDFT->size[0U]);
        }
      }
    }
  }

  emxInit_real_T(&cpu_Fmat, 2, &xd_emlrtRTEI, true);
  eint = cpu_Fmat->size[0] * cpu_Fmat->size[1];
  cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
  cpu_Fmat->size[1] = cpu_omega->size[1];
  emxEnsureCapacity_real_T(cpu_Fmat, eint, &bb_emlrtRTEI);
  nrefine = cpu_omega->size[1];
  offsetH = cpu_fb_Scales->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(nrefine - 1, offsetH), &grid, &block,
    2147483647U);
  if (b_fx_data_outdatedOnCpu) {
    gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
  }

  gpuEmxEnsureCapacity_real_T(cpu_Fmat, &gpu_Fmat, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel46<<<grid, block>>>(gpu_fb_Scales, gpu_omega, offsetH, nrefine
      - 1, gpu_Fmat, cpu_Fmat->size[0U]);
  }

  emxFree_real_T(&cpu_omega);
  emxInit_creal32_T(&d_cpu_x, 2, &cb_emlrtRTEI, true);
  if ((cpu_Fmat->size[0] == cpu_cfsDFT->size[0]) && (cpu_Fmat->size[1] ==
       cpu_cfsDFT->size[1])) {
    eint = d_cpu_x->size[0] * d_cpu_x->size[1];
    d_cpu_x->size[0] = cpu_Fmat->size[0];
    d_cpu_x->size[1] = cpu_Fmat->size[1];
    emxEnsureCapacity_creal32_T(d_cpu_x, eint, &cb_emlrtRTEI);
    eint = cpu_Fmat->size[0] * cpu_Fmat->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(d_cpu_x, &d_gpu_x, true);
    x_data_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel47<<<grid, block>>>(gpu_cfsDFT, gpu_Fmat, eint, d_gpu_x);
    }

    a_data_outdatedOnGpu = false;
  } else {
    gpuEmxMemcpyGpuToCpu_real_T(cpu_Fmat, &gpu_Fmat);
    gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfsDFT, &gpu_cfsDFT);
    binary_expand_op_5(d_cpu_x, cpu_Fmat, cpu_cfsDFT);
    a_data_outdatedOnGpu = true;
    x_data_outdatedOnGpu = true;
  }

  emxFree_real_T(&cpu_Fmat);
  emxFree_creal32_T(&cpu_cfsDFT);
  emxInit_creal32_T(&g_cpu_y, 2, &yd_emlrtRTEI, true);
  if ((d_cpu_x->size[0] == 0) || (d_cpu_x->size[1] == 0)) {
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(d_cpu_x->size[itime]);
    }

    xSize[1] = static_cast<uint32_T>(d_cpu_x->size[1]);
    eint = g_cpu_y->size[0] * g_cpu_y->size[1];
    g_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    g_cpu_y->size[1] = d_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(g_cpu_y, eint, &db_emlrtRTEI);
    eint = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(g_cpu_y, &d_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel48<<<grid, block>>>(eint, d_gpu_y);
    }
  } else {
    cufftHandle j_fftPlanHandle;
    cpu_lidx = d_cpu_x->size[1];
    j_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, d_cpu_x->size[0],
      1, CUFFT_C2C, d_cpu_x->size[0]);
    if (x_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(d_cpu_x, &d_gpu_x, !a_data_outdatedOnGpu);
    }

    if (a_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&d_gpu_x, d_cpu_x);
    }

    cufftExecC2C(j_fftPlanHandle, (cufftComplex *)&d_gpu_x.data[0],
                 (cufftComplex *)&d_gpu_x.data[0], CUFFT_INVERSE);
    eint = g_cpu_y->size[0] * g_cpu_y->size[1];
    g_cpu_y->size[0] = d_cpu_x->size[0];
    g_cpu_y->size[1] = d_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(g_cpu_y, eint, &db_emlrtRTEI);
    ec_wtcc_kernel1258<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_cfsposdft,
      d_cpu_x->size[1U]);
    eint = d_cpu_x->size[0] * d_cpu_x->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(g_cpu_y, &d_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1259<<<grid, block>>>(c_gpu_cfsposdft, d_gpu_x, eint,
        d_gpu_y);
    }
  }

  emxFree_creal32_T(&d_cpu_x);
  emxInit_real32_T(&cpu_smooth, 2, &ae_emlrtRTEI, true);
  eint = cpu_smooth->size[0] * cpu_smooth->size[1];
  cpu_smooth->size[0] = g_cpu_y->size[0];
  cpu_smooth->size[1] = g_cpu_y->size[1];
  emxEnsureCapacity_real32_T(cpu_smooth, eint, &eb_emlrtRTEI);
  eint = g_cpu_y->size[0] * g_cpu_y->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(cpu_smooth, &gpu_smooth, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel49<<<grid, block>>>(d_gpu_y, eint, gpu_smooth);
  }

  emxFree_creal32_T(&g_cpu_y);
  ix = cpu_cfs1->size[1];
  a = 1.0 / halfh;
  emxInit_real32_T(&cpu_a, 1, &fb_emlrtRTEI, true);
  emxInit_real32_T(&cpu_c, 1, &ce_emlrtRTEI, true);
  emxInit_real32_T(&cpu_expanded, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&h_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_expanded, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&i_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv8, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv9, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&j_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv10, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_rows, 2, &jb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_smooth, 1, &ib_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_smooth, 2, &lb_emlrtRTEI, true);
  if ((cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
    eint = cpu_a->size[0];
    cpu_a->size[0] = cpu_cfs1->size[1];
    emxEnsureCapacity_real32_T(cpu_a, eint, &fb_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_a, &gpu_a, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel50<<<grid, block>>>(gpu_smooth, ix - 1, gpu_a,
        cpu_smooth->size[0U]);
    }

    eint = cpu_c->size[0];
    cpu_c->size[0] = cpu_a->size[0];
    emxEnsureCapacity_real32_T(cpu_c, eint, &hb_emlrtRTEI);
    eint = cpu_a->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel51<<<grid, block>>>(eint, gpu_c);
    }

    if (cpu_a->size[0] != 0) {
      if (cpu_a->size[0] == 1) {
        eint = cpu_c->size[0];
        cpu_c->size[0] = 1;
        emxEnsureCapacity_real32_T(cpu_c, eint, &hb_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
        ec_wtcc_kernel52<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a, gpu_a,
          gpu_c);
      } else {
        itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
          (cpu_a->size[0])));
        b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(cpu_a->size[0]) + static_cast<uint32_T>(itime))
          - 1.0) / static_cast<real_T>(itime)));
        threadDims[0] = static_cast<int8_T>(itime);
        x_size_idx_1 = cpu_a->size[0];
        if (cpu_a->size[0] > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = cpu_a->size[0] + 1;
        }

        eint = b_cpu_expanded->size[0];
        b_cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_real32_T(b_cpu_expanded, eint, &jb_emlrtRTEI);
        eint = cpu_a->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(b_cpu_expanded, &ee_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1245<<<grid, block>>>(eint, ee_gpu_expanded);
        }

        n = cpu_a->size[0];
        eint = i_cpu_y->size[0] * i_cpu_y->size[1];
        i_cpu_y->size[0] = 1;
        i_cpu_y->size[1] = cpu_a->size[0];
        emxEnsureCapacity_int32_T(i_cpu_y, eint, &kb_emlrtRTEI);
        i_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          i_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv9->size[0];
        cpu_iv9->size[0] = i_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv9, eint, &jb_emlrtRTEI);
        eint = i_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(i_cpu_y, &dh_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv9, &gpu_iv9, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&dh_gpu_y, i_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1246<<<grid, block>>>(dh_gpu_y, eint, gpu_iv9);
        }

        omega_tmp2[0] = cpu_iv9->size[0];
        mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1247<<<grid, block>>>(gpu_a, gpu_iv9, omega_tmp2[0] - 1,
            ee_gpu_expanded);
        }

        eint = cpu_c->size[0];
        cpu_c->size[0] = cpu_a->size[0];
        emxEnsureCapacity_real32_T(cpu_c, eint, &jb_emlrtRTEI);
        mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
          static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
          (static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
        gpuEmxEnsureCapacity_real32_T(cpu_c, &gpu_c, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1248<<<grid, block>>>(a, ee_gpu_expanded, x_size_idx_1 -
            1, gpu_c);
        }
      }
    }

    eint = cpu_cfs1->size[0] * cpu_cfs1->size[1];
    cpu_cfs1->size[0] = 1;
    cpu_cfs1->size[1] = cpu_c->size[0];
    emxEnsureCapacity_real32_T(cpu_cfs1, eint, &gb_emlrtRTEI);
    offsetH = cpu_c->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel53<<<grid, block>>>(gpu_c, offsetH, gpu_cfs1, cpu_cfs1->
        size[0U]);
    }
  } else {
    eint = cpu_cfs1->size[0] * cpu_cfs1->size[1];
    cpu_cfs1->size[0] = cpu_smooth->size[0];
    cpu_cfs1->size[1] = ix;
    emxEnsureCapacity_real32_T(cpu_cfs1, eint, &gb_emlrtRTEI);
    offsetH = cpu_smooth->size[0] * ix - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1249<<<grid, block>>>(offsetH, gpu_cfs1);
    }

    if ((cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
      if ((cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
        eint = b_cpu_smooth->size[0];
        b_cpu_smooth->size[0] = 1;
        emxEnsureCapacity_real32_T(b_cpu_smooth, eint, &ib_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(b_cpu_smooth, &g_gpu_smooth, true);
        ec_wtcc_kernel1250<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a,
          gpu_smooth, g_gpu_smooth);
        eint = cpu_cfs1->size[0] * cpu_cfs1->size[1];
        cpu_cfs1->size[0] = 1;
        cpu_cfs1->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_cfs1, eint, &gb_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
        ec_wtcc_kernel1251<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(g_gpu_smooth,
          gpu_cfs1);
      } else {
        itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
          (cpu_smooth->size[0])));
        cpu_lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(ix)));
        blockDims[0] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(cpu_smooth->size[0]) + static_cast<uint32_T>
          (itime)) - 1.0) / static_cast<real_T>(itime)));
        blockDims[1] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(ix) + static_cast<uint32_T>(cpu_lidx)) - 1.0) /
          static_cast<real_T>(cpu_lidx)));
        threadDims[0] = static_cast<int8_T>(itime);
        x_size_idx_1 = cpu_smooth->size[0];
        if (static_cast<int32_T>(halfh) > MAX_int32_T - cpu_smooth->size[0]) {
          nx = MAX_int32_T;
        } else {
          nx = cpu_smooth->size[0] + static_cast<int32_T>(halfh);
        }

        eint = cpu_expanded->size[0] * cpu_expanded->size[1];
        cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_real32_T(cpu_expanded, eint, &jb_emlrtRTEI);
        if (ix > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = ix + 1;
        }

        eint = cpu_expanded->size[0] * cpu_expanded->size[1];
        cpu_expanded->size[1] = nx - 1;
        emxEnsureCapacity_real32_T(cpu_expanded, eint, &jb_emlrtRTEI);
        offsetH = ((cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) * ix
          - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_expanded, &fe_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1252<<<grid, block>>>(offsetH, fe_gpu_expanded);
        }

        n = cpu_smooth->size[0];
        eint = h_cpu_y->size[0] * h_cpu_y->size[1];
        h_cpu_y->size[0] = 1;
        h_cpu_y->size[1] = cpu_smooth->size[0];
        emxEnsureCapacity_int32_T(h_cpu_y, eint, &kb_emlrtRTEI);
        h_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          h_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv8->size[0];
        cpu_iv8->size[0] = h_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv8, eint, &jb_emlrtRTEI);
        eint = h_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(h_cpu_y, &eh_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv8, &gpu_iv8, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&eh_gpu_y, h_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1253<<<grid, block>>>(static_cast<int32_T>(std::floor
            ((halfh - 1.0) / 2.0)), eh_gpu_y, eint, gpu_iv8);
        }

        eint = j_cpu_y->size[0] * j_cpu_y->size[1];
        j_cpu_y->size[0] = 1;
        j_cpu_y->size[1] = ix;
        emxEnsureCapacity_int32_T(j_cpu_y, eint, &kb_emlrtRTEI);
        j_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= ix - 2; k++) {
          itime++;
          j_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv10->size[0];
        cpu_iv10->size[0] = j_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv10, eint, &jb_emlrtRTEI);
        eint = j_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(j_cpu_y, &fh_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv10, &gpu_iv10, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&fh_gpu_y, j_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1254<<<grid, block>>>(fh_gpu_y, eint, gpu_iv10);
        }

        eint = c_cpu_smooth->size[0] * c_cpu_smooth->size[1];
        c_cpu_smooth->size[0] = cpu_smooth->size[0];
        c_cpu_smooth->size[1] = ix;
        emxEnsureCapacity_real32_T(c_cpu_smooth, eint, &lb_emlrtRTEI);
        offsetH = cpu_smooth->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(ix - 1, offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(c_cpu_smooth, &h_gpu_smooth, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1255<<<grid, block>>>(gpu_smooth, offsetH, ix - 1,
            h_gpu_smooth, c_cpu_smooth->size[0U], cpu_smooth->size[0U]);
        }

        xt_size[0] = cpu_iv8->size[0];
        xt_size[1] = cpu_iv10->size[0];
        mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] - 1),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1256<<<grid, block>>>(h_gpu_smooth, xt_size[0], gpu_iv10,
            gpu_iv8, xt_size[0] - 1, xt_size[1] - 1, fe_gpu_expanded,
            cpu_expanded->size[0U]);
        }

        n = static_cast<int32_T>(halfh);
        eint = cpu_rows->size[0] * cpu_rows->size[1];
        cpu_rows->size[0] = 1;
        cpu_rows->size[1] = static_cast<int32_T>(halfh);
        emxEnsureCapacity_int32_T(cpu_rows, eint, &kb_emlrtRTEI);
        cpu_rows->data[0] = 0;
        itime = 0;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          cpu_rows->data[k + 1] = itime;
        }

        eint = cpu_cfs1->size[0] * cpu_cfs1->size[1];
        cpu_cfs1->size[0] = cpu_smooth->size[0];
        cpu_cfs1->size[1] = ix;
        emxEnsureCapacity_real32_T(cpu_cfs1, eint, &jb_emlrtRTEI);
        mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1), dim3
          (blockDims[0], blockDims[1], 1U), dim3(static_cast<uint32_T>
          (threadDims[0]), static_cast<uint32_T>(static_cast<int8_T>(cpu_lidx)),
          1U), &grid, &block);
        gpuEmxEnsureCapacity_int32_T(cpu_rows, &pd_gpu_rows, false);
        gpuEmxEnsureCapacity_real32_T(cpu_cfs1, &gpu_cfs1, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&pd_gpu_rows, cpu_rows);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1257<<<grid, block>>>(a, fe_gpu_expanded, pd_gpu_rows,
            halfh, x_size_idx_1 - 1, ix - 1, gpu_cfs1, cpu_expanded->size[0U],
            cpu_cfs1->size[0U]);
        }
      }
    }
  }

  emxFree_real32_T(&c_cpu_smooth);
  emxFree_real32_T(&b_cpu_smooth);
  emxFree_int32_T(&cpu_rows);
  emxFree_int32_T(&cpu_iv10);
  emxFree_int32_T(&j_cpu_y);
  emxFree_int32_T(&cpu_iv9);
  emxFree_int32_T(&cpu_iv8);
  emxFree_int32_T(&i_cpu_y);
  emxFree_real32_T(&b_cpu_expanded);
  emxFree_int32_T(&h_cpu_y);
  emxFree_real32_T(&cpu_expanded);
  emxFree_real32_T(&cpu_c);
  emxFree_real32_T(&cpu_a);
  emxFree_real32_T(&cpu_smooth);
  nx = b_cpu_cfspos->size[0] * b_cpu_cfspos->size[1];
  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(b_cpu_cfspos->size[itime]);
  }

  emxInit_real32_T(&k_cpu_y, 2, &be_emlrtRTEI, true);
  eint = k_cpu_y->size[0] * k_cpu_y->size[1];
  k_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
  k_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(k_cpu_y, eint, &n_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  if (c_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_creal32_T(b_cpu_cfspos, &b_gpu_cfspos,
      !wav_outdatedOnCpu);
  }

  gpuEmxEnsureCapacity_real32_T(k_cpu_y, &e_gpu_y, true);
  if (wav_outdatedOnCpu) {
    gpuEmxMemcpyCpuToGpu_creal32_T(&b_gpu_cfspos, b_cpu_cfspos);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel54<<<grid, block>>>(b_gpu_cfspos, nx - 1, e_gpu_y);
  }

  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(k_cpu_y->size[itime]);
  }

  emxInit_real32_T(&cpu_cfs2, 2, &mb_emlrtRTEI, true);
  eint = cpu_cfs2->size[0] * cpu_cfs2->size[1];
  cpu_cfs2->size[0] = static_cast<int32_T>(xSize[0]);
  cpu_cfs2->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(cpu_cfs2, eint, &e_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
    static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel55<<<grid, block>>>(e_gpu_y, static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1, gpu_cfs2);
  }

  emxFree_real32_T(&k_cpu_y);
  fa = std::frexp(static_cast<real_T>(cpu_cfs2->size[1]), &c_eint);
  if (fa == 0.5) {
    c_eint--;
  }

  r = rt_powd_snf(2.0, static_cast<real_T>(c_eint));
  nrefine = static_cast<int32_T>(std::trunc(r / 2.0));
  emxInit_int32_T(&c_cpu_omega_tmp1, 2, &w_emlrtRTEI, true);
  if (nrefine < 1) {
    c_cpu_omega_tmp1->size[0] = 1;
    c_cpu_omega_tmp1->size[1] = 0;
  } else {
    eint = c_cpu_omega_tmp1->size[0] * c_cpu_omega_tmp1->size[1];
    c_cpu_omega_tmp1->size[0] = 1;
    c_cpu_omega_tmp1->size[1] = nrefine;
    emxEnsureCapacity_int32_T(c_cpu_omega_tmp1, eint, &w_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_int32_T(c_cpu_omega_tmp1, &c_gpu_omega_tmp1, true);
    e_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1244<<<grid, block>>>(nrefine - 1, c_gpu_omega_tmp1);
    }
  }

  emxInit_real_T(&c_cpu_omega_tmp2, 2, &x_emlrtRTEI, true);
  eint = c_cpu_omega_tmp2->size[0] * c_cpu_omega_tmp2->size[1];
  c_cpu_omega_tmp2->size[0] = 1;
  c_cpu_omega_tmp2->size[1] = c_cpu_omega_tmp1->size[1];
  emxEnsureCapacity_real_T(c_cpu_omega_tmp2, eint, &x_emlrtRTEI);
  eint = c_cpu_omega_tmp1->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (e_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_int32_T(c_cpu_omega_tmp1, &c_gpu_omega_tmp1, true);
  }

  gpuEmxEnsureCapacity_real_T(c_cpu_omega_tmp2, &c_gpu_omega_tmp2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel56<<<grid, block>>>(6.2831853071795862 / r, c_gpu_omega_tmp1,
      eint, c_gpu_omega_tmp2);
  }

  emxFree_int32_T(&c_cpu_omega_tmp1);
  cpu_lidx = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
  if (cpu_lidx < 1) {
    nrefine = 1;
    pathlen = -1;
  } else {
    cpu_lidx--;
    nrefine = -1;
    pathlen = 0;
  }

  emxInit_real_T(&b_cpu_omega, 2, &y_emlrtRTEI, true);
  eint = b_cpu_omega->size[0] * b_cpu_omega->size[1];
  b_cpu_omega->size[0] = 1;
  b_cpu_omega->size[1] = (c_cpu_omega_tmp2->size[1] + div_s32(pathlen - cpu_lidx,
    nrefine)) + 2;
  emxEnsureCapacity_real_T(b_cpu_omega, eint, &y_emlrtRTEI);
  gpuEmxEnsureCapacity_real_T(b_cpu_omega, &b_gpu_omega, true);
  ec_wtcc_kernel57<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_omega);
  nx = c_cpu_omega_tmp2->size[1];
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel58<<<grid, block>>>(c_gpu_omega_tmp2, nx - 1, b_gpu_omega);
  }

  nx = div_s32(pathlen - cpu_lidx, nrefine);
  mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel59<<<grid, block>>>(nrefine, cpu_lidx, c_gpu_omega_tmp2, nx,
      b_gpu_omega, c_cpu_omega_tmp2->size[1U]);
  }

  emxFree_real_T(&c_cpu_omega_tmp2);
  emxInit_creal32_T(&b_cpu_cfsDFT, 2, &ab_emlrtRTEI, true);
  if ((cpu_cfs2->size[0] == 0) || (cpu_cfs2->size[1] == 0) ||
      (static_cast<int32_T>(r) == 0)) {
    eint = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
    b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
    b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
    emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, eint, &ab_emlrtRTEI);
    offsetH = cpu_cfs2->size[0] * static_cast<int32_T>(r) - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel60<<<grid, block>>>(offsetH, b_gpu_cfsDFT);
    }
  } else if (cpu_cfs2->size[1] != static_cast<int32_T>(r)) {
    cufftHandle m_fftPlanHandle;
    if (cpu_cfs2->size[1] < static_cast<int32_T>(r)) {
      eint = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
      b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
      b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, eint, &ab_emlrtRTEI);
      offsetH = cpu_cfs2->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
      a_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1239<<<grid, block>>>(offsetH, b_gpu_cfsDFT);
      }
    } else {
      eint = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
      b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
      b_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, eint, &r_emlrtRTEI);
      a_data_outdatedOnGpu = true;
    }

    cpu_lidx = cpu_cfs2->size[0];
    if (cpu_cfs2->size[1] > static_cast<int32_T>(r)) {
      pathlen = static_cast<int32_T>(r);
    } else {
      pathlen = cpu_cfs2->size[1];
    }

    mwGetLaunchParameters1D(computeNumIters(pathlen - 1, cpu_lidx - 1), &grid,
      &block, 2147483647U);
    if (a_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1240<<<grid, block>>>(gpu_cfs2, cpu_lidx - 1, pathlen - 1,
        b_gpu_cfsDFT, b_cpu_cfsDFT->size[0U], cpu_cfs2->size[0U]);
    }

    cpu_lidx = b_cpu_cfsDFT->size[1];
    m_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
      b_cpu_cfsDFT->size[0], 1, CUFFT_C2C, b_cpu_cfsDFT->size[0]);
    cufftExecC2C(m_fftPlanHandle, (cufftComplex *)&b_gpu_cfsDFT.data[0],
                 (cufftComplex *)&b_gpu_cfsDFT.data[0], CUFFT_FORWARD);
  } else {
    itime = cpu_cfs2->size[0] * cpu_cfs2->size[1];
    if (itime - (static_cast<int32_T>(static_cast<uint32_T>(itime) >> 1) << 1) ==
        1) {
      cufftHandle k_fftPlanHandle;
      eint = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
      b_cpu_cfsDFT->size[0] = cpu_cfs2->size[0];
      b_cpu_cfsDFT->size[1] = cpu_cfs2->size[1];
      emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, eint, &ab_emlrtRTEI);
      offsetH = cpu_cfs2->size[0] * cpu_cfs2->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1241<<<grid, block>>>(gpu_cfs2, offsetH, b_gpu_cfsDFT);
      }

      cpu_lidx = b_cpu_cfsDFT->size[1];
      k_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
        b_cpu_cfsDFT->size[0], 1, CUFFT_C2C, b_cpu_cfsDFT->size[0]);
      cufftExecC2C(k_fftPlanHandle, (cufftComplex *)&b_gpu_cfsDFT.data[0],
                   (cufftComplex *)&b_gpu_cfsDFT.data[0], CUFFT_FORWARD);
    } else {
      cpu_lidx = cpu_cfs2->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_cfs2->size[itime]);
      }

      cufftHandle l_fftPlanHandle;
      eint = b_cpu_cfsDFT->size[0] * b_cpu_cfsDFT->size[1];
      b_cpu_cfsDFT->size[0] = static_cast<int32_T>(xSize[0]);
      b_cpu_cfsDFT->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_creal32_T(b_cpu_cfsDFT, eint, &r_emlrtRTEI);
      l_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, cpu_cfs2->
        size[0], 1, CUFFT_R2C, cpu_cfs2->size[0]);
      gpuEmxEnsureCapacity_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT, true);
      cufftExecR2C(l_fftPlanHandle, (cufftReal *)&gpu_cfs2.data[0],
                   (cufftComplex *)&b_gpu_cfsDFT.data[0]);
      cpu_lidx = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
        (xSize[1]) + 1) / 2.0) - 2;
      if ((b_cpu_cfsDFT->size[0] == 1) || (b_cpu_cfsDFT->size[1] == 1)) {
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx), &grid, &block,
          2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1242<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
            cpu_lidx, b_gpu_cfsDFT);
        }
      } else {
        offsetH = b_cpu_cfsDFT->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx, offsetH), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1243<<<grid, block>>>(static_cast<int32_T>(xSize[1]),
            offsetH, cpu_lidx, b_gpu_cfsDFT, b_cpu_cfsDFT->size[0U]);
        }
      }
    }
  }

  emxInit_real_T(&b_cpu_Fmat, 2, &xd_emlrtRTEI, true);
  eint = b_cpu_Fmat->size[0] * b_cpu_Fmat->size[1];
  b_cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
  b_cpu_Fmat->size[1] = b_cpu_omega->size[1];
  emxEnsureCapacity_real_T(b_cpu_Fmat, eint, &bb_emlrtRTEI);
  cpu_lidx = b_cpu_omega->size[1];
  offsetH = cpu_fb_Scales->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, offsetH), &grid, &block,
    2147483647U);
  gpuEmxEnsureCapacity_real_T(b_cpu_Fmat, &b_gpu_Fmat, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel61<<<grid, block>>>(gpu_fb_Scales, b_gpu_omega, offsetH,
      cpu_lidx - 1, b_gpu_Fmat, b_cpu_Fmat->size[0U]);
  }

  emxFree_real_T(&b_cpu_omega);
  emxInit_creal32_T(&e_cpu_x, 2, &cb_emlrtRTEI, true);
  if ((b_cpu_Fmat->size[0] == b_cpu_cfsDFT->size[0]) && (b_cpu_Fmat->size[1] ==
       b_cpu_cfsDFT->size[1])) {
    eint = e_cpu_x->size[0] * e_cpu_x->size[1];
    e_cpu_x->size[0] = b_cpu_Fmat->size[0];
    e_cpu_x->size[1] = b_cpu_Fmat->size[1];
    emxEnsureCapacity_creal32_T(e_cpu_x, eint, &cb_emlrtRTEI);
    eint = b_cpu_Fmat->size[0] * b_cpu_Fmat->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(e_cpu_x, &e_gpu_x, true);
    x_data_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel62<<<grid, block>>>(b_gpu_cfsDFT, b_gpu_Fmat, eint, e_gpu_x);
    }

    a_data_outdatedOnGpu = false;
  } else {
    gpuEmxMemcpyGpuToCpu_real_T(b_cpu_Fmat, &b_gpu_Fmat);
    gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfsDFT, &b_gpu_cfsDFT);
    binary_expand_op_5(e_cpu_x, b_cpu_Fmat, b_cpu_cfsDFT);
    a_data_outdatedOnGpu = true;
    x_data_outdatedOnGpu = true;
  }

  emxFree_real_T(&b_cpu_Fmat);
  emxFree_creal32_T(&b_cpu_cfsDFT);
  emxInit_creal32_T(&l_cpu_y, 2, &yd_emlrtRTEI, true);
  if ((e_cpu_x->size[0] == 0) || (e_cpu_x->size[1] == 0)) {
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(e_cpu_x->size[itime]);
    }

    xSize[1] = static_cast<uint32_T>(e_cpu_x->size[1]);
    eint = l_cpu_y->size[0] * l_cpu_y->size[1];
    l_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    l_cpu_y->size[1] = e_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(l_cpu_y, eint, &db_emlrtRTEI);
    eint = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(l_cpu_y, &f_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel63<<<grid, block>>>(eint, f_gpu_y);
    }
  } else {
    cufftHandle n_fftPlanHandle;
    cpu_lidx = e_cpu_x->size[1];
    n_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, e_cpu_x->size[0],
      1, CUFFT_C2C, e_cpu_x->size[0]);
    if (x_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(e_cpu_x, &e_gpu_x, !a_data_outdatedOnGpu);
    }

    if (a_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&e_gpu_x, e_cpu_x);
    }

    cufftExecC2C(n_fftPlanHandle, (cufftComplex *)&e_gpu_x.data[0],
                 (cufftComplex *)&e_gpu_x.data[0], CUFFT_INVERSE);
    eint = l_cpu_y->size[0] * l_cpu_y->size[1];
    l_cpu_y->size[0] = e_cpu_x->size[0];
    l_cpu_y->size[1] = e_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(l_cpu_y, eint, &db_emlrtRTEI);
    ec_wtcc_kernel1237<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_cfsposdft,
      e_cpu_x->size[1U]);
    eint = e_cpu_x->size[0] * e_cpu_x->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(l_cpu_y, &f_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1238<<<grid, block>>>(c_gpu_cfsposdft, e_gpu_x, eint,
        f_gpu_y);
    }
  }

  emxFree_creal32_T(&e_cpu_x);
  emxInit_real32_T(&d_cpu_smooth, 2, &ae_emlrtRTEI, true);
  eint = d_cpu_smooth->size[0] * d_cpu_smooth->size[1];
  d_cpu_smooth->size[0] = l_cpu_y->size[0];
  d_cpu_smooth->size[1] = l_cpu_y->size[1];
  emxEnsureCapacity_real32_T(d_cpu_smooth, eint, &eb_emlrtRTEI);
  eint = l_cpu_y->size[0] * l_cpu_y->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(d_cpu_smooth, &b_gpu_smooth, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel64<<<grid, block>>>(f_gpu_y, eint, b_gpu_smooth);
  }

  emxFree_creal32_T(&l_cpu_y);
  ix = cpu_cfs2->size[1];
  a = 1.0 / halfh;
  emxInit_real32_T(&b_cpu_a, 1, &fb_emlrtRTEI, true);
  emxInit_real32_T(&b_cpu_c, 1, &ce_emlrtRTEI, true);
  emxInit_real32_T(&c_cpu_expanded, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&m_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_real32_T(&d_cpu_expanded, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&n_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv11, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv12, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&o_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv13, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_rows, 2, &jb_emlrtRTEI, true);
  emxInit_real32_T(&e_cpu_smooth, 1, &ib_emlrtRTEI, true);
  emxInit_real32_T(&f_cpu_smooth, 2, &lb_emlrtRTEI, true);
  if ((d_cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
    eint = b_cpu_a->size[0];
    b_cpu_a->size[0] = cpu_cfs2->size[1];
    emxEnsureCapacity_real32_T(b_cpu_a, eint, &fb_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_a, &b_gpu_a, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel65<<<grid, block>>>(b_gpu_smooth, ix - 1, b_gpu_a,
        d_cpu_smooth->size[0U]);
    }

    eint = b_cpu_c->size[0];
    b_cpu_c->size[0] = b_cpu_a->size[0];
    emxEnsureCapacity_real32_T(b_cpu_c, eint, &hb_emlrtRTEI);
    eint = b_cpu_a->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel66<<<grid, block>>>(eint, b_gpu_c);
    }

    if (b_cpu_a->size[0] != 0) {
      if (b_cpu_a->size[0] == 1) {
        eint = b_cpu_c->size[0];
        b_cpu_c->size[0] = 1;
        emxEnsureCapacity_real32_T(b_cpu_c, eint, &hb_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
        ec_wtcc_kernel67<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a, b_gpu_a,
          b_gpu_c);
      } else {
        itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
          (b_cpu_a->size[0])));
        b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(b_cpu_a->size[0]) + static_cast<uint32_T>(itime))
          - 1.0) / static_cast<real_T>(itime)));
        threadDims[0] = static_cast<int8_T>(itime);
        x_size_idx_1 = b_cpu_a->size[0];
        if (b_cpu_a->size[0] > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = b_cpu_a->size[0] + 1;
        }

        eint = d_cpu_expanded->size[0];
        d_cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_real32_T(d_cpu_expanded, eint, &jb_emlrtRTEI);
        eint = b_cpu_a->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(d_cpu_expanded, &ce_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1224<<<grid, block>>>(eint, ce_gpu_expanded);
        }

        n = b_cpu_a->size[0];
        eint = n_cpu_y->size[0] * n_cpu_y->size[1];
        n_cpu_y->size[0] = 1;
        n_cpu_y->size[1] = b_cpu_a->size[0];
        emxEnsureCapacity_int32_T(n_cpu_y, eint, &kb_emlrtRTEI);
        n_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          n_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv12->size[0];
        cpu_iv12->size[0] = n_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv12, eint, &jb_emlrtRTEI);
        eint = n_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(n_cpu_y, &ah_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv12, &gpu_iv12, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&ah_gpu_y, n_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1225<<<grid, block>>>(ah_gpu_y, eint, gpu_iv12);
        }

        omega_tmp2[0] = cpu_iv12->size[0];
        mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1226<<<grid, block>>>(b_gpu_a, gpu_iv12, omega_tmp2[0] -
            1, ce_gpu_expanded);
        }

        eint = b_cpu_c->size[0];
        b_cpu_c->size[0] = b_cpu_a->size[0];
        emxEnsureCapacity_real32_T(b_cpu_c, eint, &jb_emlrtRTEI);
        mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
          static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
          (static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
        gpuEmxEnsureCapacity_real32_T(b_cpu_c, &b_gpu_c, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1227<<<grid, block>>>(a, ce_gpu_expanded, x_size_idx_1 -
            1, b_gpu_c);
        }
      }
    }

    eint = cpu_cfs2->size[0] * cpu_cfs2->size[1];
    cpu_cfs2->size[0] = 1;
    cpu_cfs2->size[1] = b_cpu_c->size[0];
    emxEnsureCapacity_real32_T(cpu_cfs2, eint, &mb_emlrtRTEI);
    offsetH = b_cpu_c->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel68<<<grid, block>>>(b_gpu_c, offsetH, gpu_cfs2,
        cpu_cfs2->size[0U]);
    }
  } else {
    eint = cpu_cfs2->size[0] * cpu_cfs2->size[1];
    cpu_cfs2->size[0] = d_cpu_smooth->size[0];
    cpu_cfs2->size[1] = ix;
    emxEnsureCapacity_real32_T(cpu_cfs2, eint, &mb_emlrtRTEI);
    offsetH = d_cpu_smooth->size[0] * ix - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1228<<<grid, block>>>(offsetH, gpu_cfs2);
    }

    if ((d_cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
      if ((d_cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
        eint = e_cpu_smooth->size[0];
        e_cpu_smooth->size[0] = 1;
        emxEnsureCapacity_real32_T(e_cpu_smooth, eint, &ib_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(e_cpu_smooth, &e_gpu_smooth, true);
        ec_wtcc_kernel1229<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(a,
          b_gpu_smooth, e_gpu_smooth);
        eint = cpu_cfs2->size[0] * cpu_cfs2->size[1];
        cpu_cfs2->size[0] = 1;
        cpu_cfs2->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_cfs2, eint, &mb_emlrtRTEI);
        gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
        ec_wtcc_kernel1230<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(e_gpu_smooth,
          gpu_cfs2);
      } else {
        itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
          (d_cpu_smooth->size[0])));
        cpu_lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(ix)));
        blockDims[0] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(d_cpu_smooth->size[0]) + static_cast<uint32_T>
          (itime)) - 1.0) / static_cast<real_T>(itime)));
        blockDims[1] = static_cast<uint32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(ix) + static_cast<uint32_T>(cpu_lidx)) - 1.0) /
          static_cast<real_T>(cpu_lidx)));
        threadDims[0] = static_cast<int8_T>(itime);
        x_size_idx_1 = d_cpu_smooth->size[0];
        if (static_cast<int32_T>(halfh) > MAX_int32_T - d_cpu_smooth->size[0]) {
          nx = MAX_int32_T;
        } else {
          nx = d_cpu_smooth->size[0] + static_cast<int32_T>(halfh);
        }

        eint = c_cpu_expanded->size[0] * c_cpu_expanded->size[1];
        c_cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_real32_T(c_cpu_expanded, eint, &jb_emlrtRTEI);
        if (ix > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = ix + 1;
        }

        eint = c_cpu_expanded->size[0] * c_cpu_expanded->size[1];
        c_cpu_expanded->size[1] = nx - 1;
        emxEnsureCapacity_real32_T(c_cpu_expanded, eint, &jb_emlrtRTEI);
        offsetH = ((d_cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) *
          ix - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(c_cpu_expanded, &de_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1231<<<grid, block>>>(offsetH, de_gpu_expanded);
        }

        n = d_cpu_smooth->size[0];
        eint = m_cpu_y->size[0] * m_cpu_y->size[1];
        m_cpu_y->size[0] = 1;
        m_cpu_y->size[1] = d_cpu_smooth->size[0];
        emxEnsureCapacity_int32_T(m_cpu_y, eint, &kb_emlrtRTEI);
        m_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          m_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv11->size[0];
        cpu_iv11->size[0] = m_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv11, eint, &jb_emlrtRTEI);
        eint = m_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(m_cpu_y, &bh_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv11, &gpu_iv11, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&bh_gpu_y, m_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1232<<<grid, block>>>(static_cast<int32_T>(std::floor
            ((halfh - 1.0) / 2.0)), bh_gpu_y, eint, gpu_iv11);
        }

        eint = o_cpu_y->size[0] * o_cpu_y->size[1];
        o_cpu_y->size[0] = 1;
        o_cpu_y->size[1] = ix;
        emxEnsureCapacity_int32_T(o_cpu_y, eint, &kb_emlrtRTEI);
        o_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= ix - 2; k++) {
          itime++;
          o_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv13->size[0];
        cpu_iv13->size[0] = o_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv13, eint, &jb_emlrtRTEI);
        eint = o_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(o_cpu_y, &ch_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv13, &gpu_iv13, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&ch_gpu_y, o_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1233<<<grid, block>>>(ch_gpu_y, eint, gpu_iv13);
        }

        eint = f_cpu_smooth->size[0] * f_cpu_smooth->size[1];
        f_cpu_smooth->size[0] = d_cpu_smooth->size[0];
        f_cpu_smooth->size[1] = ix;
        emxEnsureCapacity_real32_T(f_cpu_smooth, eint, &lb_emlrtRTEI);
        offsetH = d_cpu_smooth->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(ix - 1, offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(f_cpu_smooth, &f_gpu_smooth, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1234<<<grid, block>>>(b_gpu_smooth, offsetH, ix - 1,
            f_gpu_smooth, f_cpu_smooth->size[0U], d_cpu_smooth->size[0U]);
        }

        xt_size[0] = cpu_iv11->size[0];
        xt_size[1] = cpu_iv13->size[0];
        mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] - 1),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1235<<<grid, block>>>(f_gpu_smooth, xt_size[0], gpu_iv13,
            gpu_iv11, xt_size[0] - 1, xt_size[1] - 1, de_gpu_expanded,
            c_cpu_expanded->size[0U]);
        }

        n = static_cast<int32_T>(halfh);
        eint = b_cpu_rows->size[0] * b_cpu_rows->size[1];
        b_cpu_rows->size[0] = 1;
        b_cpu_rows->size[1] = static_cast<int32_T>(halfh);
        emxEnsureCapacity_int32_T(b_cpu_rows, eint, &kb_emlrtRTEI);
        b_cpu_rows->data[0] = 0;
        itime = 0;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          b_cpu_rows->data[k + 1] = itime;
        }

        eint = cpu_cfs2->size[0] * cpu_cfs2->size[1];
        cpu_cfs2->size[0] = d_cpu_smooth->size[0];
        cpu_cfs2->size[1] = ix;
        emxEnsureCapacity_real32_T(cpu_cfs2, eint, &jb_emlrtRTEI);
        mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1), dim3
          (blockDims[0], blockDims[1], 1U), dim3(static_cast<uint32_T>
          (threadDims[0]), static_cast<uint32_T>(static_cast<int8_T>(cpu_lidx)),
          1U), &grid, &block);
        gpuEmxEnsureCapacity_int32_T(b_cpu_rows, &od_gpu_rows, false);
        gpuEmxEnsureCapacity_real32_T(cpu_cfs2, &gpu_cfs2, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&od_gpu_rows, b_cpu_rows);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1236<<<grid, block>>>(a, de_gpu_expanded, od_gpu_rows,
            halfh, x_size_idx_1 - 1, ix - 1, gpu_cfs2, c_cpu_expanded->size[0U],
            cpu_cfs2->size[0U]);
        }
      }
    }
  }

  emxFree_real32_T(&f_cpu_smooth);
  emxFree_real32_T(&e_cpu_smooth);
  emxFree_int32_T(&b_cpu_rows);
  emxFree_int32_T(&cpu_iv13);
  emxFree_int32_T(&o_cpu_y);
  emxFree_int32_T(&cpu_iv12);
  emxFree_int32_T(&cpu_iv11);
  emxFree_int32_T(&n_cpu_y);
  emxFree_real32_T(&d_cpu_expanded);
  emxFree_int32_T(&m_cpu_y);
  emxFree_real32_T(&c_cpu_expanded);
  emxFree_real32_T(&b_cpu_c);
  emxFree_real32_T(&b_cpu_a);
  emxFree_real32_T(&d_cpu_smooth);
  emxInit_creal32_T(&cpu_crossCFS, 2, &nb_emlrtRTEI, true);
  if ((cpu_cfspos->size[0] == b_cpu_cfspos->size[0]) && (cpu_cfspos->size[1] ==
       b_cpu_cfspos->size[1])) {
    eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
    cpu_crossCFS->size[0] = cpu_cfspos->size[0];
    cpu_crossCFS->size[1] = cpu_cfspos->size[1];
    emxEnsureCapacity_creal32_T(cpu_crossCFS, eint, &nb_emlrtRTEI);
    eint = cpu_cfspos->size[0] * cpu_cfspos->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel69<<<grid, block>>>(gpu_cfspos, b_gpu_cfspos, eint,
        gpu_crossCFS);
    }

    x_data_outdatedOnGpu = false;
  } else {
    if (y_needsGpuEnsureCapacity) {
      gpuEmxMemcpyGpuToCpu_creal32_T(cpu_cfspos, &gpu_cfspos);
    }

    if (fx_data_outdatedOnCpu) {
      gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_cfspos, &b_gpu_cfspos);
    }

    binary_expand_op_6(cpu_crossCFS, cpu_cfspos, b_cpu_cfspos);
    x_data_outdatedOnGpu = true;
    interval_outdatedOnGpu = true;
  }

  emxFree_creal32_T(&b_cpu_cfspos);
  emxFree_creal32_T(&cpu_cfspos);
  fa = std::frexp(static_cast<real_T>(cpu_crossCFS->size[1]), &d_eint);
  if (fa == 0.5) {
    d_eint--;
  }

  r = rt_powd_snf(2.0, static_cast<real_T>(d_eint));
  nrefine = static_cast<int32_T>(std::trunc(r / 2.0));
  emxInit_int32_T(&d_cpu_omega_tmp1, 2, &w_emlrtRTEI, true);
  if (nrefine < 1) {
    d_cpu_omega_tmp1->size[0] = 1;
    d_cpu_omega_tmp1->size[1] = 0;
  } else {
    eint = d_cpu_omega_tmp1->size[0] * d_cpu_omega_tmp1->size[1];
    d_cpu_omega_tmp1->size[0] = 1;
    d_cpu_omega_tmp1->size[1] = nrefine;
    emxEnsureCapacity_int32_T(d_cpu_omega_tmp1, eint, &w_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_int32_T(d_cpu_omega_tmp1, &d_gpu_omega_tmp1, true);
    f_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1223<<<grid, block>>>(nrefine - 1, d_gpu_omega_tmp1);
    }
  }

  emxInit_real_T(&d_cpu_omega_tmp2, 2, &x_emlrtRTEI, true);
  eint = d_cpu_omega_tmp2->size[0] * d_cpu_omega_tmp2->size[1];
  d_cpu_omega_tmp2->size[0] = 1;
  d_cpu_omega_tmp2->size[1] = d_cpu_omega_tmp1->size[1];
  emxEnsureCapacity_real_T(d_cpu_omega_tmp2, eint, &x_emlrtRTEI);
  eint = d_cpu_omega_tmp1->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (f_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_int32_T(d_cpu_omega_tmp1, &d_gpu_omega_tmp1, true);
  }

  gpuEmxEnsureCapacity_real_T(d_cpu_omega_tmp2, &d_gpu_omega_tmp2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel70<<<grid, block>>>(6.2831853071795862 / r, d_gpu_omega_tmp1,
      eint, d_gpu_omega_tmp2);
  }

  emxFree_int32_T(&d_cpu_omega_tmp1);
  nrefine = static_cast<int32_T>(std::trunc((r - 1.0) / 2.0));
  if (nrefine < 1) {
    cpu_lidx = 0;
    nsubs = 1;
    ix = -1;
  } else {
    cpu_lidx = nrefine - 1;
    nsubs = -1;
    ix = 0;
  }

  emxInit_real_T(&c_cpu_omega, 2, &y_emlrtRTEI, true);
  eint = c_cpu_omega->size[0] * c_cpu_omega->size[1];
  c_cpu_omega->size[0] = 1;
  c_cpu_omega->size[1] = (d_cpu_omega_tmp2->size[1] + div_s32(ix - cpu_lidx,
    nsubs)) + 2;
  emxEnsureCapacity_real_T(c_cpu_omega, eint, &y_emlrtRTEI);
  gpuEmxEnsureCapacity_real_T(c_cpu_omega, &c_gpu_omega, true);
  ec_wtcc_kernel71<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_omega);
  nx = d_cpu_omega_tmp2->size[1];
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel72<<<grid, block>>>(d_gpu_omega_tmp2, nx - 1, c_gpu_omega);
  }

  nx = div_s32(ix - cpu_lidx, nsubs);
  mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel73<<<grid, block>>>(nsubs, cpu_lidx, d_gpu_omega_tmp2, nx,
      c_gpu_omega, d_cpu_omega_tmp2->size[1U]);
  }

  emxFree_real_T(&d_cpu_omega_tmp2);
  emxInit_creal32_T(&c_cpu_cfsDFT, 2, &ab_emlrtRTEI, true);
  if ((cpu_crossCFS->size[0] == 0) || (cpu_crossCFS->size[1] == 0) || (
       static_cast<int32_T>(r) == 0)) {
    eint = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
    c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
    c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
    emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, eint, &ab_emlrtRTEI);
    eint = cpu_crossCFS->size[0] * static_cast<int32_T>(r) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel74<<<grid, block>>>(eint, c_gpu_cfsDFT);
    }
  } else if (cpu_crossCFS->size[1] != static_cast<int32_T>(r)) {
    cufftHandle p_fftPlanHandle;
    if (cpu_crossCFS->size[1] < static_cast<int32_T>(r)) {
      eint = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
      c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
      c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, eint, &ab_emlrtRTEI);
      eint = cpu_crossCFS->size[0] * static_cast<int32_T>(r) - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
      a_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1220<<<grid, block>>>(eint, c_gpu_cfsDFT);
      }
    } else {
      eint = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
      c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
      c_cpu_cfsDFT->size[1] = static_cast<int32_T>(r);
      emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, eint, &r_emlrtRTEI);
      a_data_outdatedOnGpu = true;
    }

    cpu_lidx = cpu_crossCFS->size[0];
    if (cpu_crossCFS->size[1] > static_cast<int32_T>(r)) {
      pathlen = static_cast<int32_T>(r);
    } else {
      pathlen = cpu_crossCFS->size[1];
    }

    mwGetLaunchParameters1D(computeNumIters(pathlen - 1, cpu_lidx - 1), &grid,
      &block, 2147483647U);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
        !x_data_outdatedOnGpu);
    }

    if (a_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
    }

    if (x_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1221<<<grid, block>>>(gpu_crossCFS, cpu_lidx - 1, pathlen -
        1, c_gpu_cfsDFT, c_cpu_cfsDFT->size[0U], cpu_crossCFS->size[0U]);
    }

    cpu_lidx = c_cpu_cfsDFT->size[1];
    p_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
      c_cpu_cfsDFT->size[0], 1, CUFFT_C2C, c_cpu_cfsDFT->size[0]);
    cufftExecC2C(p_fftPlanHandle, (cufftComplex *)&c_gpu_cfsDFT.data[0],
                 (cufftComplex *)&c_gpu_cfsDFT.data[0], CUFFT_FORWARD);
  } else {
    cufftHandle o_fftPlanHandle;
    cpu_lidx = cpu_crossCFS->size[1];
    o_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx,
      cpu_crossCFS->size[0], 1, CUFFT_C2C, cpu_crossCFS->size[0]);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
        !x_data_outdatedOnGpu);
    }

    if (x_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
    }

    cufftExecC2C(o_fftPlanHandle, (cufftComplex *)&gpu_crossCFS.data[0],
                 (cufftComplex *)&gpu_crossCFS.data[0], CUFFT_FORWARD);
    eint = c_cpu_cfsDFT->size[0] * c_cpu_cfsDFT->size[1];
    c_cpu_cfsDFT->size[0] = cpu_crossCFS->size[0];
    c_cpu_cfsDFT->size[1] = cpu_crossCFS->size[1];
    emxEnsureCapacity_creal32_T(c_cpu_cfsDFT, eint, &ab_emlrtRTEI);
    eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1222<<<grid, block>>>(gpu_crossCFS, eint, c_gpu_cfsDFT);
    }
  }

  emxInit_real_T(&c_cpu_Fmat, 2, &xd_emlrtRTEI, true);
  eint = c_cpu_Fmat->size[0] * c_cpu_Fmat->size[1];
  c_cpu_Fmat->size[0] = cpu_fb_Scales->size[1];
  c_cpu_Fmat->size[1] = c_cpu_omega->size[1];
  emxEnsureCapacity_real_T(c_cpu_Fmat, eint, &bb_emlrtRTEI);
  cpu_lidx = c_cpu_omega->size[1];
  offsetH = cpu_fb_Scales->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, offsetH), &grid, &block,
    2147483647U);
  gpuEmxEnsureCapacity_real_T(c_cpu_Fmat, &c_gpu_Fmat, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel75<<<grid, block>>>(gpu_fb_Scales, c_gpu_omega, offsetH,
      cpu_lidx - 1, c_gpu_Fmat, c_cpu_Fmat->size[0U]);
  }

  emxFree_real_T(&c_cpu_omega);
  emxFree_real_T(&cpu_fb_Scales);
  emxInit_creal32_T(&f_cpu_x, 2, &ob_emlrtRTEI, true);
  if ((c_cpu_Fmat->size[0] == c_cpu_cfsDFT->size[0]) && (c_cpu_Fmat->size[1] ==
       c_cpu_cfsDFT->size[1])) {
    eint = f_cpu_x->size[0] * f_cpu_x->size[1];
    f_cpu_x->size[0] = c_cpu_Fmat->size[0];
    f_cpu_x->size[1] = c_cpu_Fmat->size[1];
    emxEnsureCapacity_creal32_T(f_cpu_x, eint, &ob_emlrtRTEI);
    eint = c_cpu_Fmat->size[0] * c_cpu_Fmat->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(f_cpu_x, &f_gpu_x, true);
    x_data_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel76<<<grid, block>>>(c_gpu_cfsDFT, c_gpu_Fmat, eint, f_gpu_x);
    }

    a_data_outdatedOnGpu = false;
  } else {
    gpuEmxMemcpyGpuToCpu_real_T(c_cpu_Fmat, &c_gpu_Fmat);
    gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_cfsDFT, &c_gpu_cfsDFT);
    binary_expand_op_5(f_cpu_x, c_cpu_Fmat, c_cpu_cfsDFT);
    a_data_outdatedOnGpu = true;
    x_data_outdatedOnGpu = true;
  }

  emxFree_real_T(&c_cpu_Fmat);
  emxFree_creal32_T(&c_cpu_cfsDFT);
  emxInit_creal32_T(&g_cpu_smooth, 2, &ae_emlrtRTEI, true);
  if ((f_cpu_x->size[0] == 0) || (f_cpu_x->size[1] == 0)) {
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(f_cpu_x->size[itime]);
    }

    xSize[1] = static_cast<uint32_T>(f_cpu_x->size[1]);
    eint = g_cpu_smooth->size[0] * g_cpu_smooth->size[1];
    g_cpu_smooth->size[0] = static_cast<int32_T>(xSize[0]);
    g_cpu_smooth->size[1] = f_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(g_cpu_smooth, eint, &pb_emlrtRTEI);
    eint = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(g_cpu_smooth, &c_gpu_smooth, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel77<<<grid, block>>>(eint, c_gpu_smooth);
    }
  } else {
    cufftHandle q_fftPlanHandle;
    cpu_lidx = f_cpu_x->size[1];
    q_fftPlanHandle = acquireCUFFTPlan(1, &cpu_lidx, &cpu_lidx, f_cpu_x->size[0],
      1, CUFFT_C2C, f_cpu_x->size[0]);
    if (x_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal32_T(f_cpu_x, &f_gpu_x, !a_data_outdatedOnGpu);
    }

    if (a_data_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_creal32_T(&f_gpu_x, f_cpu_x);
    }

    cufftExecC2C(q_fftPlanHandle, (cufftComplex *)&f_gpu_x.data[0],
                 (cufftComplex *)&f_gpu_x.data[0], CUFFT_INVERSE);
    eint = g_cpu_smooth->size[0] * g_cpu_smooth->size[1];
    g_cpu_smooth->size[0] = f_cpu_x->size[0];
    g_cpu_smooth->size[1] = f_cpu_x->size[1];
    emxEnsureCapacity_creal32_T(g_cpu_smooth, eint, &pb_emlrtRTEI);
    ec_wtcc_kernel1218<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(c_gpu_cfsposdft,
      f_cpu_x->size[1U]);
    eint = f_cpu_x->size[0] * f_cpu_x->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(g_cpu_smooth, &c_gpu_smooth, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1219<<<grid, block>>>(c_gpu_cfsposdft, f_gpu_x, eint,
        c_gpu_smooth);
    }
  }

  emxFree_creal32_T(&f_cpu_x);
  ix = cpu_crossCFS->size[1];
  a = 1.0 / halfh;
  emxInit_creal32_T(&c_cpu_a, 1, &fb_emlrtRTEI, true);
  emxInit_creal32_T(&c_cpu_c, 1, &ce_emlrtRTEI, true);
  emxInit_creal32_T(&e_cpu_expanded, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&p_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&f_cpu_expanded, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&q_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv15, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv16, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&r_cpu_y, 2, &jb_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv17, 1, &jb_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_rows, 2, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&cpu_newIm, 1, &jb_emlrtRTEI, true);
  emxInit_creal32_T(&smooth, 1, &ib_emlrtRTEI, true);
  emxInit_creal32_T(&h_cpu_smooth, 2, &lb_emlrtRTEI, true);
  if ((g_cpu_smooth->size[0] == 1) && (halfh == 1.0)) {
    eint = c_cpu_a->size[0];
    c_cpu_a->size[0] = cpu_crossCFS->size[1];
    emxEnsureCapacity_creal32_T(c_cpu_a, eint, &fb_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(c_cpu_a, &c_gpu_a, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel78<<<grid, block>>>(c_gpu_smooth, ix - 1, c_gpu_a,
        g_cpu_smooth->size[0U]);
    }

    eint = c_cpu_c->size[0];
    c_cpu_c->size[0] = c_cpu_a->size[0];
    emxEnsureCapacity_creal32_T(c_cpu_c, eint, &hb_emlrtRTEI);
    eint = c_cpu_a->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel79<<<grid, block>>>(eint, c_gpu_c);
    }

    if (c_cpu_a->size[0] != 0) {
      if (c_cpu_a->size[0] == 1) {
        eint = c_cpu_c->size[0];
        c_cpu_c->size[0] = 1;
        emxEnsureCapacity_creal32_T(c_cpu_c, eint, &hb_emlrtRTEI);
        gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_a, &c_gpu_a);
        cpu_cv_re = static_cast<real32_T>(a) * c_cpu_a->data[0].re;
        cv_im = static_cast<real32_T>(a) * c_cpu_a->data[0].im;
        gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
        ec_wtcc_kernel80<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_cv_re,
          cv_im, c_gpu_c);
      } else {
        itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
          (c_cpu_a->size[0])));
        b_blockDims[0] = static_cast<int32_T>(std::floor((static_cast<real_T>(
          static_cast<uint32_T>(c_cpu_a->size[0]) + static_cast<uint32_T>(itime))
          - 1.0) / static_cast<real_T>(itime)));
        threadDims[0] = static_cast<int8_T>(itime);
        x_size_idx_1 = c_cpu_a->size[0];
        if (c_cpu_a->size[0] > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = c_cpu_a->size[0] + 1;
        }

        eint = f_cpu_expanded->size[0];
        f_cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_creal32_T(f_cpu_expanded, eint, &jb_emlrtRTEI);
        eint = c_cpu_a->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(f_cpu_expanded, &ae_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1206<<<grid, block>>>(eint, ae_gpu_expanded);
        }

        n = c_cpu_a->size[0];
        eint = q_cpu_y->size[0] * q_cpu_y->size[1];
        q_cpu_y->size[0] = 1;
        q_cpu_y->size[1] = c_cpu_a->size[0];
        emxEnsureCapacity_int32_T(q_cpu_y, eint, &kb_emlrtRTEI);
        q_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          q_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv16->size[0];
        cpu_iv16->size[0] = q_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv16, eint, &jb_emlrtRTEI);
        eint = q_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(q_cpu_y, &wg_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv16, &gpu_iv16, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&wg_gpu_y, q_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1207<<<grid, block>>>(wg_gpu_y, eint, gpu_iv16);
        }

        omega_tmp2[0] = cpu_iv16->size[0];
        mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1208<<<grid, block>>>(c_gpu_a, gpu_iv16, omega_tmp2[0] -
            1, ae_gpu_expanded);
        }

        eint = c_cpu_c->size[0];
        c_cpu_c->size[0] = c_cpu_a->size[0];
        emxEnsureCapacity_creal32_T(c_cpu_c, eint, &jb_emlrtRTEI);
        mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
          static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3
          (static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
        gpuEmxEnsureCapacity_creal32_T(c_cpu_c, &c_gpu_c, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1209<<<grid, block>>>(ae_gpu_expanded, a, x_size_idx_1 -
            1, c_gpu_c);
        }
      }
    }

    eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
    cpu_crossCFS->size[0] = 1;
    cpu_crossCFS->size[1] = c_cpu_c->size[0];
    emxEnsureCapacity_creal32_T(cpu_crossCFS, eint, &qb_emlrtRTEI);
    offsetH = c_cpu_c->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel81<<<grid, block>>>(c_gpu_c, offsetH, gpu_crossCFS,
        cpu_crossCFS->size[0U]);
    }

    x_data_outdatedOnGpu = false;
  } else {
    eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
    cpu_crossCFS->size[0] = g_cpu_smooth->size[0];
    cpu_crossCFS->size[1] = ix;
    emxEnsureCapacity_creal32_T(cpu_crossCFS, eint, &qb_emlrtRTEI);
    offsetH = g_cpu_smooth->size[0] * ix - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1210<<<grid, block>>>(offsetH, gpu_crossCFS);
    }

    x_data_outdatedOnGpu = false;
    if ((g_cpu_smooth->size[0] != 0) && (ix != 0) && (!(halfh == 0.0))) {
      if ((g_cpu_smooth->size[0] == 1) && (ix == 1) && (halfh == 1.0)) {
        eint = smooth->size[0];
        smooth->size[0] = 1;
        emxEnsureCapacity_creal32_T(smooth, eint, &ib_emlrtRTEI);
        gpuEmxMemcpyGpuToCpu_creal32_T(g_cpu_smooth, &c_gpu_smooth);
        smooth->data[0].re = g_cpu_smooth->data[0].re * static_cast<real32_T>(a)
          - g_cpu_smooth->data[0].im * 0.0F;
        smooth->data[0].im = g_cpu_smooth->data[0].re * 0.0F +
          g_cpu_smooth->data[0].im * static_cast<real32_T>(a);
        eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
        cpu_crossCFS->size[0] = 1;
        cpu_crossCFS->size[1] = 1;
        emxEnsureCapacity_creal32_T(cpu_crossCFS, eint, &qb_emlrtRTEI);
        cpu_crossCFS->data[0] = smooth->data[0];
        x_data_outdatedOnGpu = true;
        interval_outdatedOnGpu = true;
      } else {
        x_size_idx_1 = g_cpu_smooth->size[0];
        if (static_cast<int32_T>(halfh) > MAX_int32_T - g_cpu_smooth->size[0]) {
          nx = MAX_int32_T;
        } else {
          nx = g_cpu_smooth->size[0] + static_cast<int32_T>(halfh);
        }

        eint = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
        e_cpu_expanded->size[0] = nx - 1;
        emxEnsureCapacity_creal32_T(e_cpu_expanded, eint, &jb_emlrtRTEI);
        if (ix > 2147483646) {
          nx = MAX_int32_T;
        } else {
          nx = ix + 1;
        }

        eint = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
        e_cpu_expanded->size[1] = nx - 1;
        emxEnsureCapacity_creal32_T(e_cpu_expanded, eint, &jb_emlrtRTEI);
        offsetH = ((g_cpu_smooth->size[0] + static_cast<int32_T>(halfh)) - 1) *
          ix - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(e_cpu_expanded, &be_gpu_expanded, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1211<<<grid, block>>>(offsetH, be_gpu_expanded);
        }

        n = g_cpu_smooth->size[0];
        eint = p_cpu_y->size[0] * p_cpu_y->size[1];
        p_cpu_y->size[0] = 1;
        p_cpu_y->size[1] = g_cpu_smooth->size[0];
        emxEnsureCapacity_int32_T(p_cpu_y, eint, &kb_emlrtRTEI);
        p_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          p_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv15->size[0];
        cpu_iv15->size[0] = p_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv15, eint, &jb_emlrtRTEI);
        eint = p_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(p_cpu_y, &xg_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv15, &gpu_iv15, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&xg_gpu_y, p_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1212<<<grid, block>>>(static_cast<int32_T>(std::floor
            ((halfh - 1.0) / 2.0)), xg_gpu_y, eint, gpu_iv15);
        }

        eint = r_cpu_y->size[0] * r_cpu_y->size[1];
        r_cpu_y->size[0] = 1;
        r_cpu_y->size[1] = ix;
        emxEnsureCapacity_int32_T(r_cpu_y, eint, &kb_emlrtRTEI);
        r_cpu_y->data[0] = 1;
        itime = 1;
        for (k = 0; k <= ix - 2; k++) {
          itime++;
          r_cpu_y->data[k + 1] = itime;
        }

        eint = cpu_iv17->size[0];
        cpu_iv17->size[0] = r_cpu_y->size[1];
        emxEnsureCapacity_int32_T(cpu_iv17, eint, &jb_emlrtRTEI);
        eint = r_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(r_cpu_y, &yg_gpu_y, false);
        gpuEmxEnsureCapacity_int32_T(cpu_iv17, &gpu_iv17, true);
        gpuEmxMemcpyCpuToGpu_int32_T(&yg_gpu_y, r_cpu_y);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1213<<<grid, block>>>(yg_gpu_y, eint, gpu_iv17);
        }

        eint = h_cpu_smooth->size[0] * h_cpu_smooth->size[1];
        h_cpu_smooth->size[0] = g_cpu_smooth->size[0];
        h_cpu_smooth->size[1] = ix;
        emxEnsureCapacity_creal32_T(h_cpu_smooth, eint, &lb_emlrtRTEI);
        offsetH = g_cpu_smooth->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(ix - 1, offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(h_cpu_smooth, &d_gpu_smooth, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1214<<<grid, block>>>(c_gpu_smooth, offsetH, ix - 1,
            d_gpu_smooth, h_cpu_smooth->size[0U], g_cpu_smooth->size[0U]);
        }

        xt_size[0] = cpu_iv15->size[0];
        xt_size[1] = cpu_iv17->size[0];
        mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] - 1),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1215<<<grid, block>>>(d_gpu_smooth, xt_size[0], gpu_iv17,
            gpu_iv15, xt_size[0] - 1, xt_size[1] - 1, be_gpu_expanded,
            e_cpu_expanded->size[0U]);
        }

        n = static_cast<int32_T>(halfh);
        eint = c_cpu_rows->size[0] * c_cpu_rows->size[1];
        c_cpu_rows->size[0] = 1;
        c_cpu_rows->size[1] = static_cast<int32_T>(halfh);
        emxEnsureCapacity_int32_T(c_cpu_rows, eint, &kb_emlrtRTEI);
        c_cpu_rows->data[0] = 0;
        y_needsGpuEnsureCapacity = true;
        c_omega_tmp1_needsGpuEnsureCapa = true;
        itime = 0;
        for (k = 0; k <= n - 2; k++) {
          itime++;
          c_cpu_rows->data[k + 1] = itime;
        }

        eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
        cpu_crossCFS->size[0] = g_cpu_smooth->size[0];
        cpu_crossCFS->size[1] = ix;
        emxEnsureCapacity_creal32_T(cpu_crossCFS, eint, &jb_emlrtRTEI);
        interval_outdatedOnGpu = true;
        cpu_lidx = static_cast<int32_T>(halfh);
        for (nrefine = 0; nrefine < ix; nrefine++) {
          for (nx = 0; nx < x_size_idx_1; nx++) {
            eint = cpu_newIm->size[0];
            cpu_newIm->size[0] = c_cpu_rows->size[1];
            emxEnsureCapacity_creal32_T(cpu_newIm, eint, &jb_emlrtRTEI);
            eint = c_cpu_rows->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxEnsureCapacity_int32_T(c_cpu_rows, &nd_gpu_rows,
                !y_needsGpuEnsureCapacity);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            gpuEmxEnsureCapacity_creal32_T(cpu_newIm, &w_gpu_newIm, true);
            if (y_needsGpuEnsureCapacity) {
              gpuEmxMemcpyCpuToGpu_int32_T(&nd_gpu_rows, c_cpu_rows);
            }

            y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1216<<<grid, block>>>(nrefine, be_gpu_expanded, nx,
                nd_gpu_rows, eint, w_gpu_newIm, e_cpu_expanded->size[0U]);
            }

            wav_outdatedOnCpu = true;
            cpu_cv_re = 0.0F;
            cv_im = 0.0F;
            for (n = 0; n < cpu_lidx; n++) {
              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_creal32_T(cpu_newIm, &w_gpu_newIm);
              }

              cpu_cv_re += cpu_newIm->data[n].re * static_cast<real32_T>(a);
              wav_outdatedOnCpu = false;
              cv_im += cpu_newIm->data[n].im * static_cast<real32_T>(a);
            }

            if (interval_outdatedOnGpu) {
              gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS, true);
            }

            interval_outdatedOnGpu = false;
            ec_wtcc_kernel1217<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cv_im,
              cpu_cv_re, nrefine, nx, gpu_crossCFS, cpu_crossCFS->size[0U]);
          }
        }
      }
    }
  }

  emxFree_creal32_T(&h_cpu_smooth);
  emxFree_creal32_T(&smooth);
  emxFree_creal32_T(&cpu_newIm);
  emxFree_int32_T(&c_cpu_rows);
  emxFree_int32_T(&cpu_iv17);
  emxFree_int32_T(&r_cpu_y);
  emxFree_int32_T(&cpu_iv16);
  emxFree_int32_T(&cpu_iv15);
  emxFree_int32_T(&q_cpu_y);
  emxFree_creal32_T(&f_cpu_expanded);
  emxFree_int32_T(&p_cpu_y);
  emxFree_creal32_T(&e_cpu_expanded);
  emxFree_creal32_T(&c_cpu_c);
  emxFree_creal32_T(&c_cpu_a);
  emxFree_creal32_T(&g_cpu_smooth);
  nx = cpu_crossCFS->size[0] * cpu_crossCFS->size[1];
  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(cpu_crossCFS->size[itime]);
  }

  emxInit_real32_T(&s_cpu_y, 2, &de_emlrtRTEI, true);
  eint = s_cpu_y->size[0] * s_cpu_y->size[1];
  s_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
  s_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(s_cpu_y, eint, &n_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block, 2147483647U);
  if (interval_outdatedOnGpu) {
    gpuEmxEnsureCapacity_creal32_T(cpu_crossCFS, &gpu_crossCFS,
      !x_data_outdatedOnGpu);
  }

  gpuEmxEnsureCapacity_real32_T(s_cpu_y, &g_gpu_y, true);
  if (x_data_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_crossCFS, cpu_crossCFS);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel82<<<grid, block>>>(gpu_crossCFS, nx - 1, g_gpu_y);
  }

  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(s_cpu_y->size[itime]);
  }

  emxInit_real32_T(&t_cpu_y, 2, &de_emlrtRTEI, true);
  eint = t_cpu_y->size[0] * t_cpu_y->size[1];
  t_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
  t_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(t_cpu_y, eint, &e_emlrtRTEI);
  mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(xSize[0]) *
    static_cast<int32_T>(xSize[1]) - 1), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(t_cpu_y, &h_gpu_y, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel83<<<grid, block>>>(g_gpu_y, static_cast<int32_T>(xSize[0]) *
      static_cast<int32_T>(xSize[1]) - 1, h_gpu_y);
  }

  emxFree_real32_T(&s_cpu_y);
  emxInit_real32_T(&cpu_wtc, 2, &rb_emlrtRTEI, true);
  if (cpu_cfs1->size[0] == 1) {
    eint = cpu_cfs2->size[0];
  } else {
    eint = cpu_cfs1->size[0];
  }

  if (cpu_cfs1->size[1] == 1) {
    offsetH = cpu_cfs2->size[1];
  } else {
    offsetH = cpu_cfs1->size[1];
  }

  if ((cpu_cfs1->size[0] == cpu_cfs2->size[0]) && (cpu_cfs1->size[1] ==
       cpu_cfs2->size[1]) && (t_cpu_y->size[0] == eint) && (t_cpu_y->size[1] ==
       offsetH)) {
    eint = cpu_wtc->size[0] * cpu_wtc->size[1];
    cpu_wtc->size[0] = t_cpu_y->size[0];
    cpu_wtc->size[1] = t_cpu_y->size[1];
    emxEnsureCapacity_real32_T(cpu_wtc, eint, &rb_emlrtRTEI);
    eint = t_cpu_y->size[0] * t_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real32_T(cpu_wtc, &gpu_wtc, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel84<<<grid, block>>>(gpu_cfs2, gpu_cfs1, h_gpu_y, eint,
        gpu_wtc);
    }

    interval_outdatedOnGpu = false;
  } else {
    gpuEmxMemcpyGpuToCpu_real32_T(t_cpu_y, &h_gpu_y);
    gpuEmxMemcpyGpuToCpu_real32_T(cpu_cfs1, &gpu_cfs1);
    gpuEmxMemcpyGpuToCpu_real32_T(cpu_cfs2, &gpu_cfs2);
    binary_expand_op_4(cpu_wtc, t_cpu_y, cpu_cfs1, cpu_cfs2);
    interval_outdatedOnGpu = true;
    fx_data_outdatedOnCpu = true;
  }

  emxFree_real32_T(&t_cpu_y);
  emxFree_real32_T(&cpu_cfs2);
  emxFree_real32_T(&cpu_cfs1);
  nrefine = cpu_wtc->size[0] * cpu_wtc->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(nrefine), &grid, &block, 2147483647U);
  if (fx_data_outdatedOnCpu) {
    gpuEmxEnsureCapacity_real32_T(cpu_wtc, &gpu_wtc, !interval_outdatedOnGpu);
  }

  if (interval_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_real32_T(&gpu_wtc, cpu_wtc);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel85<<<grid, block>>>(nrefine, gpu_wtc);
  }

  x_data_outdatedOnGpu = true;

  //  Downsample
  // 'ec_wtcc:36' x = resample(x,ds(1),ds(2),Dimension=2);
  if ((cpu_wtc->size[0] == 1) || (cpu_wtc->size[1] == 1)) {
    x_size_idx_1 = 1;
  } else {
    x_size_idx_1 = 2;
  }

  opts_isRowVectorInput = (cpu_wtc->size[0] == 1);
  if (x_size_idx_1 == 1) {
    if ((cpu_wtc->size[0] == 1) || (cpu_wtc->size[1] == 1)) {
      if ((cpu_wtc->size[0] == 0) || (cpu_wtc->size[1] == 0)) {
        pathlen = 0;
      } else {
        itime = cpu_wtc->size[0];
        pathlen = cpu_wtc->size[1];
        if (itime >= pathlen) {
          pathlen = itime;
        }
      }

      eint = xx[0].f1->size[0] * xx[0].f1->size[1];
      xx[0].f1->size[0] = pathlen;
      xx[0].f1->size[1] = 1;
      emxEnsureCapacity_real32_T(xx[0].f1, eint, &sb_emlrtRTEI);
      for (eint = 0; eint < pathlen; eint++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_wtc, &gpu_wtc);
        }

        x_data_outdatedOnGpu = false;
        xx[0].f1->data[eint] = cpu_wtc->data[eint];
      }
    } else {
      eint = xx[0].f1->size[0] * xx[0].f1->size[1];
      xx[0].f1->size[0] = cpu_wtc->size[0];
      xx[0].f1->size[1] = cpu_wtc->size[1];
      emxEnsureCapacity_real32_T(xx[0].f1, eint, &sb_emlrtRTEI);
      for (eint = 0; eint < cpu_wtc->size[0] * cpu_wtc->size[1]; eint++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_wtc, &gpu_wtc);
        }

        x_data_outdatedOnGpu = false;
        xx[0].f1->data[eint] = cpu_wtc->data[eint];
      }
    }
  } else {
    eint = xx[0].f1->size[0] * xx[0].f1->size[1];
    xx[0].f1->size[0] = cpu_wtc->size[1];
    xx[0].f1->size[1] = cpu_wtc->size[0];
    emxEnsureCapacity_real32_T(xx[0].f1, eint, &sb_emlrtRTEI);
    for (eint = 0; eint < cpu_wtc->size[0]; eint++) {
      for (n = 0; n < cpu_wtc->size[1]; n++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_wtc, &gpu_wtc);
        }

        x_data_outdatedOnGpu = false;
        xx[0].f1->data[n + xx[0].f1->size[0] * eint] = cpu_wtc->data[eint
          + cpu_wtc->size[0] * n];
      }
    }
  }

  s = static_cast<real_T>(ds[0]) / ds[1];
  p = s;
  r = std::abs(s);
  if (std::isinf(r) || std::isnan(r)) {
    b_r = rtNaN;
  } else if (r < 4.4501477170144028E-308) {
    b_r = 4.94065645841247E-324;
  } else {
    std::frexp(r, &exponent);
    b_r = std::ldexp(1.0, exponent - 53);
  }

  fb = std::fmax(1.0E-12, b_r);
  if (std::isinf(s) || std::isnan(s)) {
    if (!std::isnan(s)) {
      if (s < 0.0) {
        toler = -1.0;
      } else {
        toler = 1.0;
      }
    } else {
      toler = 0.0;
    }

    b_m = 0.0;
  } else {
    r = 1.0;
    d = 0.0;
    fa = 0.0;
    halfh = 1.0;
    do {
      exitg2 = 0;
      tol = std::round(s);
      if (!std::isinf(s)) {
        s -= tol;
        T = fa;
        fa = r;
        r = r * tol + T;
        T = halfh;
        halfh = d;
        d = d * tol + T;
      } else {
        fa = r;
        halfh = d;
        r = s;
        d = 0.0;
      }

      if ((s == 0.0) || (std::abs(r / d - p) <= fb)) {
        exitg2 = 1;
      } else {
        s = 1.0 / s;
      }
    } while (exitg2 == 0);

    if (std::isnan(d)) {
      halfh = rtNaN;
    } else if (d < 0.0) {
      halfh = -1.0;
    } else {
      halfh = (d > 0.0);
    }

    toler = r / halfh;
    b_m = std::abs(d);
  }

  fa = std::fmax(toler, b_m);
  fc = 0.5 / fa;
  fb = 20.0 * fa + 1.0;
  varargin_2[0] = 0.0;
  varargin_2[1] = 2.0 * fc;
  varargin_2[2] = 2.0 * fc;
  varargin_2[3] = 1.0;
  r = 0.0;
  fa = 0.0;
  Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] > 0.0));
  if (Nodd) {
    r = varargin_2[1];
  }

  Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] < 0.0));
  if (Nodd) {
    fa = varargin_2[1];
  }

  Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(r) || (r < varargin_2[2])));
  if (Nodd) {
    r = varargin_2[2];
  }

  Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(fa) || (fa > varargin_2[2])));
  if (Nodd) {
    fa = varargin_2[2];
  }

  Nodd = (std::isnan(r) || (r < 1.0));
  if (Nodd) {
    r = 1.0;
  }

  Nodd = (std::isnan(fa) || (fa > 1.0));
  if (Nodd) {
    fa = 1.0;
  }

  emxInit_real_T(&cpu_h, 2, &fe_emlrtRTEI, true);
  if ((!(r > 1.0)) && (!(fa < 0.0))) {
    for (itime = 0; itime < 4; itime++) {
      F[itime] = varargin_2[itime] / 2.0;
    }

    halfh = (((fb - 1.0) + 1.0) - 1.0) / 2.0;
    Nodd = (rt_remd_snf((fb - 1.0) + 1.0, 2.0) == 1.0);
    T = 0.0;
    emxInit_real_T(&cpu_m, 2, &wb_emlrtRTEI, true);
    if (!Nodd) {
      eint = cpu_m->size[0] * cpu_m->size[1];
      cpu_m->size[0] = 1;
      cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
      emxEnsureCapacity_real_T(cpu_m, eint, &wb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel86<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
      }
    } else {
      eint = cpu_m->size[0] * cpu_m->size[1];
      cpu_m->size[0] = 1;
      cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
      emxEnsureCapacity_real_T(cpu_m, eint, &vb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1205<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
      }
    }

    emxInit_real_T(&cpu_k, 1, &yb_emlrtRTEI, true);
    eint = cpu_k->size[0];
    cpu_k->size[0] = cpu_m->size[1];
    emxEnsureCapacity_real_T(cpu_k, eint, &yb_emlrtRTEI);
    offsetH = cpu_m->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel87<<<grid, block>>>(gpu_m, offsetH, gpu_k);
    }

    x_data_outdatedOnGpu = false;
    a_data_outdatedOnGpu = true;
    emxFree_real_T(&cpu_m);
    first_iteration = (F[2] - F[1] != 0.0);
    nsubs = cpu_k->size[0];
    emxInit_real_T(&cpu_G, 2, &ge_emlrtRTEI, true);
    if (first_iteration) {
      eint = cpu_G->size[0] * cpu_G->size[1];
      cpu_G->size[0] = cpu_k->size[0];
      cpu_G->size[1] = cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_G, eint, &ac_emlrtRTEI);
      k = cpu_k->size[0] * cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
      G_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel88<<<grid, block>>>(k, gpu_G);
      }

      f_omega_tmp1_needsGpuEnsureCapa = true;
      p = 2.0 * static_cast<real_T>(cpu_k->size[0]) - 1.0;
    } else {
      f_omega_tmp1_needsGpuEnsureCapa = false;
      cpu_G->size[0] = 0;
      cpu_G->size[1] = 0;
      p = 0.0;
    }

    emxInit_real_T(&cpu_sinc1A, 2, &he_emlrtRTEI, true);
    eint = cpu_sinc1A->size[0] * cpu_sinc1A->size[1];
    cpu_sinc1A->size[0] = 1;
    cpu_sinc1A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(cpu_sinc1A, eint, &bc_emlrtRTEI);
    y_needsGpuEnsureCapacity = true;
    emxInit_real_T(&cpu_sinc2A, 2, &ie_emlrtRTEI, true);
    eint = cpu_sinc2A->size[0] * cpu_sinc2A->size[1];
    cpu_sinc2A->size[0] = 1;
    cpu_sinc2A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(cpu_sinc2A, eint, &cc_emlrtRTEI);
    fx_data_outdatedOnCpu = true;
    emxInit_real_T(&cpu_sinc3A, 2, &je_emlrtRTEI, true);
    eint = cpu_sinc3A->size[0] * cpu_sinc3A->size[1];
    cpu_sinc3A->size[0] = 1;
    cpu_sinc3A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(cpu_sinc3A, eint, &dc_emlrtRTEI);
    c_omega_tmp1_needsGpuEnsureCapa = true;
    emxInit_real_T(&cpu_sinc4A, 2, &le_emlrtRTEI, true);
    eint = cpu_sinc4A->size[0] * cpu_sinc4A->size[1];
    cpu_sinc4A->size[0] = 1;
    cpu_sinc4A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(cpu_sinc4A, eint, &fc_emlrtRTEI);
    wav_outdatedOnCpu = true;
    if (Nodd) {
      ix = -1;
      if (cpu_k->size[0] < 2) {
        cpu_lidx = 0;
        nrefine = 0;
      } else {
        cpu_lidx = 1;
        nrefine = cpu_k->size[0];
      }

      nx = nrefine - cpu_lidx;
      for (eint = 0; eint < nx; eint++) {
        if (a_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
        }

        cpu_k->data[eint] = cpu_k->data[cpu_lidx + eint];
        a_data_outdatedOnGpu = false;
        x_data_outdatedOnGpu = true;
      }

      eint = cpu_k->size[0];
      cpu_k->size[0] = nrefine - cpu_lidx;
      emxEnsureCapacity_real_T(cpu_k, eint, &ic_emlrtRTEI);
      interval_outdatedOnGpu = true;
    } else {
      ix = 0;
    }

    emxInit_real_T(&cpu_b, 1, &gc_emlrtRTEI, true);
    eint = cpu_b->size[0];
    cpu_b->size[0] = cpu_k->size[0];
    emxEnsureCapacity_real_T(cpu_b, eint, &gc_emlrtRTEI);
    k = cpu_k->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
    b_y_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel89<<<grid, block>>>(k, gpu_b);
    }

    d_omega_tmp1_needsGpuEnsureCapa = false;
    b_fx_data_outdatedOnCpu = true;
    emxInit_real_T(&cpu_dv25, 1, &oe_emlrtRTEI, true);
    emxInit_real_T(&cpu_dv26, 1, &oe_emlrtRTEI, true);
    emxInit_real_T(&v_cpu_y, 1, &qe_emlrtRTEI, true);
    emxInit_real_T(&w_cpu_y, 1, &te_emlrtRTEI, true);
    for (pathlen = 0; pathlen < 2; pathlen++) {
      nrefine = pathlen << 1;
      n_idx_0 = A[nrefine];
      tol = F[nrefine + 1];
      s = F[nrefine];
      r = static_cast<real_T>(A[nrefine + 1] - n_idx_0) / (tol - s);
      fa = static_cast<real_T>(n_idx_0) - r * s;
      if (Nodd) {
        T += fa * (tol - s) + r / 2.0 * (tol * tol - s * s);
      }

      eint = cpu_dv25->size[0];
      cpu_dv25->size[0] = cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_dv25, eint, &mc_emlrtRTEI);
      k = cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, !x_data_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_dv25, &gpu_dv25, true);
      if (x_data_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_k, cpu_k);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel90<<<grid, block>>>(tol, gpu_k, k, gpu_dv25);
      }

      nx = cpu_dv25->size[0];
      eint = cpu_dv26->size[0];
      cpu_dv26->size[0] = cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_dv26, eint, &mc_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv26, &gpu_dv26, true);
      x_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel91<<<grid, block>>>(F[nrefine], gpu_k, nx - 1, gpu_dv26,
          gpu_dv25);
      }

      nx = cpu_dv26->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel92<<<grid, block>>>(nx - 1, gpu_dv26);
      }

      a = r / 39.478417604357432;
      if (cpu_dv25->size[0] == 1) {
        eint = cpu_k->size[0];
      } else {
        eint = cpu_dv25->size[0];
      }

      if ((cpu_dv25->size[0] == cpu_k->size[0]) && (cpu_b->size[0] == eint)) {
        eint = cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        interval_outdatedOnGpu = false;
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        b_y_needsGpuEnsureCapacity = false;
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel93<<<grid, block>>>(gpu_k, gpu_dv26, gpu_dv25, a, eint,
            gpu_b);
        }

        d_omega_tmp1_needsGpuEnsureCapa = false;
        b_fx_data_outdatedOnCpu = true;
      } else {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
        }

        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv25, &gpu_dv25);
        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv26, &gpu_dv26);
        if (a_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
        }

        a_data_outdatedOnGpu = false;
        binary_expand_op_1(cpu_b, a, cpu_dv25, cpu_dv26, cpu_k);
        b_fx_data_outdatedOnCpu = false;
        d_omega_tmp1_needsGpuEnsureCapa = true;
        interval_outdatedOnGpu = true;
        b_y_needsGpuEnsureCapacity = true;
      }

      eint = v_cpu_y->size[0];
      v_cpu_y->size[0] = cpu_k->size[0];
      emxEnsureCapacity_real_T(v_cpu_y, eint, &mc_emlrtRTEI);
      k = cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
      }

      gpuEmxEnsureCapacity_real_T(v_cpu_y, &i_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel94<<<grid, block>>>(F[nrefine + 1], gpu_k, k, i_gpu_y);
      }

      cpu_lidx = v_cpu_y->size[0];
      s = F[nrefine + 1];
      a = s * (r * s + fa);
      eint = w_cpu_y->size[0];
      w_cpu_y->size[0] = cpu_k->size[0];
      emxEnsureCapacity_real_T(w_cpu_y, eint, &mc_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
        2147483647U);
      interval_outdatedOnGpu = false;
      gpuEmxEnsureCapacity_real_T(w_cpu_y, &j_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel95<<<grid, block>>>(F[nrefine], gpu_k, cpu_lidx - 1,
          j_gpu_y, i_gpu_y);
      }

      cpu_lidx = w_cpu_y->size[0];
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel96<<<grid, block>>>(cpu_lidx - 1, j_gpu_y);
      }

      s = F[nrefine];
      c_a = s * (r * s + fa);
      if (cpu_b->size[0] == v_cpu_y->size[0]) {
        eint = cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        b_y_needsGpuEnsureCapacity = false;
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel97<<<grid, block>>>(j_gpu_y, c_a, i_gpu_y, a, eint,
            gpu_b);
        }

        d_omega_tmp1_needsGpuEnsureCapa = false;
        b_fx_data_outdatedOnCpu = true;
      } else {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
        }

        gpuEmxMemcpyGpuToCpu_real_T(v_cpu_y, &i_gpu_y);
        gpuEmxMemcpyGpuToCpu_real_T(w_cpu_y, &j_gpu_y);
        binary_expand_op(cpu_b, a, v_cpu_y, c_a, w_cpu_y);
        b_fx_data_outdatedOnCpu = false;
        d_omega_tmp1_needsGpuEnsureCapa = true;
        b_y_needsGpuEnsureCapacity = true;
      }

      if (first_iteration) {
        r = 2.0 * F[nrefine + 1];
        fa = 2.0 * F[nrefine];
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(p) - 1),
          &grid, &block, 2147483647U);
        if (wav_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(cpu_sinc4A, &gpu_sinc4A, true);
        }

        if (c_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxEnsureCapacity_real_T(cpu_sinc3A, &gpu_sinc3A, true);
        }

        if (fx_data_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(cpu_sinc2A, &gpu_sinc2A, true);
        }

        if (y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_sinc1A, &gpu_sinc1A, true);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel98<<<grid, block>>>(fa, r, nsubs, ix,
            static_cast<int32_T>(p) - 1, gpu_sinc4A, gpu_sinc3A, gpu_sinc2A,
            gpu_sinc1A);
        }

        mwGetLaunchParameters1D(computeNumIters(nsubs - 1, nsubs - 1), &grid,
          &block, 2147483647U);
        wav_outdatedOnCpu = false;
        fx_data_outdatedOnCpu = false;
        c_omega_tmp1_needsGpuEnsureCapa = false;
        y_needsGpuEnsureCapacity = false;
        if (G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
        }

        G_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel99<<<grid, block>>>(gpu_sinc4A, gpu_sinc2A, fa,
            gpu_sinc3A, gpu_sinc1A, r, nsubs, nsubs - 1, nsubs - 1, gpu_G,
            cpu_G->size[0U]);
        }

        f_omega_tmp1_needsGpuEnsureCapa = true;
      }
    }

    emxFree_real_T(&w_cpu_y);
    emxFree_real_T(&v_cpu_y);
    emxFree_real_T(&cpu_dv26);
    emxFree_real_T(&cpu_dv25);
    emxFree_real_T(&cpu_sinc4A);
    emxFree_real_T(&cpu_sinc3A);
    emxFree_real_T(&cpu_sinc2A);
    emxFree_real_T(&cpu_sinc1A);
    emxFree_real_T(&cpu_k);
    if (Nodd) {
      emxInit_real_T(&cpu_b0, 1, &jc_emlrtRTEI, true);
      eint = cpu_b0->size[0];
      cpu_b0->size[0] = cpu_b->size[0] + 1;
      emxEnsureCapacity_real_T(cpu_b0, eint, &jc_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(cpu_b0, &gpu_b0, true);
      ec_wtcc_kernel100<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(T, gpu_b0);
      nx = cpu_b->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      if (b_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
          !d_omega_tmp1_needsGpuEnsureCapa);
      }

      if (d_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel101<<<grid, block>>>(gpu_b, nx - 1, gpu_b0);
      }

      eint = cpu_b->size[0];
      cpu_b->size[0] = cpu_b0->size[0];
      emxEnsureCapacity_real_T(cpu_b, eint, &pc_emlrtRTEI);
      eint = cpu_b0->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
      b_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel102<<<grid, block>>>(gpu_b0, eint, gpu_b);
      }

      d_omega_tmp1_needsGpuEnsureCapa = false;
      emxFree_real_T(&cpu_b0);
    }

    emxInit_real_T(&d_cpu_a, 1, &fe_emlrtRTEI, true);
    if (first_iteration) {
      emxInit_int32_T(&cpu_jpvt, 2, &fe_emlrtRTEI, true);
      emxInit_real_T(&cpu_tau, 1, &fe_emlrtRTEI, true);
      emxInit_ptrdiff_t(&jpvt_t, 1, &ad_emlrtRTEI, true);
      emxInit_int32_T(&cpu_IPIV, 1, &re_emlrtRTEI, true);
      if ((cpu_G->size[0] == 0) || (cpu_G->size[1] == 0) || (cpu_b->size[0] == 0))
      {
        eint = d_cpu_a->size[0];
        d_cpu_a->size[0] = cpu_G->size[1];
        emxEnsureCapacity_real_T(d_cpu_a, eint, &lc_emlrtRTEI);
        eint = cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
        c_omega_tmp1_needsGpuEnsureCapa = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel103<<<grid, block>>>(eint, d_gpu_a);
        }

        fx_data_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
      } else if (cpu_G->size[0] == cpu_G->size[1]) {
        eint = d_cpu_a->size[0];
        d_cpu_a->size[0] = cpu_b->size[0];
        emxEnsureCapacity_real_T(d_cpu_a, eint, &lc_emlrtRTEI);
        eint = cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1193<<<grid, block>>>(gpu_b, eint, d_gpu_a);
        }

        itime = cpu_G->size[0];
        pathlen = cpu_G->size[1];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        itime = d_cpu_a->size[0];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        eint = cpu_IPIV->size[0];
        cpu_IPIV->size[0] = pathlen;
        emxEnsureCapacity_int32_T(cpu_IPIV, eint, &sc_emlrtRTEI);
        if (G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
        }

        cusolverCheck(cusolverDnDgetrf_bufferSize(getCuSolverGlobalHandle(),
          pathlen, pathlen, (double *)&gpu_G.data[0], cpu_G->size[0],
          getCuSolverWorkspaceReq()), __FILE__, __LINE__);
        setCuSolverWorkspaceTypeSize(8);
        cusolverInitWorkspace();
        gpuEmxEnsureCapacity_int32_T(cpu_IPIV, &b_gpu_IPIV, true);
        cusolverCheck(cusolverDnDgetrf(getCuSolverGlobalHandle(), pathlen,
          pathlen, (double *)&gpu_G.data[0], cpu_G->size[0], static_cast<real_T *>
          (getCuSolverWorkspaceBuff()), &b_gpu_IPIV.data[0], gpu_lidx), __FILE__,
                      __LINE__);
        checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        if (cpu_lidx < 0) {
          omega_tmp2[0] = d_cpu_a->size[0];
          eint = d_cpu_a->size[0];
          d_cpu_a->size[0] = omega_tmp2[0];
          emxEnsureCapacity_real_T(d_cpu_a, eint, &bd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
          c_omega_tmp1_needsGpuEnsureCapa = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1194<<<grid, block>>>(omega_tmp2[0] - 1, d_gpu_a);
          }

          fx_data_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
        } else {
          c_omega_tmp1_needsGpuEnsureCapa = false;
          cusolverCheck(cusolverDnDgetrs(getCuSolverGlobalHandle(), CUBLAS_OP_N,
            pathlen, 1, (double *)&gpu_G.data[0], cpu_G->size[0],
            &b_gpu_IPIV.data[0], (double *)&d_gpu_a.data[0], d_cpu_a->size[0],
            gpu_lidx), __FILE__, __LINE__);
          fx_data_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
        }
      } else {
        ptrdiff_t info_t;
        n = cpu_G->size[0];
        ix = cpu_G->size[1] - 1;
        eint = cpu_jpvt->size[0] * cpu_jpvt->size[1];
        cpu_jpvt->size[0] = 1;
        cpu_jpvt->size[1] = cpu_G->size[1];
        emxEnsureCapacity_int32_T(cpu_jpvt, eint, &rc_emlrtRTEI);
        eint = cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &b_gpu_jpvt, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1195<<<grid, block>>>(eint, b_gpu_jpvt);
        }

        wav_outdatedOnCpu = false;
        y_needsGpuEnsureCapacity = true;
        itime = cpu_G->size[0];
        cpu_lidx = cpu_G->size[1];
        if (itime <= cpu_lidx) {
          cpu_lidx = itime;
        }

        eint = cpu_tau->size[0];
        cpu_tau->size[0] = cpu_lidx;
        emxEnsureCapacity_real_T(cpu_tau, eint, &xc_emlrtRTEI);
        eint = jpvt_t->size[0];
        jpvt_t->size[0] = cpu_G->size[1];
        emxEnsureCapacity_ptrdiff_t(jpvt_t, eint, &ad_emlrtRTEI);
        for (eint = 0; eint < cpu_G->size[1]; eint++) {
          jpvt_t->data[eint] = (ptrdiff_t)0;
        }

        if (f_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
        }

        info_t = LAPACKE_dgeqp3(102, (ptrdiff_t)cpu_G->size[0], (ptrdiff_t)
          cpu_G->size[1], &cpu_G->data[0], (ptrdiff_t)cpu_G->size[0],
          &jpvt_t->data[0], &cpu_tau->data[0]);
        fx_data_outdatedOnCpu = true;
        f_omega_tmp1_needsGpuEnsureCapa = false;
        x_data_outdatedOnGpu = true;
        a_data_outdatedOnGpu = true;
        G_needsGpuEnsureCapacity = true;
        if ((int32_T)info_t != 0) {
          mwGetLaunchParameters1D(computeNumIters(ix, n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, false);
          G_needsGpuEnsureCapacity = false;
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1196<<<grid, block>>>(n - 1, ix, gpu_G, cpu_G->size[0U]);
          }

          x_data_outdatedOnGpu = false;
          f_omega_tmp1_needsGpuEnsureCapa = true;
          itime = cpu_G->size[0];
          nrefine = cpu_G->size[1];
          if (itime <= nrefine) {
            nrefine = itime;
          }

          mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_tau, &b_gpu_tau, false);
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_tau, cpu_tau);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1197<<<grid, block>>>(nrefine - 1, b_gpu_tau);
          }

          f = computeEndIdx(static_cast<int64_T>(nrefine + 1),
                            static_cast<int64_T>(cpu_lidx), 1L);
          mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
          a_data_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1198<<<grid, block>>>(nrefine + 1, f, b_gpu_tau);
          }

          fx_data_outdatedOnCpu = false;
          mwGetLaunchParameters1D(computeNumIters(ix), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1199<<<grid, block>>>(ix, b_gpu_jpvt);
          }
        } else {
          for (k = 0; k <= ix; k++) {
            if (y_needsGpuEnsureCapacity) {
              gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &b_gpu_jpvt);
            }

            cpu_jpvt->data[k] = (int32_T)jpvt_t->data[k];
            y_needsGpuEnsureCapacity = false;
            wav_outdatedOnCpu = true;
            interval_outdatedOnGpu = true;
          }
        }

        nsubs = -1;
        if (cpu_G->size[0] < cpu_G->size[1]) {
          nrefine = cpu_G->size[0];
          cpu_lidx = cpu_G->size[1];
        } else {
          nrefine = cpu_G->size[1];
          cpu_lidx = cpu_G->size[0];
        }

        exitg1 = false;
        while ((!exitg1) && (nsubs + 1 < nrefine)) {
          if (f_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
          }

          f_omega_tmp1_needsGpuEnsureCapa = false;
          if (!(std::abs(cpu_G->data[(nsubs + cpu_G->size[0] * (nsubs + 1)) + 1])
                <= std::fmin(1.4901161193847656E-8, 2.2204460492503131E-15 *
                             static_cast<real_T>(cpu_lidx)) * std::abs
                (cpu_G->data[0]))) {
            G_needsGpuEnsureCapacity = true;
            nsubs++;
          } else {
            G_needsGpuEnsureCapacity = true;
            exitg1 = true;
          }
        }

        eint = d_cpu_a->size[0];
        d_cpu_a->size[0] = cpu_G->size[1];
        emxEnsureCapacity_real_T(d_cpu_a, eint, &lc_emlrtRTEI);
        eint = cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1200<<<grid, block>>>(eint, d_gpu_a);
        }

        cpu_lidx = 0;
        itime = cpu_G->size[0];
        pathlen = cpu_G->size[1];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        if (G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, !x_data_outdatedOnGpu);
        }

        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(cpu_tau, &b_gpu_tau,
            !fx_data_outdatedOnCpu);
        }

        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
        }

        if (fx_data_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_tau, cpu_tau);
        }

        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
        }

        cusolverCheck(cusolverDnDormqr_bufferSize(getCuSolverGlobalHandle(),
          CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, pathlen, (double *)
          &gpu_G.data[0], cpu_G->size[0], (double *)&b_gpu_tau.data[0], (double *)
          &gpu_b.data[0], cpu_b->size[0], getCuSolverWorkspaceReq()), __FILE__,
                      __LINE__);
        setCuSolverWorkspaceTypeSize(8);
        cusolverInitWorkspace();
        checkCudaError(cudaMemcpy(gpu_lidx, &cpu_lidx, 4UL,
          cudaMemcpyHostToDevice), __FILE__, __LINE__);
        cusolverCheck(cusolverDnDormqr(getCuSolverGlobalHandle(),
          CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, pathlen, (double *)
          &gpu_G.data[0], cpu_G->size[0], (double *)&b_gpu_tau.data[0], (double *)
          &gpu_b.data[0], cpu_b->size[0], static_cast<real_T *>
          (getCuSolverWorkspaceBuff()), *getCuSolverWorkspaceReq(), gpu_lidx),
                      __FILE__, __LINE__);
        checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        if (cpu_lidx < 0) {
          omega_tmp2[0] = cpu_b->size[0];
          eint = cpu_b->size[0];
          cpu_b->size[0] = omega_tmp2[0];
          emxEnsureCapacity_real_T(cpu_b, eint, &fd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1201<<<grid, block>>>(omega_tmp2[0] - 1, gpu_b);
          }
        }

        mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &b_gpu_jpvt, !wav_outdatedOnCpu);
        }

        c_omega_tmp1_needsGpuEnsureCapa = false;
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_jpvt, cpu_jpvt);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1202<<<grid, block>>>(gpu_b, b_gpu_jpvt, nsubs, d_gpu_a);
        }

        fx_data_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        for (nx = 0; nx <= nsubs; nx++) {
          if (y_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &b_gpu_jpvt);
          }

          y_needsGpuEnsureCapacity = false;
          eint = cpu_jpvt->data[nsubs - nx];
          if (interval_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(d_cpu_a, &d_gpu_a);
          }

          if (f_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
          }

          f_omega_tmp1_needsGpuEnsureCapa = false;
          d_cpu_a->data[eint - 1] /= cpu_G->data[(nsubs - nx) + cpu_G->size[0] *
            (nsubs - nx)];
          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = true;
          c_omega_tmp1_needsGpuEnsureCapa = true;
          cpu_lidx = nsubs - nx;
          for (ix = 0; ix < cpu_lidx; ix++) {
            d_cpu_a->data[cpu_jpvt->data[ix] - 1] -= d_cpu_a->data
              [cpu_jpvt->data[nsubs - nx] - 1] * cpu_G->data[ix + cpu_G->size[0]
              * (nsubs - nx)];
          }
        }
      }

      emxFree_int32_T(&cpu_IPIV);
      emxFree_ptrdiff_t(&jpvt_t);
      emxFree_real_T(&cpu_tau);
      emxFree_int32_T(&cpu_jpvt);
    } else {
      eint = d_cpu_a->size[0];
      d_cpu_a->size[0] = cpu_b->size[0];
      emxEnsureCapacity_real_T(d_cpu_a, eint, &kc_emlrtRTEI);
      eint = cpu_b->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      if (b_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
          !d_omega_tmp1_needsGpuEnsureCapa);
      }

      gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, true);
      c_omega_tmp1_needsGpuEnsureCapa = false;
      if (d_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1203<<<grid, block>>>(gpu_b, eint, d_gpu_a);
      }

      fx_data_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      if (Nodd) {
        ec_wtcc_kernel1204<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_a);
      }
    }

    emxFree_real_T(&cpu_b);
    emxFree_real_T(&cpu_G);
    if (Nodd) {
      if (halfh + 1.0 < 2.0) {
        nrefine = 0;
        ix = 1;
        cpu_lidx = -1;
        pathlen = 0;
        nsubs = 0;
      } else {
        nrefine = static_cast<int32_T>(halfh + 1.0) - 1;
        ix = -1;
        cpu_lidx = 1;
        pathlen = 1;
        nsubs = static_cast<int32_T>(halfh + 1.0);
      }

      eint = cpu_h->size[0] * cpu_h->size[1];
      cpu_h->size[0] = 1;
      cpu_h->size[1] = ((div_s32(cpu_lidx - nrefine, ix) + nsubs) - pathlen) + 2;
      emxEnsureCapacity_real_T(cpu_h, eint, &cd_emlrtRTEI);
      nx = div_s32(cpu_lidx - nrefine, ix);
      mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
      if (c_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&d_gpu_a, d_cpu_a);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel104<<<grid, block>>>(d_gpu_a, ix, nrefine, nx, gpu_h);
      }

      h_needsGpuEnsureCapacity = false;
      ec_wtcc_kernel105<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_a, ix,
        nrefine, cpu_lidx, gpu_h);
      b_fx_data_outdatedOnCpu = true;
      nx = nsubs - pathlen;
      for (eint = 0; eint < nx; eint++) {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_h, &gpu_h);
        }

        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(d_cpu_a, &d_gpu_a);
        }

        interval_outdatedOnGpu = false;
        cpu_h->data[(eint + div_s32(cpu_lidx - nrefine, ix)) + 2] =
          d_cpu_a->data[pathlen + eint] / 2.0;
        b_fx_data_outdatedOnCpu = false;
        h_outdatedOnGpu = true;
        h_needsGpuEnsureCapacity = true;
      }
    } else {
      emxInit_real_T(&p_cpu_x, 1, &pe_emlrtRTEI, true);
      eint = p_cpu_x->size[0];
      p_cpu_x->size[0] = d_cpu_a->size[0];
      emxEnsureCapacity_real_T(p_cpu_x, eint, &vc_emlrtRTEI);
      eint = d_cpu_a->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      if (c_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxEnsureCapacity_real_T(d_cpu_a, &d_gpu_a, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(p_cpu_x, &q_gpu_x, true);
      x_data_outdatedOnGpu = false;
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&d_gpu_a, d_cpu_a);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1190<<<grid, block>>>(d_gpu_a, eint, q_gpu_x);
      }

      a_data_outdatedOnGpu = false;
      interval_outdatedOnGpu = true;
      n = d_cpu_a->size[0] - 1;
      nrefine = d_cpu_a->size[0] >> 1;
      for (ix = 0; ix < nrefine; ix++) {
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(p_cpu_x, &q_gpu_x);
        }

        r = p_cpu_x->data[ix];
        p_cpu_x->data[ix] = p_cpu_x->data[n - ix];
        p_cpu_x->data[n - ix] = r;
        interval_outdatedOnGpu = false;
        a_data_outdatedOnGpu = true;
        x_data_outdatedOnGpu = true;
      }

      eint = cpu_h->size[0] * cpu_h->size[1];
      cpu_h->size[0] = 1;
      cpu_h->size[1] = p_cpu_x->size[0] + d_cpu_a->size[0];
      emxEnsureCapacity_real_T(cpu_h, eint, &dd_emlrtRTEI);
      nx = p_cpu_x->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      if (x_data_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(p_cpu_x, &q_gpu_x, !a_data_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
      if (a_data_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&q_gpu_x, p_cpu_x);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1191<<<grid, block>>>(q_gpu_x, nx - 1, gpu_h);
      }

      nx = d_cpu_a->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      h_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel1192<<<grid, block>>>(d_gpu_a, nx - 1, gpu_h,
          p_cpu_x->size[0U]);
      }

      emxFree_real_T(&p_cpu_x);
    }

    emxFree_real_T(&d_cpu_a);
  }

  if (fb == std::floor(fb)) {
    nsubs = static_cast<int32_T>(fb);
  } else {
    nsubs = static_cast<int32_T>(std::round(fb));
    coder::internal::warning();
  }

  emxInit_real_T(&cpu_dv23, 1, &ee_emlrtRTEI, true);
  eint = cpu_dv23->size[0];
  cpu_dv23->size[0] = nsubs;
  emxEnsureCapacity_real_T(cpu_dv23, eint, &tb_emlrtRTEI);
  if (nsubs <= 1) {
    eint = cpu_dv23->size[0];
    cpu_dv23->size[0] = nsubs;
    emxEnsureCapacity_real_T(cpu_dv23, eint, &ub_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel106<<<grid, block>>>(nsubs - 1, gpu_dv23);
    }

    x_data_outdatedOnGpu = false;
  } else {
    cpu_lidx = nsubs >> 1;
    f = computeEndIdx(static_cast<int64_T>(cpu_lidx + 1), static_cast<int64_T>
                      (nsubs), 1L);
    mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1189<<<grid, block>>>(gpu_dc6, *global_gpu_table100, dc7,
        gpu_dc, nsubs, cpu_lidx, 1 - (nsubs & 1), cpu_lidx + 1, f, gpu_dv23, q1
        [0], q1[1], q1[2], q1[3], q1[4], q1[5], q1[6], q1[7], p1[0], p1[1], p1[2],
        p1[3], p1[4], p1[5], p1[6], p1[7], q2[0], q2[1], q2[2], q2[3], q2[4],
        q2[5], q2[6], q2[7], p2[0], p2[1], p2[2], p2[3], p2[4], p2[5], p2[6],
        p2[7], q4[0], q4[1], q4[2], q4[3], q4[4], q4[5], q4[6], q4[7], p4[0],
        p4[1], p4[2], p4[3], p4[4], p4[5], p4[6], p4[7], c_c[0], c_c[1], c_c[2],
        c_c[3], c_c[4], c_c[5], c_c[6]);
    }

    x_data_outdatedOnGpu = false;
    fx_data_outdatedOnCpu = true;
    for (k = 0; k < cpu_lidx; k++) {
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv23, &gpu_dv23);
      }

      cpu_dv23->data[k] = cpu_dv23->data[(nsubs - k) - 1];
      fx_data_outdatedOnCpu = false;
      x_data_outdatedOnGpu = true;
      interval_outdatedOnGpu = true;
    }
  }

  emxInit_real_T(&cpu_h1, 1, &xb_emlrtRTEI, true);
  eint = cpu_h1->size[0];
  cpu_h1->size[0] = cpu_h->size[1];
  emxEnsureCapacity_real_T(cpu_h1, eint, &xb_emlrtRTEI);
  offsetH = cpu_h->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  if (interval_outdatedOnGpu) {
    gpuEmxEnsureCapacity_real_T(cpu_dv23, &gpu_dv23, !x_data_outdatedOnGpu);
  }

  if (h_needsGpuEnsureCapacity) {
    gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, !h_outdatedOnGpu);
  }

  gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
  interval_outdatedOnGpu = false;
  if (x_data_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_real_T(&gpu_dv23, cpu_dv23);
  }

  if (h_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_real_T(&gpu_h, cpu_h);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel107<<<grid, block>>>(gpu_dv23, gpu_h, offsetH, gpu_h1);
  }

  emxFree_real_T(&cpu_h);
  emxFree_real_T(&cpu_dv23);
  cpu_lidx = cpu_h1->size[0];
  if (cpu_h1->size[0] == 0) {
    halfh = 0.0;
  } else {
    gpuEmxMemcpyGpuToCpu_real_T(cpu_h1, &gpu_h1);
    halfh = cpu_h1->data[0];
    interval_outdatedOnGpu = true;
    for (k = 0; k <= cpu_lidx - 2; k++) {
      halfh += cpu_h1->data[k + 1];
    }
  }

  emxInit_real32_T(&cpu_opts_filter, 1, &sb_emlrtRTEI, true);
  eint = cpu_opts_filter->size[0];
  cpu_opts_filter->size[0] = cpu_h1->size[0];
  emxEnsureCapacity_real32_T(cpu_opts_filter, eint, &sb_emlrtRTEI);
  offsetH = cpu_h1->size[0] - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  if (interval_outdatedOnGpu) {
    gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
  }

  gpuEmxEnsureCapacity_real32_T(cpu_opts_filter, &gpu_opts_filter, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel108<<<grid, block>>>(halfh, gpu_h1, toler, offsetH,
      gpu_opts_filter);
  }

  emxFree_real_T(&cpu_h1);
  r = (static_cast<real_T>(cpu_opts_filter->size[0]) - 1.0) / 2.0;
  b_r = r;
  if (b_m == 0.0) {
    if (r == 0.0) {
      b_r = 0.0;
    }
  } else if (std::isnan(b_m)) {
    b_r = rtNaN;
  } else if (r == 0.0) {
    b_r = 0.0;
  } else if (std::isinf(b_m)) {
    if (r < 0.0) {
      b_r = b_m;
    }
  } else {
    b_r = std::fmod(r, b_m);
    if (b_r == 0.0) {
      b_r = b_m * 0.0;
    } else if (r < 0.0) {
      b_r += b_m;
    }
  }

  halfh = std::floor(b_m - b_r);
  T = std::floor(std::ceil(r + halfh) / b_m);
  r = static_cast<real_T>(cpu_opts_filter->size[0]) + halfh;
  fa = 0.0;
  cpu_lidx = xx[0].f1->size[0];
  while (std::ceil((((static_cast<real_T>(cpu_lidx) - 1.0) * toler + r) + fa) /
                   b_m) - T < std::ceil(static_cast<real_T>(cpu_lidx) * toler /
          b_m)) {
    fa++;
  }

  emxInit_real32_T(&b_cpu_h, 1, &ec_emlrtRTEI, true);
  eint = b_cpu_h->size[0];
  b_cpu_h->size[0] = static_cast<int32_T>((halfh + static_cast<real_T>
    (cpu_opts_filter->size[0])) + fa);
  emxEnsureCapacity_real32_T(b_cpu_h, eint, &ec_emlrtRTEI);
  offsetH = static_cast<int32_T>((halfh + static_cast<real_T>
    (cpu_opts_filter->size[0])) + fa) - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(b_cpu_h, &b_gpu_h, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel109<<<grid, block>>>(offsetH, b_gpu_h);
  }

  emxInit_uint32_T(&u_cpu_y, 2, &ke_emlrtRTEI, true);
  if (cpu_opts_filter->size[0] < 1) {
    u_cpu_y->size[0] = 1;
    u_cpu_y->size[1] = 0;
  } else {
    N = static_cast<uint32_T>(cpu_opts_filter->size[0]);
    eint = u_cpu_y->size[0] * u_cpu_y->size[1];
    u_cpu_y->size[0] = 1;
    u_cpu_y->size[1] = cpu_opts_filter->size[0];
    emxEnsureCapacity_uint32_T(u_cpu_y, eint, &d_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(N) - 1), &grid,
      &block, 2147483647U);
    gpuEmxEnsureCapacity_uint32_T(u_cpu_y, &k_gpu_y, true);
    c_y_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel1188<<<grid, block>>>(static_cast<int32_T>(N) - 1, k_gpu_y);
    }
  }

  emxInit_int32_T(&cpu_iv18, 2, &me_emlrtRTEI, true);
  eint = cpu_iv18->size[0] * cpu_iv18->size[1];
  cpu_iv18->size[0] = 1;
  cpu_iv18->size[1] = u_cpu_y->size[1];
  emxEnsureCapacity_int32_T(cpu_iv18, eint, &hc_emlrtRTEI);
  eint = u_cpu_y->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (c_y_needsGpuEnsureCapacity) {
    gpuEmxEnsureCapacity_uint32_T(u_cpu_y, &k_gpu_y, true);
  }

  gpuEmxEnsureCapacity_int32_T(cpu_iv18, &gpu_iv18, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel110<<<grid, block>>>(k_gpu_y, halfh, eint, gpu_iv18);
  }

  emxFree_uint32_T(&u_cpu_y);
  offsetH = cpu_iv18->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel111<<<grid, block>>>(gpu_opts_filter, gpu_iv18, offsetH,
      b_gpu_h);
  }

  emxFree_int32_T(&cpu_iv18);
  emxFree_real32_T(&cpu_opts_filter);
  emxInit_real32_T(&cpu_y1, 2, &ne_emlrtRTEI, true);
  if (x_size_idx_1 == 1) {
    if (opts_isRowVectorInput) {
      emxInit_real32_T(&b_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&e_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&k_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&d_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&f_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&n_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&f_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&f_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&e_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&e_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&l_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&o_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&l_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&o_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&q_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&t_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ib_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&x_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ab_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&r_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_int32_T(&qb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&c_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&ub_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&wb_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv44, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&f_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_real32_T(&ac_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv46, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&db_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&gb_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv50, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv51, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ec_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv54, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&mc_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv57, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&sc_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&h_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&uc_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_real32_T(&kb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&mb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv64, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ad_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv66, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&j_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv69, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&qb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&tb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ed_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&wb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&yb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&id_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv74, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ld_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&n_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&od_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&bc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ec_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv76, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&c_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&q_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&rd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&t_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv78, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ud_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv83, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&f_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&w_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv88, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv89, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ab_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv91, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&eb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv97, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv102, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&tb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&vb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&o_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&r_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&t_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&w_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&ab_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&yd_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&be_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&db_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((toler == 1.0) && (b_m == 1.0)) {
        fx_data_outdatedOnCpu = false;
        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = xx[0].f1->size[0];
        cpu_y1->size[1] = xx[0].f1->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, eint, &oc_emlrtRTEI);
        for (eint = 0; eint < xx[0].f1->size[0] * xx[0].f1->size[1]; eint++) {
          cpu_y1->data[eint] = xx[0].f1->data[eint];
        }
      } else if ((xx[0].f1->size[0] == 1) || (xx[0].f1->size[1] == 1)) {
        if ((xx[0].f1->size[0] == 0) || (xx[0].f1->size[1] == 0)) {
          pathlen = 0;
        } else {
          itime = xx[0].f1->size[0];
          pathlen = xx[0].f1->size[1];
          if (itime >= pathlen) {
            pathlen = itime;
          }
        }

        halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
        if ((xx[0].f1->size[0] == 1) && (xx[0].f1->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            v_y = nullptr;
            m23 = emlrtCreateCharArray(2, &iv28[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m23, &rfmt[0]);
            emlrtAssign(&v_y, m23);
            fb_y = nullptr;
            m29 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&fb_y, m29);
            emlrt_marshallIn(b_sprintf(v_y, fb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          eint = h_cpu_yCol->size[0];
          h_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(h_cpu_yCol, eint, &yc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(h_cpu_yCol, &t_gpu_yCol, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel721<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              t_gpu_yCol);
          }

          c_omega_tmp1_needsGpuEnsureCapa = false;
          x_data_outdatedOnGpu = true;
          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = static_cast<int32_T>(toler);
          }

          omega_tmp2[0] = div_s32(cpu_lidx - 1, nrefine) + 1;
          for (eint = 0; eint < omega_tmp2[0]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(h_cpu_yCol, &t_gpu_yCol);
            }

            h_cpu_yCol->data[nrefine * eint] = xx[0].f1->data[eint];
            x_data_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            wav_outdatedOnCpu = true;
          }

          ec_wtcc_kernel722<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
            *gpu_csz);
          eint = n_cpu_x->size[0] * n_cpu_x->size[1];
          n_cpu_x->size[0] = static_cast<int32_T>(toler);
          n_cpu_x->size[1] = 1;
          emxEnsureCapacity_real32_T(n_cpu_x, eint, &ed_emlrtRTEI);
          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[0] - 1), &grid,
            &block, 2147483647U);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(h_cpu_yCol, &t_gpu_yCol,
              !c_omega_tmp1_needsGpuEnsureCapa);
          }

          gpuEmxEnsureCapacity_real32_T(n_cpu_x, &h_gpu_x, true);
          if (c_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyCpuToGpu_real32_T(&t_gpu_yCol, h_cpu_yCol);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel723<<<grid, block>>>(t_gpu_yCol, b_cpu_csz[0] - 1,
              h_gpu_x);
          }

          if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            eint = e_a->size[0];
            e_a->size[0] = 1;
            emxEnsureCapacity_real32_T(e_a, eint, &fb_emlrtRTEI);
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(h_cpu_yCol, &t_gpu_yCol);
            }

            e_a->data[0] = h_cpu_yCol->data[0];
            ec_wtcc_kernel724<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
              gpu_cv_re);
            eint = e_c->size[0];
            e_c->size[0] = 1;
            emxEnsureCapacity_real32_T(e_c, eint, &hb_emlrtRTEI);
            checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            e_c->data[0] = e_a->data[0] * cpu_cv_re;
            eint = i_cpu_w->size[0] * i_cpu_w->size[1];
            i_cpu_w->size[0] = 1;
            i_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
            i_cpu_w->data[0] = e_c->data[0];
            x_data_outdatedOnGpu = true;
            a_data_outdatedOnGpu = true;
          } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            eint = i_cpu_w->size[0] * i_cpu_w->size[1];
            i_cpu_w->size[0] = itime;
            i_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel736<<<grid, block>>>(itime - 1, db_gpu_w);
            }

            x_data_outdatedOnGpu = false;
            if (b_cpu_csz[0] == 0) {
              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = itime;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel737<<<grid, block>>>(itime - 1, db_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && (b_cpu_csz[0] == 1)) {
              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = 1;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel738<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (t_gpu_yCol, b_gpu_h, db_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = gb_cpu_expanded->size[0] * gb_cpu_expanded->size[1];
              gb_cpu_expanded->size[0] = nx;
              gb_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(gb_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + b_cpu_csz[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(gb_cpu_expanded, &ac_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel739<<<grid, block>>>(eint, ac_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              eint = kc_cpu_y->size[0] * kc_cpu_y->size[1];
              kc_cpu_y->size[0] = 1;
              kc_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(kc_cpu_y, eint, &kb_emlrtRTEI);
              kc_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                kc_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv64->size[0];
              cpu_iv64->size[0] = kc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv64, eint, &jb_emlrtRTEI);
              eint = kc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(kc_cpu_y, &wd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv64, &gpu_iv64, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&wd_gpu_y, kc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel740<<<grid, block>>>(offsetH, wd_gpu_y, eint,
                  gpu_iv64);
              }

              omega_tmp2[0] = cpu_iv64->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel741<<<grid, block>>>(b_gpu_h, gpu_iv64,
                  omega_tmp2[0] - 1, ac_gpu_expanded);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = q_cpu_rows->size[0] * q_cpu_rows->size[1];
              q_cpu_rows->size[0] = 1;
              q_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(q_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                q_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  q_cpu_rows->data[k + 1] = itime;
                }
              }

              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = x_size_idx_1;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_int32_T(q_cpu_rows, &tb_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&tb_gpu_rows, q_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel742<<<grid, block>>>(t_gpu_yCol, ac_gpu_expanded,
                    tb_gpu_rows, *gpu_csz, x_size_idx_1 - 1, db_gpu_w);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
            }

            eint = i_cpu_w->size[0] * i_cpu_w->size[1];
            i_cpu_w->size[0] = itime;
            i_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel743<<<grid, block>>>(itime - 1, db_gpu_w);
            }

            x_data_outdatedOnGpu = false;
            if (b_cpu_csz[0] == 0) {
              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = itime;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel744<<<grid, block>>>(itime - 1, db_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              eint = r_cpu_c->size[0];
              r_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(r_cpu_c, eint, &hd_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(r_cpu_c, &j_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &h_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&j_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = itime;
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel745<<<grid, block>>>(j_gpu_c, itime - 1, db_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
              b_blockDims[0] = itime;
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = db_cpu_expanded->size[0] * db_cpu_expanded->size[1];
              db_cpu_expanded->size[0] = nx - 1;
              db_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(db_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(db_cpu_expanded, &bc_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel746<<<grid, block>>>(eint, bc_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = ec_cpu_y->size[0] * ec_cpu_y->size[1];
              ec_cpu_y->size[0] = 1;
              ec_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(ec_cpu_y, eint, &kb_emlrtRTEI);
              ec_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ec_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv66->size[0];
              cpu_iv66->size[0] = ec_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv66, eint, &jb_emlrtRTEI);
              eint = ec_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ec_cpu_y, &xd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv66, &gpu_iv66, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&xd_gpu_y, ec_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel747<<<grid, block>>>(offsetH, xd_gpu_y, eint,
                  gpu_iv66);
              }

              xt_size[0] = cpu_iv66->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel748<<<grid, block>>>(t_gpu_yCol, gpu_iv66,
                  xt_size[0] - 1, bc_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              eint = hb_cpu_rows->size[0] * hb_cpu_rows->size[1];
              hb_cpu_rows->size[0] = 1;
              hb_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(hb_cpu_rows, eint, &kb_emlrtRTEI);
              hb_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                hb_cpu_rows->data[k + 1] = itime;
              }

              eint = i_cpu_w->size[0] * i_cpu_w->size[1];
              i_cpu_w->size[0] = static_cast<int32_T>(N);
              i_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(i_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(b_blockDims[0]),
                  1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(hb_cpu_rows, &ub_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&ub_gpu_rows, hb_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel749<<<grid, block>>>(bc_gpu_expanded,
                    ub_gpu_rows, b_gpu_h, x_size_idx_1 - 1, db_gpu_w,
                    b_cpu_h->size[0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            pb_y = nullptr;
            m46 = emlrtCreateCharArray(2, &iv39[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m46, &rfmt[0]);
            emlrtAssign(&pb_y, m46);
            wb_y = nullptr;
            m50 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&wb_y, m50);
            emlrt_marshallIn(b_sprintf(pb_y, wb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (i_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = i_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = i_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel725<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            nrefine = 1;
            pathlen = -1;
          } else {
            nrefine = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel726<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
            pathlen, nsubs, *gpu_csz);
          eint = r_cpu_w->size[0] * r_cpu_w->size[1];
          r_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          r_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(r_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(i_cpu_w, &db_gpu_w,
              !x_data_outdatedOnGpu);
          }

          gpuEmxEnsureCapacity_real32_T(r_cpu_w, &eb_gpu_w, true);
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyCpuToGpu_real32_T(&db_gpu_w, i_cpu_w);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel727<<<grid, block>>>(db_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_lidx - 1, eb_gpu_w, r_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = sc_cpu_y->size[0] * sc_cpu_y->size[1];
          sc_cpu_y->size[0] = b_cpu_csz[0];
          sc_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(sc_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(sc_cpu_y, &sd_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel728<<<grid, block>>>(eb_gpu_w, offsetH, sd_gpu_y);
          }

          Ly = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                         b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(Ly);
            }

            n = ab_cpu_w->size[0] * ab_cpu_w->size[1];
            ab_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            ab_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_real32_T(ab_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(ab_cpu_w, &fb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel729<<<grid, block>>>(db_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_csz[1] - 1, fb_gpu_w, ab_cpu_w->size[0U]);
            }

            n = sc_cpu_y->size[0] * sc_cpu_y->size[1];
            sc_cpu_y->size[0] = cpu_lidx;
            sc_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(sc_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(sc_cpu_y, &sd_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel730<<<grid, block>>>(fb_gpu_w, b_cpu_csz[0],
                cpu_lidx - 1, b_cpu_csz[1] - 1, sd_gpu_y, sc_cpu_y->size[0U]);
            }
          }

          if (sc_cpu_y->size[0] * sc_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = sc_cpu_y->size[0] * sc_cpu_y->size[1];
          }

          omega_tmp2[0] = sc_cpu_y->size[0] * sc_cpu_y->size[1];
          eint = be_cpu_y->size[0] * be_cpu_y->size[1];
          be_cpu_y->size[0] = 1;
          be_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(be_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(be_cpu_y, &td_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel731<<<grid, block>>>(sd_gpu_y, omega_tmp2[0] - 1,
              td_gpu_y);
          }

          eint = wb_cpu_y->size[0] * wb_cpu_y->size[1];
          wb_cpu_y->size[0] = n;
          wb_cpu_y->size[1] = 1;
          emxEnsureCapacity_real32_T(wb_cpu_y, eint, &ld_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ud_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel732<<<grid, block>>>(td_gpu_y, n - 1, ud_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            u_y = nullptr;
            m13 = emlrtCreateCharArray(2, &iv22[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m13, &rfmt[0]);
            emlrtAssign(&u_y, m13);
            eb_y = nullptr;
            m21 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&eb_y, m21);
            emlrt_marshallIn(b_sprintf(u_y, eb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = xx[0].f1->size[0] * xx[0].f1->size[1];
          b_cpu_csz[1] = xx[0].f1->size[1];
          nrefine = xx[0].f1->size[0] * xx[0].f1->size[1];
          eint = b_cpu_yCol->size[0];
          b_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(b_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &u_gpu_yCol, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel750<<<grid, block>>>(eint, u_gpu_yCol);
          }

          c_omega_tmp1_needsGpuEnsureCapa = false;
          x_data_outdatedOnGpu = true;
          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = nx * static_cast<int32_T>(toler);
          }

          omega_tmp2[0] = div_s32(cpu_lidx - 1, nrefine) + 1;
          for (eint = 0; eint < omega_tmp2[0]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_yCol, &u_gpu_yCol);
            }

            b_cpu_yCol->data[nrefine * eint] = xx[0].f1->data[eint];
            x_data_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            wav_outdatedOnCpu = true;
          }

          b_cpu_csz[0] = xx[0].f1->size[0] * static_cast<int32_T>(toler);
          a_data_outdatedOnGpu = false;
          eint = h_cpu_x->size[0] * h_cpu_x->size[1];
          h_cpu_x->size[0] = b_cpu_csz[0];
          h_cpu_x->size[1] = xx[0].f1->size[1];
          emxEnsureCapacity_real32_T(h_cpu_x, eint, &ed_emlrtRTEI);
          for (eint = 0; eint < b_cpu_csz[0] * xx[0].f1->size[1]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_yCol, &u_gpu_yCol);
            }

            x_data_outdatedOnGpu = false;
            h_cpu_x->data[eint] = b_cpu_yCol->data[eint];
            a_data_outdatedOnGpu = true;
            wav_outdatedOnCpu = true;
          }

          if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (xx[0].f1->size[1] < 1) {
              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel751<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (gb_gpu_w);
            } else {
              eint = xx[0].f1->size[1];
              n = f_cpu_a->size[0];
              f_cpu_a->size[0] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(f_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                2147483647U);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &u_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_real32_T(f_cpu_a, &n_gpu_a, true);
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&u_gpu_yCol, b_cpu_yCol);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel758<<<grid, block>>>(u_gpu_yCol, eint - 1, n_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              eint = f_cpu_c->size[0];
              f_cpu_c->size[0] = f_cpu_a->size[0];
              emxEnsureCapacity_real32_T(f_cpu_c, eint, &hb_emlrtRTEI);
              eint = f_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(f_cpu_c, &k_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel759<<<grid, block>>>(eint, k_gpu_c);
              }

              if (f_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                eint = f_cpu_c->size[0];
                f_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(f_cpu_c, eint, &hb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(f_cpu_c, &k_gpu_c, true);
                ec_wtcc_kernel760<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, n_gpu_a, k_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (f_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(f_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = f_cpu_a->size[0];
                if (f_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = f_cpu_a->size[0] + 1;
                }

                eint = l_cpu_expanded->size[0];
                l_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_real32_T(l_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = f_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(l_cpu_expanded, &cc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel762<<<grid, block>>>(eint, cc_gpu_expanded);
                }

                n = f_cpu_a->size[0];
                eint = fb_cpu_y->size[0] * fb_cpu_y->size[1];
                fb_cpu_y->size[0] = 1;
                fb_cpu_y->size[1] = f_cpu_a->size[0];
                emxEnsureCapacity_int32_T(fb_cpu_y, eint, &kb_emlrtRTEI);
                fb_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  fb_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv44->size[0];
                cpu_iv44->size[0] = fb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv44, eint, &jb_emlrtRTEI);
                eint = fb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(fb_cpu_y, &yd_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv44, &gpu_iv44, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&yd_gpu_y, fb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel763<<<grid, block>>>(yd_gpu_y, eint, gpu_iv44);
                }

                omega_tmp2[0] = cpu_iv44->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel764<<<grid, block>>>(n_gpu_a, gpu_iv44,
                    omega_tmp2[0] - 1, cc_gpu_expanded);
                }

                eint = f_cpu_c->size[0];
                f_cpu_c->size[0] = f_cpu_a->size[0];
                emxEnsureCapacity_real32_T(f_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_real32_T(f_cpu_c, &k_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel765<<<grid, block>>>(cpu_cv_re, cc_gpu_expanded,
                    x_size_idx_1 - 1, k_gpu_c);
                }
              }

              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = f_cpu_c->size[0];
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = f_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel761<<<grid, block>>>(k_gpu_c, offsetH, gb_gpu_w,
                  d_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (xx[0].f1->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = xx[0].f1->size[1];
            }

            eint = d_cpu_w->size[0] * d_cpu_w->size[1];
            d_cpu_w->size[0] = itime;
            d_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel766<<<grid, block>>>(eint, gb_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = itime;
              d_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel767<<<grid, block>>>(eint, gb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) && (xx[0]
                         .f1->size[1] == 1))) {
              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = 1;
              d_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &u_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&u_gpu_yCol, b_cpu_yCol);
              }

              ec_wtcc_kernel768<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (u_gpu_yCol, b_gpu_h, gb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = xx[0].f1->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = q_cpu_expanded->size[0] * q_cpu_expanded->size[1];
              q_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(q_cpu_expanded, eint, &jb_emlrtRTEI);
              if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                   - xx[0].f1->size[1])) {
                nx = MAX_int32_T;
              } else {
                nx = xx[0].f1->size[1] + xx[0].f1->size[1];
              }

              eint = q_cpu_expanded->size[0] * q_cpu_expanded->size[1];
              q_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(q_cpu_expanded, eint, &jb_emlrtRTEI);
              fx_data_outdatedOnCpu = true;
              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                   - xx[0].f1->size[1])) {
                nrefine = MAX_int32_T;
              } else {
                nrefine = xx[0].f1->size[1] + xx[0].f1->size[1];
              }

              if (nx * (nrefine - 1) - 1 >= 0) {
                gpuEmxEnsureCapacity_real32_T(q_cpu_expanded, &dc_gpu_expanded,
                  true);
                fx_data_outdatedOnCpu = false;
                cudaMemset(&dc_gpu_expanded.data[0], 0, static_cast<uint32_T>(nx
                            * nrefine - nx) * sizeof(real32_T));
              }

              n = b_cpu_h->size[0];
              eint = kb_cpu_y->size[0] * kb_cpu_y->size[1];
              kb_cpu_y->size[0] = 1;
              kb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(kb_cpu_y, eint, &kb_emlrtRTEI);
              kb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                kb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv46->size[0];
              cpu_iv46->size[0] = kb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv46, eint, &jb_emlrtRTEI);
              eint = kb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(kb_cpu_y, &ae_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv46, &gpu_iv46, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ae_gpu_y, kb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel769<<<grid, block>>>(offsetH, ae_gpu_y, eint,
                  gpu_iv46);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>(xx
                [0].f1->size[1]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(xx[0].f1->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv46->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              if (fx_data_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(q_cpu_expanded, &dc_gpu_expanded,
                  true);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel770<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv46,
                  omega_tmp2[0] - 1, dc_gpu_expanded, q_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = h_cpu_rows->size[0] * h_cpu_rows->size[1];
              h_cpu_rows->size[0] = 1;
              h_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(h_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                h_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  h_cpu_rows->data[k + 1] = itime;
                }
              }

              n = xx[0].f1->size[1];
              eint = c_cpu_cols->size[0] * c_cpu_cols->size[1];
              c_cpu_cols->size[0] = 1;
              c_cpu_cols->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_int32_T(c_cpu_cols, eint, &kb_emlrtRTEI);
              c_cpu_cols->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                c_cpu_cols->data[k + 1] = itime;
              }

              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = x_size_idx_1;
              d_cpu_w->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(eint), static_cast<uint32_T>
                  (b_blockDims[1]), 1U), &grid, &block);
                if (wav_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &u_gpu_yCol,
                    !c_omega_tmp1_needsGpuEnsureCapa);
                }

                gpuEmxEnsureCapacity_int32_T(c_cpu_cols, &g_gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(h_cpu_rows, &vb_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&u_gpu_yCol, b_cpu_yCol);
                }

                gpuEmxMemcpyCpuToGpu_int32_T(&g_gpu_cols, c_cpu_cols);
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&vb_gpu_rows, h_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel771<<<grid, block>>>(u_gpu_yCol, dc_gpu_expanded,
                    g_gpu_cols, vb_gpu_rows, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                    gb_gpu_w, q_cpu_expanded->size[0U], d_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
            }

            if (xx[0].f1->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = xx[0].f1->size[1];
            }

            eint = d_cpu_w->size[0] * d_cpu_w->size[1];
            d_cpu_w->size[0] = itime;
            d_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel772<<<grid, block>>>(eint, gb_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = itime;
              d_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel773<<<grid, block>>>(eint, gb_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (xx[0].f1->size[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              eint = l_cpu_c->size[0];
              l_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(l_cpu_c, eint, &hd_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(h_cpu_x, &i_gpu_x,
                !a_data_outdatedOnGpu);
              gpuEmxEnsureCapacity_real32_T(l_cpu_c, &l_gpu_c, true);
              if (a_data_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_real32_T(&i_gpu_x, h_cpu_x);
              }

              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &i_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&l_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = itime;
              d_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel774<<<grid, block>>>(l_gpu_c, eint, gb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              threadDims[0] = static_cast<int8_T>(itime);
              ix = xx[0].f1->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = o_cpu_expanded->size[0] * o_cpu_expanded->size[1];
              o_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_real32_T(o_cpu_expanded, eint, &jb_emlrtRTEI);
              if (xx[0].f1->size[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = xx[0].f1->size[1] + 1;
              }

              eint = o_cpu_expanded->size[0] * o_cpu_expanded->size[1];
              o_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(o_cpu_expanded, eint, &jb_emlrtRTEI);
              fx_data_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              if (xx[0].f1->size[1] > 2147483646) {
                nrefine = MAX_int32_T;
              } else {
                nrefine = xx[0].f1->size[1] + 1;
              }

              if ((nx - 1) * (nrefine - 1) - 1 >= 0) {
                gpuEmxEnsureCapacity_real32_T(o_cpu_expanded, &ec_gpu_expanded,
                  true);
                fx_data_outdatedOnCpu = false;
                cudaMemset(&ec_gpu_expanded.data[0], 0, static_cast<uint32_T>
                           (((nx * nrefine - nrefine) - nx) + 1) * sizeof
                           (real32_T));
              }

              n = b_cpu_csz[0];
              eint = ib_cpu_y->size[0] * ib_cpu_y->size[1];
              ib_cpu_y->size[0] = 1;
              ib_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(ib_cpu_y, eint, &kb_emlrtRTEI);
              ib_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ib_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv51->size[0];
              cpu_iv51->size[0] = ib_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv51, eint, &jb_emlrtRTEI);
              eint = ib_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ib_cpu_y, &be_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv51, &gpu_iv51, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&be_gpu_y, ib_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel775<<<grid, block>>>(offsetH, be_gpu_y, eint,
                  gpu_iv51);
              }

              n = xx[0].f1->size[1];
              eint = hc_cpu_y->size[0] * hc_cpu_y->size[1];
              hc_cpu_y->size[0] = 1;
              hc_cpu_y->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_int32_T(hc_cpu_y, eint, &kb_emlrtRTEI);
              hc_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                hc_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv69->size[0];
              cpu_iv69->size[0] = hc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv69, eint, &jb_emlrtRTEI);
              eint = hc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(hc_cpu_y, &ce_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv69, &gpu_iv69, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ce_gpu_y, hc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel776<<<grid, block>>>(ce_gpu_y, eint, gpu_iv69);
              }

              xt_size[0] = cpu_iv51->size[0];
              xt_size[1] = cpu_iv69->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(b_cpu_yCol, &u_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              if (fx_data_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(o_cpu_expanded, &ec_gpu_expanded,
                  true);
              }

              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&u_gpu_yCol, b_cpu_yCol);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel777<<<grid, block>>>(u_gpu_yCol, xt_size[0],
                  gpu_iv69, gpu_iv51, xt_size[0] - 1, xt_size[1] - 1,
                  ec_gpu_expanded, o_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              eint = n_cpu_rows->size[0] * n_cpu_rows->size[1];
              n_cpu_rows->size[0] = 1;
              n_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(n_cpu_rows, eint, &kb_emlrtRTEI);
              n_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                n_cpu_rows->data[k + 1] = itime;
              }

              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = static_cast<int32_T>(N);
              d_cpu_w->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(d_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), static_cast<uint32_T>(
                  static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(n_cpu_rows, &wb_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&wb_gpu_rows, n_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel778<<<grid, block>>>(ec_gpu_expanded,
                    wb_gpu_rows, b_gpu_h, x_size_idx_1 - 1, ix - 1, gb_gpu_w,
                    b_cpu_h->size[0U], o_cpu_expanded->size[0U], d_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            lb_y = nullptr;
            m33 = emlrtCreateCharArray(2, &iv32[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m33, &rfmt[0]);
            emlrtAssign(&lb_y, m33);
            sb_y = nullptr;
            m39 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&sb_y, m39);
            emlrt_marshallIn(b_sprintf(lb_y, sb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (d_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = d_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = d_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel752<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            nrefine = 1;
            pathlen = -1;
          } else {
            nrefine = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel753<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
            pathlen, nsubs, *gpu_csz);
          eint = o_cpu_w->size[0] * o_cpu_w->size[1];
          o_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          o_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(o_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(d_cpu_w, &gb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(o_cpu_w, &hb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel754<<<grid, block>>>(gb_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_lidx - 1, hb_gpu_w, o_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = wb_cpu_y->size[0] * wb_cpu_y->size[1];
          wb_cpu_y->size[0] = b_cpu_csz[0];
          wb_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(wb_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ud_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel755<<<grid, block>>>(hb_gpu_w, offsetH, ud_gpu_y);
          }

          Ly = std::ceil(((static_cast<real_T>(xx[0].f1->size[0]) - 1.0) * toler
                          + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(Ly);
            }

            n = w_cpu_w->size[0] * w_cpu_w->size[1];
            w_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            w_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_real32_T(w_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(w_cpu_w, &ib_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel756<<<grid, block>>>(gb_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_csz[1] - 1, ib_gpu_w, w_cpu_w->size[0U]);
            }

            n = wb_cpu_y->size[0] * wb_cpu_y->size[1];
            wb_cpu_y->size[0] = cpu_lidx;
            wb_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(wb_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(wb_cpu_y, &ud_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel757<<<grid, block>>>(ib_gpu_w, b_cpu_csz[0],
                cpu_lidx - 1, b_cpu_csz[1] - 1, ud_gpu_y, wb_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          eint = mc_cpu_y->size[0] * mc_cpu_y->size[1];
          mc_cpu_y->size[0] = 1;
          mc_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(mc_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(mc_cpu_y, &vd_gpu_y, true);
          f_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel733<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(vd_gpu_y);
        } else if (halfh < 1.0) {
          mc_cpu_y->size[0] = 1;
          mc_cpu_y->size[1] = 0;
        } else {
          eint = mc_cpu_y->size[0] * mc_cpu_y->size[1];
          mc_cpu_y->size[0] = 1;
          mc_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(mc_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(mc_cpu_y, &vd_gpu_y, true);
          f_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel735<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              vd_gpu_y);
          }
        }

        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = static_cast<int32_T>(halfh);
        cpu_y1->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_y1, eint, &oc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (f_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(mc_cpu_y, &vd_gpu_y, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_y1, &b_gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel734<<<grid, block>>>(ud_gpu_y, vd_gpu_y, T, static_cast<
            int32_T>(halfh) - 1, b_gpu_y1);
        }

        fx_data_outdatedOnCpu = true;
      } else {
        tol = std::ceil(static_cast<real_T>(xx[0].f1->size[0]) * toler / b_m);
        first_iteration = (xx[0].f1->size[0] == 1);
        if (first_iteration) {
          eint = xx[0].f1->size[0] * xx[0].f1->size[1];
          xx[0].f1->size[0] *= xx[0].f1->size[1];
          xx[0].f1->size[1] = 1;
          emxEnsureCapacity_real32_T(xx[0].f1, eint, &uc_emlrtRTEI);
        }

        if (!(toler - 1.0 >= 0.0)) {
          p_y = nullptr;
          m12 = emlrtCreateCharArray(2, &iv21[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m12, &rfmt[0]);
          emlrtAssign(&p_y, m12);
          x_y = nullptr;
          m20 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&x_y, m20);
          emlrt_marshallIn(b_sprintf(p_y, x_y, &emlrtMCI), "<output of sprintf>",
                           unusedExpr);
        }

        nx = xx[0].f1->size[0] * xx[0].f1->size[1];
        if ((xx[0].f1->size[0] == 1) && (xx[0].f1->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (xx[0].f1->size[0] != 1) {
            nsubs = 0;
          }
        }

        b_cpu_csz[0] = xx[0].f1->size[0];
        b_cpu_csz[1] = xx[0].f1->size[1];
        nrefine = xx[0].f1->size[0] * xx[0].f1->size[1];
        eint = e_cpu_yCol->size[0];
        e_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
        emxEnsureCapacity_real32_T(e_cpu_yCol, eint, &yc_emlrtRTEI);
        eint = nx * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(e_cpu_yCol, &v_gpu_yCol, true);
        wav_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel807<<<grid, block>>>(eint, v_gpu_yCol);
        }

        c_omega_tmp1_needsGpuEnsureCapa = false;
        x_data_outdatedOnGpu = true;
        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (nrefine * static_cast<
               int32_T>(toler) > 1)))) {
          cpu_lidx = 1;
          nrefine = 0;
        } else {
          cpu_lidx = static_cast<int32_T>(toler);
          nrefine = nx * static_cast<int32_T>(toler);
        }

        omega_tmp2[0] = div_s32(nrefine - 1, cpu_lidx) + 1;
        for (eint = 0; eint < omega_tmp2[0]; eint++) {
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real32_T(e_cpu_yCol, &v_gpu_yCol);
          }

          e_cpu_yCol->data[cpu_lidx * eint] = xx[0].f1->data[eint];
          x_data_outdatedOnGpu = false;
          c_omega_tmp1_needsGpuEnsureCapa = true;
          wav_outdatedOnCpu = true;
        }

        b_cpu_csz[nsubs] = xx[0].f1->size[nsubs] * static_cast<int32_T>(toler);
        eint = k_cpu_x->size[0] * k_cpu_x->size[1];
        k_cpu_x->size[0] = b_cpu_csz[0];
        k_cpu_x->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_real32_T(k_cpu_x, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        if (wav_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real32_T(e_cpu_yCol, &v_gpu_yCol,
            !c_omega_tmp1_needsGpuEnsureCapa);
        }

        gpuEmxEnsureCapacity_real32_T(k_cpu_x, &j_gpu_x, true);
        if (c_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real32_T(&v_gpu_yCol, e_cpu_yCol);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel808<<<grid, block>>>(v_gpu_yCol, offsetH, j_gpu_x);
        }

        if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
          if (b_cpu_csz[1] < 1) {
            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = 1;
            f_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel809<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(jb_gpu_w);
          } else {
            n = i_cpu_a->size[0];
            i_cpu_a->size[0] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(i_cpu_a, n, &fb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_a, &o_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel821<<<grid, block>>>(v_gpu_yCol, b_cpu_csz[1] - 1,
                o_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
            cpu_cv_re = b_cpu_h->data[0];
            eint = h_cpu_c->size[0];
            h_cpu_c->size[0] = i_cpu_a->size[0];
            emxEnsureCapacity_real32_T(h_cpu_c, eint, &hb_emlrtRTEI);
            eint = i_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(h_cpu_c, &m_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel822<<<grid, block>>>(eint, m_gpu_c);
            }

            if (i_cpu_a->size[0] == 1) {
              cpu_cv_re = b_cpu_h->data[0];
              eint = h_cpu_c->size[0];
              h_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(h_cpu_c, eint, &hb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(h_cpu_c, &m_gpu_c, true);
              ec_wtcc_kernel823<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cpu_cv_re, o_gpu_a, m_gpu_c);
            } else {
              itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (i_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(i_cpu_a->size[0]) +
                static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>(itime)));
              threadDims[0] = static_cast<int8_T>(itime);
              x_size_idx_1 = i_cpu_a->size[0];
              if (i_cpu_a->size[0] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = i_cpu_a->size[0] + 1;
              }

              eint = t_cpu_expanded->size[0];
              t_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_real32_T(t_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = i_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(t_cpu_expanded, &jc_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel825<<<grid, block>>>(eint, jc_gpu_expanded);
              }

              n = i_cpu_a->size[0];
              eint = nb_cpu_y->size[0] * nb_cpu_y->size[1];
              nb_cpu_y->size[0] = 1;
              nb_cpu_y->size[1] = i_cpu_a->size[0];
              emxEnsureCapacity_int32_T(nb_cpu_y, eint, &kb_emlrtRTEI);
              nb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                nb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv50->size[0];
              cpu_iv50->size[0] = nb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv50, eint, &jb_emlrtRTEI);
              eint = nb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(nb_cpu_y, &ke_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv50, &gpu_iv50, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ke_gpu_y, nb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel826<<<grid, block>>>(ke_gpu_y, eint, gpu_iv50);
              }

              omega_tmp2[0] = cpu_iv50->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel827<<<grid, block>>>(o_gpu_a, gpu_iv50,
                  omega_tmp2[0] - 1, jc_gpu_expanded);
              }

              eint = h_cpu_c->size[0];
              h_cpu_c->size[0] = i_cpu_a->size[0];
              emxEnsureCapacity_real32_T(h_cpu_c, eint, &jb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
              gpuEmxEnsureCapacity_real32_T(h_cpu_c, &m_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel828<<<grid, block>>>(cpu_cv_re, jc_gpu_expanded,
                  x_size_idx_1 - 1, m_gpu_c);
              }
            }

            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = 1;
            f_cpu_w->size[1] = h_cpu_c->size[0];
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = h_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel824<<<grid, block>>>(m_gpu_c, offsetH, jb_gpu_w,
                f_cpu_w->size[0U]);
            }
          }
        } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
          if (b_cpu_csz[0] == 0) {
            itime = b_cpu_h->size[0];
          } else {
            itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = f_cpu_w->size[0] * f_cpu_w->size[1];
          f_cpu_w->size[0] = itime;
          f_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel829<<<grid, block>>>(eint, jb_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = itime;
            f_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel830<<<grid, block>>>(eint, jb_gpu_w);
            }
          } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                      (b_cpu_csz[1] == 1))) {
            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = 1;
            f_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel831<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (v_gpu_yCol, b_gpu_h, jb_gpu_w);
          } else {
            r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                 (b_cpu_csz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              eint = static_cast<int32_T>(s);
            } else {
              eint = MIN_int32_T;
            }

            b_blockDims[0] = eint;
            b_blockDims[1] = cpu_lidx;
            ix = b_cpu_csz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                x_size_idx_1 = static_cast<int32_T>(r);
              } else {
                x_size_idx_1 = MIN_int32_T;
              }
            } else {
              x_size_idx_1 = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T - x_size_idx_1))
            {
              nx = MIN_int32_T;
            } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                        - x_size_idx_1)) {
              nx = MAX_int32_T;
            } else {
              nx = x_size_idx_1 + b_cpu_csz[0];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = ab_cpu_expanded->size[0] * ab_cpu_expanded->size[1];
            ab_cpu_expanded->size[0] = nx;
            emxEnsureCapacity_real32_T(ab_cpu_expanded, eint, &jb_emlrtRTEI);
            if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz[1]))
            {
              nx = MIN_int32_T;
            } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                        - b_cpu_csz[1])) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + b_cpu_csz[1];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = ab_cpu_expanded->size[0] * ab_cpu_expanded->size[1];
            ab_cpu_expanded->size[1] = nx;
            emxEnsureCapacity_real32_T(ab_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
              b_cpu_csz[1]) - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(ab_cpu_expanded, &kc_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel832<<<grid, block>>>(eint, kc_gpu_expanded);
            }

            n = b_cpu_h->size[0];
            eint = ub_cpu_y->size[0] * ub_cpu_y->size[1];
            ub_cpu_y->size[0] = 1;
            ub_cpu_y->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(ub_cpu_y, eint, &kb_emlrtRTEI);
            ub_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              ub_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv54->size[0];
            cpu_iv54->size[0] = ub_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv54, eint, &jb_emlrtRTEI);
            eint = ub_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(ub_cpu_y, &le_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv54, &gpu_iv54, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&le_gpu_y, ub_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel833<<<grid, block>>>(offsetH, le_gpu_y, eint,
                gpu_iv54);
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv54->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel834<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv54,
                omega_tmp2[0] - 1, kc_gpu_expanded, ab_cpu_expanded->size[0U]);
            }

            if (b_cpu_csz[0] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[0] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            y_needsGpuEnsureCapacity = false;
            eint = j_cpu_rows->size[0] * j_cpu_rows->size[1];
            j_cpu_rows->size[0] = 1;
            j_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(j_cpu_rows, eint, &kb_emlrtRTEI);
            if (n > 0) {
              j_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                j_cpu_rows->data[k + 1] = itime;
              }
            }

            if (b_cpu_csz[1] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[1] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            interval_outdatedOnGpu = false;
            eint = f_cpu_cols->size[0] * f_cpu_cols->size[1];
            f_cpu_cols->size[0] = 1;
            f_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(f_cpu_cols, eint, &kb_emlrtRTEI);
            if (n > 0) {
              f_cpu_cols->data[0] = 0;
              interval_outdatedOnGpu = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                f_cpu_cols->data[k + 1] = itime;
              }
            }

            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = x_size_idx_1;
            f_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              n = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                n = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                static_cast<uint32_T>(n), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(f_cpu_cols, &h_gpu_cols,
                !interval_outdatedOnGpu);
              gpuEmxEnsureCapacity_int32_T(j_cpu_rows, &cc_gpu_rows,
                !y_needsGpuEnsureCapacity);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&h_gpu_cols, f_cpu_cols);
              }

              if (y_needsGpuEnsureCapacity) {
                gpuEmxMemcpyCpuToGpu_int32_T(&cc_gpu_rows, j_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel835<<<grid, block>>>(v_gpu_yCol, kc_gpu_expanded,
                  h_gpu_cols, cc_gpu_rows, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                  jb_gpu_w, ab_cpu_expanded->size[0U], f_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (b_cpu_csz[0] == 0) {
            itime = b_cpu_h->size[0];
          } else {
            itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = f_cpu_w->size[0] * f_cpu_w->size[1];
          f_cpu_w->size[0] = itime;
          f_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel836<<<grid, block>>>(eint, jb_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = itime;
            f_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel837<<<grid, block>>>(eint, jb_gpu_w);
            }
          } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                     (b_cpu_h->size[0] == 1)) {
            eint = o_cpu_c->size[0];
            o_cpu_c->size[0] = 1;
            emxEnsureCapacity_real32_T(o_cpu_c, eint, &hd_emlrtRTEI);
            cpu_cv_re = 1.0F;
            cv_im = 0.0F;
            gpuEmxEnsureCapacity_real32_T(o_cpu_c, &n_gpu_c, true);
            cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
              CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)&j_gpu_x.data
              [0], 1, (float *)&b_gpu_h.data[0], 1, (float *)&cv_im, (float *)
              &n_gpu_c.data[0], 1), __FILE__, __LINE__);
            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = itime;
            f_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel838<<<grid, block>>>(n_gpu_c, eint, jb_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                 (b_cpu_h->size[0])) - 1U;
            itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((static_cast<real_T>(N) +
              (static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            b_blockDims[0] = itime;
            ix = b_cpu_csz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            x_size_idx_1 = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              nx = MAX_int32_T;
            } else {
              nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
            }

            eint = x_cpu_expanded->size[0] * x_cpu_expanded->size[1];
            x_cpu_expanded->size[0] = nx - 1;
            emxEnsureCapacity_real32_T(x_cpu_expanded, eint, &jb_emlrtRTEI);
            if (b_cpu_csz[1] > 2147483646) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + 1;
            }

            eint = x_cpu_expanded->size[0] * x_cpu_expanded->size[1];
            x_cpu_expanded->size[1] = nx - 1;
            emxEnsureCapacity_real32_T(x_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
              b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(x_cpu_expanded, &lc_gpu_expanded, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel839<<<grid, block>>>(eint, lc_gpu_expanded);
            }

            n = b_cpu_csz[0];
            eint = qb_cpu_y->size[0] * qb_cpu_y->size[1];
            qb_cpu_y->size[0] = 1;
            qb_cpu_y->size[1] = b_cpu_csz[0];
            emxEnsureCapacity_int32_T(qb_cpu_y, eint, &kb_emlrtRTEI);
            qb_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              qb_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv57->size[0];
            cpu_iv57->size[0] = qb_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv57, eint, &jb_emlrtRTEI);
            eint = qb_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(qb_cpu_y, &me_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv57, &gpu_iv57, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&me_gpu_y, qb_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel840<<<grid, block>>>(offsetH, me_gpu_y, eint,
                gpu_iv57);
            }

            if (b_cpu_csz[1] < 1) {
              n = 0;
            } else {
              n = b_cpu_csz[1];
            }

            fx_data_outdatedOnCpu = false;
            eint = qc_cpu_y->size[0] * qc_cpu_y->size[1];
            qc_cpu_y->size[0] = 1;
            qc_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(qc_cpu_y, eint, &kb_emlrtRTEI);
            if (n > 0) {
              qc_cpu_y->data[0] = 1;
              fx_data_outdatedOnCpu = true;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                qc_cpu_y->data[k + 1] = itime;
              }
            }

            eint = cpu_iv74->size[0];
            cpu_iv74->size[0] = qc_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv74, eint, &jb_emlrtRTEI);
            eint = qc_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(qc_cpu_y, &ne_gpu_y,
              !fx_data_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv74, &gpu_iv74, true);
            if (fx_data_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&ne_gpu_y, qc_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel841<<<grid, block>>>(ne_gpu_y, eint, gpu_iv74);
            }

            xt_size[0] = cpu_iv57->size[0];
            xt_size[1] = cpu_iv74->size[0];
            mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel842<<<grid, block>>>(v_gpu_yCol, xt_size[0],
                gpu_iv74, gpu_iv57, xt_size[0] - 1, xt_size[1] - 1,
                lc_gpu_expanded, x_cpu_expanded->size[0U]);
            }

            n = b_cpu_h->size[0];
            eint = t_cpu_rows->size[0] * t_cpu_rows->size[1];
            t_cpu_rows->size[0] = 1;
            t_cpu_rows->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(t_cpu_rows, eint, &kb_emlrtRTEI);
            t_cpu_rows->data[0] = 0;
            itime = 0;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              t_cpu_rows->data[k + 1] = itime;
            }

            eint = f_cpu_w->size[0] * f_cpu_w->size[1];
            f_cpu_w->size[0] = static_cast<int32_T>(N);
            f_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(f_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = cpu_lidx;
              if (cpu_lidx < 0) {
                eint = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(b_blockDims[0]),
                static_cast<uint32_T>(eint), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(t_cpu_rows, &dc_gpu_rows, false);
              gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              gpuEmxMemcpyCpuToGpu_int32_T(&dc_gpu_rows, t_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel843<<<grid, block>>>(lc_gpu_expanded, dc_gpu_rows,
                  b_gpu_h, x_size_idx_1 - 1, ix - 1, jb_gpu_w, b_cpu_h->size[0U],
                  x_cpu_expanded->size[0U], f_cpu_w->size[0U]);
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          nb_y = nullptr;
          m37 = emlrtCreateCharArray(2, &iv36[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m37, &rfmt[0]);
          emlrtAssign(&nb_y, m37);
          ub_y = nullptr;
          m44 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&ub_y, m44);
          emlrt_marshallIn(b_sprintf(nb_y, ub_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (f_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        interval_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = false;
        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = f_cpu_w->size[itime];
          fx_data_outdatedOnCpu = true;
          cpu_csz[itime] = f_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel810<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *b_gpu_csz);
          }

          checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        cpu_lidx = cpu_csz[0];
        cpu_csz[0] = cpu_csz[1];
        cpu_csz[1] = cpu_lidx;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
          nrefine = 1;
          pathlen = -1;
        } else {
          nrefine = static_cast<int32_T>(b_m);
          pathlen = cpu_csz[0] - 1;
        }

        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel811<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
          pathlen, nsubs, *gpu_csz);
        eint = t_cpu_w->size[0] * t_cpu_w->size[1];
        t_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
        t_cpu_w->size[1] = cpu_lidx;
        emxEnsureCapacity_real32_T(t_cpu_w, eint, &jd_emlrtRTEI);
        eint = pathlen / nrefine;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real32_T(f_cpu_w, &jb_gpu_w, true);
        }

        gpuEmxEnsureCapacity_real32_T(t_cpu_w, &kb_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel812<<<grid, block>>>(jb_gpu_w, cpu_csz[0], nrefine, eint,
            cpu_lidx - 1, kb_gpu_w, t_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        eint = ac_cpu_y->size[0] * ac_cpu_y->size[1];
        ac_cpu_y->size[0] = b_cpu_csz[0];
        ac_cpu_y->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_real32_T(ac_cpu_y, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(ac_cpu_y, &he_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel813<<<grid, block>>>(kb_gpu_w, offsetH, he_gpu_y);
        }

        Ly = std::ceil(((static_cast<real_T>(xx[0].f1->size[0]) - 1.0) * toler +
                        static_cast<real_T>(b_cpu_h->size[0])) / b_m);
        if (!(b_cpu_csz[0] < Ly)) {
          if (Ly < 1.0) {
            cpu_lidx = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(Ly);
          }

          n = db_cpu_w->size[0] * db_cpu_w->size[1];
          db_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          db_cpu_w->size[1] = cpu_csz[1];
          emxEnsureCapacity_real32_T(db_cpu_w, n, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(db_cpu_w, &lb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel814<<<grid, block>>>(jb_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_csz[1] - 1, lb_gpu_w, db_cpu_w->size[0U]);
          }

          n = ac_cpu_y->size[0] * ac_cpu_y->size[1];
          ac_cpu_y->size[0] = cpu_lidx;
          ac_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(ac_cpu_y, n, &gd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx - 1),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(ac_cpu_y, &he_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel815<<<grid, block>>>(lb_gpu_w, b_cpu_csz[0], cpu_lidx
              - 1, b_cpu_csz[1] - 1, he_gpu_y, ac_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = ac_cpu_y->size[0] * ac_cpu_y->size[1];
          eint = yd_cpu_y->size[0] * yd_cpu_y->size[1];
          yd_cpu_y->size[0] = 1;
          yd_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(yd_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(yd_cpu_y, &ie_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel816<<<grid, block>>>(he_gpu_y, omega_tmp2[0] - 1,
              ie_gpu_y, yd_cpu_y->size[0U]);
          }

          eint = ac_cpu_y->size[0] * ac_cpu_y->size[1];
          ac_cpu_y->size[0] = 1;
          ac_cpu_y->size[1] = yd_cpu_y->size[1];
          emxEnsureCapacity_real32_T(ac_cpu_y, eint, &md_emlrtRTEI);
          eint = yd_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(ac_cpu_y, &he_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel817<<<grid, block>>>(ie_gpu_y, eint, he_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          eint = uc_cpu_y->size[0] * uc_cpu_y->size[1];
          uc_cpu_y->size[0] = 1;
          uc_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(uc_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(uc_cpu_y, &je_gpu_y, true);
          g_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel818<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(je_gpu_y);
        } else if (tol < 1.0) {
          uc_cpu_y->size[0] = 1;
          uc_cpu_y->size[1] = 0;
        } else {
          eint = uc_cpu_y->size[0] * uc_cpu_y->size[1];
          uc_cpu_y->size[0] = 1;
          uc_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(uc_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(uc_cpu_y, &je_gpu_y, true);
          g_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel820<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              je_gpu_y);
          }
        }

        cpu_lidx = ac_cpu_y->size[1];
        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = uc_cpu_y->size[1];
        cpu_y1->size[1] = ac_cpu_y->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, eint, &oc_emlrtRTEI);
        eint = uc_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (g_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(uc_cpu_y, &je_gpu_y, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_y1, &b_gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel819<<<grid, block>>>(he_gpu_y, je_gpu_y, T, eint,
            cpu_lidx - 1, b_gpu_y1, cpu_y1->size[0U], ac_cpu_y->size[0U]);
        }

        fx_data_outdatedOnCpu = true;
      }

      emxFree_real32_T(&db_cpu_w);
      emxFree_real32_T(&be_cpu_y);
      emxFree_real32_T(&yd_cpu_y);
      emxFree_real32_T(&ab_cpu_w);
      emxFree_real32_T(&w_cpu_w);
      emxFree_real32_T(&t_cpu_w);
      emxFree_real32_T(&r_cpu_w);
      emxFree_real32_T(&o_cpu_w);
      emxFree_int32_T(&vb_cpu_rows);
      emxFree_int32_T(&tb_cpu_rows);
      emxFree_int32_T(&qb_cpu_rows);
      emxFree_int32_T(&cpu_iv102);
      emxFree_int32_T(&nb_cpu_rows);
      emxFree_int32_T(&kb_cpu_rows);
      emxFree_int32_T(&cpu_iv97);
      emxFree_int32_T(&hb_cpu_rows);
      emxFree_int32_T(&eb_cpu_rows);
      emxFree_int32_T(&cpu_iv91);
      emxFree_int32_T(&ab_cpu_rows);
      emxFree_int32_T(&cpu_iv89);
      emxFree_int32_T(&cpu_iv88);
      emxFree_int32_T(&w_cpu_rows);
      emxFree_int32_T(&f_cpu_cols);
      emxFree_int32_T(&cpu_iv83);
      emxFree_int32_T(&ud_cpu_y);
      emxFree_int32_T(&cpu_iv78);
      emxFree_int32_T(&t_cpu_rows);
      emxFree_int32_T(&rd_cpu_y);
      emxFree_int32_T(&q_cpu_rows);
      emxFree_int32_T(&c_cpu_cols);
      emxFree_int32_T(&cpu_iv76);
      emxFree_real32_T(&ec_cpu_expanded);
      emxFree_real32_T(&bc_cpu_expanded);
      emxFree_int32_T(&od_cpu_y);
      emxFree_int32_T(&n_cpu_rows);
      emxFree_int32_T(&ld_cpu_y);
      emxFree_int32_T(&cpu_iv74);
      emxFree_int32_T(&id_cpu_y);
      emxFree_real32_T(&yb_cpu_expanded);
      emxFree_real32_T(&wb_cpu_expanded);
      emxFree_int32_T(&ed_cpu_y);
      emxFree_real32_T(&tb_cpu_expanded);
      emxFree_real32_T(&qb_cpu_expanded);
      emxFree_int32_T(&cpu_iv69);
      emxFree_int32_T(&cd_cpu_y);
      emxFree_int32_T(&j_cpu_rows);
      emxFree_int32_T(&cpu_iv66);
      emxFree_int32_T(&ad_cpu_y);
      emxFree_int32_T(&cpu_iv64);
      emxFree_real32_T(&mb_cpu_expanded);
      emxFree_real32_T(&kb_cpu_expanded);
      emxFree_real_T(&uc_cpu_y);
      emxFree_int32_T(&h_cpu_rows);
      emxFree_real32_T(&sc_cpu_y);
      emxFree_int32_T(&qc_cpu_y);
      emxFree_int32_T(&cpu_iv57);
      emxFree_real_T(&mc_cpu_y);
      emxFree_int32_T(&cpu_iv54);
      emxFree_int32_T(&kc_cpu_y);
      emxFree_int32_T(&hc_cpu_y);
      emxFree_int32_T(&ec_cpu_y);
      emxFree_int32_T(&cpu_iv51);
      emxFree_int32_T(&cpu_iv50);
      emxFree_real32_T(&gb_cpu_expanded);
      emxFree_real32_T(&db_cpu_expanded);
      emxFree_int32_T(&cpu_iv46);
      emxFree_real32_T(&ac_cpu_y);
      emxFree_real32_T(&f_cpu_result);
      emxFree_int32_T(&cpu_iv44);
      emxFree_real32_T(&wb_cpu_y);
      emxFree_int32_T(&ub_cpu_y);
      emxFree_real32_T(&c_cpu_result);
      emxFree_int32_T(&qb_cpu_y);
      emxFree_real32_T(&r_cpu_c);
      emxFree_int32_T(&nb_cpu_y);
      emxFree_real32_T(&ab_cpu_expanded);
      emxFree_real32_T(&x_cpu_expanded);
      emxFree_int32_T(&kb_cpu_y);
      emxFree_int32_T(&ib_cpu_y);
      emxFree_real32_T(&t_cpu_expanded);
      emxFree_int32_T(&fb_cpu_y);
      emxFree_real32_T(&q_cpu_expanded);
      emxFree_real32_T(&o_cpu_expanded);
      emxFree_real32_T(&l_cpu_expanded);
      emxFree_real32_T(&o_cpu_c);
      emxFree_real32_T(&l_cpu_c);
      emxFree_real32_T(&e_a);
      emxFree_real32_T(&e_c);
      emxFree_real32_T(&i_cpu_a);
      emxFree_real32_T(&h_cpu_c);
      emxFree_real32_T(&f_cpu_a);
      emxFree_real32_T(&f_cpu_c);
      emxFree_real32_T(&i_cpu_w);
      emxFree_real32_T(&n_cpu_x);
      emxFree_real32_T(&f_cpu_w);
      emxFree_real32_T(&d_cpu_w);
      emxFree_real32_T(&k_cpu_x);
      emxFree_real32_T(&h_cpu_yCol);
      emxFree_real32_T(&h_cpu_x);
      emxFree_real32_T(&e_cpu_yCol);
      emxFree_real32_T(&b_cpu_yCol);
      if ((cpu_y1->size[0] == 0) || (cpu_y1->size[1] == 0)) {
        pathlen = 0;
      } else {
        itime = cpu_y1->size[0];
        pathlen = cpu_y1->size[1];
        if (itime >= pathlen) {
          pathlen = itime;
        }
      }

      eint = xx[0].f1->size[0] * xx[0].f1->size[1];
      xx[0].f1->size[0] = 1;
      xx[0].f1->size[1] = pathlen;
      emxEnsureCapacity_real32_T(xx[0].f1, eint, &wc_emlrtRTEI);
      for (eint = 0; eint < pathlen; eint++) {
        if (fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_y1, &b_gpu_y1);
        }

        fx_data_outdatedOnCpu = false;
        xx[0].f1->data[eint] = cpu_y1->data[eint];
      }
    } else {
      emxInit_real32_T(&cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&d_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&j_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&c_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&e_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&m_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&e_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&e_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&d_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&d_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&k_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&n_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&k_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&n_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&p_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&eb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&s_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&w_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&y_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&mb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&q_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_int32_T(&pb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&b_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&tb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&vb_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv43, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&e_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_real32_T(&yb_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv45, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&cb_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&fb_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv48, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv49, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&dc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv53, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&lc_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv56, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&rc_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&g_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&tc_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_real32_T(&jb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&lb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv63, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&yc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv65, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&i_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&bd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv68, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&pb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&sb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&dd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&vb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&xb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv73, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&m_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ac_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&dc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv75, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&b_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&p_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&s_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv77, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&td_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv81, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&e_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&v_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv86, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv87, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&y_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv90, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&db_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv96, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&mb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv100, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&sb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ub_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&n_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&q_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&s_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&v_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&y_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&xd_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&ae_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&cb_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((!(toler == 1.0)) || (!(b_m == 1.0))) {
        if ((xx[0].f1->size[0] == 1) || (xx[0].f1->size[1] == 1)) {
          if ((xx[0].f1->size[0] == 0) || (xx[0].f1->size[1] == 0)) {
            pathlen = 0;
          } else {
            itime = xx[0].f1->size[0];
            pathlen = xx[0].f1->size[1];
            if (itime >= pathlen) {
              pathlen = itime;
            }
          }

          halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
          if ((xx[0].f1->size[0] == 1) && (xx[0].f1->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              t_y = nullptr;
              m22 = emlrtCreateCharArray(2, &iv27[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m22, &rfmt[0]);
              emlrtAssign(&t_y, m22);
              db_y = nullptr;
              m28 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&db_y, m28);
              emlrt_marshallIn(b_sprintf(t_y, db_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            eint = g_cpu_yCol->size[0];
            g_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(g_cpu_yCol, eint, &yc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_yCol, &w_gpu_yCol, true);
            wav_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel872<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                w_gpu_yCol);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            x_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              nrefine = 1;
              cpu_lidx = 0;
            } else {
              nrefine = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            omega_tmp2[0] = div_s32(cpu_lidx - 1, nrefine) + 1;
            for (eint = 0; eint < omega_tmp2[0]; eint++) {
              if (x_data_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(g_cpu_yCol, &w_gpu_yCol);
              }

              g_cpu_yCol->data[nrefine * eint] = xx[0].f1->data[eint];
              x_data_outdatedOnGpu = false;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              wav_outdatedOnCpu = true;
            }

            ec_wtcc_kernel873<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_csz);
            eint = m_cpu_x->size[0] * m_cpu_x->size[1];
            m_cpu_x->size[0] = static_cast<int32_T>(toler);
            m_cpu_x->size[1] = 1;
            emxEnsureCapacity_real32_T(m_cpu_x, eint, &ed_emlrtRTEI);
            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[0] - 1), &grid,
              &block, 2147483647U);
            if (wav_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real32_T(g_cpu_yCol, &w_gpu_yCol,
                !c_omega_tmp1_needsGpuEnsureCapa);
            }

            gpuEmxEnsureCapacity_real32_T(m_cpu_x, &k_gpu_x, true);
            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxMemcpyCpuToGpu_real32_T(&w_gpu_yCol, g_cpu_yCol);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel874<<<grid, block>>>(w_gpu_yCol, b_cpu_csz[0] - 1,
                k_gpu_x);
            }

            if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              eint = d_a->size[0];
              d_a->size[0] = 1;
              emxEnsureCapacity_real32_T(d_a, eint, &fb_emlrtRTEI);
              if (x_data_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(g_cpu_yCol, &w_gpu_yCol);
              }

              d_a->data[0] = g_cpu_yCol->data[0];
              ec_wtcc_kernel875<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                gpu_cv_re);
              eint = d_c->size[0];
              d_c->size[0] = 1;
              emxEnsureCapacity_real32_T(d_c, eint, &hb_emlrtRTEI);
              checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              d_c->data[0] = d_a->data[0] * cpu_cv_re;
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = 1;
              h_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
              h_cpu_w->data[0] = d_c->data[0];
              x_data_outdatedOnGpu = true;
              a_data_outdatedOnGpu = true;
            } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
              if (b_cpu_csz[0] == 0) {
                itime = b_cpu_h->size[0];
              } else {
                itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
              }

              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = itime;
              h_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel885<<<grid, block>>>(itime - 1, mb_gpu_w);
              }

              x_data_outdatedOnGpu = false;
              if (b_cpu_csz[0] == 0) {
                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = itime;
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel886<<<grid, block>>>(itime - 1, mb_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && (b_cpu_csz[0] == 1)) {
                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = 1;
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel887<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (w_gpu_yCol, b_gpu_h, mb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (b_cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                b_blockDims[0] = eint;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    x_size_idx_1 = static_cast<int32_T>(r);
                  } else {
                    x_size_idx_1 = MIN_int32_T;
                  }
                } else {
                  x_size_idx_1 = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                     - x_size_idx_1)) {
                  nx = MIN_int32_T;
                } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                            - x_size_idx_1)) {
                  nx = MAX_int32_T;
                } else {
                  nx = x_size_idx_1 + b_cpu_csz[0];
                }

                if (nx >= -2147483647) {
                  nx--;
                }

                eint = fb_cpu_expanded->size[0] * fb_cpu_expanded->size[1];
                fb_cpu_expanded->size[0] = nx;
                fb_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(fb_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = (x_size_idx_1 + b_cpu_csz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(fb_cpu_expanded, &qc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel888<<<grid, block>>>(eint, qc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                eint = jc_cpu_y->size[0] * jc_cpu_y->size[1];
                jc_cpu_y->size[0] = 1;
                jc_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(jc_cpu_y, eint, &kb_emlrtRTEI);
                jc_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  jc_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv63->size[0];
                cpu_iv63->size[0] = jc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv63, eint, &jb_emlrtRTEI);
                eint = jc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(jc_cpu_y, &we_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv63, &gpu_iv63, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&we_gpu_y, jc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel889<<<grid, block>>>(offsetH, we_gpu_y, eint,
                    gpu_iv63);
                }

                omega_tmp2[0] = cpu_iv63->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel890<<<grid, block>>>(b_gpu_h, gpu_iv63,
                    omega_tmp2[0] - 1, qc_gpu_expanded);
                }

                if (b_cpu_csz[0] < -2147483647) {
                  nx = MIN_int32_T;
                } else {
                  nx = b_cpu_csz[0] - 1;
                }

                if (nx < 0) {
                  n = 0;
                } else {
                  n = nx + 1;
                }

                y_needsGpuEnsureCapacity = false;
                eint = p_cpu_rows->size[0] * p_cpu_rows->size[1];
                p_cpu_rows->size[0] = 1;
                p_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(p_cpu_rows, eint, &kb_emlrtRTEI);
                if (n > 0) {
                  p_cpu_rows->data[0] = 0;
                  y_needsGpuEnsureCapacity = true;
                  itime = 0;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    p_cpu_rows->data[k + 1] = itime;
                  }
                }

                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = x_size_idx_1;
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (x_size_idx_1 != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                    dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(p_cpu_rows, &ic_gpu_rows,
                    !y_needsGpuEnsureCapacity);
                  gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&ic_gpu_rows, p_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel891<<<grid, block>>>(w_gpu_yCol,
                      qc_gpu_expanded, ic_gpu_rows, *gpu_csz, x_size_idx_1 - 1,
                      mb_gpu_w);
                  }
                }
              }
            } else {
              if (b_cpu_csz[0] == 0) {
                itime = b_cpu_h->size[0];
              } else {
                itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
              }

              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = itime;
              h_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel892<<<grid, block>>>(itime - 1, mb_gpu_w);
              }

              x_data_outdatedOnGpu = false;
              if (b_cpu_csz[0] == 0) {
                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = itime;
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel893<<<grid, block>>>(itime - 1, mb_gpu_w);
                }
              } else if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                eint = q_cpu_c->size[0];
                q_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(q_cpu_c, eint, &hd_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(q_cpu_c, &o_gpu_c, true);
                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &k_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&o_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = itime;
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel894<<<grid, block>>>(o_gpu_c, itime - 1,
                    mb_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                     (b_cpu_h->size[0])) - 1U;
                itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
                b_blockDims[0] = itime;
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                x_size_idx_1 = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  nx = MAX_int32_T;
                } else {
                  nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = cb_cpu_expanded->size[0] * cb_cpu_expanded->size[1];
                cb_cpu_expanded->size[0] = nx - 1;
                cb_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(cb_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(cb_cpu_expanded, &rc_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel895<<<grid, block>>>(eint, rc_gpu_expanded);
                }

                n = b_cpu_csz[0];
                eint = dc_cpu_y->size[0] * dc_cpu_y->size[1];
                dc_cpu_y->size[0] = 1;
                dc_cpu_y->size[1] = b_cpu_csz[0];
                emxEnsureCapacity_int32_T(dc_cpu_y, eint, &kb_emlrtRTEI);
                dc_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  dc_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv65->size[0];
                cpu_iv65->size[0] = dc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv65, eint, &jb_emlrtRTEI);
                eint = dc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(dc_cpu_y, &xe_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv65, &gpu_iv65, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xe_gpu_y, dc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel896<<<grid, block>>>(offsetH, xe_gpu_y, eint,
                    gpu_iv65);
                }

                xt_size[0] = cpu_iv65->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel897<<<grid, block>>>(w_gpu_yCol, gpu_iv65,
                    xt_size[0] - 1, rc_gpu_expanded);
                }

                n = b_cpu_h->size[0];
                eint = gb_cpu_rows->size[0] * gb_cpu_rows->size[1];
                gb_cpu_rows->size[0] = 1;
                gb_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(gb_cpu_rows, eint, &kb_emlrtRTEI);
                gb_cpu_rows->data[0] = 0;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  gb_cpu_rows->data[k + 1] = itime;
                }

                eint = h_cpu_w->size[0] * h_cpu_w->size[1];
                h_cpu_w->size[0] = static_cast<int32_T>(N);
                h_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(h_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                    dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(b_blockDims[0]),
                    1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(gb_cpu_rows, &jc_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&jc_gpu_rows, gb_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel898<<<grid, block>>>(rc_gpu_expanded,
                      jc_gpu_rows, b_gpu_h, x_size_idx_1 - 1, mb_gpu_w,
                      b_cpu_h->size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              ob_y = nullptr;
              m45 = emlrtCreateCharArray(2, &iv38[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m45, &rfmt[0]);
              emlrtAssign(&ob_y, m45);
              vb_y = nullptr;
              m49 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&vb_y, m49);
              emlrt_marshallIn(b_sprintf(ob_y, vb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (h_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              b_cpu_csz[itime] = h_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_csz[itime] = h_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel876<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *b_gpu_csz);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_csz[0];
            cpu_csz[0] = cpu_csz[1];
            cpu_csz[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
              nrefine = 1;
              pathlen = -1;
            } else {
              nrefine = static_cast<int32_T>(b_m);
              pathlen = cpu_csz[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel877<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
              pathlen, nsubs, *gpu_csz);
            eint = q_cpu_w->size[0] * q_cpu_w->size[1];
            q_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            q_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(q_cpu_w, eint, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
              &block, 2147483647U);
            if (a_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real32_T(h_cpu_w, &mb_gpu_w,
                !x_data_outdatedOnGpu);
            }

            gpuEmxEnsureCapacity_real32_T(q_cpu_w, &nb_gpu_w, true);
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyCpuToGpu_real32_T(&mb_gpu_w, h_cpu_w);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel878<<<grid, block>>>(mb_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_lidx - 1, nb_gpu_w, q_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = rc_cpu_y->size[0] * rc_cpu_y->size[1];
            rc_cpu_y->size[0] = b_cpu_csz[0];
            rc_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(rc_cpu_y, eint, &ed_emlrtRTEI);
            offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(rc_cpu_y, &se_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel879<<<grid, block>>>(nb_gpu_w, offsetH, se_gpu_y);
            }

            Ly = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0]))
                           / b_m);
            if (!(b_cpu_csz[0] < Ly)) {
              if (Ly < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(Ly);
              }

              n = y_cpu_w->size[0] * y_cpu_w->size[1];
              y_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
              y_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_real32_T(y_cpu_w, n, &jd_emlrtRTEI);
              eint = pathlen / nrefine;
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(y_cpu_w, &ob_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel880<<<grid, block>>>(mb_gpu_w, cpu_csz[0], nrefine,
                  eint, cpu_csz[1] - 1, ob_gpu_w, y_cpu_w->size[0U]);
              }

              n = rc_cpu_y->size[0] * rc_cpu_y->size[1];
              rc_cpu_y->size[0] = cpu_lidx;
              rc_cpu_y->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_real32_T(rc_cpu_y, n, &gd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx
                - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(rc_cpu_y, &se_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel881<<<grid, block>>>(ob_gpu_w, b_cpu_csz[0],
                  cpu_lidx - 1, b_cpu_csz[1] - 1, se_gpu_y, rc_cpu_y->size[0U]);
              }
            }

            if (rc_cpu_y->size[0] * rc_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = rc_cpu_y->size[0] * rc_cpu_y->size[1];
            }

            omega_tmp2[0] = rc_cpu_y->size[0] * rc_cpu_y->size[1];
            eint = ae_cpu_y->size[0] * ae_cpu_y->size[1];
            ae_cpu_y->size[0] = 1;
            ae_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(ae_cpu_y, eint, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(ae_cpu_y, &te_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel882<<<grid, block>>>(se_gpu_y, omega_tmp2[0] - 1,
                te_gpu_y);
            }

            eint = vb_cpu_y->size[0] * vb_cpu_y->size[1];
            vb_cpu_y->size[0] = n;
            vb_cpu_y->size[1] = 1;
            emxEnsureCapacity_real32_T(vb_cpu_y, eint, &ld_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(vb_cpu_y, &ue_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel883<<<grid, block>>>(te_gpu_y, n - 1, ue_gpu_y);
            }

            interval_outdatedOnGpu = true;
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              s_y = nullptr;
              m11 = emlrtCreateCharArray(2, &iv20[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m11, &rfmt[0]);
              emlrtAssign(&s_y, m11);
              cb_y = nullptr;
              m19 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&cb_y, m19);
              emlrt_marshallIn(b_sprintf(s_y, cb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nx = xx[0].f1->size[0] * xx[0].f1->size[1];
            b_cpu_csz[1] = xx[0].f1->size[1];
            nrefine = xx[0].f1->size[0] * xx[0].f1->size[1];
            eint = cpu_yCol->size[0];
            cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
            emxEnsureCapacity_real32_T(cpu_yCol, eint, &yc_emlrtRTEI);
            eint = nx * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(cpu_yCol, &x_gpu_yCol, true);
            wav_outdatedOnCpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel899<<<grid, block>>>(eint, x_gpu_yCol);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            x_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
                 ((static_cast<int32_T>(toler) < 0) && (nrefine *
                   static_cast<int32_T>(toler) > 1)))) {
              nrefine = 1;
              cpu_lidx = 0;
            } else {
              nrefine = static_cast<int32_T>(toler);
              cpu_lidx = nx * static_cast<int32_T>(toler);
            }

            omega_tmp2[0] = div_s32(cpu_lidx - 1, nrefine) + 1;
            for (eint = 0; eint < omega_tmp2[0]; eint++) {
              if (x_data_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(cpu_yCol, &x_gpu_yCol);
              }

              cpu_yCol->data[nrefine * eint] = xx[0].f1->data[eint];
              x_data_outdatedOnGpu = false;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              wav_outdatedOnCpu = true;
            }

            b_cpu_csz[0] = xx[0].f1->size[0] * static_cast<int32_T>(toler);
            a_data_outdatedOnGpu = false;
            eint = g_cpu_x->size[0] * g_cpu_x->size[1];
            g_cpu_x->size[0] = b_cpu_csz[0];
            g_cpu_x->size[1] = xx[0].f1->size[1];
            emxEnsureCapacity_real32_T(g_cpu_x, eint, &ed_emlrtRTEI);
            for (eint = 0; eint < b_cpu_csz[0] * xx[0].f1->size[1]; eint++) {
              if (x_data_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(cpu_yCol, &x_gpu_yCol);
              }

              x_data_outdatedOnGpu = false;
              g_cpu_x->data[eint] = cpu_yCol->data[eint];
              a_data_outdatedOnGpu = true;
              wav_outdatedOnCpu = true;
            }

            if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (xx[0].f1->size[1] < 1) {
                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel900<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (pb_gpu_w);
              } else {
                eint = xx[0].f1->size[1];
                n = e_cpu_a->size[0];
                e_cpu_a->size[0] = xx[0].f1->size[1];
                emxEnsureCapacity_real32_T(e_cpu_a, n, &fb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                  2147483647U);
                if (wav_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(cpu_yCol, &x_gpu_yCol,
                    !c_omega_tmp1_needsGpuEnsureCapa);
                }

                gpuEmxEnsureCapacity_real32_T(e_cpu_a, &p_gpu_a, true);
                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&x_gpu_yCol, cpu_yCol);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel907<<<grid, block>>>(x_gpu_yCol, eint - 1,
                    p_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
                cpu_cv_re = b_cpu_h->data[0];
                eint = e_cpu_c->size[0];
                e_cpu_c->size[0] = e_cpu_a->size[0];
                emxEnsureCapacity_real32_T(e_cpu_c, eint, &hb_emlrtRTEI);
                eint = e_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(e_cpu_c, &p_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel908<<<grid, block>>>(eint, p_gpu_c);
                }

                if (e_cpu_a->size[0] == 1) {
                  cpu_cv_re = b_cpu_h->data[0];
                  eint = e_cpu_c->size[0];
                  e_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real32_T(e_cpu_c, eint, &hb_emlrtRTEI);
                  gpuEmxEnsureCapacity_real32_T(e_cpu_c, &p_gpu_c, true);
                  ec_wtcc_kernel909<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_cv_re, p_gpu_a, p_gpu_c);
                } else {
                  itime = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(e_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(e_cpu_a->size[0])
                    + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                     (itime)));
                  threadDims[0] = static_cast<int8_T>(itime);
                  x_size_idx_1 = e_cpu_a->size[0];
                  if (e_cpu_a->size[0] > 2147483646) {
                    nx = MAX_int32_T;
                  } else {
                    nx = e_cpu_a->size[0] + 1;
                  }

                  eint = k_cpu_expanded->size[0];
                  k_cpu_expanded->size[0] = nx - 1;
                  emxEnsureCapacity_real32_T(k_cpu_expanded, eint, &jb_emlrtRTEI);
                  eint = e_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real32_T(k_cpu_expanded, &sc_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel911<<<grid, block>>>(eint, sc_gpu_expanded);
                  }

                  n = e_cpu_a->size[0];
                  eint = eb_cpu_y->size[0] * eb_cpu_y->size[1];
                  eb_cpu_y->size[0] = 1;
                  eb_cpu_y->size[1] = e_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(eb_cpu_y, eint, &kb_emlrtRTEI);
                  eb_cpu_y->data[0] = 1;
                  itime = 1;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    eb_cpu_y->data[k + 1] = itime;
                  }

                  eint = cpu_iv43->size[0];
                  cpu_iv43->size[0] = eb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv43, eint, &jb_emlrtRTEI);
                  eint = eb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(eb_cpu_y, &ye_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv43, &gpu_iv43, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&ye_gpu_y, eb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel912<<<grid, block>>>(ye_gpu_y, eint, gpu_iv43);
                  }

                  omega_tmp2[0] = cpu_iv43->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel913<<<grid, block>>>(p_gpu_a, gpu_iv43,
                      omega_tmp2[0] - 1, sc_gpu_expanded);
                  }

                  eint = e_cpu_c->size[0];
                  e_cpu_c->size[0] = e_cpu_a->size[0];
                  emxEnsureCapacity_real32_T(e_cpu_c, eint, &jb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1),
                    dim3(static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_real32_T(e_cpu_c, &p_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel914<<<grid, block>>>(cpu_cv_re,
                      sc_gpu_expanded, x_size_idx_1 - 1, p_gpu_c);
                  }
                }

                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = e_cpu_c->size[0];
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                offsetH = e_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel910<<<grid, block>>>(p_gpu_c, offsetH, pb_gpu_w,
                    c_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
              if (b_cpu_csz[0] == 0) {
                itime = b_cpu_h->size[0];
              } else {
                itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
              }

              if (xx[0].f1->size[1] == 0) {
                nrefine = 1;
              } else {
                nrefine = xx[0].f1->size[1];
              }

              eint = c_cpu_w->size[0] * c_cpu_w->size[1];
              c_cpu_w->size[0] = itime;
              c_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel915<<<grid, block>>>(eint, pb_gpu_w);
              }

              if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = itime;
                c_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                eint = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel916<<<grid, block>>>(eint, pb_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) && (xx
                           [0].f1->size[1] == 1))) {
                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = 1;
                c_cpu_w->size[1] = 1;
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                if (wav_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(cpu_yCol, &x_gpu_yCol,
                    !c_omega_tmp1_needsGpuEnsureCapa);
                }

                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&x_gpu_yCol, cpu_yCol);
                }

                ec_wtcc_kernel917<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (x_gpu_yCol, b_gpu_h, pb_gpu_w);
              } else {
                r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                     (b_cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                b_blockDims[0] = eint;
                b_blockDims[1] = cpu_lidx;
                ix = xx[0].f1->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    x_size_idx_1 = static_cast<int32_T>(r);
                  } else {
                    x_size_idx_1 = MIN_int32_T;
                  }
                } else {
                  x_size_idx_1 = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                     - x_size_idx_1)) {
                  nx = MIN_int32_T;
                } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                            - x_size_idx_1)) {
                  nx = MAX_int32_T;
                } else {
                  nx = x_size_idx_1 + b_cpu_csz[0];
                }

                if (nx >= -2147483647) {
                  nx--;
                }

                eint = p_cpu_expanded->size[0] * p_cpu_expanded->size[1];
                p_cpu_expanded->size[0] = nx;
                emxEnsureCapacity_real32_T(p_cpu_expanded, eint, &jb_emlrtRTEI);
                if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                     - xx[0].f1->size[1])) {
                  nx = MAX_int32_T;
                } else {
                  nx = xx[0].f1->size[1] + xx[0].f1->size[1];
                }

                eint = p_cpu_expanded->size[0] * p_cpu_expanded->size[1];
                p_cpu_expanded->size[1] = nx - 1;
                emxEnsureCapacity_real32_T(p_cpu_expanded, eint, &jb_emlrtRTEI);
                fx_data_outdatedOnCpu = true;
                if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                     - x_size_idx_1)) {
                  nx = MIN_int32_T;
                } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                            - x_size_idx_1)) {
                  nx = MAX_int32_T;
                } else {
                  nx = x_size_idx_1 + b_cpu_csz[0];
                }

                if (nx >= -2147483647) {
                  nx--;
                }

                if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                     - xx[0].f1->size[1])) {
                  nrefine = MAX_int32_T;
                } else {
                  nrefine = xx[0].f1->size[1] + xx[0].f1->size[1];
                }

                if (nx * (nrefine - 1) - 1 >= 0) {
                  gpuEmxEnsureCapacity_real32_T(p_cpu_expanded, &tc_gpu_expanded,
                    true);
                  fx_data_outdatedOnCpu = false;
                  cudaMemset(&tc_gpu_expanded.data[0], 0, static_cast<uint32_T>
                             (nx * nrefine - nx) * sizeof(real32_T));
                }

                n = b_cpu_h->size[0];
                eint = jb_cpu_y->size[0] * jb_cpu_y->size[1];
                jb_cpu_y->size[0] = 1;
                jb_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(jb_cpu_y, eint, &kb_emlrtRTEI);
                jb_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  jb_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv45->size[0];
                cpu_iv45->size[0] = jb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv45, eint, &jb_emlrtRTEI);
                eint = jb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(jb_cpu_y, &af_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv45, &gpu_iv45, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&af_gpu_y, jb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel918<<<grid, block>>>(offsetH, af_gpu_y, eint,
                    gpu_iv45);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (xx[0].f1->size[1]) / 2.0)) + static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(xx[0].f1->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv45->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                if (fx_data_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(p_cpu_expanded, &tc_gpu_expanded,
                    true);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel919<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv45,
                    omega_tmp2[0] - 1, tc_gpu_expanded, p_cpu_expanded->size[0U]);
                }

                if (b_cpu_csz[0] < -2147483647) {
                  nx = MIN_int32_T;
                } else {
                  nx = b_cpu_csz[0] - 1;
                }

                if (nx < 0) {
                  n = 0;
                } else {
                  n = nx + 1;
                }

                y_needsGpuEnsureCapacity = false;
                eint = g_cpu_rows->size[0] * g_cpu_rows->size[1];
                g_cpu_rows->size[0] = 1;
                g_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(g_cpu_rows, eint, &kb_emlrtRTEI);
                if (n > 0) {
                  g_cpu_rows->data[0] = 0;
                  y_needsGpuEnsureCapacity = true;
                  itime = 0;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    g_cpu_rows->data[k + 1] = itime;
                  }
                }

                n = xx[0].f1->size[1];
                eint = b_cpu_cols->size[0] * b_cpu_cols->size[1];
                b_cpu_cols->size[0] = 1;
                b_cpu_cols->size[1] = xx[0].f1->size[1];
                emxEnsureCapacity_int32_T(b_cpu_cols, eint, &kb_emlrtRTEI);
                b_cpu_cols->data[0] = 0;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  b_cpu_cols->data[k + 1] = itime;
                }

                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = x_size_idx_1;
                c_cpu_w->size[1] = xx[0].f1->size[1];
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (x_size_idx_1 != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 -
                    1), dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                    (static_cast<uint32_T>(eint), static_cast<uint32_T>
                     (b_blockDims[1]), 1U), &grid, &block);
                  if (wav_outdatedOnCpu) {
                    gpuEmxEnsureCapacity_real32_T(cpu_yCol, &x_gpu_yCol,
                      !c_omega_tmp1_needsGpuEnsureCapa);
                  }

                  gpuEmxEnsureCapacity_int32_T(b_cpu_cols, &i_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(g_cpu_rows, &kc_gpu_rows,
                    !y_needsGpuEnsureCapacity);
                  gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  if (c_omega_tmp1_needsGpuEnsureCapa) {
                    gpuEmxMemcpyCpuToGpu_real32_T(&x_gpu_yCol, cpu_yCol);
                  }

                  gpuEmxMemcpyCpuToGpu_int32_T(&i_gpu_cols, b_cpu_cols);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&kc_gpu_rows, g_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel920<<<grid, block>>>(x_gpu_yCol,
                      tc_gpu_expanded, i_gpu_cols, kc_gpu_rows, *gpu_csz,
                      x_size_idx_1 - 1, ix - 1, pb_gpu_w, p_cpu_expanded->size
                      [0U], c_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (b_cpu_csz[0] == 0) {
                itime = b_cpu_h->size[0];
              } else {
                itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
              }

              if (xx[0].f1->size[1] == 0) {
                nrefine = 1;
              } else {
                nrefine = xx[0].f1->size[1];
              }

              eint = c_cpu_w->size[0] * c_cpu_w->size[1];
              c_cpu_w->size[0] = itime;
              c_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel921<<<grid, block>>>(eint, pb_gpu_w);
              }

              if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = itime;
                c_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                eint = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel922<<<grid, block>>>(eint, pb_gpu_w);
                }
              } else if ((b_cpu_csz[0] == 1) && (xx[0].f1->size[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                eint = k_cpu_c->size[0];
                k_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(k_cpu_c, eint, &hd_emlrtRTEI);
                cpu_cv_re = 1.0F;
                cv_im = 0.0F;
                gpuEmxEnsureCapacity_real32_T(g_cpu_x, &l_gpu_x,
                  !a_data_outdatedOnGpu);
                gpuEmxEnsureCapacity_real32_T(k_cpu_c, &q_gpu_c, true);
                if (a_data_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&l_gpu_x, g_cpu_x);
                }

                cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                  &l_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                  &cv_im, (float *)&q_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = itime;
                c_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &ed_emlrtRTEI);
                eint = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel923<<<grid, block>>>(q_gpu_c, eint, pb_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                     (b_cpu_h->size[0])) - 1U;
                itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                threadDims[0] = static_cast<int8_T>(itime);
                ix = xx[0].f1->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                x_size_idx_1 = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  nx = MAX_int32_T;
                } else {
                  nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_real32_T(n_cpu_expanded, eint, &jb_emlrtRTEI);
                if (xx[0].f1->size[1] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = xx[0].f1->size[1] + 1;
                }

                eint = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[1] = nx - 1;
                emxEnsureCapacity_real32_T(n_cpu_expanded, eint, &jb_emlrtRTEI);
                fx_data_outdatedOnCpu = true;
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  nx = MAX_int32_T;
                } else {
                  nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                if (xx[0].f1->size[1] > 2147483646) {
                  nrefine = MAX_int32_T;
                } else {
                  nrefine = xx[0].f1->size[1] + 1;
                }

                if ((nx - 1) * (nrefine - 1) - 1 >= 0) {
                  gpuEmxEnsureCapacity_real32_T(n_cpu_expanded, &uc_gpu_expanded,
                    true);
                  fx_data_outdatedOnCpu = false;
                  cudaMemset(&uc_gpu_expanded.data[0], 0, static_cast<uint32_T>
                             (((nx * nrefine - nrefine) - nx) + 1) * sizeof
                             (real32_T));
                }

                n = b_cpu_csz[0];
                eint = hb_cpu_y->size[0] * hb_cpu_y->size[1];
                hb_cpu_y->size[0] = 1;
                hb_cpu_y->size[1] = b_cpu_csz[0];
                emxEnsureCapacity_int32_T(hb_cpu_y, eint, &kb_emlrtRTEI);
                hb_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  hb_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv49->size[0];
                cpu_iv49->size[0] = hb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv49, eint, &jb_emlrtRTEI);
                eint = hb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(hb_cpu_y, &bf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv49, &gpu_iv49, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&bf_gpu_y, hb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel924<<<grid, block>>>(offsetH, bf_gpu_y, eint,
                    gpu_iv49);
                }

                n = xx[0].f1->size[1];
                eint = gc_cpu_y->size[0] * gc_cpu_y->size[1];
                gc_cpu_y->size[0] = 1;
                gc_cpu_y->size[1] = xx[0].f1->size[1];
                emxEnsureCapacity_int32_T(gc_cpu_y, eint, &kb_emlrtRTEI);
                gc_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  gc_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv68->size[0];
                cpu_iv68->size[0] = gc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv68, eint, &jb_emlrtRTEI);
                eint = gc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(gc_cpu_y, &cf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv68, &gpu_iv68, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&cf_gpu_y, gc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel925<<<grid, block>>>(cf_gpu_y, eint, gpu_iv68);
                }

                xt_size[0] = cpu_iv49->size[0];
                xt_size[1] = cpu_iv68->size[0];
                mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size
                  [0] - 1), &grid, &block, 2147483647U);
                if (wav_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(cpu_yCol, &x_gpu_yCol,
                    !c_omega_tmp1_needsGpuEnsureCapa);
                }

                if (fx_data_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(n_cpu_expanded, &uc_gpu_expanded,
                    true);
                }

                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&x_gpu_yCol, cpu_yCol);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel926<<<grid, block>>>(x_gpu_yCol, xt_size[0],
                    gpu_iv68, gpu_iv49, xt_size[0] - 1, xt_size[1] - 1,
                    uc_gpu_expanded, n_cpu_expanded->size[0U]);
                }

                n = b_cpu_h->size[0];
                eint = m_cpu_rows->size[0] * m_cpu_rows->size[1];
                m_cpu_rows->size[0] = 1;
                m_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(m_cpu_rows, eint, &kb_emlrtRTEI);
                m_cpu_rows->data[0] = 0;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  m_cpu_rows->data[k + 1] = itime;
                }

                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = static_cast<int32_T>(N);
                c_cpu_w->size[1] = xx[0].f1->size[1];
                emxEnsureCapacity_real32_T(c_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 -
                    1), dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                    (static_cast<uint32_T>(threadDims[0]), static_cast<uint32_T>
                     (static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(m_cpu_rows, &lc_gpu_rows, false);
                  gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&lc_gpu_rows, m_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel927<<<grid, block>>>(uc_gpu_expanded,
                      lc_gpu_rows, b_gpu_h, x_size_idx_1 - 1, ix - 1, pb_gpu_w,
                      b_cpu_h->size[0U], n_cpu_expanded->size[0U], c_cpu_w->
                      size[0U]);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              kb_y = nullptr;
              m32 = emlrtCreateCharArray(2, &iv31[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m32, &rfmt[0]);
              emlrtAssign(&kb_y, m32);
              rb_y = nullptr;
              m38 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&rb_y, m38);
              emlrt_marshallIn(b_sprintf(kb_y, rb_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (c_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              b_cpu_csz[itime] = c_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_csz[itime] = c_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel901<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *b_gpu_csz);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_lidx = cpu_csz[0];
            cpu_csz[0] = cpu_csz[1];
            cpu_csz[1] = cpu_lidx;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
              nrefine = 1;
              pathlen = -1;
            } else {
              nrefine = static_cast<int32_T>(b_m);
              pathlen = cpu_csz[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel902<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
              pathlen, nsubs, *gpu_csz);
            eint = n_cpu_w->size[0] * n_cpu_w->size[1];
            n_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            n_cpu_w->size[1] = cpu_lidx;
            emxEnsureCapacity_real32_T(n_cpu_w, eint, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
              &block, 2147483647U);
            if (a_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real32_T(c_cpu_w, &pb_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real32_T(n_cpu_w, &qb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel903<<<grid, block>>>(pb_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_lidx - 1, qb_gpu_w, n_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = vb_cpu_y->size[0] * vb_cpu_y->size[1];
            vb_cpu_y->size[0] = b_cpu_csz[0];
            vb_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(vb_cpu_y, eint, &ed_emlrtRTEI);
            offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(vb_cpu_y, &ue_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel904<<<grid, block>>>(qb_gpu_w, offsetH, ue_gpu_y);
            }

            interval_outdatedOnGpu = true;
            Ly = std::ceil(((static_cast<real_T>(xx[0].f1->size[0]) - 1.0) *
                            toler + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
            if (!(b_cpu_csz[0] < Ly)) {
              if (Ly < 1.0) {
                cpu_lidx = 0;
              } else {
                cpu_lidx = static_cast<int32_T>(Ly);
              }

              n = v_cpu_w->size[0] * v_cpu_w->size[1];
              v_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
              v_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_real32_T(v_cpu_w, n, &jd_emlrtRTEI);
              eint = pathlen / nrefine;
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(v_cpu_w, &rb_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel905<<<grid, block>>>(pb_gpu_w, cpu_csz[0], nrefine,
                  eint, cpu_csz[1] - 1, rb_gpu_w, v_cpu_w->size[0U]);
              }

              n = vb_cpu_y->size[0] * vb_cpu_y->size[1];
              vb_cpu_y->size[0] = cpu_lidx;
              vb_cpu_y->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_real32_T(vb_cpu_y, n, &gd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx
                - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(vb_cpu_y, &ue_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel906<<<grid, block>>>(rb_gpu_w, b_cpu_csz[0],
                  cpu_lidx - 1, b_cpu_csz[1] - 1, ue_gpu_y, vb_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            eint = lc_cpu_y->size[0] * lc_cpu_y->size[1];
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(lc_cpu_y, eint, &d_emlrtRTEI);
            lc_cpu_y->data[0] = rtNaN;
            fx_data_outdatedOnCpu = false;
          } else if (halfh < 1.0) {
            fx_data_outdatedOnCpu = false;
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = 0;
          } else {
            eint = lc_cpu_y->size[0] * lc_cpu_y->size[1];
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(lc_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(lc_cpu_y, &ve_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel884<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), ve_gpu_y);
            }

            fx_data_outdatedOnCpu = true;
          }

          eint = xx[0].f1->size[0] * xx[0].f1->size[1];
          xx[0].f1->size[0] = static_cast<int32_T>(halfh);
          xx[0].f1->size[1] = 1;
          emxEnsureCapacity_real32_T(xx[0].f1, eint, &wc_emlrtRTEI);
          for (eint = 0; eint < static_cast<int32_T>(halfh); eint++) {
            if (interval_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(vb_cpu_y, &ue_gpu_y);
            }

            interval_outdatedOnGpu = false;
            if (fx_data_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(lc_cpu_y, &ve_gpu_y);
            }

            fx_data_outdatedOnCpu = false;
            xx[0].f1->data[eint] = vb_cpu_y->data[static_cast<int32_T>(T +
              lc_cpu_y->data[eint]) - 1];
          }
        } else {
          tol = std::ceil(static_cast<real_T>(xx[0].f1->size[0]) * toler / b_m);
          first_iteration = (xx[0].f1->size[0] == 1);
          if (first_iteration) {
            eint = xx[0].f1->size[0] * xx[0].f1->size[1];
            xx[0].f1->size[0] *= xx[0].f1->size[1];
            xx[0].f1->size[1] = 1;
            emxEnsureCapacity_real32_T(xx[0].f1, eint, &uc_emlrtRTEI);
          }

          if (!(toler - 1.0 >= 0.0)) {
            o_y = nullptr;
            m10 = emlrtCreateCharArray(2, &iv19[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m10, &rfmt[0]);
            emlrtAssign(&o_y, m10);
            w_y = nullptr;
            m18 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&w_y, m18);
            emlrt_marshallIn(b_sprintf(o_y, w_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = xx[0].f1->size[0] * xx[0].f1->size[1];
          if ((xx[0].f1->size[0] == 1) && (xx[0].f1->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (xx[0].f1->size[0] != 1) {
              nsubs = 0;
            }
          }

          b_cpu_csz[0] = xx[0].f1->size[0];
          b_cpu_csz[1] = xx[0].f1->size[1];
          nrefine = xx[0].f1->size[0] * xx[0].f1->size[1];
          eint = d_cpu_yCol->size[0];
          d_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(d_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(d_cpu_yCol, &y_gpu_yCol, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel956<<<grid, block>>>(eint, y_gpu_yCol);
          }

          c_omega_tmp1_needsGpuEnsureCapa = false;
          x_data_outdatedOnGpu = true;
          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            cpu_lidx = 1;
            nrefine = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(toler);
            nrefine = nx * static_cast<int32_T>(toler);
          }

          omega_tmp2[0] = div_s32(nrefine - 1, cpu_lidx) + 1;
          for (eint = 0; eint < omega_tmp2[0]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_yCol, &y_gpu_yCol);
            }

            d_cpu_yCol->data[cpu_lidx * eint] = xx[0].f1->data[eint];
            x_data_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            wav_outdatedOnCpu = true;
          }

          b_cpu_csz[nsubs] = xx[0].f1->size[nsubs] * static_cast<int32_T>(toler);
          eint = j_cpu_x->size[0] * j_cpu_x->size[1];
          j_cpu_x->size[0] = b_cpu_csz[0];
          j_cpu_x->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(j_cpu_x, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(d_cpu_yCol, &y_gpu_yCol,
              !c_omega_tmp1_needsGpuEnsureCapa);
          }

          gpuEmxEnsureCapacity_real32_T(j_cpu_x, &m_gpu_x, true);
          if (c_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyCpuToGpu_real32_T(&y_gpu_yCol, d_cpu_yCol);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel957<<<grid, block>>>(y_gpu_yCol, offsetH, m_gpu_x);
          }

          if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (b_cpu_csz[1] < 1) {
              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel958<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (sb_gpu_w);
            } else {
              n = h_cpu_a->size[0];
              h_cpu_a->size[0] = b_cpu_csz[1];
              emxEnsureCapacity_real32_T(h_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_a, &q_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel968<<<grid, block>>>(y_gpu_yCol, b_cpu_csz[1] - 1,
                  q_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              eint = g_cpu_c->size[0];
              g_cpu_c->size[0] = h_cpu_a->size[0];
              emxEnsureCapacity_real32_T(g_cpu_c, eint, &hb_emlrtRTEI);
              eint = h_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(g_cpu_c, &r_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel969<<<grid, block>>>(eint, r_gpu_c);
              }

              if (h_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                eint = g_cpu_c->size[0];
                g_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(g_cpu_c, eint, &hb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(g_cpu_c, &r_gpu_c, true);
                ec_wtcc_kernel970<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, q_gpu_a, r_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (h_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(h_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = h_cpu_a->size[0];
                if (h_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = h_cpu_a->size[0] + 1;
                }

                eint = s_cpu_expanded->size[0];
                s_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_real32_T(s_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = h_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(s_cpu_expanded, &ad_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel972<<<grid, block>>>(eint, ad_gpu_expanded);
                }

                n = h_cpu_a->size[0];
                eint = mb_cpu_y->size[0] * mb_cpu_y->size[1];
                mb_cpu_y->size[0] = 1;
                mb_cpu_y->size[1] = h_cpu_a->size[0];
                emxEnsureCapacity_int32_T(mb_cpu_y, eint, &kb_emlrtRTEI);
                mb_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  mb_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv48->size[0];
                cpu_iv48->size[0] = mb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv48, eint, &jb_emlrtRTEI);
                eint = mb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(mb_cpu_y, &kf_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv48, &gpu_iv48, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&kf_gpu_y, mb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel973<<<grid, block>>>(kf_gpu_y, eint, gpu_iv48);
                }

                omega_tmp2[0] = cpu_iv48->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel974<<<grid, block>>>(q_gpu_a, gpu_iv48,
                    omega_tmp2[0] - 1, ad_gpu_expanded);
                }

                eint = g_cpu_c->size[0];
                g_cpu_c->size[0] = h_cpu_a->size[0];
                emxEnsureCapacity_real32_T(g_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_real32_T(g_cpu_c, &r_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel975<<<grid, block>>>(cpu_cv_re, ad_gpu_expanded,
                    x_size_idx_1 - 1, r_gpu_c);
                }
              }

              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = g_cpu_c->size[0];
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = g_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel971<<<grid, block>>>(r_gpu_c, offsetH, sb_gpu_w,
                  e_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (b_cpu_csz[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = b_cpu_csz[1];
            }

            eint = e_cpu_w->size[0] * e_cpu_w->size[1];
            e_cpu_w->size[0] = itime;
            e_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel976<<<grid, block>>>(eint, sb_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = itime;
              e_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel977<<<grid, block>>>(eint, sb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                        (b_cpu_csz[1] == 1))) {
              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = 1;
              e_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel978<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (y_gpu_yCol, b_gpu_h, sb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(b_cpu_csz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
                1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = b_cpu_csz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = y_cpu_expanded->size[0] * y_cpu_expanded->size[1];
              y_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(y_cpu_expanded, eint, &jb_emlrtRTEI);
              if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz
                   [1])) {
                nx = MIN_int32_T;
              } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                          - b_cpu_csz[1])) {
                nx = MAX_int32_T;
              } else {
                nx = b_cpu_csz[1] + b_cpu_csz[1];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = y_cpu_expanded->size[0] * y_cpu_expanded->size[1];
              y_cpu_expanded->size[1] = nx;
              emxEnsureCapacity_real32_T(y_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
                b_cpu_csz[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(y_cpu_expanded, &bd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel979<<<grid, block>>>(eint, bd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              eint = tb_cpu_y->size[0] * tb_cpu_y->size[1];
              tb_cpu_y->size[0] = 1;
              tb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(tb_cpu_y, eint, &kb_emlrtRTEI);
              tb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                tb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv53->size[0];
              cpu_iv53->size[0] = tb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv53, eint, &jb_emlrtRTEI);
              eint = tb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(tb_cpu_y, &lf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv53, &gpu_iv53, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&lf_gpu_y, tb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel980<<<grid, block>>>(offsetH, lf_gpu_y, eint,
                  gpu_iv53);
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv53->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel981<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv53,
                  omega_tmp2[0] - 1, bd_gpu_expanded, y_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = i_cpu_rows->size[0] * i_cpu_rows->size[1];
              i_cpu_rows->size[0] = 1;
              i_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(i_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                i_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  i_cpu_rows->data[k + 1] = itime;
                }
              }

              if (b_cpu_csz[1] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[1] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              interval_outdatedOnGpu = false;
              eint = e_cpu_cols->size[0] * e_cpu_cols->size[1];
              e_cpu_cols->size[0] = 1;
              e_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(e_cpu_cols, eint, &kb_emlrtRTEI);
              if (n > 0) {
                e_cpu_cols->data[0] = 0;
                interval_outdatedOnGpu = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  e_cpu_cols->data[k + 1] = itime;
                }
              }

              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = x_size_idx_1;
              e_cpu_w->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                n = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  n = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                  static_cast<uint32_T>(n), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(e_cpu_cols, &j_gpu_cols,
                  !interval_outdatedOnGpu);
                gpuEmxEnsureCapacity_int32_T(i_cpu_rows, &qc_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (interval_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&j_gpu_cols, e_cpu_cols);
                }

                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&qc_gpu_rows, i_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel982<<<grid, block>>>(y_gpu_yCol, bd_gpu_expanded,
                    j_gpu_cols, qc_gpu_rows, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                    sb_gpu_w, y_cpu_expanded->size[0U], e_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
            }

            if (b_cpu_csz[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = b_cpu_csz[1];
            }

            eint = e_cpu_w->size[0] * e_cpu_w->size[1];
            e_cpu_w->size[0] = itime;
            e_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel983<<<grid, block>>>(eint, sb_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = itime;
              e_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel984<<<grid, block>>>(eint, sb_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              eint = n_cpu_c->size[0];
              n_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(n_cpu_c, eint, &hd_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(n_cpu_c, &s_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &m_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&s_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = itime;
              e_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel985<<<grid, block>>>(s_gpu_c, eint, sb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(b_cpu_csz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
              c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
                1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              b_blockDims[0] = itime;
              ix = b_cpu_csz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = w_cpu_expanded->size[0] * w_cpu_expanded->size[1];
              w_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_real32_T(w_cpu_expanded, eint, &jb_emlrtRTEI);
              if (b_cpu_csz[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = b_cpu_csz[1] + 1;
              }

              eint = w_cpu_expanded->size[0] * w_cpu_expanded->size[1];
              w_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(w_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                b_cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(w_cpu_expanded, &cd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel986<<<grid, block>>>(eint, cd_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = pb_cpu_y->size[0] * pb_cpu_y->size[1];
              pb_cpu_y->size[0] = 1;
              pb_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(pb_cpu_y, eint, &kb_emlrtRTEI);
              pb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                pb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv56->size[0];
              cpu_iv56->size[0] = pb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv56, eint, &jb_emlrtRTEI);
              eint = pb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pb_cpu_y, &mf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv56, &gpu_iv56, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&mf_gpu_y, pb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel987<<<grid, block>>>(offsetH, mf_gpu_y, eint,
                  gpu_iv56);
              }

              if (b_cpu_csz[1] < 1) {
                n = 0;
              } else {
                n = b_cpu_csz[1];
              }

              fx_data_outdatedOnCpu = false;
              eint = pc_cpu_y->size[0] * pc_cpu_y->size[1];
              pc_cpu_y->size[0] = 1;
              pc_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(pc_cpu_y, eint, &kb_emlrtRTEI);
              if (n > 0) {
                pc_cpu_y->data[0] = 1;
                fx_data_outdatedOnCpu = true;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  pc_cpu_y->data[k + 1] = itime;
                }
              }

              eint = cpu_iv73->size[0];
              cpu_iv73->size[0] = pc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv73, eint, &jb_emlrtRTEI);
              eint = pc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pc_cpu_y, &nf_gpu_y,
                !fx_data_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv73, &gpu_iv73, true);
              if (fx_data_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&nf_gpu_y, pc_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel988<<<grid, block>>>(nf_gpu_y, eint, gpu_iv73);
              }

              xt_size[0] = cpu_iv56->size[0];
              xt_size[1] = cpu_iv73->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel989<<<grid, block>>>(y_gpu_yCol, xt_size[0],
                  gpu_iv73, gpu_iv56, xt_size[0] - 1, xt_size[1] - 1,
                  cd_gpu_expanded, w_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              eint = s_cpu_rows->size[0] * s_cpu_rows->size[1];
              s_cpu_rows->size[0] = 1;
              s_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(s_cpu_rows, eint, &kb_emlrtRTEI);
              s_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                s_cpu_rows->data[k + 1] = itime;
              }

              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = static_cast<int32_T>(N);
              e_cpu_w->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_real32_T(e_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                eint = cpu_lidx;
                if (cpu_lidx < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(b_blockDims[0]),
                  static_cast<uint32_T>(eint), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(s_cpu_rows, &rc_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&rc_gpu_rows, s_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel990<<<grid, block>>>(cd_gpu_expanded,
                    rc_gpu_rows, b_gpu_h, x_size_idx_1 - 1, ix - 1, sb_gpu_w,
                    b_cpu_h->size[0U], w_cpu_expanded->size[0U], e_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            mb_y = nullptr;
            m36 = emlrtCreateCharArray(2, &iv35[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m36, &rfmt[0]);
            emlrtAssign(&mb_y, m36);
            tb_y = nullptr;
            m43 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&tb_y, m43);
            emlrt_marshallIn(b_sprintf(mb_y, tb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (e_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = e_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = e_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel959<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            nrefine = 1;
            pathlen = -1;
          } else {
            nrefine = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel960<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
            pathlen, nsubs, *gpu_csz);
          eint = s_cpu_w->size[0] * s_cpu_w->size[1];
          s_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          s_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(s_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(e_cpu_w, &sb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(s_cpu_w, &tb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel961<<<grid, block>>>(sb_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_lidx - 1, tb_gpu_w, s_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = yb_cpu_y->size[0] * yb_cpu_y->size[1];
          yb_cpu_y->size[0] = b_cpu_csz[0];
          yb_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(yb_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &hf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel962<<<grid, block>>>(tb_gpu_w, offsetH, hf_gpu_y);
          }

          interval_outdatedOnGpu = true;
          Ly = std::ceil(((static_cast<real_T>(xx[0].f1->size[0]) - 1.0) * toler
                          + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(Ly);
            }

            n = cb_cpu_w->size[0] * cb_cpu_w->size[1];
            cb_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            cb_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_real32_T(cb_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(cb_cpu_w, &ub_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel963<<<grid, block>>>(sb_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_csz[1] - 1, ub_gpu_w, cb_cpu_w->size[0U]);
            }

            n = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            yb_cpu_y->size[0] = cpu_lidx;
            yb_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(yb_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &hf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel964<<<grid, block>>>(ub_gpu_w, b_cpu_csz[0],
                cpu_lidx - 1, b_cpu_csz[1] - 1, hf_gpu_y, yb_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            eint = xd_cpu_y->size[0] * xd_cpu_y->size[1];
            xd_cpu_y->size[0] = 1;
            xd_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real32_T(xd_cpu_y, eint, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(xd_cpu_y, &if_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel965<<<grid, block>>>(hf_gpu_y, omega_tmp2[0] - 1,
                if_gpu_y, xd_cpu_y->size[0U]);
            }

            eint = yb_cpu_y->size[0] * yb_cpu_y->size[1];
            yb_cpu_y->size[0] = 1;
            yb_cpu_y->size[1] = xd_cpu_y->size[1];
            emxEnsureCapacity_real32_T(yb_cpu_y, eint, &md_emlrtRTEI);
            eint = xd_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(yb_cpu_y, &hf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel966<<<grid, block>>>(if_gpu_y, eint, hf_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            eint = tc_cpu_y->size[0] * tc_cpu_y->size[1];
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(tc_cpu_y, eint, &d_emlrtRTEI);
            tc_cpu_y->data[0] = rtNaN;
            fx_data_outdatedOnCpu = false;
          } else if (tol < 1.0) {
            fx_data_outdatedOnCpu = false;
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = 0;
          } else {
            eint = tc_cpu_y->size[0] * tc_cpu_y->size[1];
            tc_cpu_y->size[0] = 1;
            tc_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(tc_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(tc_cpu_y, &jf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel967<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                jf_gpu_y);
            }

            fx_data_outdatedOnCpu = true;
          }

          nrefine = yb_cpu_y->size[1];
          eint = xx[0].f1->size[0] * xx[0].f1->size[1];
          xx[0].f1->size[0] = tc_cpu_y->size[1];
          xx[0].f1->size[1] = yb_cpu_y->size[1];
          emxEnsureCapacity_real32_T(xx[0].f1, eint, &wc_emlrtRTEI);
          for (eint = 0; eint < nrefine; eint++) {
            for (n = 0; n < tc_cpu_y->size[1]; n++) {
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(yb_cpu_y, &hf_gpu_y);
              }

              interval_outdatedOnGpu = false;
              if (fx_data_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_real_T(tc_cpu_y, &jf_gpu_y);
              }

              fx_data_outdatedOnCpu = false;
              xx[0].f1->data[n + xx[0].f1->size[0] * eint] = yb_cpu_y->data[(
                static_cast<int32_T>(T + tc_cpu_y->data[n]) + yb_cpu_y->size[0] *
                eint) - 1];
            }
          }
        }
      }

      emxFree_real32_T(&cb_cpu_w);
      emxFree_real32_T(&ae_cpu_y);
      emxFree_real32_T(&xd_cpu_y);
      emxFree_real32_T(&y_cpu_w);
      emxFree_real32_T(&v_cpu_w);
      emxFree_real32_T(&s_cpu_w);
      emxFree_real32_T(&q_cpu_w);
      emxFree_real32_T(&n_cpu_w);
      emxFree_int32_T(&ub_cpu_rows);
      emxFree_int32_T(&sb_cpu_rows);
      emxFree_int32_T(&pb_cpu_rows);
      emxFree_int32_T(&cpu_iv100);
      emxFree_int32_T(&mb_cpu_rows);
      emxFree_int32_T(&jb_cpu_rows);
      emxFree_int32_T(&cpu_iv96);
      emxFree_int32_T(&gb_cpu_rows);
      emxFree_int32_T(&db_cpu_rows);
      emxFree_int32_T(&cpu_iv90);
      emxFree_int32_T(&y_cpu_rows);
      emxFree_int32_T(&cpu_iv87);
      emxFree_int32_T(&cpu_iv86);
      emxFree_int32_T(&v_cpu_rows);
      emxFree_int32_T(&e_cpu_cols);
      emxFree_int32_T(&cpu_iv81);
      emxFree_int32_T(&td_cpu_y);
      emxFree_int32_T(&cpu_iv77);
      emxFree_int32_T(&s_cpu_rows);
      emxFree_int32_T(&qd_cpu_y);
      emxFree_int32_T(&p_cpu_rows);
      emxFree_int32_T(&b_cpu_cols);
      emxFree_int32_T(&cpu_iv75);
      emxFree_real32_T(&dc_cpu_expanded);
      emxFree_real32_T(&ac_cpu_expanded);
      emxFree_int32_T(&nd_cpu_y);
      emxFree_int32_T(&m_cpu_rows);
      emxFree_int32_T(&kd_cpu_y);
      emxFree_int32_T(&cpu_iv73);
      emxFree_int32_T(&hd_cpu_y);
      emxFree_real32_T(&xb_cpu_expanded);
      emxFree_real32_T(&vb_cpu_expanded);
      emxFree_int32_T(&dd_cpu_y);
      emxFree_real32_T(&sb_cpu_expanded);
      emxFree_real32_T(&pb_cpu_expanded);
      emxFree_int32_T(&cpu_iv68);
      emxFree_int32_T(&bd_cpu_y);
      emxFree_int32_T(&i_cpu_rows);
      emxFree_int32_T(&cpu_iv65);
      emxFree_int32_T(&yc_cpu_y);
      emxFree_int32_T(&cpu_iv63);
      emxFree_real32_T(&lb_cpu_expanded);
      emxFree_real32_T(&jb_cpu_expanded);
      emxFree_real_T(&tc_cpu_y);
      emxFree_int32_T(&g_cpu_rows);
      emxFree_real32_T(&rc_cpu_y);
      emxFree_int32_T(&pc_cpu_y);
      emxFree_int32_T(&cpu_iv56);
      emxFree_real_T(&lc_cpu_y);
      emxFree_int32_T(&cpu_iv53);
      emxFree_int32_T(&jc_cpu_y);
      emxFree_int32_T(&gc_cpu_y);
      emxFree_int32_T(&dc_cpu_y);
      emxFree_int32_T(&cpu_iv49);
      emxFree_int32_T(&cpu_iv48);
      emxFree_real32_T(&fb_cpu_expanded);
      emxFree_real32_T(&cb_cpu_expanded);
      emxFree_int32_T(&cpu_iv45);
      emxFree_real32_T(&yb_cpu_y);
      emxFree_real32_T(&e_cpu_result);
      emxFree_int32_T(&cpu_iv43);
      emxFree_real32_T(&vb_cpu_y);
      emxFree_int32_T(&tb_cpu_y);
      emxFree_real32_T(&b_cpu_result);
      emxFree_int32_T(&pb_cpu_y);
      emxFree_real32_T(&q_cpu_c);
      emxFree_int32_T(&mb_cpu_y);
      emxFree_real32_T(&y_cpu_expanded);
      emxFree_real32_T(&w_cpu_expanded);
      emxFree_int32_T(&jb_cpu_y);
      emxFree_int32_T(&hb_cpu_y);
      emxFree_real32_T(&s_cpu_expanded);
      emxFree_int32_T(&eb_cpu_y);
      emxFree_real32_T(&p_cpu_expanded);
      emxFree_real32_T(&n_cpu_expanded);
      emxFree_real32_T(&k_cpu_expanded);
      emxFree_real32_T(&n_cpu_c);
      emxFree_real32_T(&k_cpu_c);
      emxFree_real32_T(&d_a);
      emxFree_real32_T(&d_c);
      emxFree_real32_T(&h_cpu_a);
      emxFree_real32_T(&g_cpu_c);
      emxFree_real32_T(&e_cpu_a);
      emxFree_real32_T(&e_cpu_c);
      emxFree_real32_T(&h_cpu_w);
      emxFree_real32_T(&m_cpu_x);
      emxFree_real32_T(&e_cpu_w);
      emxFree_real32_T(&c_cpu_w);
      emxFree_real32_T(&j_cpu_x);
      emxFree_real32_T(&g_cpu_yCol);
      emxFree_real32_T(&g_cpu_x);
      emxFree_real32_T(&d_cpu_yCol);
      emxFree_real32_T(&cpu_yCol);
    }
  } else {
    if (xx[0].f1->size[0] == 1) {
      halfh = std::ceil(toler / b_m);
      fx_data_outdatedOnCpu = false;
      eint = cpu_y1->size[0] * cpu_y1->size[1];
      cpu_y1->size[0] = static_cast<int32_T>(halfh);
      cpu_y1->size[1] = xx[0].f1->size[1];
      emxEnsureCapacity_real32_T(cpu_y1, eint, &qc_emlrtRTEI);
      interval_outdatedOnGpu = true;
      ix = xx[0].f1->size[0] * xx[0].f1->size[1];
      if (ix - 1 >= 0) {
        if ((static_cast<int32_T>(toler) == 0) || ((static_cast<int32_T>(toler) >
              0) && (static_cast<int32_T>(toler) < 1))) {
          i69 = 1;
          i72 = 0;
        } else {
          i69 = static_cast<int32_T>(toler);
          i72 = static_cast<int32_T>(toler);
        }

        b_p = (static_cast<int32_T>(toler) == 1);
        Ly = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                       b_m);
      }

      emxInit_real32_T(&j_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&k_cpu_w, 1, &ed_emlrtRTEI, true);
      emxInit_real32_T(&x_cpu_y, 1, &ed_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&h_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&y_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ab_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&bb_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv41, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv42, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&d_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&e_cpu_rows, 2, &jb_emlrtRTEI, true);
      for (b_nx = 0; b_nx < ix; b_nx++) {
        if (!(toler - 1.0 >= 0.0)) {
          k_y = nullptr;
          m16 = emlrtCreateCharArray(2, &iv25[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m16, &rfmt[0]);
          emlrtAssign(&k_y, m16);
          l_y = nullptr;
          m25 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&l_y, m25);
          emlrt_marshallIn(b_sprintf(k_y, l_y, &emlrtMCI), "<output of sprintf>",
                           unusedExpr);
        }

        eint = j_cpu_yCol->size[0];
        j_cpu_yCol->size[0] = static_cast<int32_T>(toler);
        emxEnsureCapacity_real32_T(j_cpu_yCol, eint, &yc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) - 1),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &ab_gpu_yCol, true);
        wav_outdatedOnCpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1019<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
            ab_gpu_yCol);
        }

        c_omega_tmp1_needsGpuEnsureCapa = false;
        x_data_outdatedOnGpu = true;
        nrefine = div_s32(i72 - 1, i69) + 1;
        for (eint = 0; eint < nrefine; eint++) {
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real32_T(j_cpu_yCol, &ab_gpu_yCol);
          }

          j_cpu_yCol->data[i69 * eint] = xx[0].f1->data[b_nx];
          x_data_outdatedOnGpu = false;
          c_omega_tmp1_needsGpuEnsureCapa = true;
          wav_outdatedOnCpu = true;
        }

        if (b_p && (b_cpu_h->size[0] == 1)) {
          eint = k_cpu_w->size[0];
          k_cpu_w->size[0] = 1;
          emxEnsureCapacity_real32_T(k_cpu_w, eint, &ed_emlrtRTEI);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &ab_gpu_yCol,
              !c_omega_tmp1_needsGpuEnsureCapa);
          }

          gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
          if (c_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyCpuToGpu_real32_T(&ab_gpu_yCol, j_cpu_yCol);
          }

          ec_wtcc_kernel1020<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
            ab_gpu_yCol, vb_gpu_w);
        } else if (b_cpu_h->size[0] > static_cast<int32_T>(toler)) {
          if (static_cast<int32_T>(toler) == 0) {
            itime = b_cpu_h->size[0] + static_cast<int32_T>(toler);
          } else {
            itime = (b_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
          }

          eint = k_cpu_w->size[0];
          k_cpu_w->size[0] = itime;
          emxEnsureCapacity_real32_T(k_cpu_w, eint, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1025<<<grid, block>>>(itime - 1, vb_gpu_w);
          }

          if (static_cast<int32_T>(toler) != 0) {
            if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) == 1)) {
              if (x_data_outdatedOnGpu) {
                gpuEmxMemcpyGpuToCpu_real32_T(j_cpu_yCol, &ab_gpu_yCol);
              }

              cpu_cv_re = j_cpu_yCol->data[0];
              eint = k_cpu_w->size[0];
              k_cpu_w->size[0] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
              ec_wtcc_kernel1026<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cpu_cv_re, b_gpu_h, vb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (static_cast<int32_T>(toler) <
                   MIN_int32_T - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (static_cast<int32_T>(toler) >
                          MAX_int32_T - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + static_cast<int32_T>(toler);
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = h_cpu_expanded->size[0];
              h_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(h_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(h_cpu_expanded, &hd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1027<<<grid, block>>>(eint, hd_gpu_expanded);
              }

              eint = b_cpu_h->size[0];
              n = ab_cpu_y->size[0] * ab_cpu_y->size[1];
              ab_cpu_y->size[0] = 1;
              ab_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(ab_cpu_y, n, &kb_emlrtRTEI);
              ab_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= eint - 2; k++) {
                itime++;
                ab_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv42->size[0];
              cpu_iv42->size[0] = ab_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv42, eint, &jb_emlrtRTEI);
              eint = ab_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ab_cpu_y, &uf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv42, &gpu_iv42, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&uf_gpu_y, ab_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1028<<<grid, block>>>(offsetH, uf_gpu_y, eint,
                  gpu_iv42);
              }

              omega_tmp2[0] = cpu_iv42->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1029<<<grid, block>>>(b_gpu_h, gpu_iv42,
                  omega_tmp2[0] - 1, hd_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                nx = MIN_int32_T;
                nrefine = MIN_int32_T;
              } else {
                nx = static_cast<int32_T>(toler) - 1;
                nrefine = static_cast<int32_T>(toler) - 1;
              }

              eint = e_cpu_rows->size[0] * e_cpu_rows->size[1];
              e_cpu_rows->size[0] = 1;
              e_cpu_rows->size[1] = nrefine + 1;
              emxEnsureCapacity_int32_T(e_cpu_rows, eint, &kb_emlrtRTEI);
              e_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k < nx; k++) {
                itime++;
                e_cpu_rows->data[k + 1] = itime;
              }

              eint = k_cpu_w->size[0];
              k_cpu_w->size[0] = x_size_idx_1;
              emxEnsureCapacity_real32_T(k_cpu_w, eint, &jb_emlrtRTEI);
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(N,
                1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U), &grid,
                &block);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &ab_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_int32_T(e_cpu_rows, &wc_gpu_rows, false);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&ab_gpu_yCol, j_cpu_yCol);
              }

              gpuEmxMemcpyCpuToGpu_int32_T(&wc_gpu_rows, e_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1030<<<grid, block>>>(ab_gpu_yCol, hd_gpu_expanded,
                  wc_gpu_rows, toler, x_size_idx_1 - 1, vb_gpu_w);
              }
            }
          }
        } else {
          if (static_cast<int32_T>(toler) == 0) {
            itime = static_cast<int32_T>(toler) + b_cpu_h->size[0];
          } else {
            itime = (static_cast<int32_T>(toler) + b_cpu_h->size[0]) - 1;
          }

          eint = k_cpu_w->size[0];
          k_cpu_w->size[0] = itime;
          emxEnsureCapacity_real32_T(k_cpu_w, eint, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1031<<<grid, block>>>(itime - 1, vb_gpu_w);
          }

          if (static_cast<int32_T>(toler) != 0) {
            if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] == 1)) {
              eint = k_cpu_w->size[0];
              k_cpu_w->size[0] = 1;
              emxEnsureCapacity_real32_T(k_cpu_w, eint, &ed_emlrtRTEI);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &ab_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&ab_gpu_yCol, j_cpu_yCol);
              }

              ec_wtcc_kernel1032<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (b_gpu_h, ab_gpu_yCol, vb_gpu_w);
            } else {
              r = (static_cast<real_T>(static_cast<int32_T>(toler)) +
                   static_cast<real_T>(b_cpu_h->size[0])) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((x_size_idx_1 < 0) && (b_cpu_h->size[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_h->size[0] > MAX_int32_T -
                          x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_h->size[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = g_cpu_expanded->size[0];
              g_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(g_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + b_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(g_cpu_expanded, &id_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1033<<<grid, block>>>(eint, id_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              eint = y_cpu_y->size[0] * y_cpu_y->size[1];
              y_cpu_y->size[0] = 1;
              y_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(y_cpu_y, eint, &kb_emlrtRTEI);
              y_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                y_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv41->size[0];
              cpu_iv41->size[0] = y_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv41, eint, &jb_emlrtRTEI);
              eint = y_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(y_cpu_y, &vf_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv41, &gpu_iv41, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&vf_gpu_y, y_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1034<<<grid, block>>>(offsetH, vf_gpu_y, eint,
                  gpu_iv41);
              }

              omega_tmp2[0] = cpu_iv41->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(j_cpu_yCol, &ab_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&ab_gpu_yCol, j_cpu_yCol);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1035<<<grid, block>>>(ab_gpu_yCol, gpu_iv41,
                  omega_tmp2[0] - 1, id_gpu_expanded);
              }

              eint = b_cpu_h->size[0];
              n = d_cpu_rows->size[0] * d_cpu_rows->size[1];
              d_cpu_rows->size[0] = 1;
              d_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(d_cpu_rows, n, &kb_emlrtRTEI);
              d_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= eint - 2; k++) {
                itime++;
                d_cpu_rows->data[k + 1] = itime;
              }

              eint = k_cpu_w->size[0];
              k_cpu_w->size[0] = x_size_idx_1;
              emxEnsureCapacity_real32_T(k_cpu_w, eint, &jb_emlrtRTEI);
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(N,
                1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U), &grid,
                &block);
              gpuEmxEnsureCapacity_int32_T(d_cpu_rows, &xc_gpu_rows, false);
              gpuEmxEnsureCapacity_real32_T(k_cpu_w, &vb_gpu_w, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&xc_gpu_rows, d_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1036<<<grid, block>>>(id_gpu_expanded, xc_gpu_rows,
                  b_gpu_h, x_size_idx_1 - 1, vb_gpu_w, b_cpu_h->size[0U]);
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          m_y = nullptr;
          m34 = emlrtCreateCharArray(2, &iv33[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m34, &rfmt[0]);
          emlrtAssign(&m_y, m34);
          n_y = nullptr;
          m40 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&n_y, m40);
          emlrt_marshallIn(b_sprintf(m_y, n_y, &emlrtMCI), "<output of sprintf>",
                           unusedExpr);
        }

        if (b_m == 0.0) {
          nrefine = 1;
          pathlen = -1;
        } else {
          nrefine = static_cast<int32_T>(b_m);
          pathlen = k_cpu_w->size[0] - 1;
        }

        eint = x_cpu_y->size[0];
        x_cpu_y->size[0] = div_s32(pathlen, nrefine) + 1;
        emxEnsureCapacity_real32_T(x_cpu_y, eint, &ed_emlrtRTEI);
        eint = pathlen / nrefine;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(x_cpu_y, &sf_gpu_y, true);
        h_y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1021<<<grid, block>>>(vb_gpu_w, nrefine, eint, sf_gpu_y);
        }

        if (!(div_s32(pathlen, nrefine) + 1 < Ly)) {
          eint = x_cpu_y->size[0];
          if (Ly < 1.0) {
            x_cpu_y->size[0] = 0;
          } else {
            x_cpu_y->size[0] = static_cast<int32_T>(Ly);
          }

          emxEnsureCapacity_real32_T(x_cpu_y, eint, &gd_emlrtRTEI);
          h_y_needsGpuEnsureCapacity = true;
        }

        if (std::isnan(halfh)) {
          eint = bb_cpu_y->size[0] * bb_cpu_y->size[1];
          bb_cpu_y->size[0] = 1;
          bb_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(bb_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(bb_cpu_y, &tf_gpu_y, true);
          d_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel1022<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(tf_gpu_y);
        } else if (halfh < 1.0) {
          bb_cpu_y->size[0] = 1;
          bb_cpu_y->size[1] = 0;
        } else {
          eint = bb_cpu_y->size[0] * bb_cpu_y->size[1];
          bb_cpu_y->size[0] = 1;
          bb_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(bb_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(bb_cpu_y, &tf_gpu_y, true);
          d_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1024<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              tf_gpu_y);
          }
        }

        cpu_lidx = cpu_y1->size[0];
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        if (h_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real32_T(x_cpu_y, &sf_gpu_y, true);
        }

        if (d_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(bb_cpu_y, &tf_gpu_y, true);
        }

        d_y_needsGpuEnsureCapacity = false;
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real32_T(cpu_y1, &b_gpu_y1, true);
        }

        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1023<<<grid, block>>>(sf_gpu_y, tf_gpu_y, T, b_nx,
            cpu_lidx - 1, b_gpu_y1, cpu_y1->size[0U]);
        }

        fx_data_outdatedOnCpu = true;
      }

      emxFree_int32_T(&e_cpu_rows);
      emxFree_int32_T(&d_cpu_rows);
      emxFree_int32_T(&cpu_iv42);
      emxFree_int32_T(&cpu_iv41);
      emxFree_real_T(&bb_cpu_y);
      emxFree_int32_T(&ab_cpu_y);
      emxFree_int32_T(&y_cpu_y);
      emxFree_real32_T(&h_cpu_expanded);
      emxFree_real32_T(&g_cpu_expanded);
      emxFree_real32_T(&x_cpu_y);
      emxFree_real32_T(&k_cpu_w);
      emxFree_real32_T(&j_cpu_yCol);
    } else {
      emxInit_real32_T(&cpu_xCol, 2, &uc_emlrtRTEI, true);
      emxInit_real32_T(&c_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&f_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_real32_T(&b_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&l_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&o_cpu_x, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&d_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&j_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_real32_T(&g_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_real32_T(&j_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_real32_T(&j_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&i_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&m_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_real32_T(&j_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&m_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&db_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&r_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&u_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&v_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&lb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_real32_T(&p_cpu_c, 1, &ve_emlrtRTEI, true);
      emxInit_int32_T(&ob_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&rb_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&sb_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv47, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&d_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv52, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&xb_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv55, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&bb_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&eb_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv58, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&bc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&fc_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&ic_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv61, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv62, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&oc_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&f_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&hb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ib_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&vc_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_int32_T(&wc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv70, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xc_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv71, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv72, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&k_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&nb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ob_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&rb_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ub_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&l_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv79, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&md_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv80, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&cc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&fc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv85, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&o_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&r_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&sd_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&u_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv93, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&d_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv94, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&x_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv98, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv99, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&bb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv106, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ib_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&lb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv107, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ob_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&rb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&l_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&m_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&p_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&vd_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&u_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&x_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_real32_T(&wd_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_real32_T(&bb_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((toler == 1.0) && (b_m == 1.0)) {
        fx_data_outdatedOnCpu = false;
        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = xx[0].f1->size[0];
        cpu_y1->size[1] = xx[0].f1->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, eint, &nc_emlrtRTEI);
        for (eint = 0; eint < xx[0].f1->size[0] * xx[0].f1->size[1]; eint++) {
          cpu_y1->data[eint] = xx[0].f1->data[eint];
        }
      } else if ((xx[0].f1->size[0] == 1) || (xx[0].f1->size[1] == 1)) {
        if ((xx[0].f1->size[0] == 0) || (xx[0].f1->size[1] == 0)) {
          pathlen = 0;
        } else {
          itime = xx[0].f1->size[0];
          pathlen = xx[0].f1->size[1];
          if (itime >= pathlen) {
            pathlen = itime;
          }
        }

        halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
        if ((xx[0].f1->size[0] == 1) && (xx[0].f1->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            r_y = nullptr;
            m27 = emlrtCreateCharArray(2, &iv29[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m27, &rfmt[0]);
            emlrtAssign(&r_y, m27);
            ab_y = nullptr;
            m31 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&ab_y, m31);
            emlrt_marshallIn(b_sprintf(r_y, ab_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          eint = i_cpu_yCol->size[0];
          i_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(i_cpu_yCol, eint, &yc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(i_cpu_yCol, &bb_gpu_yCol, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1037<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              bb_gpu_yCol);
          }

          c_omega_tmp1_needsGpuEnsureCapa = false;
          x_data_outdatedOnGpu = true;
          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            cpu_lidx = 1;
            nrefine = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(toler);
            nrefine = static_cast<int32_T>(toler);
          }

          omega_tmp2[0] = div_s32(nrefine - 1, cpu_lidx) + 1;
          for (eint = 0; eint < omega_tmp2[0]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(i_cpu_yCol, &bb_gpu_yCol);
            }

            i_cpu_yCol->data[cpu_lidx * eint] = xx[0].f1->data[eint];
            x_data_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            wav_outdatedOnCpu = true;
          }

          eint = o_cpu_x->size[0] * o_cpu_x->size[1];
          o_cpu_x->size[0] = static_cast<int32_T>(toler);
          o_cpu_x->size[1] = 1;
          emxEnsureCapacity_real32_T(o_cpu_x, eint, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          if (wav_outdatedOnCpu) {
            gpuEmxEnsureCapacity_real32_T(i_cpu_yCol, &bb_gpu_yCol,
              !c_omega_tmp1_needsGpuEnsureCapa);
          }

          gpuEmxEnsureCapacity_real32_T(o_cpu_x, &n_gpu_x, true);
          if (c_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyCpuToGpu_real32_T(&bb_gpu_yCol, i_cpu_yCol);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1038<<<grid, block>>>(bb_gpu_yCol, static_cast<int32_T>
              (toler) - 1, n_gpu_x);
          }

          if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] == 1)) {
            eint = j_cpu_w->size[0] * j_cpu_w->size[1];
            j_cpu_w->size[0] = 1;
            j_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel1039<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
              bb_gpu_yCol, wb_gpu_w);
          } else if (b_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            eint = j_cpu_w->size[0] * j_cpu_w->size[1];
            j_cpu_w->size[0] = itime;
            j_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1051<<<grid, block>>>(itime - 1, wb_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = itime;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1052<<<grid, block>>>(itime - 1, wb_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) ==
                        1)) {
              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = 1;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel1053<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (bb_gpu_yCol, b_gpu_h, wb_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (static_cast<int32_T>(toler) <
                   MIN_int32_T - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (static_cast<int32_T>(toler) >
                          MAX_int32_T - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + static_cast<int32_T>(toler);
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = eb_cpu_expanded->size[0] * eb_cpu_expanded->size[1];
              eb_cpu_expanded->size[0] = nx;
              eb_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(eb_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(eb_cpu_expanded, &jd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1054<<<grid, block>>>(eint, jd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              eint = ic_cpu_y->size[0] * ic_cpu_y->size[1];
              ic_cpu_y->size[0] = 1;
              ic_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(ic_cpu_y, eint, &kb_emlrtRTEI);
              ic_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ic_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv70->size[0];
              cpu_iv70->size[0] = ic_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv70, eint, &jb_emlrtRTEI);
              eint = ic_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ic_cpu_y, &bg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv70, &gpu_iv70, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&bg_gpu_y, ic_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1055<<<grid, block>>>(offsetH, bg_gpu_y, eint,
                  gpu_iv70);
              }

              omega_tmp2[0] = cpu_iv70->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1056<<<grid, block>>>(b_gpu_h, gpu_iv70,
                  omega_tmp2[0] - 1, jd_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = static_cast<int32_T>(toler) - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = o_cpu_rows->size[0] * o_cpu_rows->size[1];
              o_cpu_rows->size[0] = 1;
              o_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(o_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                o_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  o_cpu_rows->data[k + 1] = itime;
                }
              }

              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = x_size_idx_1;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_int32_T(o_cpu_rows, &yc_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&yc_gpu_rows, o_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1057<<<grid, block>>>(bb_gpu_yCol,
                    jd_gpu_expanded, yc_gpu_rows, toler, x_size_idx_1 - 1,
                    wb_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (static_cast<int32_T>(toler) + b_cpu_h->size[0]) - 1;
            }

            eint = j_cpu_w->size[0] * j_cpu_w->size[1];
            j_cpu_w->size[0] = itime;
            j_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1058<<<grid, block>>>(itime - 1, wb_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = itime;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1059<<<grid, block>>>(itime - 1, wb_gpu_w);
              }
            } else if ((static_cast<int32_T>(toler) == 1) && (b_cpu_h->size[0] ==
                        1)) {
              eint = p_cpu_c->size[0];
              p_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(p_cpu_c, eint, &hd_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(p_cpu_c, &t_gpu_c, true);
              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &n_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&t_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = itime;
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1060<<<grid, block>>>(t_gpu_c, itime - 1, wb_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(static_cast<int32_T>(toler)) +
                   static_cast<uint32_T>(b_cpu_h->size[0])) - 1U;
              itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
              threadDims[0] = static_cast<int8_T>(itime);
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = bb_cpu_expanded->size[0] * bb_cpu_expanded->size[1];
              bb_cpu_expanded->size[0] = nx - 1;
              bb_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(bb_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(bb_cpu_expanded, &kd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1061<<<grid, block>>>(eint, kd_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              eint = cc_cpu_y->size[0] * cc_cpu_y->size[1];
              cc_cpu_y->size[0] = 1;
              cc_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(cc_cpu_y, eint, &kb_emlrtRTEI);
              cc_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                cc_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv72->size[0];
              cpu_iv72->size[0] = cc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv72, eint, &jb_emlrtRTEI);
              eint = cc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(cc_cpu_y, &cg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv72, &gpu_iv72, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&cg_gpu_y, cc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1062<<<grid, block>>>(offsetH, cg_gpu_y, eint,
                  gpu_iv72);
              }

              xt_size[0] = cpu_iv72->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1063<<<grid, block>>>(bb_gpu_yCol, gpu_iv72,
                  xt_size[0] - 1, kd_gpu_expanded);
              }

              n = b_cpu_h->size[0];
              eint = fb_cpu_rows->size[0] * fb_cpu_rows->size[1];
              fb_cpu_rows->size[0] = 1;
              fb_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(fb_cpu_rows, eint, &kb_emlrtRTEI);
              fb_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                fb_cpu_rows->data[k + 1] = itime;
              }

              eint = j_cpu_w->size[0] * j_cpu_w->size[1];
              j_cpu_w->size[0] = static_cast<int32_T>(N);
              j_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(j_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(threadDims[0]), 1U,
                  1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(fb_cpu_rows, &ad_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&ad_gpu_rows, fb_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1064<<<grid, block>>>(kd_gpu_expanded,
                    ad_gpu_rows, b_gpu_h, x_size_idx_1 - 1, wb_gpu_w,
                    b_cpu_h->size[0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            hb_y = nullptr;
            m48 = emlrtCreateCharArray(2, &iv40[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m48, &rfmt[0]);
            emlrtAssign(&hb_y, m48);
            ib_y = nullptr;
            m51 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&ib_y, m51);
            emlrt_marshallIn(b_sprintf(hb_y, ib_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (j_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = j_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = j_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1040<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            nrefine = 1;
            pathlen = -1;
          } else {
            nrefine = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1041<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
            pathlen, nsubs, *gpu_csz);
          eint = l_cpu_w->size[0] * l_cpu_w->size[1];
          l_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          l_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(l_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(j_cpu_w, &wb_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(l_cpu_w, &xb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1042<<<grid, block>>>(wb_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_lidx - 1, xb_gpu_w, l_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = oc_cpu_y->size[0] * oc_cpu_y->size[1];
          oc_cpu_y->size[0] = b_cpu_csz[0];
          oc_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(oc_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(oc_cpu_y, &wf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1043<<<grid, block>>>(xb_gpu_w, offsetH, wf_gpu_y);
          }

          Ly = std::ceil((0.0 * toler + static_cast<real_T>(b_cpu_h->size[0])) /
                         b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(Ly);
            }

            n = p_cpu_w->size[0] * p_cpu_w->size[1];
            p_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            p_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_real32_T(p_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(p_cpu_w, &yb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1044<<<grid, block>>>(wb_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_csz[1] - 1, yb_gpu_w, p_cpu_w->size[0U]);
            }

            n = oc_cpu_y->size[0] * oc_cpu_y->size[1];
            oc_cpu_y->size[0] = cpu_lidx;
            oc_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(oc_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(oc_cpu_y, &wf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1045<<<grid, block>>>(yb_gpu_w, b_cpu_csz[0],
                cpu_lidx - 1, b_cpu_csz[1] - 1, wf_gpu_y, oc_cpu_y->size[0U]);
            }
          }

          if (oc_cpu_y->size[0] * oc_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = oc_cpu_y->size[0] * oc_cpu_y->size[1];
          }

          omega_tmp2[0] = oc_cpu_y->size[0] * oc_cpu_y->size[1];
          eint = vd_cpu_y->size[0] * vd_cpu_y->size[1];
          vd_cpu_y->size[0] = 1;
          vd_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(vd_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(vd_cpu_y, &xf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1046<<<grid, block>>>(wf_gpu_y, omega_tmp2[0] - 1,
              xf_gpu_y);
          }

          eint = rb_cpu_y->size[0] * rb_cpu_y->size[1];
          rb_cpu_y->size[0] = n;
          rb_cpu_y->size[1] = 1;
          emxEnsureCapacity_real32_T(rb_cpu_y, eint, &ld_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &yf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1047<<<grid, block>>>(xf_gpu_y, n - 1, yf_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            q_y = nullptr;
            m15 = emlrtCreateCharArray(2, &iv24[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m15, &rfmt[0]);
            emlrtAssign(&q_y, m15);
            y_y = nullptr;
            m24 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&y_y, m24);
            emlrt_marshallIn(b_sprintf(q_y, y_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = xx[0].f1->size[0] * xx[0].f1->size[1];
          b_cpu_csz[1] = xx[0].f1->size[1];
          nrefine = xx[0].f1->size[0] * xx[0].f1->size[1];
          eint = c_cpu_yCol->size[0];
          c_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_real32_T(c_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &cb_gpu_yCol, true);
          wav_outdatedOnCpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1065<<<grid, block>>>(eint, cb_gpu_yCol);
          }

          c_omega_tmp1_needsGpuEnsureCapa = false;
          x_data_outdatedOnGpu = true;
          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = nx * static_cast<int32_T>(toler);
          }

          omega_tmp2[0] = div_s32(cpu_lidx - 1, nrefine) + 1;
          for (eint = 0; eint < omega_tmp2[0]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(c_cpu_yCol, &cb_gpu_yCol);
            }

            c_cpu_yCol->data[nrefine * eint] = xx[0].f1->data[eint];
            x_data_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            wav_outdatedOnCpu = true;
          }

          b_cpu_csz[0] = xx[0].f1->size[0] * static_cast<int32_T>(toler);
          a_data_outdatedOnGpu = false;
          eint = i_cpu_x->size[0] * i_cpu_x->size[1];
          i_cpu_x->size[0] = b_cpu_csz[0];
          i_cpu_x->size[1] = xx[0].f1->size[1];
          emxEnsureCapacity_real32_T(i_cpu_x, eint, &ed_emlrtRTEI);
          for (eint = 0; eint < b_cpu_csz[0] * xx[0].f1->size[1]; eint++) {
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real32_T(c_cpu_yCol, &cb_gpu_yCol);
            }

            x_data_outdatedOnGpu = false;
            i_cpu_x->data[eint] = c_cpu_yCol->data[eint];
            a_data_outdatedOnGpu = true;
            wav_outdatedOnCpu = true;
          }

          if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (xx[0].f1->size[1] < 1) {
              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = 1;
              b_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel1066<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (ac_gpu_w);
            } else {
              eint = xx[0].f1->size[1];
              n = g_cpu_a->size[0];
              g_cpu_a->size[0] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(g_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                2147483647U);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &cb_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_real32_T(g_cpu_a, &r_gpu_a, true);
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&cb_gpu_yCol, c_cpu_yCol);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1073<<<grid, block>>>(cb_gpu_yCol, eint - 1,
                  r_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
              cpu_cv_re = b_cpu_h->data[0];
              eint = d_cpu_c->size[0];
              d_cpu_c->size[0] = g_cpu_a->size[0];
              emxEnsureCapacity_real32_T(d_cpu_c, eint, &hb_emlrtRTEI);
              eint = g_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(d_cpu_c, &u_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1074<<<grid, block>>>(eint, u_gpu_c);
              }

              if (g_cpu_a->size[0] == 1) {
                cpu_cv_re = b_cpu_h->data[0];
                eint = d_cpu_c->size[0];
                d_cpu_c->size[0] = 1;
                emxEnsureCapacity_real32_T(d_cpu_c, eint, &hb_emlrtRTEI);
                gpuEmxEnsureCapacity_real32_T(d_cpu_c, &u_gpu_c, true);
                ec_wtcc_kernel1075<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (cpu_cv_re, r_gpu_a, u_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (g_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(g_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = g_cpu_a->size[0];
                if (g_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = g_cpu_a->size[0] + 1;
                }

                eint = i_cpu_expanded->size[0];
                i_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_real32_T(i_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = g_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(i_cpu_expanded, &ld_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1077<<<grid, block>>>(eint, ld_gpu_expanded);
                }

                n = g_cpu_a->size[0];
                eint = cb_cpu_y->size[0] * cb_cpu_y->size[1];
                cb_cpu_y->size[0] = 1;
                cb_cpu_y->size[1] = g_cpu_a->size[0];
                emxEnsureCapacity_int32_T(cb_cpu_y, eint, &kb_emlrtRTEI);
                cb_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  cb_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv47->size[0];
                cpu_iv47->size[0] = cb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv47, eint, &jb_emlrtRTEI);
                eint = cb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(cb_cpu_y, &dg_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv47, &gpu_iv47, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&dg_gpu_y, cb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1078<<<grid, block>>>(dg_gpu_y, eint, gpu_iv47);
                }

                omega_tmp2[0] = cpu_iv47->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1079<<<grid, block>>>(r_gpu_a, gpu_iv47,
                    omega_tmp2[0] - 1, ld_gpu_expanded);
                }

                eint = d_cpu_c->size[0];
                d_cpu_c->size[0] = g_cpu_a->size[0];
                emxEnsureCapacity_real32_T(d_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_real32_T(d_cpu_c, &u_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1080<<<grid, block>>>(cpu_cv_re, ld_gpu_expanded,
                    x_size_idx_1 - 1, u_gpu_c);
                }
              }

              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = 1;
              b_cpu_w->size[1] = d_cpu_c->size[0];
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = d_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1076<<<grid, block>>>(u_gpu_c, offsetH, ac_gpu_w,
                  b_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (xx[0].f1->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = xx[0].f1->size[1];
            }

            eint = b_cpu_w->size[0] * b_cpu_w->size[1];
            b_cpu_w->size[0] = itime;
            b_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1081<<<grid, block>>>(eint, ac_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = itime;
              b_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1082<<<grid, block>>>(eint, ac_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) && (xx[0]
                         .f1->size[1] == 1))) {
              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = 1;
              b_cpu_w->size[1] = 1;
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &cb_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&cb_gpu_yCol, c_cpu_yCol);
              }

              ec_wtcc_kernel1083<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cb_gpu_yCol, b_gpu_h, ac_gpu_w);
            } else {
              r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = xx[0].f1->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
              m_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(m_cpu_expanded, eint, &jb_emlrtRTEI);
              if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                   - xx[0].f1->size[1])) {
                nx = MAX_int32_T;
              } else {
                nx = xx[0].f1->size[1] + xx[0].f1->size[1];
              }

              eint = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
              m_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(m_cpu_expanded, eint, &jb_emlrtRTEI);
              fx_data_outdatedOnCpu = true;
              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              if ((xx[0].f1->size[1] > 0) && (xx[0].f1->size[1] > MAX_int32_T
                   - xx[0].f1->size[1])) {
                nrefine = MAX_int32_T;
              } else {
                nrefine = xx[0].f1->size[1] + xx[0].f1->size[1];
              }

              if (nx * (nrefine - 1) - 1 >= 0) {
                gpuEmxEnsureCapacity_real32_T(m_cpu_expanded, &md_gpu_expanded,
                  true);
                fx_data_outdatedOnCpu = false;
                cudaMemset(&md_gpu_expanded.data[0], 0, static_cast<uint32_T>(nx
                            * nrefine - nx) * sizeof(real32_T));
              }

              n = b_cpu_h->size[0];
              eint = gb_cpu_y->size[0] * gb_cpu_y->size[1];
              gb_cpu_y->size[0] = 1;
              gb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(gb_cpu_y, eint, &kb_emlrtRTEI);
              gb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                gb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv52->size[0];
              cpu_iv52->size[0] = gb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv52, eint, &jb_emlrtRTEI);
              eint = gb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(gb_cpu_y, &eg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv52, &gpu_iv52, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&eg_gpu_y, gb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1084<<<grid, block>>>(offsetH, eg_gpu_y, eint,
                  gpu_iv52);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>(xx
                [0].f1->size[1]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(xx[0].f1->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv52->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              if (fx_data_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(m_cpu_expanded, &md_gpu_expanded,
                  true);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1085<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv52,
                  omega_tmp2[0] - 1, md_gpu_expanded, m_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = f_cpu_rows->size[0] * f_cpu_rows->size[1];
              f_cpu_rows->size[0] = 1;
              f_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(f_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                f_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  f_cpu_rows->data[k + 1] = itime;
                }
              }

              n = xx[0].f1->size[1];
              eint = cpu_cols->size[0] * cpu_cols->size[1];
              cpu_cols->size[0] = 1;
              cpu_cols->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_int32_T(cpu_cols, eint, &kb_emlrtRTEI);
              cpu_cols->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                cpu_cols->data[k + 1] = itime;
              }

              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = x_size_idx_1;
              b_cpu_w->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(eint), static_cast<uint32_T>
                  (b_blockDims[1]), 1U), &grid, &block);
                if (wav_outdatedOnCpu) {
                  gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &cb_gpu_yCol,
                    !c_omega_tmp1_needsGpuEnsureCapa);
                }

                gpuEmxEnsureCapacity_int32_T(cpu_cols, &k_gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(f_cpu_rows, &bd_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxMemcpyCpuToGpu_real32_T(&cb_gpu_yCol, c_cpu_yCol);
                }

                gpuEmxMemcpyCpuToGpu_int32_T(&k_gpu_cols, cpu_cols);
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&bd_gpu_rows, f_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1086<<<grid, block>>>(cb_gpu_yCol,
                    md_gpu_expanded, k_gpu_cols, bd_gpu_rows, *gpu_csz,
                    x_size_idx_1 - 1, ix - 1, ac_gpu_w, m_cpu_expanded->size[0U],
                    b_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = b_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
            }

            if (xx[0].f1->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = xx[0].f1->size[1];
            }

            eint = b_cpu_w->size[0] * b_cpu_w->size[1];
            b_cpu_w->size[0] = itime;
            b_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1087<<<grid, block>>>(eint, ac_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (xx[0].f1->size[1] == 0)) {
              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = itime;
              b_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1088<<<grid, block>>>(eint, ac_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (xx[0].f1->size[1] == 1) &&
                       (b_cpu_h->size[0] == 1)) {
              eint = j_cpu_c->size[0];
              j_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(j_cpu_c, eint, &hd_emlrtRTEI);
              cpu_cv_re = 1.0F;
              cv_im = 0.0F;
              gpuEmxEnsureCapacity_real32_T(i_cpu_x, &o_gpu_x,
                !a_data_outdatedOnGpu);
              gpuEmxEnsureCapacity_real32_T(j_cpu_c, &v_gpu_c, true);
              if (a_data_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_real32_T(&o_gpu_x, i_cpu_x);
              }

              cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)
                &o_gpu_x.data[0], 1, (float *)&b_gpu_h.data[0], 1, (float *)
                &cv_im, (float *)&v_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = itime;
              b_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1089<<<grid, block>>>(v_gpu_c, eint, ac_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(xx[0].f1->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((static_cast<real_T>(N) + (
                static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(xx[0].f1->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              threadDims[0] = static_cast<int8_T>(itime);
              ix = xx[0].f1->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = j_cpu_expanded->size[0] * j_cpu_expanded->size[1];
              j_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_real32_T(j_cpu_expanded, eint, &jb_emlrtRTEI);
              if (xx[0].f1->size[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = xx[0].f1->size[1] + 1;
              }

              eint = j_cpu_expanded->size[0] * j_cpu_expanded->size[1];
              j_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(j_cpu_expanded, eint, &jb_emlrtRTEI);
              fx_data_outdatedOnCpu = true;
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              if (xx[0].f1->size[1] > 2147483646) {
                nrefine = MAX_int32_T;
              } else {
                nrefine = xx[0].f1->size[1] + 1;
              }

              if ((nx - 1) * (nrefine - 1) - 1 >= 0) {
                gpuEmxEnsureCapacity_real32_T(j_cpu_expanded, &nd_gpu_expanded,
                  true);
                fx_data_outdatedOnCpu = false;
                cudaMemset(&nd_gpu_expanded.data[0], 0, static_cast<uint32_T>
                           (((nx * nrefine - nrefine) - nx) + 1) * sizeof
                           (real32_T));
              }

              n = b_cpu_csz[0];
              eint = db_cpu_y->size[0] * db_cpu_y->size[1];
              db_cpu_y->size[0] = 1;
              db_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(db_cpu_y, eint, &kb_emlrtRTEI);
              db_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                db_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv55->size[0];
              cpu_iv55->size[0] = db_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv55, eint, &jb_emlrtRTEI);
              eint = db_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(db_cpu_y, &fg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv55, &gpu_iv55, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&fg_gpu_y, db_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1090<<<grid, block>>>(offsetH, fg_gpu_y, eint,
                  gpu_iv55);
              }

              n = xx[0].f1->size[1];
              eint = bc_cpu_y->size[0] * bc_cpu_y->size[1];
              bc_cpu_y->size[0] = 1;
              bc_cpu_y->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_int32_T(bc_cpu_y, eint, &kb_emlrtRTEI);
              bc_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                bc_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv71->size[0];
              cpu_iv71->size[0] = bc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv71, eint, &jb_emlrtRTEI);
              eint = bc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(bc_cpu_y, &gg_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv71, &gpu_iv71, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&gg_gpu_y, bc_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1091<<<grid, block>>>(gg_gpu_y, eint, gpu_iv71);
              }

              xt_size[0] = cpu_iv55->size[0];
              xt_size[1] = cpu_iv71->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              if (wav_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(c_cpu_yCol, &cb_gpu_yCol,
                  !c_omega_tmp1_needsGpuEnsureCapa);
              }

              if (fx_data_outdatedOnCpu) {
                gpuEmxEnsureCapacity_real32_T(j_cpu_expanded, &nd_gpu_expanded,
                  true);
              }

              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyCpuToGpu_real32_T(&cb_gpu_yCol, c_cpu_yCol);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1092<<<grid, block>>>(cb_gpu_yCol, xt_size[0],
                  gpu_iv71, gpu_iv55, xt_size[0] - 1, xt_size[1] - 1,
                  nd_gpu_expanded, j_cpu_expanded->size[0U]);
              }

              n = b_cpu_h->size[0];
              eint = l_cpu_rows->size[0] * l_cpu_rows->size[1];
              l_cpu_rows->size[0] = 1;
              l_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(l_cpu_rows, eint, &kb_emlrtRTEI);
              l_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                l_cpu_rows->data[k + 1] = itime;
              }

              eint = b_cpu_w->size[0] * b_cpu_w->size[1];
              b_cpu_w->size[0] = static_cast<int32_T>(N);
              b_cpu_w->size[1] = xx[0].f1->size[1];
              emxEnsureCapacity_real32_T(b_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), static_cast<uint32_T>(
                  static_cast<int8_T>(cpu_lidx)), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(l_cpu_rows, &cd_gpu_rows, false);
                gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&cd_gpu_rows, l_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel1093<<<grid, block>>>(nd_gpu_expanded,
                    cd_gpu_rows, b_gpu_h, x_size_idx_1 - 1, ix - 1, ac_gpu_w,
                    b_cpu_h->size[0U], j_cpu_expanded->size[0U], b_cpu_w->size
                    [0U]);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            jb_y = nullptr;
            m35 = emlrtCreateCharArray(2, &iv34[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m35, &rfmt[0]);
            emlrtAssign(&jb_y, m35);
            qb_y = nullptr;
            m42 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&qb_y, m42);
            emlrt_marshallIn(b_sprintf(jb_y, qb_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (b_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = b_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = b_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1067<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_lidx = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = cpu_lidx;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            nrefine = 1;
            pathlen = -1;
          } else {
            nrefine = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel1068<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
            pathlen, nsubs, *gpu_csz);
          eint = m_cpu_w->size[0] * m_cpu_w->size[1];
          m_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          m_cpu_w->size[1] = cpu_lidx;
          emxEnsureCapacity_real32_T(m_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real32_T(b_cpu_w, &ac_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real32_T(m_cpu_w, &bc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1069<<<grid, block>>>(ac_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_lidx - 1, bc_gpu_w, m_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = rb_cpu_y->size[0] * rb_cpu_y->size[1];
          rb_cpu_y->size[0] = b_cpu_csz[0];
          rb_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(rb_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &yf_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1070<<<grid, block>>>(bc_gpu_w, offsetH, yf_gpu_y);
          }

          Ly = std::ceil(((static_cast<real_T>(xx[0].f1->size[0]) - 1.0) * toler
                          + static_cast<real_T>(b_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              cpu_lidx = 0;
            } else {
              cpu_lidx = static_cast<int32_T>(Ly);
            }

            n = u_cpu_w->size[0] * u_cpu_w->size[1];
            u_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
            u_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_real32_T(u_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / nrefine;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(u_cpu_w, &cc_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1071<<<grid, block>>>(ac_gpu_w, cpu_csz[0], nrefine,
                eint, cpu_csz[1] - 1, cc_gpu_w, u_cpu_w->size[0U]);
            }

            n = rb_cpu_y->size[0] * rb_cpu_y->size[1];
            rb_cpu_y->size[0] = cpu_lidx;
            rb_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(rb_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(rb_cpu_y, &yf_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1072<<<grid, block>>>(cc_gpu_w, b_cpu_csz[0],
                cpu_lidx - 1, b_cpu_csz[1] - 1, yf_gpu_y, rb_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          eint = fc_cpu_y->size[0] * fc_cpu_y->size[1];
          fc_cpu_y->size[0] = 1;
          fc_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(fc_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(fc_cpu_y, &ag_gpu_y, true);
          e_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel1048<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ag_gpu_y);
        } else if (halfh < 1.0) {
          fc_cpu_y->size[0] = 1;
          fc_cpu_y->size[1] = 0;
        } else {
          eint = fc_cpu_y->size[0] * fc_cpu_y->size[1];
          fc_cpu_y->size[0] = 1;
          fc_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(fc_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(fc_cpu_y, &ag_gpu_y, true);
          e_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1050<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              ag_gpu_y);
          }
        }

        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = static_cast<int32_T>(halfh);
        cpu_y1->size[1] = 1;
        emxEnsureCapacity_real32_T(cpu_y1, eint, &nc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (e_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(fc_cpu_y, &ag_gpu_y, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_y1, &b_gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1049<<<grid, block>>>(yf_gpu_y, ag_gpu_y, T,
            static_cast<int32_T>(halfh) - 1, b_gpu_y1);
        }

        fx_data_outdatedOnCpu = true;
      } else {
        tol = std::ceil(static_cast<real_T>(xx[0].f1->size[0]) * toler / b_m);
        first_iteration = (xx[0].f1->size[0] == 1);
        if (first_iteration) {
          interval_outdatedOnGpu = false;
          eint = cpu_xCol->size[0] * cpu_xCol->size[1];
          cpu_xCol->size[0] = xx[0].f1->size[0] * xx[0].f1->size[1];
          cpu_xCol->size[1] = 1;
          emxEnsureCapacity_real32_T(cpu_xCol, eint, &uc_emlrtRTEI);
          for (eint = 0; eint < xx[0].f1->size[0] * xx[0].f1->size[1]; eint++) {
            cpu_xCol->data[eint] = xx[0].f1->data[eint];
            interval_outdatedOnGpu = true;
          }
        } else {
          interval_outdatedOnGpu = false;
          eint = cpu_xCol->size[0] * cpu_xCol->size[1];
          cpu_xCol->size[0] = xx[0].f1->size[0];
          cpu_xCol->size[1] = xx[0].f1->size[1];
          emxEnsureCapacity_real32_T(cpu_xCol, eint, &tc_emlrtRTEI);
          for (eint = 0; eint < xx[0].f1->size[0] * xx[0].f1->size[1]; eint++) {
            cpu_xCol->data[eint] = xx[0].f1->data[eint];
            interval_outdatedOnGpu = true;
          }
        }

        if (!(toler - 1.0 >= 0.0)) {
          bb_y = nullptr;
          m17 = emlrtCreateCharArray(2, &iv26[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m17, &rfmt[0]);
          emlrtAssign(&bb_y, m17);
          gb_y = nullptr;
          m26 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&gb_y, m26);
          emlrt_marshallIn(b_sprintf(bb_y, gb_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nx = cpu_xCol->size[0] * cpu_xCol->size[1];
        if ((cpu_xCol->size[0] == 1) && (cpu_xCol->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (cpu_xCol->size[0] != 1) {
            nsubs = 0;
          }
        }

        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = cpu_xCol->size[itime];
        }

        nrefine = cpu_xCol->size[0] * cpu_xCol->size[1];
        eint = f_cpu_yCol->size[0];
        f_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
        emxEnsureCapacity_real32_T(f_cpu_yCol, eint, &yc_emlrtRTEI);
        eint = nx * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(f_cpu_yCol, &db_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1122<<<grid, block>>>(eint, db_gpu_yCol);
        }

        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (nrefine * static_cast<
               int32_T>(toler) > 1)))) {
          nrefine = 1;
          cpu_lidx = 0;
        } else {
          nrefine = static_cast<int32_T>(toler);
          cpu_lidx = nx * static_cast<int32_T>(toler);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real32_T(cpu_xCol, &b_gpu_xCol,
          !interval_outdatedOnGpu);
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real32_T(&b_gpu_xCol, cpu_xCol);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1123<<<grid, block>>>(b_gpu_xCol, nrefine, div_s32
            (cpu_lidx - 1, nrefine), db_gpu_yCol);
        }

        b_cpu_csz[nsubs] = cpu_xCol->size[nsubs] * static_cast<int32_T>(toler);
        eint = l_cpu_x->size[0] * l_cpu_x->size[1];
        l_cpu_x->size[0] = b_cpu_csz[0];
        l_cpu_x->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_real32_T(l_cpu_x, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(l_cpu_x, &p_gpu_x, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1124<<<grid, block>>>(db_gpu_yCol, offsetH, p_gpu_x);
        }

        if ((b_cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
          if (b_cpu_csz[1] < 1) {
            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = 1;
            g_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel1125<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(dc_gpu_w);
          } else {
            n = j_cpu_a->size[0];
            j_cpu_a->size[0] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(j_cpu_a, n, &fb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real32_T(j_cpu_a, &s_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1137<<<grid, block>>>(db_gpu_yCol, b_cpu_csz[1] - 1,
                s_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(b_cpu_h, &b_gpu_h);
            cpu_cv_re = b_cpu_h->data[0];
            eint = i_cpu_c->size[0];
            i_cpu_c->size[0] = j_cpu_a->size[0];
            emxEnsureCapacity_real32_T(i_cpu_c, eint, &hb_emlrtRTEI);
            eint = j_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(i_cpu_c, &w_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1138<<<grid, block>>>(eint, w_gpu_c);
            }

            if (j_cpu_a->size[0] == 1) {
              cpu_cv_re = b_cpu_h->data[0];
              eint = i_cpu_c->size[0];
              i_cpu_c->size[0] = 1;
              emxEnsureCapacity_real32_T(i_cpu_c, eint, &hb_emlrtRTEI);
              gpuEmxEnsureCapacity_real32_T(i_cpu_c, &w_gpu_c, true);
              ec_wtcc_kernel1139<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (cpu_cv_re, s_gpu_a, w_gpu_c);
            } else {
              itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (j_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(j_cpu_a->size[0]) +
                static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>(itime)));
              threadDims[0] = static_cast<int8_T>(itime);
              x_size_idx_1 = j_cpu_a->size[0];
              if (j_cpu_a->size[0] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = j_cpu_a->size[0] + 1;
              }

              eint = r_cpu_expanded->size[0];
              r_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_real32_T(r_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = j_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(r_cpu_expanded, &sd_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1141<<<grid, block>>>(eint, sd_gpu_expanded);
              }

              n = j_cpu_a->size[0];
              eint = lb_cpu_y->size[0] * lb_cpu_y->size[1];
              lb_cpu_y->size[0] = 1;
              lb_cpu_y->size[1] = j_cpu_a->size[0];
              emxEnsureCapacity_int32_T(lb_cpu_y, eint, &kb_emlrtRTEI);
              lb_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                lb_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv58->size[0];
              cpu_iv58->size[0] = lb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv58, eint, &jb_emlrtRTEI);
              eint = lb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(lb_cpu_y, &og_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv58, &gpu_iv58, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&og_gpu_y, lb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1142<<<grid, block>>>(og_gpu_y, eint, gpu_iv58);
              }

              omega_tmp2[0] = cpu_iv58->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1143<<<grid, block>>>(s_gpu_a, gpu_iv58,
                  omega_tmp2[0] - 1, sd_gpu_expanded);
              }

              eint = i_cpu_c->size[0];
              i_cpu_c->size[0] = j_cpu_a->size[0];
              emxEnsureCapacity_real32_T(i_cpu_c, eint, &jb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
              gpuEmxEnsureCapacity_real32_T(i_cpu_c, &w_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1144<<<grid, block>>>(cpu_cv_re, sd_gpu_expanded,
                  x_size_idx_1 - 1, w_gpu_c);
              }
            }

            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = 1;
            g_cpu_w->size[1] = i_cpu_c->size[0];
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = i_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1140<<<grid, block>>>(w_gpu_c, offsetH, dc_gpu_w,
                g_cpu_w->size[0U]);
            }
          }
        } else if (b_cpu_h->size[0] > b_cpu_csz[0]) {
          if (b_cpu_csz[0] == 0) {
            itime = b_cpu_h->size[0];
          } else {
            itime = (b_cpu_h->size[0] + b_cpu_csz[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = g_cpu_w->size[0] * g_cpu_w->size[1];
          g_cpu_w->size[0] = itime;
          g_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1145<<<grid, block>>>(eint, dc_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = itime;
            g_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1146<<<grid, block>>>(eint, dc_gpu_w);
            }
          } else if ((b_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                      (b_cpu_csz[1] == 1))) {
            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = 1;
            g_cpu_w->size[1] = 1;
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel1147<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (db_gpu_yCol, b_gpu_h, dc_gpu_w);
          } else {
            r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<real_T>
                 (b_cpu_csz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              eint = static_cast<int32_T>(s);
            } else {
              eint = MIN_int32_T;
            }

            b_blockDims[0] = eint;
            b_blockDims[1] = cpu_lidx;
            ix = b_cpu_csz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                x_size_idx_1 = static_cast<int32_T>(r);
              } else {
                x_size_idx_1 = MIN_int32_T;
              }
            } else {
              x_size_idx_1 = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T - x_size_idx_1))
            {
              nx = MIN_int32_T;
            } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                        - x_size_idx_1)) {
              nx = MAX_int32_T;
            } else {
              nx = x_size_idx_1 + b_cpu_csz[0];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = v_cpu_expanded->size[0] * v_cpu_expanded->size[1];
            v_cpu_expanded->size[0] = nx;
            emxEnsureCapacity_real32_T(v_cpu_expanded, eint, &jb_emlrtRTEI);
            if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz[1]))
            {
              nx = MIN_int32_T;
            } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                        - b_cpu_csz[1])) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + b_cpu_csz[1];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = v_cpu_expanded->size[0] * v_cpu_expanded->size[1];
            v_cpu_expanded->size[1] = nx;
            emxEnsureCapacity_real32_T(v_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
              b_cpu_csz[1]) - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(v_cpu_expanded, &td_gpu_expanded, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1148<<<grid, block>>>(eint, td_gpu_expanded);
            }

            n = b_cpu_h->size[0];
            eint = sb_cpu_y->size[0] * sb_cpu_y->size[1];
            sb_cpu_y->size[0] = 1;
            sb_cpu_y->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(sb_cpu_y, eint, &kb_emlrtRTEI);
            sb_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              sb_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv61->size[0];
            cpu_iv61->size[0] = sb_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv61, eint, &jb_emlrtRTEI);
            eint = sb_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(sb_cpu_y, &pg_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv61, &gpu_iv61, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&pg_gpu_y, sb_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1149<<<grid, block>>>(offsetH, pg_gpu_y, eint,
                gpu_iv61);
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv61->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1150<<<grid, block>>>(b_gpu_h, cpu_lidx, gpu_iv61,
                omega_tmp2[0] - 1, td_gpu_expanded, v_cpu_expanded->size[0U]);
            }

            if (b_cpu_csz[0] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[0] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            y_needsGpuEnsureCapacity = false;
            eint = k_cpu_rows->size[0] * k_cpu_rows->size[1];
            k_cpu_rows->size[0] = 1;
            k_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(k_cpu_rows, eint, &kb_emlrtRTEI);
            if (n > 0) {
              k_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                k_cpu_rows->data[k + 1] = itime;
              }
            }

            if (b_cpu_csz[1] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[1] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            interval_outdatedOnGpu = false;
            eint = d_cpu_cols->size[0] * d_cpu_cols->size[1];
            d_cpu_cols->size[0] = 1;
            d_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(d_cpu_cols, eint, &kb_emlrtRTEI);
            if (n > 0) {
              d_cpu_cols->data[0] = 0;
              interval_outdatedOnGpu = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                d_cpu_cols->data[k + 1] = itime;
              }
            }

            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = x_size_idx_1;
            g_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              n = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                n = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                static_cast<uint32_T>(n), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(d_cpu_cols, &l_gpu_cols,
                !interval_outdatedOnGpu);
              gpuEmxEnsureCapacity_int32_T(k_cpu_rows, &hd_gpu_rows,
                !y_needsGpuEnsureCapacity);
              gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&l_gpu_cols, d_cpu_cols);
              }

              if (y_needsGpuEnsureCapacity) {
                gpuEmxMemcpyCpuToGpu_int32_T(&hd_gpu_rows, k_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1151<<<grid, block>>>(db_gpu_yCol, td_gpu_expanded,
                  l_gpu_cols, hd_gpu_rows, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                  dc_gpu_w, v_cpu_expanded->size[0U], g_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (b_cpu_csz[0] == 0) {
            itime = b_cpu_h->size[0];
          } else {
            itime = (b_cpu_csz[0] + b_cpu_h->size[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = g_cpu_w->size[0] * g_cpu_w->size[1];
          g_cpu_w->size[0] = itime;
          g_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1152<<<grid, block>>>(eint, dc_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = itime;
            g_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1153<<<grid, block>>>(eint, dc_gpu_w);
            }
          } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                     (b_cpu_h->size[0] == 1)) {
            eint = m_cpu_c->size[0];
            m_cpu_c->size[0] = 1;
            emxEnsureCapacity_real32_T(m_cpu_c, eint, &hd_emlrtRTEI);
            cpu_cv_re = 1.0F;
            cv_im = 0.0F;
            gpuEmxEnsureCapacity_real32_T(m_cpu_c, &x_gpu_c, true);
            cublasCheck(cublasSgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
              CUBLAS_OP_N, 1, 1, 1, (float *)&cpu_cv_re, (float *)&p_gpu_x.data
              [0], 1, (float *)&b_gpu_h.data[0], 1, (float *)&cv_im, (float *)
              &x_gpu_c.data[0], 1), __FILE__, __LINE__);
            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = itime;
            g_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1154<<<grid, block>>>(x_gpu_c, eint, dc_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                 (b_cpu_h->size[0])) - 1U;
            itime = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((static_cast<real_T>(N) +
              (static_cast<real_T>(itime) - 1.0)) / static_cast<real_T>(itime));
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            b_blockDims[0] = itime;
            ix = b_cpu_csz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            x_size_idx_1 = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              nx = MAX_int32_T;
            } else {
              nx = static_cast<int32_T>(N) + b_cpu_h->size[0];
            }

            eint = u_cpu_expanded->size[0] * u_cpu_expanded->size[1];
            u_cpu_expanded->size[0] = nx - 1;
            emxEnsureCapacity_real32_T(u_cpu_expanded, eint, &jb_emlrtRTEI);
            if (b_cpu_csz[1] > 2147483646) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + 1;
            }

            eint = u_cpu_expanded->size[0] * u_cpu_expanded->size[1];
            u_cpu_expanded->size[1] = nx - 1;
            emxEnsureCapacity_real32_T(u_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
              b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(u_cpu_expanded, &ud_gpu_expanded, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1155<<<grid, block>>>(eint, ud_gpu_expanded);
            }

            n = b_cpu_csz[0];
            eint = ob_cpu_y->size[0] * ob_cpu_y->size[1];
            ob_cpu_y->size[0] = 1;
            ob_cpu_y->size[1] = b_cpu_csz[0];
            emxEnsureCapacity_int32_T(ob_cpu_y, eint, &kb_emlrtRTEI);
            ob_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              ob_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv62->size[0];
            cpu_iv62->size[0] = ob_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv62, eint, &jb_emlrtRTEI);
            eint = ob_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(ob_cpu_y, &qg_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv62, &gpu_iv62, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&qg_gpu_y, ob_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1156<<<grid, block>>>(offsetH, qg_gpu_y, eint,
                gpu_iv62);
            }

            if (b_cpu_csz[1] < 1) {
              n = 0;
            } else {
              n = b_cpu_csz[1];
            }

            fx_data_outdatedOnCpu = false;
            eint = nc_cpu_y->size[0] * nc_cpu_y->size[1];
            nc_cpu_y->size[0] = 1;
            nc_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(nc_cpu_y, eint, &kb_emlrtRTEI);
            if (n > 0) {
              nc_cpu_y->data[0] = 1;
              fx_data_outdatedOnCpu = true;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                nc_cpu_y->data[k + 1] = itime;
              }
            }

            eint = cpu_iv79->size[0];
            cpu_iv79->size[0] = nc_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv79, eint, &jb_emlrtRTEI);
            eint = nc_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(nc_cpu_y, &rg_gpu_y,
              !fx_data_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv79, &gpu_iv79, true);
            if (fx_data_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&rg_gpu_y, nc_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1157<<<grid, block>>>(rg_gpu_y, eint, gpu_iv79);
            }

            xt_size[0] = cpu_iv62->size[0];
            xt_size[1] = cpu_iv79->size[0];
            mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel1158<<<grid, block>>>(db_gpu_yCol, xt_size[0],
                gpu_iv79, gpu_iv62, xt_size[0] - 1, xt_size[1] - 1,
                ud_gpu_expanded, u_cpu_expanded->size[0U]);
            }

            n = b_cpu_h->size[0];
            eint = r_cpu_rows->size[0] * r_cpu_rows->size[1];
            r_cpu_rows->size[0] = 1;
            r_cpu_rows->size[1] = b_cpu_h->size[0];
            emxEnsureCapacity_int32_T(r_cpu_rows, eint, &kb_emlrtRTEI);
            r_cpu_rows->data[0] = 0;
            itime = 0;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              r_cpu_rows->data[k + 1] = itime;
            }

            eint = g_cpu_w->size[0] * g_cpu_w->size[1];
            g_cpu_w->size[0] = static_cast<int32_T>(N);
            g_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_real32_T(g_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = cpu_lidx;
              if (cpu_lidx < 0) {
                eint = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(b_blockDims[0]),
                static_cast<uint32_T>(eint), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(r_cpu_rows, &id_gpu_rows, false);
              gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
              a_data_outdatedOnGpu = false;
              gpuEmxMemcpyCpuToGpu_int32_T(&id_gpu_rows, r_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel1159<<<grid, block>>>(ud_gpu_expanded, id_gpu_rows,
                  b_gpu_h, x_size_idx_1 - 1, ix - 1, dc_gpu_w, b_cpu_h->size[0U],
                  u_cpu_expanded->size[0U], g_cpu_w->size[0U]);
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          xb_y = nullptr;
          m41 = emlrtCreateCharArray(2, &iv37[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m41, &rfmt[0]);
          emlrtAssign(&xb_y, m41);
          yb_y = nullptr;
          m47 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&yb_y, m47);
          emlrt_marshallIn(b_sprintf(xb_y, yb_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (g_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        interval_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = false;
        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = g_cpu_w->size[itime];
          fx_data_outdatedOnCpu = true;
          cpu_csz[itime] = g_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1126<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *b_gpu_csz);
          }

          checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        cpu_lidx = cpu_csz[0];
        cpu_csz[0] = cpu_csz[1];
        cpu_csz[1] = cpu_lidx;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
          nrefine = 1;
          pathlen = -1;
        } else {
          nrefine = static_cast<int32_T>(b_m);
          pathlen = cpu_csz[0] - 1;
        }

        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel1127<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nrefine,
          pathlen, nsubs, *gpu_csz);
        eint = x_cpu_w->size[0] * x_cpu_w->size[1];
        x_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
        x_cpu_w->size[1] = cpu_lidx;
        emxEnsureCapacity_real32_T(x_cpu_w, eint, &jd_emlrtRTEI);
        eint = pathlen / nrefine;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real32_T(g_cpu_w, &dc_gpu_w, true);
        }

        gpuEmxEnsureCapacity_real32_T(x_cpu_w, &ec_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1128<<<grid, block>>>(dc_gpu_w, cpu_csz[0], nrefine,
            eint, cpu_lidx - 1, ec_gpu_w, x_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        eint = xb_cpu_y->size[0] * xb_cpu_y->size[1];
        xb_cpu_y->size[0] = b_cpu_csz[0];
        xb_cpu_y->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_real32_T(xb_cpu_y, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &lg_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1129<<<grid, block>>>(ec_gpu_w, offsetH, lg_gpu_y);
        }

        Ly = std::ceil(((static_cast<real_T>(cpu_xCol->size[0]) - 1.0) * toler +
                        static_cast<real_T>(b_cpu_h->size[0])) / b_m);
        if (!(b_cpu_csz[0] < Ly)) {
          if (Ly < 1.0) {
            cpu_lidx = 0;
          } else {
            cpu_lidx = static_cast<int32_T>(Ly);
          }

          n = bb_cpu_w->size[0] * bb_cpu_w->size[1];
          bb_cpu_w->size[0] = div_s32(pathlen, nrefine) + 1;
          bb_cpu_w->size[1] = cpu_csz[1];
          emxEnsureCapacity_real32_T(bb_cpu_w, n, &jd_emlrtRTEI);
          eint = pathlen / nrefine;
          mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(bb_cpu_w, &fc_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1130<<<grid, block>>>(dc_gpu_w, cpu_csz[0], nrefine,
              eint, cpu_csz[1] - 1, fc_gpu_w, bb_cpu_w->size[0U]);
          }

          n = xb_cpu_y->size[0] * xb_cpu_y->size[1];
          xb_cpu_y->size[0] = cpu_lidx;
          xb_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_real32_T(xb_cpu_y, n, &gd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, cpu_lidx - 1),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &lg_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1131<<<grid, block>>>(fc_gpu_w, b_cpu_csz[0], cpu_lidx
              - 1, b_cpu_csz[1] - 1, lg_gpu_y, xb_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = xb_cpu_y->size[0] * xb_cpu_y->size[1];
          eint = wd_cpu_y->size[0] * wd_cpu_y->size[1];
          wd_cpu_y->size[0] = 1;
          wd_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_real32_T(wd_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real32_T(wd_cpu_y, &mg_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1132<<<grid, block>>>(lg_gpu_y, omega_tmp2[0] - 1,
              mg_gpu_y, wd_cpu_y->size[0U]);
          }

          eint = xb_cpu_y->size[0] * xb_cpu_y->size[1];
          xb_cpu_y->size[0] = 1;
          xb_cpu_y->size[1] = wd_cpu_y->size[1];
          emxEnsureCapacity_real32_T(xb_cpu_y, eint, &md_emlrtRTEI);
          eint = wd_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real32_T(xb_cpu_y, &lg_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1133<<<grid, block>>>(mg_gpu_y, eint, lg_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          eint = vc_cpu_y->size[0] * vc_cpu_y->size[1];
          vc_cpu_y->size[0] = 1;
          vc_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(vc_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(vc_cpu_y, &ng_gpu_y, true);
          h_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel1134<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ng_gpu_y);
        } else if (tol < 1.0) {
          vc_cpu_y->size[0] = 1;
          vc_cpu_y->size[1] = 0;
        } else {
          eint = vc_cpu_y->size[0] * vc_cpu_y->size[1];
          vc_cpu_y->size[0] = 1;
          vc_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(vc_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(vc_cpu_y, &ng_gpu_y, true);
          h_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel1136<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              ng_gpu_y);
          }
        }

        cpu_lidx = xb_cpu_y->size[1];
        eint = cpu_y1->size[0] * cpu_y1->size[1];
        cpu_y1->size[0] = vc_cpu_y->size[1];
        cpu_y1->size[1] = xb_cpu_y->size[1];
        emxEnsureCapacity_real32_T(cpu_y1, eint, &nc_emlrtRTEI);
        eint = vc_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (h_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(vc_cpu_y, &ng_gpu_y, true);
        }

        gpuEmxEnsureCapacity_real32_T(cpu_y1, &b_gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel1135<<<grid, block>>>(lg_gpu_y, ng_gpu_y, T, eint,
            cpu_lidx - 1, b_gpu_y1, cpu_y1->size[0U], xb_cpu_y->size[0U]);
        }

        fx_data_outdatedOnCpu = true;
      }

      emxFree_real32_T(&bb_cpu_w);
      emxFree_real32_T(&wd_cpu_y);
      emxFree_real32_T(&x_cpu_w);
      emxFree_real32_T(&u_cpu_w);
      emxFree_real32_T(&vd_cpu_y);
      emxFree_real32_T(&p_cpu_w);
      emxFree_real32_T(&m_cpu_w);
      emxFree_real32_T(&l_cpu_w);
      emxFree_int32_T(&rb_cpu_rows);
      emxFree_int32_T(&ob_cpu_rows);
      emxFree_int32_T(&cpu_iv107);
      emxFree_int32_T(&lb_cpu_rows);
      emxFree_int32_T(&ib_cpu_rows);
      emxFree_int32_T(&cpu_iv106);
      emxFree_int32_T(&fb_cpu_rows);
      emxFree_int32_T(&cb_cpu_rows);
      emxFree_int32_T(&bb_cpu_rows);
      emxFree_int32_T(&cpu_iv99);
      emxFree_int32_T(&cpu_iv98);
      emxFree_int32_T(&x_cpu_rows);
      emxFree_int32_T(&cpu_iv94);
      emxFree_int32_T(&d_cpu_cols);
      emxFree_int32_T(&cpu_iv93);
      emxFree_int32_T(&u_cpu_rows);
      emxFree_int32_T(&sd_cpu_y);
      emxFree_int32_T(&r_cpu_rows);
      emxFree_int32_T(&pd_cpu_y);
      emxFree_int32_T(&o_cpu_rows);
      emxFree_int32_T(&cpu_iv85);
      emxFree_real32_T(&fc_cpu_expanded);
      emxFree_real32_T(&cc_cpu_expanded);
      emxFree_int32_T(&cpu_cols);
      emxFree_int32_T(&cpu_iv80);
      emxFree_int32_T(&md_cpu_y);
      emxFree_int32_T(&cpu_iv79);
      emxFree_int32_T(&jd_cpu_y);
      emxFree_int32_T(&l_cpu_rows);
      emxFree_int32_T(&gd_cpu_y);
      emxFree_int32_T(&fd_cpu_y);
      emxFree_real32_T(&ub_cpu_expanded);
      emxFree_real32_T(&rb_cpu_expanded);
      emxFree_real32_T(&ob_cpu_expanded);
      emxFree_real32_T(&nb_cpu_expanded);
      emxFree_int32_T(&k_cpu_rows);
      emxFree_int32_T(&cpu_iv72);
      emxFree_int32_T(&cpu_iv71);
      emxFree_int32_T(&xc_cpu_y);
      emxFree_int32_T(&cpu_iv70);
      emxFree_int32_T(&wc_cpu_y);
      emxFree_real_T(&vc_cpu_y);
      emxFree_real32_T(&ib_cpu_expanded);
      emxFree_real32_T(&hb_cpu_expanded);
      emxFree_int32_T(&f_cpu_rows);
      emxFree_real32_T(&oc_cpu_y);
      emxFree_int32_T(&nc_cpu_y);
      emxFree_int32_T(&cpu_iv62);
      emxFree_int32_T(&cpu_iv61);
      emxFree_int32_T(&ic_cpu_y);
      emxFree_real_T(&fc_cpu_y);
      emxFree_int32_T(&cc_cpu_y);
      emxFree_int32_T(&bc_cpu_y);
      emxFree_int32_T(&cpu_iv58);
      emxFree_real32_T(&eb_cpu_expanded);
      emxFree_real32_T(&bb_cpu_expanded);
      emxFree_int32_T(&cpu_iv55);
      emxFree_real32_T(&xb_cpu_y);
      emxFree_int32_T(&cpu_iv52);
      emxFree_real32_T(&d_cpu_result);
      emxFree_int32_T(&cpu_iv47);
      emxFree_int32_T(&sb_cpu_y);
      emxFree_real32_T(&rb_cpu_y);
      emxFree_int32_T(&ob_cpu_y);
      emxFree_real32_T(&p_cpu_c);
      emxFree_real32_T(&cpu_result);
      emxFree_int32_T(&lb_cpu_y);
      emxFree_real32_T(&v_cpu_expanded);
      emxFree_real32_T(&u_cpu_expanded);
      emxFree_int32_T(&gb_cpu_y);
      emxFree_real32_T(&r_cpu_expanded);
      emxFree_int32_T(&db_cpu_y);
      emxFree_int32_T(&cb_cpu_y);
      emxFree_real32_T(&m_cpu_expanded);
      emxFree_real32_T(&j_cpu_expanded);
      emxFree_real32_T(&m_cpu_c);
      emxFree_real32_T(&i_cpu_expanded);
      emxFree_real32_T(&j_cpu_c);
      emxFree_real32_T(&j_cpu_a);
      emxFree_real32_T(&i_cpu_c);
      emxFree_real32_T(&g_cpu_a);
      emxFree_real32_T(&j_cpu_w);
      emxFree_real32_T(&d_cpu_c);
      emxFree_real32_T(&o_cpu_x);
      emxFree_real32_T(&g_cpu_w);
      emxFree_real32_T(&l_cpu_x);
      emxFree_real32_T(&b_cpu_w);
      emxFree_real32_T(&i_cpu_yCol);
      emxFree_real32_T(&i_cpu_x);
      emxFree_real32_T(&f_cpu_yCol);
      emxFree_real32_T(&c_cpu_yCol);
      emxFree_real32_T(&cpu_xCol);
    }

    if ((xx[0].f1->size[0] == 1) || (xx[0].f1->size[1] == 1)) {
      N = static_cast<uint32_T>(cpu_y1->size[0]);
      eint = xx[0].f1->size[0] * xx[0].f1->size[1];
      xx[0].f1->size[0] = cpu_wtc->size[0];
      xx[0].f1->size[1] = cpu_y1->size[0];
      emxEnsureCapacity_real32_T(xx[0].f1, eint, &wc_emlrtRTEI);
      for (eint = 0; eint < cpu_wtc->size[0] * static_cast<int32_T>(N); eint++)
      {
        if (fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real32_T(cpu_y1, &b_gpu_y1);
        }

        fx_data_outdatedOnCpu = false;
        xx[0].f1->data[eint] = cpu_y1->data[eint];
      }
    } else {
      eint = xx[0].f1->size[0] * xx[0].f1->size[1];
      xx[0].f1->size[0] = cpu_y1->size[1];
      xx[0].f1->size[1] = cpu_y1->size[0];
      emxEnsureCapacity_real32_T(xx[0].f1, eint, &wc_emlrtRTEI);
      for (eint = 0; eint < cpu_y1->size[0]; eint++) {
        for (n = 0; n < cpu_y1->size[1]; n++) {
          if (fx_data_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real32_T(cpu_y1, &b_gpu_y1);
          }

          fx_data_outdatedOnCpu = false;
          xx[0].f1->data[n + xx[0].f1->size[0] * eint] = cpu_y1->data[eint
            + cpu_y1->size[0] * n];
        }
      }
    }
  }

  emxFree_real32_T(&cpu_y1);
  emxFree_real32_T(&b_cpu_h);
  emxFree_real32_T(&cpu_wtc);

  // 'ec_wtcc:37' y = resample(y,ds(1),ds(2),Dimension=2);
  if ((cpu_crossCFS->size[0] == 1) || (cpu_crossCFS->size[1] == 1)) {
    x_size_idx_1 = 1;
  } else {
    x_size_idx_1 = 2;
  }

  opts_isRowVectorInput = (cpu_crossCFS->size[0] == 1);
  emxInit_creal32_T(&cpu_opts_x, 2, &sb_emlrtRTEI, true);
  if (x_size_idx_1 == 1) {
    if ((cpu_crossCFS->size[0] == 1) || (cpu_crossCFS->size[1] == 1)) {
      if ((cpu_crossCFS->size[0] == 0) || (cpu_crossCFS->size[1] == 0)) {
        pathlen = 0;
      } else {
        itime = cpu_crossCFS->size[0];
        pathlen = cpu_crossCFS->size[1];
        if (itime >= pathlen) {
          pathlen = itime;
        }
      }

      eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = pathlen;
      cpu_opts_x->size[1] = 1;
      emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &sb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(pathlen - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
      e_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel112<<<grid, block>>>(gpu_crossCFS, pathlen - 1, gpu_opts_x);
      }

      h_needsGpuEnsureCapacity = true;
    } else {
      eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = cpu_crossCFS->size[0];
      cpu_opts_x->size[1] = cpu_crossCFS->size[1];
      emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &sb_emlrtRTEI);
      eint = cpu_crossCFS->size[0] * cpu_crossCFS->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
      e_omega_tmp1_needsGpuEnsureCapa = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel719<<<grid, block>>>(gpu_crossCFS, eint, gpu_opts_x);
      }

      h_needsGpuEnsureCapacity = true;
    }
  } else {
    eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
    cpu_opts_x->size[0] = cpu_crossCFS->size[1];
    cpu_opts_x->size[1] = cpu_crossCFS->size[0];
    emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &sb_emlrtRTEI);
    eint = cpu_crossCFS->size[0] - 1;
    offsetH = cpu_crossCFS->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(eint, offsetH), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
    e_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel720<<<grid, block>>>(gpu_crossCFS, offsetH, eint, gpu_opts_x,
        cpu_opts_x->size[0U], cpu_crossCFS->size[0U]);
    }

    h_needsGpuEnsureCapacity = true;
  }

  s = static_cast<real_T>(ds[0]) / ds[1];
  p = s;
  r = std::abs(s);
  if (std::isinf(r) || std::isnan(r)) {
    b_r = rtNaN;
  } else if (r < 4.4501477170144028E-308) {
    b_r = 4.94065645841247E-324;
  } else {
    std::frexp(r, &b_exponent);
    b_r = std::ldexp(1.0, b_exponent - 53);
  }

  fb = std::fmax(1.0E-12, b_r);
  if (std::isinf(s) || std::isnan(s)) {
    if (!std::isnan(s)) {
      if (s < 0.0) {
        toler = -1.0;
      } else {
        toler = 1.0;
      }
    } else {
      toler = 0.0;
    }

    b_m = 0.0;
  } else {
    r = 1.0;
    d = 0.0;
    fa = 0.0;
    halfh = 1.0;
    do {
      exitg2 = 0;
      tol = std::round(s);
      if (!std::isinf(s)) {
        s -= tol;
        T = fa;
        fa = r;
        r = r * tol + T;
        T = halfh;
        halfh = d;
        d = d * tol + T;
      } else {
        fa = r;
        halfh = d;
        r = s;
        d = 0.0;
      }

      if ((s == 0.0) || (std::abs(r / d - p) <= fb)) {
        exitg2 = 1;
      } else {
        s = 1.0 / s;
      }
    } while (exitg2 == 0);

    if (std::isnan(d)) {
      halfh = rtNaN;
    } else if (d < 0.0) {
      halfh = -1.0;
    } else {
      halfh = (d > 0.0);
    }

    toler = r / halfh;
    b_m = std::abs(d);
  }

  fa = std::fmax(toler, b_m);
  fc = 0.5 / fa;
  fb = 20.0 * fa + 1.0;
  varargin_2[0] = 0.0;
  varargin_2[1] = 2.0 * fc;
  varargin_2[2] = 2.0 * fc;
  varargin_2[3] = 1.0;
  r = 0.0;
  fa = 0.0;
  Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] > 0.0));
  if (Nodd) {
    r = varargin_2[1];
  }

  Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] < 0.0));
  if (Nodd) {
    fa = varargin_2[1];
  }

  Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(r) || (r < varargin_2[2])));
  if (Nodd) {
    r = varargin_2[2];
  }

  Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(fa) || (fa > varargin_2[2])));
  if (Nodd) {
    fa = varargin_2[2];
  }

  Nodd = (std::isnan(r) || (r < 1.0));
  if (Nodd) {
    r = 1.0;
  }

  Nodd = (std::isnan(fa) || (fa > 1.0));
  if (Nodd) {
    fa = 1.0;
  }

  emxInit_real_T(&c_cpu_h, 2, &fe_emlrtRTEI, true);
  if ((!(r > 1.0)) && (!(fa < 0.0))) {
    for (itime = 0; itime < 4; itime++) {
      F[itime] = varargin_2[itime] / 2.0;
    }

    halfh = (((fb - 1.0) + 1.0) - 1.0) / 2.0;
    Nodd = (rt_remd_snf((fb - 1.0) + 1.0, 2.0) == 1.0);
    T = 0.0;
    emxInit_real_T(&b_cpu_m, 2, &wb_emlrtRTEI, true);
    if (!Nodd) {
      eint = b_cpu_m->size[0] * b_cpu_m->size[1];
      b_cpu_m->size[0] = 1;
      b_cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
      emxEnsureCapacity_real_T(b_cpu_m, eint, &wb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_m, &b_gpu_m, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel113<<<grid, block>>>(static_cast<int32_T>(halfh), b_gpu_m);
      }
    } else {
      eint = b_cpu_m->size[0] * b_cpu_m->size[1];
      b_cpu_m->size[0] = 1;
      b_cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
      emxEnsureCapacity_real_T(b_cpu_m, eint, &vb_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
        &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_m, &b_gpu_m, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel718<<<grid, block>>>(static_cast<int32_T>(halfh), b_gpu_m);
      }
    }

    emxInit_real_T(&b_cpu_k, 1, &yb_emlrtRTEI, true);
    eint = b_cpu_k->size[0];
    b_cpu_k->size[0] = b_cpu_m->size[1];
    emxEnsureCapacity_real_T(b_cpu_k, eint, &yb_emlrtRTEI);
    offsetH = b_cpu_m->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, true);
    interval_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel114<<<grid, block>>>(b_gpu_m, offsetH, b_gpu_k);
    }

    x_data_outdatedOnGpu = false;
    a_data_outdatedOnGpu = true;
    emxFree_real_T(&b_cpu_m);
    first_iteration = (F[2] - F[1] != 0.0);
    nsubs = b_cpu_k->size[0];
    emxInit_real_T(&b_cpu_G, 2, &ge_emlrtRTEI, true);
    if (first_iteration) {
      eint = b_cpu_G->size[0] * b_cpu_G->size[1];
      b_cpu_G->size[0] = b_cpu_k->size[0];
      b_cpu_G->size[1] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(b_cpu_G, eint, &ac_emlrtRTEI);
      k = b_cpu_k->size[0] * b_cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
      b_G_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel115<<<grid, block>>>(k, b_gpu_G);
      }

      f_omega_tmp1_needsGpuEnsureCapa = true;
      p = 2.0 * static_cast<real_T>(b_cpu_k->size[0]) - 1.0;
    } else {
      f_omega_tmp1_needsGpuEnsureCapa = false;
      b_cpu_G->size[0] = 0;
      b_cpu_G->size[1] = 0;
      p = 0.0;
    }

    emxInit_real_T(&b_cpu_sinc1A, 2, &he_emlrtRTEI, true);
    eint = b_cpu_sinc1A->size[0] * b_cpu_sinc1A->size[1];
    b_cpu_sinc1A->size[0] = 1;
    b_cpu_sinc1A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(b_cpu_sinc1A, eint, &bc_emlrtRTEI);
    y_needsGpuEnsureCapacity = true;
    emxInit_real_T(&b_cpu_sinc2A, 2, &ie_emlrtRTEI, true);
    eint = b_cpu_sinc2A->size[0] * b_cpu_sinc2A->size[1];
    b_cpu_sinc2A->size[0] = 1;
    b_cpu_sinc2A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(b_cpu_sinc2A, eint, &cc_emlrtRTEI);
    fx_data_outdatedOnCpu = true;
    emxInit_real_T(&b_cpu_sinc3A, 2, &je_emlrtRTEI, true);
    eint = b_cpu_sinc3A->size[0] * b_cpu_sinc3A->size[1];
    b_cpu_sinc3A->size[0] = 1;
    b_cpu_sinc3A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(b_cpu_sinc3A, eint, &dc_emlrtRTEI);
    c_omega_tmp1_needsGpuEnsureCapa = true;
    emxInit_real_T(&b_cpu_sinc4A, 2, &le_emlrtRTEI, true);
    eint = b_cpu_sinc4A->size[0] * b_cpu_sinc4A->size[1];
    b_cpu_sinc4A->size[0] = 1;
    b_cpu_sinc4A->size[1] = static_cast<int32_T>(p);
    emxEnsureCapacity_real_T(b_cpu_sinc4A, eint, &fc_emlrtRTEI);
    wav_outdatedOnCpu = true;
    if (Nodd) {
      ix = -1;
      if (b_cpu_k->size[0] < 2) {
        pathlen = 0;
        cpu_lidx = 0;
      } else {
        pathlen = 1;
        cpu_lidx = b_cpu_k->size[0];
      }

      nx = cpu_lidx - pathlen;
      for (eint = 0; eint < nx; eint++) {
        if (a_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(b_cpu_k, &b_gpu_k);
        }

        b_cpu_k->data[eint] = b_cpu_k->data[pathlen + eint];
        a_data_outdatedOnGpu = false;
        x_data_outdatedOnGpu = true;
      }

      eint = b_cpu_k->size[0];
      b_cpu_k->size[0] = cpu_lidx - pathlen;
      emxEnsureCapacity_real_T(b_cpu_k, eint, &ic_emlrtRTEI);
      interval_outdatedOnGpu = true;
    } else {
      ix = 0;
    }

    emxInit_real_T(&b_cpu_b, 1, &gc_emlrtRTEI, true);
    eint = b_cpu_b->size[0];
    b_cpu_b->size[0] = b_cpu_k->size[0];
    emxEnsureCapacity_real_T(b_cpu_b, eint, &gc_emlrtRTEI);
    k = b_cpu_k->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
    b_y_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel116<<<grid, block>>>(k, b_gpu_b);
    }

    d_omega_tmp1_needsGpuEnsureCapa = false;
    b_fx_data_outdatedOnCpu = true;
    emxInit_real_T(&cpu_dv29, 1, &oe_emlrtRTEI, true);
    emxInit_real_T(&cpu_dv31, 1, &oe_emlrtRTEI, true);
    emxInit_real_T(&de_cpu_y, 1, &qe_emlrtRTEI, true);
    emxInit_real_T(&ee_cpu_y, 1, &te_emlrtRTEI, true);
    for (pathlen = 0; pathlen < 2; pathlen++) {
      nrefine = pathlen << 1;
      n_idx_0 = A[nrefine];
      tol = F[nrefine + 1];
      s = F[nrefine];
      r = static_cast<real_T>(A[nrefine + 1] - n_idx_0) / (tol - s);
      fa = static_cast<real_T>(n_idx_0) - r * s;
      if (Nodd) {
        T += fa * (tol - s) + r / 2.0 * (tol * tol - s * s);
      }

      eint = cpu_dv29->size[0];
      cpu_dv29->size[0] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_dv29, eint, &mc_emlrtRTEI);
      k = b_cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, !x_data_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_real_T(cpu_dv29, &gpu_dv29, true);
      if (x_data_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_k, b_cpu_k);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel117<<<grid, block>>>(tol, b_gpu_k, k, gpu_dv29);
      }

      nx = cpu_dv29->size[0];
      eint = cpu_dv31->size[0];
      cpu_dv31->size[0] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(cpu_dv31, eint, &mc_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_dv31, &gpu_dv31, true);
      x_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel118<<<grid, block>>>(F[nrefine], b_gpu_k, nx - 1, gpu_dv31,
          gpu_dv29);
      }

      nx = cpu_dv31->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel119<<<grid, block>>>(nx - 1, gpu_dv31);
      }

      a = r / 39.478417604357432;
      if (cpu_dv29->size[0] == 1) {
        eint = b_cpu_k->size[0];
      } else {
        eint = cpu_dv29->size[0];
      }

      if ((cpu_dv29->size[0] == b_cpu_k->size[0]) && (b_cpu_b->size[0] == eint))
      {
        eint = b_cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        interval_outdatedOnGpu = false;
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        b_y_needsGpuEnsureCapacity = false;
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel120<<<grid, block>>>(b_gpu_k, gpu_dv31, gpu_dv29, a,
            eint, b_gpu_b);
        }

        d_omega_tmp1_needsGpuEnsureCapa = false;
        b_fx_data_outdatedOnCpu = true;
      } else {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(b_cpu_b, &b_gpu_b);
        }

        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv29, &gpu_dv29);
        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv31, &gpu_dv31);
        if (a_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(b_cpu_k, &b_gpu_k);
        }

        a_data_outdatedOnGpu = false;
        binary_expand_op_1(b_cpu_b, a, cpu_dv29, cpu_dv31, b_cpu_k);
        b_fx_data_outdatedOnCpu = false;
        d_omega_tmp1_needsGpuEnsureCapa = true;
        interval_outdatedOnGpu = true;
        b_y_needsGpuEnsureCapacity = true;
      }

      eint = de_cpu_y->size[0];
      de_cpu_y->size[0] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(de_cpu_y, eint, &mc_emlrtRTEI);
      k = b_cpu_k->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(b_cpu_k, &b_gpu_k, true);
      }

      gpuEmxEnsureCapacity_real_T(de_cpu_y, &l_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel121<<<grid, block>>>(F[nrefine + 1], b_gpu_k, k, l_gpu_y);
      }

      cpu_lidx = de_cpu_y->size[0];
      s = F[nrefine + 1];
      a = s * (r * s + fa);
      eint = ee_cpu_y->size[0];
      ee_cpu_y->size[0] = b_cpu_k->size[0];
      emxEnsureCapacity_real_T(ee_cpu_y, eint, &mc_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
        2147483647U);
      interval_outdatedOnGpu = false;
      gpuEmxEnsureCapacity_real_T(ee_cpu_y, &m_gpu_y, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel122<<<grid, block>>>(F[nrefine], b_gpu_k, cpu_lidx - 1,
          m_gpu_y, l_gpu_y);
      }

      cpu_lidx = ee_cpu_y->size[0];
      mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel123<<<grid, block>>>(cpu_lidx - 1, m_gpu_y);
      }

      s = F[nrefine];
      c_a = s * (r * s + fa);
      if (b_cpu_b->size[0] == de_cpu_y->size[0]) {
        eint = b_cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        b_y_needsGpuEnsureCapacity = false;
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel124<<<grid, block>>>(m_gpu_y, c_a, l_gpu_y, a, eint,
            b_gpu_b);
        }

        d_omega_tmp1_needsGpuEnsureCapa = false;
        b_fx_data_outdatedOnCpu = true;
      } else {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(b_cpu_b, &b_gpu_b);
        }

        gpuEmxMemcpyGpuToCpu_real_T(de_cpu_y, &l_gpu_y);
        gpuEmxMemcpyGpuToCpu_real_T(ee_cpu_y, &m_gpu_y);
        binary_expand_op(b_cpu_b, a, de_cpu_y, c_a, ee_cpu_y);
        b_fx_data_outdatedOnCpu = false;
        d_omega_tmp1_needsGpuEnsureCapa = true;
        b_y_needsGpuEnsureCapacity = true;
      }

      if (first_iteration) {
        r = 2.0 * F[nrefine + 1];
        fa = 2.0 * F[nrefine];
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(p) - 1),
          &grid, &block, 2147483647U);
        if (wav_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_sinc4A, &b_gpu_sinc4A, true);
        }

        if (c_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxEnsureCapacity_real_T(b_cpu_sinc3A, &b_gpu_sinc3A, true);
        }

        if (fx_data_outdatedOnCpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_sinc2A, &b_gpu_sinc2A, true);
        }

        if (y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_sinc1A, &b_gpu_sinc1A, true);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel125<<<grid, block>>>(fa, r, nsubs, ix,
            static_cast<int32_T>(p) - 1, b_gpu_sinc4A, b_gpu_sinc3A,
            b_gpu_sinc2A, b_gpu_sinc1A);
        }

        mwGetLaunchParameters1D(computeNumIters(nsubs - 1, nsubs - 1), &grid,
          &block, 2147483647U);
        wav_outdatedOnCpu = false;
        fx_data_outdatedOnCpu = false;
        c_omega_tmp1_needsGpuEnsureCapa = false;
        y_needsGpuEnsureCapacity = false;
        if (b_G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
        }

        b_G_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel126<<<grid, block>>>(b_gpu_sinc4A, b_gpu_sinc2A, fa,
            b_gpu_sinc3A, b_gpu_sinc1A, r, nsubs, nsubs - 1, nsubs - 1, b_gpu_G,
            b_cpu_G->size[0U]);
        }

        f_omega_tmp1_needsGpuEnsureCapa = true;
      }
    }

    emxFree_real_T(&ee_cpu_y);
    emxFree_real_T(&de_cpu_y);
    emxFree_real_T(&cpu_dv31);
    emxFree_real_T(&cpu_dv29);
    emxFree_real_T(&b_cpu_sinc4A);
    emxFree_real_T(&b_cpu_sinc3A);
    emxFree_real_T(&b_cpu_sinc2A);
    emxFree_real_T(&b_cpu_sinc1A);
    emxFree_real_T(&b_cpu_k);
    if (Nodd) {
      emxInit_real_T(&b_cpu_b0, 1, &jc_emlrtRTEI, true);
      eint = b_cpu_b0->size[0];
      b_cpu_b0->size[0] = b_cpu_b->size[0] + 1;
      emxEnsureCapacity_real_T(b_cpu_b0, eint, &jc_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(b_cpu_b0, &b_gpu_b0, true);
      ec_wtcc_kernel127<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(T, b_gpu_b0);
      nx = b_cpu_b->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      if (b_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
          !d_omega_tmp1_needsGpuEnsureCapa);
      }

      if (d_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel128<<<grid, block>>>(b_gpu_b, nx - 1, b_gpu_b0);
      }

      eint = b_cpu_b->size[0];
      b_cpu_b->size[0] = b_cpu_b0->size[0];
      emxEnsureCapacity_real_T(b_cpu_b, eint, &pc_emlrtRTEI);
      eint = b_cpu_b0->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
      b_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel129<<<grid, block>>>(b_gpu_b0, eint, b_gpu_b);
      }

      d_omega_tmp1_needsGpuEnsureCapa = false;
      emxFree_real_T(&b_cpu_b0);
    }

    emxInit_real_T(&k_cpu_a, 1, &fe_emlrtRTEI, true);
    if (first_iteration) {
      emxInit_int32_T(&b_cpu_jpvt, 2, &fe_emlrtRTEI, true);
      emxInit_real_T(&b_cpu_tau, 1, &fe_emlrtRTEI, true);
      emxInit_ptrdiff_t(&b_jpvt_t, 1, &ad_emlrtRTEI, true);
      emxInit_int32_T(&b_cpu_IPIV, 1, &re_emlrtRTEI, true);
      if ((b_cpu_G->size[0] == 0) || (b_cpu_G->size[1] == 0) || (b_cpu_b->size[0]
           == 0)) {
        eint = k_cpu_a->size[0];
        k_cpu_a->size[0] = b_cpu_G->size[1];
        emxEnsureCapacity_real_T(k_cpu_a, eint, &lc_emlrtRTEI);
        eint = b_cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, true);
        c_omega_tmp1_needsGpuEnsureCapa = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel130<<<grid, block>>>(eint, e_gpu_a);
        }

        fx_data_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
      } else if (b_cpu_G->size[0] == b_cpu_G->size[1]) {
        eint = k_cpu_a->size[0];
        k_cpu_a->size[0] = b_cpu_b->size[0];
        emxEnsureCapacity_real_T(k_cpu_a, eint, &lc_emlrtRTEI);
        eint = b_cpu_b->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, true);
        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel706<<<grid, block>>>(b_gpu_b, eint, e_gpu_a);
        }

        itime = b_cpu_G->size[0];
        pathlen = b_cpu_G->size[1];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        itime = k_cpu_a->size[0];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        eint = b_cpu_IPIV->size[0];
        b_cpu_IPIV->size[0] = pathlen;
        emxEnsureCapacity_int32_T(b_cpu_IPIV, eint, &sc_emlrtRTEI);
        if (b_G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, true);
        }

        cusolverCheck(cusolverDnDgetrf_bufferSize(getCuSolverGlobalHandle(),
          pathlen, pathlen, (double *)&b_gpu_G.data[0], b_cpu_G->size[0],
          getCuSolverWorkspaceReq()), __FILE__, __LINE__);
        setCuSolverWorkspaceTypeSize(8);
        cusolverInitWorkspace();
        gpuEmxEnsureCapacity_int32_T(b_cpu_IPIV, &gpu_IPIV, true);
        cusolverCheck(cusolverDnDgetrf(getCuSolverGlobalHandle(), pathlen,
          pathlen, (double *)&b_gpu_G.data[0], b_cpu_G->size[0], static_cast<
          real_T *>(getCuSolverWorkspaceBuff()), &gpu_IPIV.data[0], gpu_lidx),
                      __FILE__, __LINE__);
        checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        if (cpu_lidx < 0) {
          omega_tmp2[0] = k_cpu_a->size[0];
          eint = k_cpu_a->size[0];
          k_cpu_a->size[0] = omega_tmp2[0];
          emxEnsureCapacity_real_T(k_cpu_a, eint, &bd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, true);
          c_omega_tmp1_needsGpuEnsureCapa = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel707<<<grid, block>>>(omega_tmp2[0] - 1, e_gpu_a);
          }

          fx_data_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
        } else {
          c_omega_tmp1_needsGpuEnsureCapa = false;
          cusolverCheck(cusolverDnDgetrs(getCuSolverGlobalHandle(), CUBLAS_OP_N,
            pathlen, 1, (double *)&b_gpu_G.data[0], b_cpu_G->size[0],
            &gpu_IPIV.data[0], (double *)&e_gpu_a.data[0], k_cpu_a->size[0],
            gpu_lidx), __FILE__, __LINE__);
          fx_data_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
        }
      } else {
        ptrdiff_t b_info_t;
        n = b_cpu_G->size[0];
        ix = b_cpu_G->size[1] - 1;
        eint = b_cpu_jpvt->size[0] * b_cpu_jpvt->size[1];
        b_cpu_jpvt->size[0] = 1;
        b_cpu_jpvt->size[1] = b_cpu_G->size[1];
        emxEnsureCapacity_int32_T(b_cpu_jpvt, eint, &rc_emlrtRTEI);
        eint = b_cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_int32_T(b_cpu_jpvt, &gpu_jpvt, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel708<<<grid, block>>>(eint, gpu_jpvt);
        }

        wav_outdatedOnCpu = false;
        y_needsGpuEnsureCapacity = true;
        itime = b_cpu_G->size[0];
        cpu_lidx = b_cpu_G->size[1];
        if (itime <= cpu_lidx) {
          cpu_lidx = itime;
        }

        eint = b_cpu_tau->size[0];
        b_cpu_tau->size[0] = cpu_lidx;
        emxEnsureCapacity_real_T(b_cpu_tau, eint, &xc_emlrtRTEI);
        eint = b_jpvt_t->size[0];
        b_jpvt_t->size[0] = b_cpu_G->size[1];
        emxEnsureCapacity_ptrdiff_t(b_jpvt_t, eint, &ad_emlrtRTEI);
        for (eint = 0; eint < b_cpu_G->size[1]; eint++) {
          b_jpvt_t->data[eint] = (ptrdiff_t)0;
        }

        if (f_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
        }

        b_info_t = LAPACKE_dgeqp3(102, (ptrdiff_t)b_cpu_G->size[0], (ptrdiff_t)
          b_cpu_G->size[1], &b_cpu_G->data[0], (ptrdiff_t)b_cpu_G->size[0],
          &b_jpvt_t->data[0], &b_cpu_tau->data[0]);
        fx_data_outdatedOnCpu = true;
        f_omega_tmp1_needsGpuEnsureCapa = false;
        x_data_outdatedOnGpu = true;
        a_data_outdatedOnGpu = true;
        b_G_needsGpuEnsureCapacity = true;
        if ((int32_T)b_info_t != 0) {
          mwGetLaunchParameters1D(computeNumIters(ix, n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, false);
          b_G_needsGpuEnsureCapacity = false;
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_G, b_cpu_G);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel709<<<grid, block>>>(n - 1, ix, b_gpu_G, b_cpu_G->
              size[0U]);
          }

          x_data_outdatedOnGpu = false;
          f_omega_tmp1_needsGpuEnsureCapa = true;
          itime = b_cpu_G->size[0];
          nrefine = b_cpu_G->size[1];
          if (itime <= nrefine) {
            nrefine = itime;
          }

          mwGetLaunchParameters1D(computeNumIters(nrefine - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(b_cpu_tau, &gpu_tau, false);
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, b_cpu_tau);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel710<<<grid, block>>>(nrefine - 1, gpu_tau);
          }

          f = computeEndIdx(static_cast<int64_T>(nrefine + 1),
                            static_cast<int64_T>(cpu_lidx), 1L);
          mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
          a_data_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel711<<<grid, block>>>(nrefine + 1, f, gpu_tau);
          }

          fx_data_outdatedOnCpu = false;
          mwGetLaunchParameters1D(computeNumIters(ix), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel712<<<grid, block>>>(ix, gpu_jpvt);
          }
        } else {
          for (k = 0; k <= ix; k++) {
            if (y_needsGpuEnsureCapacity) {
              gpuEmxMemcpyGpuToCpu_int32_T(b_cpu_jpvt, &gpu_jpvt);
            }

            b_cpu_jpvt->data[k] = (int32_T)b_jpvt_t->data[k];
            y_needsGpuEnsureCapacity = false;
            wav_outdatedOnCpu = true;
            interval_outdatedOnGpu = true;
          }
        }

        nsubs = -1;
        if (b_cpu_G->size[0] < b_cpu_G->size[1]) {
          nrefine = b_cpu_G->size[0];
          cpu_lidx = b_cpu_G->size[1];
        } else {
          nrefine = b_cpu_G->size[1];
          cpu_lidx = b_cpu_G->size[0];
        }

        exitg1 = false;
        while ((!exitg1) && (nsubs + 1 < nrefine)) {
          if (f_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
          }

          f_omega_tmp1_needsGpuEnsureCapa = false;
          if (!(std::abs(b_cpu_G->data[(nsubs + b_cpu_G->size[0] * (nsubs + 1))
                         + 1]) <= std::fmin(1.4901161193847656E-8,
                2.2204460492503131E-15 * static_cast<real_T>(cpu_lidx)) * std::
                abs(b_cpu_G->data[0]))) {
            b_G_needsGpuEnsureCapacity = true;
            nsubs++;
          } else {
            b_G_needsGpuEnsureCapacity = true;
            exitg1 = true;
          }
        }

        eint = k_cpu_a->size[0];
        k_cpu_a->size[0] = b_cpu_G->size[1];
        emxEnsureCapacity_real_T(k_cpu_a, eint, &lc_emlrtRTEI);
        eint = b_cpu_G->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel713<<<grid, block>>>(eint, e_gpu_a);
        }

        cpu_lidx = 0;
        itime = b_cpu_G->size[0];
        pathlen = b_cpu_G->size[1];
        if (itime <= pathlen) {
          pathlen = itime;
        }

        if (b_G_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_G, &b_gpu_G, !x_data_outdatedOnGpu);
        }

        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_real_T(b_cpu_tau, &gpu_tau,
            !fx_data_outdatedOnCpu);
        }

        if (b_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
            !d_omega_tmp1_needsGpuEnsureCapa);
        }

        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_G, b_cpu_G);
        }

        if (fx_data_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, b_cpu_tau);
        }

        if (d_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
        }

        cusolverCheck(cusolverDnDormqr_bufferSize(getCuSolverGlobalHandle(),
          CUBLAS_SIDE_LEFT, CUBLAS_OP_T, b_cpu_b->size[0], 1, pathlen, (double *)
          &b_gpu_G.data[0], b_cpu_G->size[0], (double *)&gpu_tau.data[0],
          (double *)&b_gpu_b.data[0], b_cpu_b->size[0], getCuSolverWorkspaceReq()),
                      __FILE__, __LINE__);
        setCuSolverWorkspaceTypeSize(8);
        cusolverInitWorkspace();
        checkCudaError(cudaMemcpy(gpu_lidx, &cpu_lidx, 4UL,
          cudaMemcpyHostToDevice), __FILE__, __LINE__);
        cusolverCheck(cusolverDnDormqr(getCuSolverGlobalHandle(),
          CUBLAS_SIDE_LEFT, CUBLAS_OP_T, b_cpu_b->size[0], 1, pathlen, (double *)
          &b_gpu_G.data[0], b_cpu_G->size[0], (double *)&gpu_tau.data[0],
          (double *)&b_gpu_b.data[0], b_cpu_b->size[0], static_cast<real_T *>
          (getCuSolverWorkspaceBuff()), *getCuSolverWorkspaceReq(), gpu_lidx),
                      __FILE__, __LINE__);
        checkCudaError(cudaMemcpy(&cpu_lidx, gpu_lidx, 4UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        if (cpu_lidx < 0) {
          omega_tmp2[0] = b_cpu_b->size[0];
          eint = b_cpu_b->size[0];
          b_cpu_b->size[0] = omega_tmp2[0];
          emxEnsureCapacity_real_T(b_cpu_b, eint, &fd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel714<<<grid, block>>>(omega_tmp2[0] - 1, b_gpu_b);
          }
        }

        mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
          2147483647U);
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_int32_T(b_cpu_jpvt, &gpu_jpvt, !wav_outdatedOnCpu);
        }

        c_omega_tmp1_needsGpuEnsureCapa = false;
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyCpuToGpu_int32_T(&gpu_jpvt, b_cpu_jpvt);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel715<<<grid, block>>>(b_gpu_b, gpu_jpvt, nsubs, e_gpu_a);
        }

        fx_data_outdatedOnCpu = false;
        interval_outdatedOnGpu = true;
        for (nx = 0; nx <= nsubs; nx++) {
          if (y_needsGpuEnsureCapacity) {
            gpuEmxMemcpyGpuToCpu_int32_T(b_cpu_jpvt, &gpu_jpvt);
          }

          y_needsGpuEnsureCapacity = false;
          eint = b_cpu_jpvt->data[nsubs - nx];
          if (interval_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_real_T(k_cpu_a, &e_gpu_a);
          }

          if (f_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxMemcpyGpuToCpu_real_T(b_cpu_G, &b_gpu_G);
          }

          f_omega_tmp1_needsGpuEnsureCapa = false;
          k_cpu_a->data[eint - 1] /= b_cpu_G->data[(nsubs - nx) + b_cpu_G->size
            [0] * (nsubs - nx)];
          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = true;
          c_omega_tmp1_needsGpuEnsureCapa = true;
          cpu_lidx = nsubs - nx;
          for (ix = 0; ix < cpu_lidx; ix++) {
            k_cpu_a->data[b_cpu_jpvt->data[ix] - 1] -= k_cpu_a->data
              [b_cpu_jpvt->data[nsubs - nx] - 1] * b_cpu_G->data[ix +
              b_cpu_G->size[0] * (nsubs - nx)];
          }
        }
      }

      emxFree_int32_T(&b_cpu_IPIV);
      emxFree_ptrdiff_t(&b_jpvt_t);
      emxFree_real_T(&b_cpu_tau);
      emxFree_int32_T(&b_cpu_jpvt);
    } else {
      eint = k_cpu_a->size[0];
      k_cpu_a->size[0] = b_cpu_b->size[0];
      emxEnsureCapacity_real_T(k_cpu_a, eint, &kc_emlrtRTEI);
      eint = b_cpu_b->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      if (b_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(b_cpu_b, &b_gpu_b,
          !d_omega_tmp1_needsGpuEnsureCapa);
      }

      gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, true);
      c_omega_tmp1_needsGpuEnsureCapa = false;
      if (d_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_b, b_cpu_b);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel716<<<grid, block>>>(b_gpu_b, eint, e_gpu_a);
      }

      fx_data_outdatedOnCpu = false;
      interval_outdatedOnGpu = true;
      if (Nodd) {
        ec_wtcc_kernel717<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(e_gpu_a);
      }
    }

    emxFree_real_T(&b_cpu_b);
    emxFree_real_T(&b_cpu_G);
    if (Nodd) {
      if (halfh + 1.0 < 2.0) {
        nrefine = 0;
        cpu_lidx = 1;
        pathlen = -1;
        nsubs = 0;
        ix = 0;
      } else {
        nrefine = static_cast<int32_T>(halfh + 1.0) - 1;
        cpu_lidx = -1;
        pathlen = 1;
        nsubs = 1;
        ix = static_cast<int32_T>(halfh + 1.0);
      }

      eint = c_cpu_h->size[0] * c_cpu_h->size[1];
      c_cpu_h->size[0] = 1;
      c_cpu_h->size[1] = ((div_s32(pathlen - nrefine, cpu_lidx) + ix) - nsubs) +
        2;
      emxEnsureCapacity_real_T(c_cpu_h, eint, &cd_emlrtRTEI);
      nx = div_s32(pathlen - nrefine, cpu_lidx);
      mwGetLaunchParameters1D(computeNumIters(nx), &grid, &block, 2147483647U);
      if (c_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, true);
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&e_gpu_a, k_cpu_a);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel131<<<grid, block>>>(e_gpu_a, cpu_lidx, nrefine, nx,
          c_gpu_h);
      }

      b_h_needsGpuEnsureCapacity = false;
      ec_wtcc_kernel132<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(e_gpu_a,
        cpu_lidx, nrefine, pathlen, c_gpu_h);
      b_fx_data_outdatedOnCpu = true;
      nx = ix - nsubs;
      for (eint = 0; eint < nx; eint++) {
        if (b_fx_data_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(c_cpu_h, &c_gpu_h);
        }

        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(k_cpu_a, &e_gpu_a);
        }

        interval_outdatedOnGpu = false;
        c_cpu_h->data[(eint + div_s32(pathlen - nrefine, cpu_lidx)) + 2] =
          k_cpu_a->data[nsubs + eint] / 2.0;
        b_fx_data_outdatedOnCpu = false;
        b_h_outdatedOnGpu = true;
        b_h_needsGpuEnsureCapacity = true;
      }
    } else {
      emxInit_real_T(&q_cpu_x, 1, &pe_emlrtRTEI, true);
      eint = q_cpu_x->size[0];
      q_cpu_x->size[0] = k_cpu_a->size[0];
      emxEnsureCapacity_real_T(q_cpu_x, eint, &vc_emlrtRTEI);
      eint = k_cpu_a->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      if (c_omega_tmp1_needsGpuEnsureCapa) {
        gpuEmxEnsureCapacity_real_T(k_cpu_a, &e_gpu_a, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_real_T(q_cpu_x, &g_gpu_x, true);
      x_data_outdatedOnGpu = false;
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&e_gpu_a, k_cpu_a);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel703<<<grid, block>>>(e_gpu_a, eint, g_gpu_x);
      }

      a_data_outdatedOnGpu = false;
      interval_outdatedOnGpu = true;
      n = k_cpu_a->size[0] - 1;
      nrefine = k_cpu_a->size[0] >> 1;
      for (ix = 0; ix < nrefine; ix++) {
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(q_cpu_x, &g_gpu_x);
        }

        r = q_cpu_x->data[ix];
        q_cpu_x->data[ix] = q_cpu_x->data[n - ix];
        q_cpu_x->data[n - ix] = r;
        interval_outdatedOnGpu = false;
        a_data_outdatedOnGpu = true;
        x_data_outdatedOnGpu = true;
      }

      eint = c_cpu_h->size[0] * c_cpu_h->size[1];
      c_cpu_h->size[0] = 1;
      c_cpu_h->size[1] = q_cpu_x->size[0] + k_cpu_a->size[0];
      emxEnsureCapacity_real_T(c_cpu_h, eint, &dd_emlrtRTEI);
      nx = q_cpu_x->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      if (x_data_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(q_cpu_x, &g_gpu_x, !a_data_outdatedOnGpu);
      }

      gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, true);
      if (a_data_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&g_gpu_x, q_cpu_x);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel704<<<grid, block>>>(g_gpu_x, nx - 1, c_gpu_h);
      }

      nx = k_cpu_a->size[0];
      mwGetLaunchParameters1D(computeNumIters(nx - 1), &grid, &block,
        2147483647U);
      b_h_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel705<<<grid, block>>>(e_gpu_a, nx - 1, c_gpu_h,
          q_cpu_x->size[0U]);
      }

      emxFree_real_T(&q_cpu_x);
    }

    emxFree_real_T(&k_cpu_a);
  }

  if (fb == std::floor(fb)) {
    nsubs = static_cast<int32_T>(fb);
  } else {
    nsubs = static_cast<int32_T>(std::round(fb));
    coder::internal::warning();
  }

  emxInit_real_T(&cpu_dv27, 1, &ee_emlrtRTEI, true);
  eint = cpu_dv27->size[0];
  cpu_dv27->size[0] = nsubs;
  emxEnsureCapacity_real_T(cpu_dv27, eint, &tb_emlrtRTEI);
  if (nsubs <= 1) {
    eint = cpu_dv27->size[0];
    cpu_dv27->size[0] = nsubs;
    emxEnsureCapacity_real_T(cpu_dv27, eint, &ub_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel133<<<grid, block>>>(nsubs - 1, gpu_dv27);
    }

    x_data_outdatedOnGpu = false;
  } else {
    cpu_lidx = nsubs >> 1;
    f = computeEndIdx(static_cast<int64_T>(cpu_lidx + 1), static_cast<int64_T>
                      (nsubs), 1L);
    mwGetLaunchParameters1D(computeNumIters(f), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, true);
    fx_data_outdatedOnCpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel702<<<grid, block>>>(gpu_dc6, *global_gpu_table100, dc7,
        gpu_dc, nsubs, cpu_lidx, 1 - (nsubs & 1), cpu_lidx + 1, f, gpu_dv27, q1
        [0], q1[1], q1[2], q1[3], q1[4], q1[5], q1[6], q1[7], p1[0], p1[1], p1[2],
        p1[3], p1[4], p1[5], p1[6], p1[7], q2[0], q2[1], q2[2], q2[3], q2[4],
        q2[5], q2[6], q2[7], p2[0], p2[1], p2[2], p2[3], p2[4], p2[5], p2[6],
        p2[7], q4[0], q4[1], q4[2], q4[3], q4[4], q4[5], q4[6], q4[7], p4[0],
        p4[1], p4[2], p4[3], p4[4], p4[5], p4[6], p4[7], c_c[0], c_c[1], c_c[2],
        c_c[3], c_c[4], c_c[5], c_c[6]);
    }

    x_data_outdatedOnGpu = false;
    interval_outdatedOnGpu = true;
    for (k = 0; k < cpu_lidx; k++) {
      if (interval_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_dv27, &gpu_dv27);
      }

      cpu_dv27->data[k] = cpu_dv27->data[(nsubs - k) - 1];
      interval_outdatedOnGpu = false;
      x_data_outdatedOnGpu = true;
      fx_data_outdatedOnCpu = true;
    }
  }

  emxInit_real_T(&b_cpu_h1, 1, &xb_emlrtRTEI, true);
  eint = b_cpu_h1->size[0];
  b_cpu_h1->size[0] = c_cpu_h->size[1];
  emxEnsureCapacity_real_T(b_cpu_h1, eint, &xb_emlrtRTEI);
  offsetH = c_cpu_h->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  if (fx_data_outdatedOnCpu) {
    gpuEmxEnsureCapacity_real_T(cpu_dv27, &gpu_dv27, !x_data_outdatedOnGpu);
  }

  if (b_h_needsGpuEnsureCapacity) {
    gpuEmxEnsureCapacity_real_T(c_cpu_h, &c_gpu_h, !b_h_outdatedOnGpu);
  }

  gpuEmxEnsureCapacity_real_T(b_cpu_h1, &b_gpu_h1, true);
  interval_outdatedOnGpu = false;
  if (x_data_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_real_T(&gpu_dv27, cpu_dv27);
  }

  if (b_h_outdatedOnGpu) {
    gpuEmxMemcpyCpuToGpu_real_T(&c_gpu_h, c_cpu_h);
  }

  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel134<<<grid, block>>>(gpu_dv27, c_gpu_h, offsetH, b_gpu_h1);
  }

  emxFree_real_T(&c_cpu_h);
  emxFree_real_T(&cpu_dv27);
  cpu_lidx = b_cpu_h1->size[0];
  if (b_cpu_h1->size[0] == 0) {
    halfh = 0.0;
  } else {
    gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h1, &b_gpu_h1);
    halfh = b_cpu_h1->data[0];
    interval_outdatedOnGpu = true;
    for (k = 0; k <= cpu_lidx - 2; k++) {
      halfh += b_cpu_h1->data[k + 1];
    }
  }

  emxInit_real32_T(&b_cpu_opts_filter, 1, &sb_emlrtRTEI, true);
  eint = b_cpu_opts_filter->size[0];
  b_cpu_opts_filter->size[0] = b_cpu_h1->size[0];
  emxEnsureCapacity_real32_T(b_cpu_opts_filter, eint, &sb_emlrtRTEI);
  offsetH = b_cpu_h1->size[0] - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  if (interval_outdatedOnGpu) {
    gpuEmxEnsureCapacity_real_T(b_cpu_h1, &b_gpu_h1, true);
  }

  gpuEmxEnsureCapacity_real32_T(b_cpu_opts_filter, &b_gpu_opts_filter, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel135<<<grid, block>>>(halfh, b_gpu_h1, toler, offsetH,
      b_gpu_opts_filter);
  }

  emxFree_real_T(&b_cpu_h1);
  r = (static_cast<real_T>(b_cpu_opts_filter->size[0]) - 1.0) / 2.0;
  b_r = r;
  if (b_m == 0.0) {
    if (r == 0.0) {
      b_r = 0.0;
    }
  } else if (std::isnan(b_m)) {
    b_r = rtNaN;
  } else if (r == 0.0) {
    b_r = 0.0;
  } else if (std::isinf(b_m)) {
    if (r < 0.0) {
      b_r = b_m;
    }
  } else {
    b_r = std::fmod(r, b_m);
    if (b_r == 0.0) {
      b_r = b_m * 0.0;
    } else if (r < 0.0) {
      b_r += b_m;
    }
  }

  halfh = std::floor(b_m - b_r);
  T = std::floor(std::ceil(r + halfh) / b_m);
  r = static_cast<real_T>(b_cpu_opts_filter->size[0]) + halfh;
  fa = 0.0;
  cpu_lidx = cpu_opts_x->size[0];
  while (std::ceil((((static_cast<real_T>(cpu_lidx) - 1.0) * toler + r) + fa) /
                   b_m) - T < std::ceil(static_cast<real_T>(cpu_lidx) * toler /
          b_m)) {
    fa++;
  }

  emxInit_real32_T(&d_cpu_h, 1, &ec_emlrtRTEI, true);
  eint = d_cpu_h->size[0];
  d_cpu_h->size[0] = static_cast<int32_T>((halfh + static_cast<real_T>
    (b_cpu_opts_filter->size[0])) + fa);
  emxEnsureCapacity_real32_T(d_cpu_h, eint, &ec_emlrtRTEI);
  offsetH = static_cast<int32_T>((halfh + static_cast<real_T>
    (b_cpu_opts_filter->size[0])) + fa) - 1;
  mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel136<<<grid, block>>>(offsetH, d_gpu_h);
  }

  emxInit_uint32_T(&ce_cpu_y, 2, &ke_emlrtRTEI, true);
  if (b_cpu_opts_filter->size[0] < 1) {
    ce_cpu_y->size[0] = 1;
    ce_cpu_y->size[1] = 0;
  } else {
    N = static_cast<uint32_T>(b_cpu_opts_filter->size[0]);
    eint = ce_cpu_y->size[0] * ce_cpu_y->size[1];
    ce_cpu_y->size[0] = 1;
    ce_cpu_y->size[1] = b_cpu_opts_filter->size[0];
    emxEnsureCapacity_uint32_T(ce_cpu_y, eint, &d_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(N) - 1), &grid,
      &block, 2147483647U);
    gpuEmxEnsureCapacity_uint32_T(ce_cpu_y, &n_gpu_y, true);
    i_y_needsGpuEnsureCapacity = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_wtcc_kernel701<<<grid, block>>>(static_cast<int32_T>(N) - 1, n_gpu_y);
    }
  }

  emxInit_int32_T(&cpu_iv92, 2, &me_emlrtRTEI, true);
  eint = cpu_iv92->size[0] * cpu_iv92->size[1];
  cpu_iv92->size[0] = 1;
  cpu_iv92->size[1] = ce_cpu_y->size[1];
  emxEnsureCapacity_int32_T(cpu_iv92, eint, &hc_emlrtRTEI);
  eint = ce_cpu_y->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  if (i_y_needsGpuEnsureCapacity) {
    gpuEmxEnsureCapacity_uint32_T(ce_cpu_y, &n_gpu_y, true);
  }

  gpuEmxEnsureCapacity_int32_T(cpu_iv92, &gpu_iv92, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel137<<<grid, block>>>(n_gpu_y, halfh, eint, gpu_iv92);
  }

  emxFree_uint32_T(&ce_cpu_y);
  eint = cpu_iv92->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  b_h_needsGpuEnsureCapacity = false;
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_wtcc_kernel138<<<grid, block>>>(b_gpu_opts_filter, gpu_iv92, eint,
      d_gpu_h);
  }

  b_fx_data_outdatedOnCpu = true;
  emxFree_int32_T(&cpu_iv92);
  emxFree_real32_T(&b_cpu_opts_filter);
  emxInit_creal32_T(&b_cpu_y1, 2, &ne_emlrtRTEI, true);
  if (x_size_idx_1 == 1) {
    if (opts_isRowVectorInput) {
      emxInit_creal32_T(&l_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&o_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&r_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&gb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&ib_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&lb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&u_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&m_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&w_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&p_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&g_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&s_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&jc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&nc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&qc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ke_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&tc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pe_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&re_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&xc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ad_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ue_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xe_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&i_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ef_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv141, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&l_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&hf_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv143, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&dd_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&gd_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv147, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv148, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&lf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&of_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&rf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv151, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&tf_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv154, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ag_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&bc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&cg_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_creal32_T(&kd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&md_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv161, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv163, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&dc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv166, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&qd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&td_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&lg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&wd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&yd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv171, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&sg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&vg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&be_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ee_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv173, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&i_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&yg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv175, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ch_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv180, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&l_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv185, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv186, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&tc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv188, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&bd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv193, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ed_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&hd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv198, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&f_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&i_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&l_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&o_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&r_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&u_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&w_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&x_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&bb_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&db_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&rb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&ub_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&wb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&ac_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&dc_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&gh_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&ih_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&gc_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((toler == 1.0) && (b_m == 1.0)) {
        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = cpu_opts_x->size[0];
        b_cpu_y1->size[1] = cpu_opts_x->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &oc_emlrtRTEI);
        offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel139<<<grid, block>>>(gpu_opts_x, offsetH, gpu_y1);
        }
      } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
        if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
          pathlen = 0;
        } else {
          itime = cpu_opts_x->size[0];
          pathlen = cpu_opts_x->size[1];
          if (itime >= pathlen) {
            pathlen = itime;
          }
        }

        halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
        if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            lc_y = nullptr;
            m65 = emlrtCreateCharArray(2, &iv125[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m65, &rfmt[0]);
            emlrtAssign(&lc_y, m65);
            uc_y = nullptr;
            m71 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&uc_y, m71);
            emlrt_marshallIn(b_sprintf(lc_y, uc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          eint = r_cpu_yCol->size[0];
          r_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(r_cpu_yCol, eint, &yc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(r_cpu_yCol, &gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel141<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel142<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
              (cpu_lidx - 1, nrefine), gpu_yCol);
          }

          ec_wtcc_kernel143<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
            *gpu_csz);
          if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
            real32_T cpu_f1;
            eint = s_cpu_a->size[0];
            s_cpu_a->size[0] = 1;
            emxEnsureCapacity_creal32_T(s_cpu_a, eint, &fb_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(s_cpu_a, &f_gpu_a, true);
            ec_wtcc_kernel144<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_yCol, gpu_cv_re, f_gpu_a);
            eint = g_c->size[0];
            g_c->size[0] = 1;
            emxEnsureCapacity_creal32_T(g_c, eint, &hb_emlrtRTEI);
            checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            gpuEmxMemcpyGpuToCpu_creal32_T(s_cpu_a, &f_gpu_a);
            cpu_f1 = cpu_cv_re * s_cpu_a->data[0].re;
            cv_im = cpu_cv_re * s_cpu_a->data[0].im;
            g_c->data[0].im = cv_im;
            g_c->data[0].re = cpu_f1;
            eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
            lb_cpu_w->size[0] = 1;
            lb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
            lb_cpu_w->data[0] = g_c->data[0];
            x_data_outdatedOnGpu = true;
            a_data_outdatedOnGpu = true;
          } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
            lb_cpu_w->size[0] = itime;
            lb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel156<<<grid, block>>>(itime - 1, gpu_w);
            }

            x_data_outdatedOnGpu = false;
            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            if (b_cpu_csz[0] == 0) {
              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = itime;
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel157<<<grid, block>>>(itime - 1, gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && (b_cpu_csz[0] == 1)) {
              ec_wtcc_kernel158<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel159<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = 1;
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel160<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (gpu_yCol, *gpu_a_data, gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = gd_cpu_expanded->size[0] * gd_cpu_expanded->size[1];
              gd_cpu_expanded->size[0] = nx;
              gd_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(gd_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + b_cpu_csz[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(gd_cpu_expanded, &gpu_expanded, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel161<<<grid, block>>>(eint, gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = rf_cpu_y->size[0] * rf_cpu_y->size[1];
              rf_cpu_y->size[0] = 1;
              rf_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(rf_cpu_y, eint, &kb_emlrtRTEI);
              rf_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                rf_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv161->size[0];
              cpu_iv161->size[0] = rf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv161, eint, &jb_emlrtRTEI);
              eint = rf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(rf_cpu_y, &s_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv161, &gpu_iv161, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&s_gpu_y, rf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel162<<<grid, block>>>(offsetH, s_gpu_y, eint,
                  gpu_iv161);
              }

              omega_tmp2[0] = cpu_iv161->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel163<<<grid, block>>>(d_gpu_h, gpu_iv161,
                  omega_tmp2[0] - 1, gpu_expanded);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = kc_cpu_rows->size[0] * kc_cpu_rows->size[1];
              kc_cpu_rows->size[0] = 1;
              kc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(kc_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                kc_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  kc_cpu_rows->data[k + 1] = itime;
                }
              }

              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = x_size_idx_1;
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_int32_T(kc_cpu_rows, &gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&gpu_rows, kc_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel164<<<grid, block>>>(gpu_expanded, gpu_rows,
                    gpu_yCol, *gpu_csz, x_size_idx_1 - 1, gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
            }

            eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
            lb_cpu_w->size[0] = itime;
            lb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel165<<<grid, block>>>(itime - 1, gpu_w);
            }

            x_data_outdatedOnGpu = false;
            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            if (b_cpu_csz[0] == 0) {
              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = itime;
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel166<<<grid, block>>>(itime - 1, gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel167<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel168<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = x_cpu_yCol->size[0];
              x_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(x_cpu_yCol, eint, &ib_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(x_cpu_yCol, &b_gpu_yCol, true);
              ec_wtcc_kernel169<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (gpu_yCol, *gpu_a_data, b_gpu_yCol);
              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = itime;
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel170<<<grid, block>>>(b_gpu_yCol, itime - 1, gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              eint = dd_cpu_expanded->size[0] * dd_cpu_expanded->size[1];
              dd_cpu_expanded->size[0] = nx - 1;
              dd_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_creal32_T(dd_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(dd_cpu_expanded, &b_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel171<<<grid, block>>>(eint, b_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = lf_cpu_y->size[0] * lf_cpu_y->size[1];
              lf_cpu_y->size[0] = 1;
              lf_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(lf_cpu_y, eint, &kb_emlrtRTEI);
              lf_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                lf_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv163->size[0];
              cpu_iv163->size[0] = lf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv163, eint, &jb_emlrtRTEI);
              eint = lf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(lf_cpu_y, &t_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv163, &gpu_iv163, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&t_gpu_y, lf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel172<<<grid, block>>>(offsetH, t_gpu_y, eint,
                  gpu_iv163);
              }

              xt_size[0] = cpu_iv163->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel173<<<grid, block>>>(gpu_yCol, gpu_iv163, xt_size
                  [0] - 1, b_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = bd_cpu_rows->size[0] * bd_cpu_rows->size[1];
              bd_cpu_rows->size[0] = 1;
              bd_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(bd_cpu_rows, eint, &kb_emlrtRTEI);
              bd_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                bd_cpu_rows->data[k + 1] = itime;
              }

              eint = lb_cpu_w->size[0] * lb_cpu_w->size[1];
              lb_cpu_w->size[0] = static_cast<int32_T>(N);
              lb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(lb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                cpu_lidx = d_cpu_h->size[0];
                for (nx = 0; nx < x_size_idx_1; nx++) {
                  eint = w_cpu_newIm->size[0];
                  w_cpu_newIm->size[0] = bd_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(w_cpu_newIm, eint, &jb_emlrtRTEI);
                  eint = bd_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  if (c_omega_tmp1_needsGpuEnsureCapa) {
                    gpuEmxEnsureCapacity_int32_T(bd_cpu_rows, &b_gpu_rows,
                      !y_needsGpuEnsureCapacity);
                  }

                  c_omega_tmp1_needsGpuEnsureCapa = false;
                  gpuEmxEnsureCapacity_creal32_T(w_cpu_newIm, &gpu_newIm, true);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_rows, bd_cpu_rows);
                  }

                  y_needsGpuEnsureCapacity = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel174<<<grid, block>>>(b_gpu_expanded, nx,
                      b_gpu_rows, eint, gpu_newIm);
                  }

                  wav_outdatedOnCpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (n = 0; n < cpu_lidx; n++) {
                    if (wav_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(w_cpu_newIm, &gpu_newIm);
                    }

                    if (b_fx_data_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += w_cpu_newIm->data[n].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                    wav_outdatedOnCpu = false;
                    b_fx_data_outdatedOnCpu = false;
                    cv_im += w_cpu_newIm->data[n].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                  }

                  if (a_data_outdatedOnGpu) {
                    gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w, true);
                  }

                  a_data_outdatedOnGpu = false;
                  ec_wtcc_kernel175<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nx, gpu_w);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            fd_y = nullptr;
            m88 = emlrtCreateCharArray(2, &iv136[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m88, &rfmt[0]);
            emlrtAssign(&fd_y, m88);
            md_y = nullptr;
            m92 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&md_y, m92);
            emlrt_marshallIn(b_sprintf(fd_y, md_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (lb_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = lb_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = lb_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel145<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          nrefine = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = nrefine;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            cpu_lidx = 1;
            pathlen = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel146<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
            pathlen, nsubs, *gpu_csz);
          eint = ub_cpu_w->size[0] * ub_cpu_w->size[1];
          ub_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          ub_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(ub_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(lb_cpu_w, &gpu_w,
              !x_data_outdatedOnGpu);
          }

          gpuEmxEnsureCapacity_creal32_T(ub_cpu_w, &b_gpu_w, true);
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyCpuToGpu_creal32_T(&gpu_w, lb_cpu_w);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel147<<<grid, block>>>(gpu_w, cpu_csz[0], cpu_lidx, eint,
              nrefine - 1, b_gpu_w, ub_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = ag_cpu_y->size[0] * ag_cpu_y->size[1];
          ag_cpu_y->size[0] = b_cpu_csz[0];
          ag_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(ag_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ag_cpu_y, &o_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel148<<<grid, block>>>(b_gpu_w, offsetH, o_gpu_y);
          }

          Ly = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                         b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              nrefine = 0;
            } else {
              nrefine = static_cast<int32_T>(Ly);
            }

            n = dc_cpu_w->size[0] * dc_cpu_w->size[1];
            dc_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            dc_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_creal32_T(dc_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(dc_cpu_w, &c_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel149<<<grid, block>>>(gpu_w, cpu_csz[0], cpu_lidx,
                eint, cpu_csz[1] - 1, c_gpu_w, dc_cpu_w->size[0U]);
            }

            n = ag_cpu_y->size[0] * ag_cpu_y->size[1];
            ag_cpu_y->size[0] = nrefine;
            ag_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(ag_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ag_cpu_y, &o_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel150<<<grid, block>>>(c_gpu_w, b_cpu_csz[0], nrefine
                - 1, b_cpu_csz[1] - 1, o_gpu_y, ag_cpu_y->size[0U]);
            }
          }

          if (ag_cpu_y->size[0] * ag_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = ag_cpu_y->size[0] * ag_cpu_y->size[1];
          }

          omega_tmp2[0] = ag_cpu_y->size[0] * ag_cpu_y->size[1];
          eint = ih_cpu_y->size[0] * ih_cpu_y->size[1];
          ih_cpu_y->size[0] = 1;
          ih_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(ih_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ih_cpu_y, &p_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel151<<<grid, block>>>(o_gpu_y, omega_tmp2[0] - 1,
              p_gpu_y);
          }

          eint = ef_cpu_y->size[0] * ef_cpu_y->size[1];
          ef_cpu_y->size[0] = n;
          ef_cpu_y->size[1] = 1;
          emxEnsureCapacity_creal32_T(ef_cpu_y, eint, &ld_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ef_cpu_y, &q_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel152<<<grid, block>>>(p_gpu_y, n - 1, q_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            kc_y = nullptr;
            m55 = emlrtCreateCharArray(2, &iv119[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m55, &rfmt[0]);
            emlrtAssign(&kc_y, m55);
            tc_y = nullptr;
            m63 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&tc_y, m63);
            emlrt_marshallIn(b_sprintf(kc_y, tc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = cpu_opts_x->size[itime];
          }

          nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          eint = l_cpu_yCol->size[0];
          l_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(l_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(l_cpu_yCol, &c_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel176<<<grid, block>>>(eint, c_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = nx * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel177<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
              (cpu_lidx - 1, nrefine), c_gpu_yCol);
          }

          b_cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
          if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (cpu_opts_x->size[1] < 1) {
              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = 1;
              gb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel178<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_w);
            } else {
              eint = cpu_opts_x->size[1];
              n = m_cpu_a->size[0];
              m_cpu_a->size[0] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(m_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(m_cpu_a, &g_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel185<<<grid, block>>>(c_gpu_yCol, eint - 1, g_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              eint = u_cpu_c->size[0];
              u_cpu_c->size[0] = m_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(u_cpu_c, eint, &hb_emlrtRTEI);
              eint = m_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &d_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel186<<<grid, block>>>(eint, d_gpu_c);
              }

              if (m_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                eint = u_cpu_c->size[0];
                u_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(u_cpu_c, eint, &hb_emlrtRTEI);
                ec_wtcc_kernel187<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_a, cpu_cv_re, gpu_f, gpu_f1);
                gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &d_gpu_c, true);
                ec_wtcc_kernel188<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, gpu_f, d_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (m_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(m_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = m_cpu_a->size[0];
                if (m_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = m_cpu_a->size[0] + 1;
                }

                eint = jc_cpu_expanded->size[0];
                jc_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_creal32_T(jc_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = m_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(jc_cpu_expanded, &c_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel190<<<grid, block>>>(eint, c_gpu_expanded);
                }

                n = m_cpu_a->size[0];
                eint = ke_cpu_y->size[0] * ke_cpu_y->size[1];
                ke_cpu_y->size[0] = 1;
                ke_cpu_y->size[1] = m_cpu_a->size[0];
                emxEnsureCapacity_int32_T(ke_cpu_y, eint, &kb_emlrtRTEI);
                ke_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  ke_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv141->size[0];
                cpu_iv141->size[0] = ke_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv141, eint, &jb_emlrtRTEI);
                eint = ke_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ke_cpu_y, &u_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv141, &gpu_iv141, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&u_gpu_y, ke_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel191<<<grid, block>>>(u_gpu_y, eint, gpu_iv141);
                }

                omega_tmp2[0] = cpu_iv141->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel192<<<grid, block>>>(g_gpu_a, gpu_iv141,
                    omega_tmp2[0] - 1, c_gpu_expanded);
                }

                eint = u_cpu_c->size[0];
                u_cpu_c->size[0] = m_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(u_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(u_cpu_c, &d_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel193<<<grid, block>>>(c_gpu_expanded, cpu_cv_re,
                    x_size_idx_1 - 1, d_gpu_c);
                }
              }

              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = 1;
              gb_cpu_w->size[1] = u_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = u_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel189<<<grid, block>>>(d_gpu_c, offsetH, d_gpu_w,
                  gb_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = cpu_opts_x->size[1];
            }

            eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
            gb_cpu_w->size[0] = itime;
            gb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel194<<<grid, block>>>(eint, d_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = itime;
              gb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel195<<<grid, block>>>(eint, d_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                        (cpu_opts_x->size[1] == 1))) {
              ec_wtcc_kernel196<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel197<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = 1;
              gb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel198<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (c_gpu_yCol, *gpu_a_data, d_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_opts_x->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = qc_cpu_expanded->size[0] * qc_cpu_expanded->size[1];
              qc_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(qc_cpu_expanded, eint, &jb_emlrtRTEI);
              if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                nx = MAX_int32_T;
              } else {
                nx = cpu_opts_x->size[1] + cpu_opts_x->size[1];
              }

              eint = qc_cpu_expanded->size[0] * qc_cpu_expanded->size[1];
              qc_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(qc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((cpu_opts_x->size[1]
                + cpu_opts_x->size[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(qc_cpu_expanded, &d_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel199<<<grid, block>>>(eint, d_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = re_cpu_y->size[0] * re_cpu_y->size[1];
              re_cpu_y->size[0] = 1;
              re_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(re_cpu_y, eint, &kb_emlrtRTEI);
              re_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                re_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv143->size[0];
              cpu_iv143->size[0] = re_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv143, eint, &jb_emlrtRTEI);
              eint = re_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(re_cpu_y, &v_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv143, &gpu_iv143, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&v_gpu_y, re_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel200<<<grid, block>>>(offsetH, v_gpu_y, eint,
                  gpu_iv143);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::floor
                ((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv143->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel201<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv143,
                  omega_tmp2[0] - 1, d_gpu_expanded, qc_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = bc_cpu_rows->size[0] * bc_cpu_rows->size[1];
              bc_cpu_rows->size[0] = 1;
              bc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(bc_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                bc_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  bc_cpu_rows->data[k + 1] = itime;
                }
              }

              n = cpu_opts_x->size[1];
              eint = i_cpu_cols->size[0] * i_cpu_cols->size[1];
              i_cpu_cols->size[0] = 1;
              i_cpu_cols->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(i_cpu_cols, eint, &kb_emlrtRTEI);
              i_cpu_cols->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                i_cpu_cols->data[k + 1] = itime;
              }

              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = x_size_idx_1;
              gb_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(eint), static_cast<uint32_T>
                  (b_blockDims[1]), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(i_cpu_cols, &gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(bc_cpu_rows, &c_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&gpu_cols, i_cpu_cols);
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_rows, bc_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel202<<<grid, block>>>(d_gpu_expanded, gpu_cols,
                    c_gpu_rows, c_gpu_yCol, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                    d_gpu_w, qc_cpu_expanded->size[0U], gb_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = cpu_opts_x->size[1];
            }

            eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
            gb_cpu_w->size[0] = itime;
            gb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel203<<<grid, block>>>(eint, d_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = itime;
              gb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel204<<<grid, block>>>(eint, d_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel205<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel206<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = bb_cpu_yCol->size[0];
              bb_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(bb_cpu_yCol, eint, &ib_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(bb_cpu_yCol, &d_gpu_yCol, true);
              ec_wtcc_kernel207<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (c_gpu_yCol, *gpu_a_data, d_gpu_yCol);
              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = itime;
              gb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel208<<<grid, block>>>(d_gpu_yCol, offsetH, d_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = cpu_opts_x->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              eint = nc_cpu_expanded->size[0] * nc_cpu_expanded->size[1];
              nc_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_creal32_T(nc_cpu_expanded, eint, &jb_emlrtRTEI);
              if (cpu_opts_x->size[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = cpu_opts_x->size[1] + 1;
              }

              eint = nc_cpu_expanded->size[0] * nc_cpu_expanded->size[1];
              nc_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_creal32_T(nc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(nc_cpu_expanded, &e_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel209<<<grid, block>>>(eint, e_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = pe_cpu_y->size[0] * pe_cpu_y->size[1];
              pe_cpu_y->size[0] = 1;
              pe_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(pe_cpu_y, eint, &kb_emlrtRTEI);
              pe_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                pe_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv148->size[0];
              cpu_iv148->size[0] = pe_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv148, eint, &jb_emlrtRTEI);
              eint = pe_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pe_cpu_y, &w_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv148, &gpu_iv148, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&w_gpu_y, pe_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel210<<<grid, block>>>(offsetH, w_gpu_y, eint,
                  gpu_iv148);
              }

              n = cpu_opts_x->size[1];
              eint = of_cpu_y->size[0] * of_cpu_y->size[1];
              of_cpu_y->size[0] = 1;
              of_cpu_y->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(of_cpu_y, eint, &kb_emlrtRTEI);
              of_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                of_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv166->size[0];
              cpu_iv166->size[0] = of_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv166, eint, &jb_emlrtRTEI);
              eint = of_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(of_cpu_y, &x_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv166, &gpu_iv166, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_y, of_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel211<<<grid, block>>>(x_gpu_y, eint, gpu_iv166);
              }

              xt_size[0] = cpu_iv148->size[0];
              xt_size[1] = cpu_iv166->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel212<<<grid, block>>>(c_gpu_yCol, xt_size[0],
                  gpu_iv166, gpu_iv148, xt_size[0] - 1, xt_size[1] - 1,
                  e_gpu_expanded, nc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              eint = hc_cpu_rows->size[0] * hc_cpu_rows->size[1];
              hc_cpu_rows->size[0] = 1;
              hc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(hc_cpu_rows, eint, &kb_emlrtRTEI);
              hc_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                hc_cpu_rows->data[k + 1] = itime;
              }

              eint = gb_cpu_w->size[0] * gb_cpu_w->size[1];
              gb_cpu_w->size[0] = static_cast<int32_T>(N);
              gb_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(gb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                for (nrefine = 0; nrefine < ix; nrefine++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nx = 0; nx < x_size_idx_1; nx++) {
                    eint = f_cpu_newIm->size[0];
                    f_cpu_newIm->size[0] = hc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(f_cpu_newIm, eint, &jb_emlrtRTEI);
                    eint = hc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                      2147483647U);
                    if (c_omega_tmp1_needsGpuEnsureCapa) {
                      gpuEmxEnsureCapacity_int32_T(hc_cpu_rows, &d_gpu_rows,
                        !y_needsGpuEnsureCapacity);
                    }

                    c_omega_tmp1_needsGpuEnsureCapa = false;
                    gpuEmxEnsureCapacity_creal32_T(f_cpu_newIm, &b_gpu_newIm,
                      true);
                    if (y_needsGpuEnsureCapacity) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_rows, hc_cpu_rows);
                    }

                    y_needsGpuEnsureCapacity = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel213<<<grid, block>>>(nrefine, e_gpu_expanded,
                        nx, d_gpu_rows, eint, b_gpu_newIm, nc_cpu_expanded->
                        size[0U]);
                    }

                    wav_outdatedOnCpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (n = 0; n < cpu_lidx; n++) {
                      if (wav_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(f_cpu_newIm, &b_gpu_newIm);
                      }

                      if (b_fx_data_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += f_cpu_newIm->data[n].re * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                      wav_outdatedOnCpu = false;
                      b_fx_data_outdatedOnCpu = false;
                      cv_im += f_cpu_newIm->data[n].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                    }

                    if (a_data_outdatedOnGpu) {
                      gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
                    }

                    a_data_outdatedOnGpu = false;
                    ec_wtcc_kernel214<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nrefine, nx, d_gpu_w, gb_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            dd_y = nullptr;
            m75 = emlrtCreateCharArray(2, &iv129[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m75, &rfmt[0]);
            emlrtAssign(&dd_y, m75);
            kd_y = nullptr;
            m81 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&kd_y, m81);
            emlrt_marshallIn(b_sprintf(dd_y, kd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (gb_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = gb_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = gb_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel179<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          nrefine = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = nrefine;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            cpu_lidx = 1;
            pathlen = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel180<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
            pathlen, nsubs, *gpu_csz);
          eint = rb_cpu_w->size[0] * rb_cpu_w->size[1];
          rb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          rb_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(rb_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(gb_cpu_w, &d_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(rb_cpu_w, &e_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel181<<<grid, block>>>(d_gpu_w, cpu_csz[0], cpu_lidx,
              eint, nrefine - 1, e_gpu_w, rb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = ef_cpu_y->size[0] * ef_cpu_y->size[1];
          ef_cpu_y->size[0] = b_cpu_csz[0];
          ef_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(ef_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ef_cpu_y, &q_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel182<<<grid, block>>>(e_gpu_w, offsetH, q_gpu_y);
          }

          Ly = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                          toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              nrefine = 0;
            } else {
              nrefine = static_cast<int32_T>(Ly);
            }

            n = ac_cpu_w->size[0] * ac_cpu_w->size[1];
            ac_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            ac_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_creal32_T(ac_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ac_cpu_w, &f_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel183<<<grid, block>>>(d_gpu_w, cpu_csz[0], cpu_lidx,
                eint, cpu_csz[1] - 1, f_gpu_w, ac_cpu_w->size[0U]);
            }

            n = ef_cpu_y->size[0] * ef_cpu_y->size[1];
            ef_cpu_y->size[0] = nrefine;
            ef_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(ef_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ef_cpu_y, &q_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel184<<<grid, block>>>(f_gpu_w, b_cpu_csz[0], nrefine
                - 1, b_cpu_csz[1] - 1, q_gpu_y, ef_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          eint = tf_cpu_y->size[0] * tf_cpu_y->size[1];
          tf_cpu_y->size[0] = 1;
          tf_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(tf_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(tf_cpu_y, &r_gpu_y, true);
          m_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel153<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(r_gpu_y);
        } else if (halfh < 1.0) {
          tf_cpu_y->size[0] = 1;
          tf_cpu_y->size[1] = 0;
        } else {
          eint = tf_cpu_y->size[0] * tf_cpu_y->size[1];
          tf_cpu_y->size[0] = 1;
          tf_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(tf_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(tf_cpu_y, &r_gpu_y, true);
          m_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel155<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              r_gpu_y);
          }
        }

        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
        b_cpu_y1->size[1] = 1;
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &oc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (m_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(tf_cpu_y, &r_gpu_y, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel154<<<grid, block>>>(q_gpu_y, r_gpu_y, T,
            static_cast<int32_T>(halfh) - 1, gpu_y1);
        }
      } else {
        tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
        first_iteration = (cpu_opts_x->size[0] == 1);
        if (first_iteration) {
          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] *= cpu_opts_x->size[1];
          cpu_opts_x->size[1] = 1;
          emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &uc_emlrtRTEI);
          e_omega_tmp1_needsGpuEnsureCapa = true;
        }

        if (!(toler - 1.0 >= 0.0)) {
          fc_y = nullptr;
          m54 = emlrtCreateCharArray(2, &iv118[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m54, &rfmt[0]);
          emlrtAssign(&fc_y, m54);
          nc_y = nullptr;
          m62 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&nc_y, m62);
          emlrt_marshallIn(b_sprintf(fc_y, nc_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (cpu_opts_x->size[0] != 1) {
            nsubs = 0;
          }
        }

        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = cpu_opts_x->size[itime];
        }

        nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        eint = o_cpu_yCol->size[0];
        o_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
        emxEnsureCapacity_creal32_T(o_cpu_yCol, eint, &yc_emlrtRTEI);
        eint = nx * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(o_cpu_yCol, &e_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel245<<<grid, block>>>(eint, e_gpu_yCol);
        }

        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (nrefine * static_cast<
               int32_T>(toler) > 1)))) {
          nrefine = 1;
          cpu_lidx = 0;
        } else {
          nrefine = static_cast<int32_T>(toler);
          cpu_lidx = nx * static_cast<int32_T>(toler);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
          &grid, &block, 2147483647U);
        if (e_omega_tmp1_needsGpuEnsureCapa) {
          gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
        }

        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel246<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
            (cpu_lidx - 1, nrefine), e_gpu_yCol);
        }

        b_cpu_csz[nsubs] = cpu_opts_x->size[nsubs] * static_cast<int32_T>(toler);
        if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
          if (b_cpu_csz[1] < 1) {
            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = 1;
            ib_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel247<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(g_gpu_w);
          } else {
            n = p_cpu_a->size[0];
            p_cpu_a->size[0] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(p_cpu_a, n, &fb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(p_cpu_a, &h_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel259<<<grid, block>>>(e_gpu_yCol, b_cpu_csz[1] - 1,
                h_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
            cpu_cv_re = d_cpu_h->data[0];
            eint = w_cpu_c->size[0];
            w_cpu_c->size[0] = p_cpu_a->size[0];
            emxEnsureCapacity_creal32_T(w_cpu_c, eint, &hb_emlrtRTEI);
            eint = p_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &e_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel260<<<grid, block>>>(eint, e_gpu_c);
            }

            if (p_cpu_a->size[0] == 1) {
              cpu_cv_re = d_cpu_h->data[0];
              eint = w_cpu_c->size[0];
              w_cpu_c->size[0] = 1;
              emxEnsureCapacity_creal32_T(w_cpu_c, eint, &hb_emlrtRTEI);
              ec_wtcc_kernel261<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(h_gpu_a,
                cpu_cv_re, gpu_f, gpu_f1);
              gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &e_gpu_c, true);
              ec_wtcc_kernel262<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                gpu_f, e_gpu_c);
            } else {
              itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (p_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(p_cpu_a->size[0]) +
                static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>(itime)));
              threadDims[0] = static_cast<int8_T>(itime);
              x_size_idx_1 = p_cpu_a->size[0];
              if (p_cpu_a->size[0] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = p_cpu_a->size[0] + 1;
              }

              eint = tc_cpu_expanded->size[0];
              tc_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_creal32_T(tc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = p_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(tc_cpu_expanded, &j_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel264<<<grid, block>>>(eint, j_gpu_expanded);
              }

              n = p_cpu_a->size[0];
              eint = ue_cpu_y->size[0] * ue_cpu_y->size[1];
              ue_cpu_y->size[0] = 1;
              ue_cpu_y->size[1] = p_cpu_a->size[0];
              emxEnsureCapacity_int32_T(ue_cpu_y, eint, &kb_emlrtRTEI);
              ue_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ue_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv147->size[0];
              cpu_iv147->size[0] = ue_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv147, eint, &jb_emlrtRTEI);
              eint = ue_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ue_cpu_y, &gb_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv147, &gpu_iv147, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&gb_gpu_y, ue_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel265<<<grid, block>>>(gb_gpu_y, eint, gpu_iv147);
              }

              omega_tmp2[0] = cpu_iv147->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel266<<<grid, block>>>(h_gpu_a, gpu_iv147,
                  omega_tmp2[0] - 1, j_gpu_expanded);
              }

              eint = w_cpu_c->size[0];
              w_cpu_c->size[0] = p_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(w_cpu_c, eint, &jb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
              gpuEmxEnsureCapacity_creal32_T(w_cpu_c, &e_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel267<<<grid, block>>>(j_gpu_expanded, cpu_cv_re,
                  x_size_idx_1 - 1, e_gpu_c);
              }
            }

            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = 1;
            ib_cpu_w->size[1] = w_cpu_c->size[0];
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = w_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel263<<<grid, block>>>(e_gpu_c, offsetH, g_gpu_w,
                ib_cpu_w->size[0U]);
            }
          }
        } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
          if (b_cpu_csz[0] == 0) {
            itime = d_cpu_h->size[0];
          } else {
            itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
          ib_cpu_w->size[0] = itime;
          ib_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel268<<<grid, block>>>(eint, g_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = itime;
            ib_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel269<<<grid, block>>>(eint, g_gpu_w);
            }
          } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                      (b_cpu_csz[1] == 1))) {
            ec_wtcc_kernel270<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f1);
            ec_wtcc_kernel271<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
              *gpu_a_data);
            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = 1;
            ib_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel272<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (e_gpu_yCol, *gpu_a_data, g_gpu_w);
          } else {
            r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                 (b_cpu_csz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              eint = static_cast<int32_T>(s);
            } else {
              eint = MIN_int32_T;
            }

            b_blockDims[0] = eint;
            b_blockDims[1] = cpu_lidx;
            ix = b_cpu_csz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                x_size_idx_1 = static_cast<int32_T>(r);
              } else {
                x_size_idx_1 = MIN_int32_T;
              }
            } else {
              x_size_idx_1 = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T - x_size_idx_1))
            {
              nx = MIN_int32_T;
            } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                        - x_size_idx_1)) {
              nx = MAX_int32_T;
            } else {
              nx = x_size_idx_1 + b_cpu_csz[0];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = ad_cpu_expanded->size[0] * ad_cpu_expanded->size[1];
            ad_cpu_expanded->size[0] = nx;
            emxEnsureCapacity_real32_T(ad_cpu_expanded, eint, &jb_emlrtRTEI);
            if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz[1]))
            {
              nx = MIN_int32_T;
            } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                        - b_cpu_csz[1])) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + b_cpu_csz[1];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = ad_cpu_expanded->size[0] * ad_cpu_expanded->size[1];
            ad_cpu_expanded->size[1] = nx;
            emxEnsureCapacity_real32_T(ad_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
              b_cpu_csz[1]) - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(ad_cpu_expanded, &k_gpu_expanded, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel273<<<grid, block>>>(eint, k_gpu_expanded);
            }

            n = d_cpu_h->size[0];
            eint = cf_cpu_y->size[0] * cf_cpu_y->size[1];
            cf_cpu_y->size[0] = 1;
            cf_cpu_y->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(cf_cpu_y, eint, &kb_emlrtRTEI);
            cf_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              cf_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv151->size[0];
            cpu_iv151->size[0] = cf_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv151, eint, &jb_emlrtRTEI);
            eint = cf_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(cf_cpu_y, &hb_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv151, &gpu_iv151, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&hb_gpu_y, cf_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel274<<<grid, block>>>(offsetH, hb_gpu_y, eint,
                gpu_iv151);
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv151->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel275<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv151,
                omega_tmp2[0] - 1, k_gpu_expanded, ad_cpu_expanded->size[0U]);
            }

            if (b_cpu_csz[0] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[0] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            y_needsGpuEnsureCapacity = false;
            eint = dc_cpu_rows->size[0] * dc_cpu_rows->size[1];
            dc_cpu_rows->size[0] = 1;
            dc_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(dc_cpu_rows, eint, &kb_emlrtRTEI);
            if (n > 0) {
              dc_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                dc_cpu_rows->data[k + 1] = itime;
              }
            }

            if (b_cpu_csz[1] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[1] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            interval_outdatedOnGpu = false;
            eint = l_cpu_cols->size[0] * l_cpu_cols->size[1];
            l_cpu_cols->size[0] = 1;
            l_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(l_cpu_cols, eint, &kb_emlrtRTEI);
            if (n > 0) {
              l_cpu_cols->data[0] = 0;
              interval_outdatedOnGpu = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                l_cpu_cols->data[k + 1] = itime;
              }
            }

            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = x_size_idx_1;
            ib_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              n = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                n = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                static_cast<uint32_T>(n), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(l_cpu_cols, &b_gpu_cols,
                !interval_outdatedOnGpu);
              gpuEmxEnsureCapacity_int32_T(dc_cpu_rows, &i_gpu_rows,
                !y_needsGpuEnsureCapacity);
              gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_cols, l_cpu_cols);
              }

              if (y_needsGpuEnsureCapacity) {
                gpuEmxMemcpyCpuToGpu_int32_T(&i_gpu_rows, dc_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel276<<<grid, block>>>(k_gpu_expanded, b_gpu_cols,
                  i_gpu_rows, e_gpu_yCol, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                  g_gpu_w, ad_cpu_expanded->size[0U], ib_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (b_cpu_csz[0] == 0) {
            itime = d_cpu_h->size[0];
          } else {
            itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
          ib_cpu_w->size[0] = itime;
          ib_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel277<<<grid, block>>>(eint, g_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = itime;
            ib_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel278<<<grid, block>>>(eint, g_gpu_w);
            }
          } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                     (d_cpu_h->size[0] == 1)) {
            ec_wtcc_kernel279<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f1);
            ec_wtcc_kernel280<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
              *gpu_a_data);
            eint = db_cpu_yCol->size[0];
            db_cpu_yCol->size[0] = 1;
            emxEnsureCapacity_creal32_T(db_cpu_yCol, eint, &ib_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(db_cpu_yCol, &f_gpu_yCol, true);
            ec_wtcc_kernel281<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (e_gpu_yCol, *gpu_a_data, f_gpu_yCol);
            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = itime;
            ib_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel282<<<grid, block>>>(f_gpu_yCol, offsetH, g_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                 (d_cpu_h->size[0])) - 1U;
            ix = b_cpu_csz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            x_size_idx_1 = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              nx = MAX_int32_T;
            } else {
              nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
            }

            eint = xc_cpu_expanded->size[0] * xc_cpu_expanded->size[1];
            xc_cpu_expanded->size[0] = nx - 1;
            emxEnsureCapacity_creal32_T(xc_cpu_expanded, eint, &jb_emlrtRTEI);
            if (b_cpu_csz[1] > 2147483646) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + 1;
            }

            eint = xc_cpu_expanded->size[0] * xc_cpu_expanded->size[1];
            xc_cpu_expanded->size[1] = nx - 1;
            emxEnsureCapacity_creal32_T(xc_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
              b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(xc_cpu_expanded, &l_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel283<<<grid, block>>>(eint, l_gpu_expanded);
            }

            n = b_cpu_csz[0];
            eint = xe_cpu_y->size[0] * xe_cpu_y->size[1];
            xe_cpu_y->size[0] = 1;
            xe_cpu_y->size[1] = b_cpu_csz[0];
            emxEnsureCapacity_int32_T(xe_cpu_y, eint, &kb_emlrtRTEI);
            xe_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              xe_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv154->size[0];
            cpu_iv154->size[0] = xe_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv154, eint, &jb_emlrtRTEI);
            eint = xe_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(xe_cpu_y, &ib_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv154, &gpu_iv154, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&ib_gpu_y, xe_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel284<<<grid, block>>>(offsetH, ib_gpu_y, eint,
                gpu_iv154);
            }

            if (b_cpu_csz[1] < 1) {
              n = 0;
            } else {
              n = b_cpu_csz[1];
            }

            fx_data_outdatedOnCpu = false;
            eint = xf_cpu_y->size[0] * xf_cpu_y->size[1];
            xf_cpu_y->size[0] = 1;
            xf_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(xf_cpu_y, eint, &kb_emlrtRTEI);
            if (n > 0) {
              xf_cpu_y->data[0] = 1;
              fx_data_outdatedOnCpu = true;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                xf_cpu_y->data[k + 1] = itime;
              }
            }

            eint = cpu_iv171->size[0];
            cpu_iv171->size[0] = xf_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv171, eint, &jb_emlrtRTEI);
            eint = xf_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(xf_cpu_y, &jb_gpu_y,
              !fx_data_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv171, &gpu_iv171, true);
            if (fx_data_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&jb_gpu_y, xf_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel285<<<grid, block>>>(jb_gpu_y, eint, gpu_iv171);
            }

            xt_size[0] = cpu_iv154->size[0];
            xt_size[1] = cpu_iv171->size[0];
            mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel286<<<grid, block>>>(e_gpu_yCol, xt_size[0],
                gpu_iv171, gpu_iv154, xt_size[0] - 1, xt_size[1] - 1,
                l_gpu_expanded, xc_cpu_expanded->size[0U]);
            }

            n = d_cpu_h->size[0];
            eint = nc_cpu_rows->size[0] * nc_cpu_rows->size[1];
            nc_cpu_rows->size[0] = 1;
            nc_cpu_rows->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(nc_cpu_rows, eint, &kb_emlrtRTEI);
            nc_cpu_rows->data[0] = 0;
            y_needsGpuEnsureCapacity = true;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            itime = 0;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              nc_cpu_rows->data[k + 1] = itime;
            }

            eint = ib_cpu_w->size[0] * ib_cpu_w->size[1];
            ib_cpu_w->size[0] = static_cast<int32_T>(N);
            ib_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(ib_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
              for (nrefine = 0; nrefine < ix; nrefine++) {
                cpu_lidx = d_cpu_h->size[0];
                for (nx = 0; nx < x_size_idx_1; nx++) {
                  eint = l_cpu_newIm->size[0];
                  l_cpu_newIm->size[0] = nc_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(l_cpu_newIm, eint, &jb_emlrtRTEI);
                  eint = nc_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  if (c_omega_tmp1_needsGpuEnsureCapa) {
                    gpuEmxEnsureCapacity_int32_T(nc_cpu_rows, &j_gpu_rows,
                      !y_needsGpuEnsureCapacity);
                  }

                  c_omega_tmp1_needsGpuEnsureCapa = false;
                  gpuEmxEnsureCapacity_creal32_T(l_cpu_newIm, &e_gpu_newIm, true);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&j_gpu_rows, nc_cpu_rows);
                  }

                  y_needsGpuEnsureCapacity = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel287<<<grid, block>>>(nrefine, l_gpu_expanded,
                      nx, j_gpu_rows, eint, e_gpu_newIm, xc_cpu_expanded->size
                      [0U]);
                  }

                  wav_outdatedOnCpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (n = 0; n < cpu_lidx; n++) {
                    if (wav_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(l_cpu_newIm, &e_gpu_newIm);
                    }

                    if (b_fx_data_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += l_cpu_newIm->data[n].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                    wav_outdatedOnCpu = false;
                    b_fx_data_outdatedOnCpu = false;
                    cv_im += l_cpu_newIm->data[n].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                  }

                  if (a_data_outdatedOnGpu) {
                    gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
                  }

                  a_data_outdatedOnGpu = false;
                  ec_wtcc_kernel288<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nrefine, nx, g_gpu_w, ib_cpu_w->size[0U]);
                }
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          cd_y = nullptr;
          m79 = emlrtCreateCharArray(2, &iv133[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m79, &rfmt[0]);
          emlrtAssign(&cd_y, m79);
          jd_y = nullptr;
          m86 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&jd_y, m86);
          emlrt_marshallIn(b_sprintf(cd_y, jd_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (ib_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        interval_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = false;
        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = ib_cpu_w->size[itime];
          fx_data_outdatedOnCpu = true;
          cpu_csz[itime] = ib_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel248<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *b_gpu_csz);
          }

          checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        nrefine = cpu_csz[0];
        cpu_csz[0] = cpu_csz[1];
        cpu_csz[1] = nrefine;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
          cpu_lidx = 1;
          pathlen = -1;
        } else {
          cpu_lidx = static_cast<int32_T>(b_m);
          pathlen = cpu_csz[0] - 1;
        }

        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel249<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
          pathlen, nsubs, *gpu_csz);
        eint = wb_cpu_w->size[0] * wb_cpu_w->size[1];
        wb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
        wb_cpu_w->size[1] = nrefine;
        emxEnsureCapacity_creal32_T(wb_cpu_w, eint, &jd_emlrtRTEI);
        eint = pathlen / cpu_lidx;
        mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
          &block, 2147483647U);
        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(ib_cpu_w, &g_gpu_w, true);
        }

        gpuEmxEnsureCapacity_creal32_T(wb_cpu_w, &h_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel250<<<grid, block>>>(g_gpu_w, cpu_csz[0], cpu_lidx, eint,
            nrefine - 1, h_gpu_w, wb_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        eint = hf_cpu_y->size[0] * hf_cpu_y->size[1];
        hf_cpu_y->size[0] = b_cpu_csz[0];
        hf_cpu_y->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_creal32_T(hf_cpu_y, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(hf_cpu_y, &db_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel251<<<grid, block>>>(h_gpu_w, offsetH, db_gpu_y);
        }

        Ly = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) * toler
                        + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
        if (!(b_cpu_csz[0] < Ly)) {
          if (Ly < 1.0) {
            nrefine = 0;
          } else {
            nrefine = static_cast<int32_T>(Ly);
          }

          n = gc_cpu_w->size[0] * gc_cpu_w->size[1];
          gc_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          gc_cpu_w->size[1] = cpu_csz[1];
          emxEnsureCapacity_creal32_T(gc_cpu_w, n, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(gc_cpu_w, &i_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel252<<<grid, block>>>(g_gpu_w, cpu_csz[0], cpu_lidx,
              eint, cpu_csz[1] - 1, i_gpu_w, gc_cpu_w->size[0U]);
          }

          n = hf_cpu_y->size[0] * hf_cpu_y->size[1];
          hf_cpu_y->size[0] = nrefine;
          hf_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(hf_cpu_y, n, &gd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine - 1),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(hf_cpu_y, &db_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel253<<<grid, block>>>(i_gpu_w, b_cpu_csz[0], nrefine -
              1, b_cpu_csz[1] - 1, db_gpu_y, hf_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = hf_cpu_y->size[0] * hf_cpu_y->size[1];
          eint = gh_cpu_y->size[0] * gh_cpu_y->size[1];
          gh_cpu_y->size[0] = 1;
          gh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(gh_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(gh_cpu_y, &eb_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel254<<<grid, block>>>(db_gpu_y, omega_tmp2[0] - 1,
              eb_gpu_y, gh_cpu_y->size[0U]);
          }

          eint = hf_cpu_y->size[0] * hf_cpu_y->size[1];
          hf_cpu_y->size[0] = 1;
          hf_cpu_y->size[1] = gh_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(hf_cpu_y, eint, &md_emlrtRTEI);
          eint = gh_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(hf_cpu_y, &db_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel255<<<grid, block>>>(eb_gpu_y, eint, db_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          eint = cg_cpu_y->size[0] * cg_cpu_y->size[1];
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(cg_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &fb_gpu_y, true);
          o_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel256<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(fb_gpu_y);
        } else if (tol < 1.0) {
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = 0;
        } else {
          eint = cg_cpu_y->size[0] * cg_cpu_y->size[1];
          cg_cpu_y->size[0] = 1;
          cg_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(cg_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &fb_gpu_y, true);
          o_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel258<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              fb_gpu_y);
          }
        }

        cpu_lidx = hf_cpu_y->size[1];
        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = cg_cpu_y->size[1];
        b_cpu_y1->size[1] = hf_cpu_y->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &oc_emlrtRTEI);
        eint = cg_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (o_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(cg_cpu_y, &fb_gpu_y, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel257<<<grid, block>>>(db_gpu_y, fb_gpu_y, T, eint,
            cpu_lidx - 1, gpu_y1, b_cpu_y1->size[0U], hf_cpu_y->size[0U]);
        }
      }

      emxFree_creal32_T(&gc_cpu_w);
      emxFree_creal32_T(&ih_cpu_y);
      emxFree_creal32_T(&gh_cpu_y);
      emxFree_creal32_T(&dc_cpu_w);
      emxFree_creal32_T(&ac_cpu_w);
      emxFree_creal32_T(&wb_cpu_w);
      emxFree_creal32_T(&ub_cpu_w);
      emxFree_creal32_T(&rb_cpu_w);
      emxFree_creal32_T(&db_cpu_yCol);
      emxFree_creal32_T(&bb_cpu_yCol);
      emxFree_creal32_T(&x_cpu_yCol);
      emxFree_creal32_T(&w_cpu_newIm);
      emxFree_creal32_T(&u_cpu_newIm);
      emxFree_creal32_T(&r_cpu_newIm);
      emxFree_creal32_T(&o_cpu_newIm);
      emxFree_creal32_T(&l_cpu_newIm);
      emxFree_creal32_T(&i_cpu_newIm);
      emxFree_creal32_T(&f_cpu_newIm);
      emxFree_int32_T(&pd_cpu_rows);
      emxFree_int32_T(&nd_cpu_rows);
      emxFree_int32_T(&kd_cpu_rows);
      emxFree_int32_T(&cpu_iv198);
      emxFree_int32_T(&hd_cpu_rows);
      emxFree_int32_T(&ed_cpu_rows);
      emxFree_int32_T(&cpu_iv193);
      emxFree_int32_T(&bd_cpu_rows);
      emxFree_int32_T(&xc_cpu_rows);
      emxFree_int32_T(&cpu_iv188);
      emxFree_int32_T(&tc_cpu_rows);
      emxFree_int32_T(&cpu_iv186);
      emxFree_int32_T(&cpu_iv185);
      emxFree_int32_T(&qc_cpu_rows);
      emxFree_int32_T(&l_cpu_cols);
      emxFree_int32_T(&cpu_iv180);
      emxFree_int32_T(&ch_cpu_y);
      emxFree_int32_T(&cpu_iv175);
      emxFree_int32_T(&nc_cpu_rows);
      emxFree_int32_T(&yg_cpu_y);
      emxFree_int32_T(&kc_cpu_rows);
      emxFree_int32_T(&i_cpu_cols);
      emxFree_int32_T(&cpu_iv173);
      emxFree_real32_T(&ee_cpu_expanded);
      emxFree_creal32_T(&be_cpu_expanded);
      emxFree_int32_T(&vg_cpu_y);
      emxFree_int32_T(&hc_cpu_rows);
      emxFree_int32_T(&sg_cpu_y);
      emxFree_int32_T(&cpu_iv171);
      emxFree_int32_T(&pg_cpu_y);
      emxFree_real32_T(&yd_cpu_expanded);
      emxFree_creal32_T(&wd_cpu_expanded);
      emxFree_int32_T(&lg_cpu_y);
      emxFree_real32_T(&td_cpu_expanded);
      emxFree_creal32_T(&qd_cpu_expanded);
      emxFree_int32_T(&cpu_iv166);
      emxFree_int32_T(&jg_cpu_y);
      emxFree_int32_T(&dc_cpu_rows);
      emxFree_int32_T(&cpu_iv163);
      emxFree_int32_T(&hg_cpu_y);
      emxFree_int32_T(&cpu_iv161);
      emxFree_real32_T(&md_cpu_expanded);
      emxFree_creal32_T(&kd_cpu_expanded);
      emxFree_real_T(&cg_cpu_y);
      emxFree_int32_T(&bc_cpu_rows);
      emxFree_creal32_T(&ag_cpu_y);
      emxFree_int32_T(&xf_cpu_y);
      emxFree_int32_T(&cpu_iv154);
      emxFree_real_T(&tf_cpu_y);
      emxFree_int32_T(&cpu_iv151);
      emxFree_int32_T(&rf_cpu_y);
      emxFree_int32_T(&of_cpu_y);
      emxFree_int32_T(&lf_cpu_y);
      emxFree_int32_T(&cpu_iv148);
      emxFree_int32_T(&cpu_iv147);
      emxFree_real32_T(&gd_cpu_expanded);
      emxFree_creal32_T(&dd_cpu_expanded);
      emxFree_int32_T(&cpu_iv143);
      emxFree_creal32_T(&hf_cpu_y);
      emxFree_creal32_T(&l_cpu_result);
      emxFree_int32_T(&cpu_iv141);
      emxFree_creal32_T(&ef_cpu_y);
      emxFree_int32_T(&cf_cpu_y);
      emxFree_creal32_T(&i_cpu_result);
      emxFree_int32_T(&xe_cpu_y);
      emxFree_int32_T(&ue_cpu_y);
      emxFree_real32_T(&ad_cpu_expanded);
      emxFree_creal32_T(&xc_cpu_expanded);
      emxFree_int32_T(&re_cpu_y);
      emxFree_int32_T(&pe_cpu_y);
      emxFree_creal32_T(&tc_cpu_expanded);
      emxFree_int32_T(&ke_cpu_y);
      emxFree_real32_T(&qc_cpu_expanded);
      emxFree_creal32_T(&nc_cpu_expanded);
      emxFree_creal32_T(&jc_cpu_expanded);
      emxFree_creal32_T(&s_cpu_a);
      emxFree_creal32_T(&g_c);
      emxFree_creal32_T(&p_cpu_a);
      emxFree_creal32_T(&w_cpu_c);
      emxFree_creal32_T(&m_cpu_a);
      emxFree_creal32_T(&u_cpu_c);
      emxFree_creal32_T(&lb_cpu_w);
      emxFree_creal32_T(&ib_cpu_w);
      emxFree_creal32_T(&gb_cpu_w);
      emxFree_creal32_T(&r_cpu_yCol);
      emxFree_creal32_T(&o_cpu_yCol);
      emxFree_creal32_T(&l_cpu_yCol);
      if ((b_cpu_y1->size[0] == 0) || (b_cpu_y1->size[1] == 0)) {
        pathlen = 0;
      } else {
        itime = b_cpu_y1->size[0];
        pathlen = b_cpu_y1->size[1];
        if (itime >= pathlen) {
          pathlen = itime;
        }
      }

      eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = 1;
      cpu_opts_x->size[1] = pathlen;
      emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &nd_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(pathlen - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel140<<<grid, block>>>(gpu_y1, pathlen - 1, gpu_opts_x);
      }
    } else {
      emxInit_creal32_T(&k_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&n_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&q_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&fb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&hb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&kb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&t_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&l_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&v_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&o_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&f_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&r_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&ic_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&mc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&pc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&je_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&sc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&oe_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qe_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&wc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&yc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&te_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&we_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&h_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&bf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&df_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv140, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&k_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&gf_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv142, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&cd_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&fd_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv145, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv146, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&nf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv150, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&sf_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv153, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&wf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&yf_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&ac_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&bg_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_creal32_T(&jd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ld_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv160, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv162, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ig_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv165, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&pd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&sd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&kg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&vd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&xd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&og_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv170, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&rg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ug_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ae_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&de_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv172, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&h_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&mc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv174, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&bh_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv178, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&k_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&pc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv183, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv184, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&sc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv187, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&wc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ad_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv192, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&dd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&gd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv196, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&md_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&od_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&e_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&h_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&k_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&n_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&q_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&t_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&v_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&w_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&ab_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&cb_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&qb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&tb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&vb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&yb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&cc_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&fh_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&hh_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&fc_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((!(toler == 1.0)) || (!(b_m == 1.0))) {
        if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
          if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
            pathlen = 0;
          } else {
            itime = cpu_opts_x->size[0];
            pathlen = cpu_opts_x->size[1];
            if (itime >= pathlen) {
              pathlen = itime;
            }
          }

          halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            if (!(toler - 1.0 >= 0.0)) {
              jc_y = nullptr;
              m64 = emlrtCreateCharArray(2, &iv124[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m64, &rfmt[0]);
              emlrtAssign(&jc_y, m64);
              sc_y = nullptr;
              m70 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&sc_y, m70);
              emlrt_marshallIn(b_sprintf(jc_y, sc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            eint = q_cpu_yCol->size[0];
            q_cpu_yCol->size[0] = static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(q_cpu_yCol, eint, &yc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler)
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(q_cpu_yCol, &g_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel319<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
                g_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                   static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>
                   (toler) > 1)))) {
              nrefine = 1;
              cpu_lidx = 0;
            } else {
              nrefine = static_cast<int32_T>(toler);
              cpu_lidx = static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1,
              nrefine)), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel320<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
                (cpu_lidx - 1, nrefine), g_gpu_yCol);
            }

            ec_wtcc_kernel321<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(toler,
              *gpu_csz);
            if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
              real32_T cpu_f1;
              eint = r_cpu_a->size[0];
              r_cpu_a->size[0] = 1;
              emxEnsureCapacity_creal32_T(r_cpu_a, eint, &fb_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(r_cpu_a, &i_gpu_a, true);
              ec_wtcc_kernel322<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                g_gpu_yCol, gpu_cv_re, i_gpu_a);
              eint = f_c->size[0];
              f_c->size[0] = 1;
              emxEnsureCapacity_creal32_T(f_c, eint, &hb_emlrtRTEI);
              checkCudaError(cudaMemcpy(&cpu_cv_re, gpu_cv_re, 4UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              gpuEmxMemcpyGpuToCpu_creal32_T(r_cpu_a, &i_gpu_a);
              cpu_f1 = cpu_cv_re * r_cpu_a->data[0].re;
              cv_im = cpu_cv_re * r_cpu_a->data[0].im;
              f_c->data[0].im = cv_im;
              f_c->data[0].re = cpu_f1;
              eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
              kb_cpu_w->size[0] = 1;
              kb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
              kb_cpu_w->data[0] = f_c->data[0];
              x_data_outdatedOnGpu = true;
              a_data_outdatedOnGpu = true;
            } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
              if (static_cast<int32_T>(toler) == 0) {
                itime = d_cpu_h->size[0];
              } else {
                itime = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
              }

              eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
              kb_cpu_w->size[0] = itime;
              kb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel334<<<grid, block>>>(itime - 1, j_gpu_w);
              }

              x_data_outdatedOnGpu = false;
              checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (b_cpu_csz[0] == 0) {
                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = itime;
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel335<<<grid, block>>>(itime - 1, j_gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && (b_cpu_csz[0] == 1)) {
                ec_wtcc_kernel336<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f1);
                ec_wtcc_kernel337<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, *gpu_a_data);
                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = 1;
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel338<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_yCol, *gpu_a_data, j_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (b_cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, r);
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                b_blockDims[0] = eint;
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    x_size_idx_1 = static_cast<int32_T>(r);
                  } else {
                    x_size_idx_1 = MIN_int32_T;
                  }
                } else {
                  x_size_idx_1 = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                     - x_size_idx_1)) {
                  nx = MIN_int32_T;
                } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                            - x_size_idx_1)) {
                  nx = MAX_int32_T;
                } else {
                  nx = x_size_idx_1 + b_cpu_csz[0];
                }

                if (nx >= -2147483647) {
                  nx--;
                }

                eint = fd_cpu_expanded->size[0] * fd_cpu_expanded->size[1];
                fd_cpu_expanded->size[0] = nx;
                fd_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real32_T(fd_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = (x_size_idx_1 + b_cpu_csz[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(fd_cpu_expanded, &q_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel339<<<grid, block>>>(eint, q_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                eint = qf_cpu_y->size[0] * qf_cpu_y->size[1];
                qf_cpu_y->size[0] = 1;
                qf_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(qf_cpu_y, eint, &kb_emlrtRTEI);
                qf_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  qf_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv160->size[0];
                cpu_iv160->size[0] = qf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv160, eint, &jb_emlrtRTEI);
                eint = qf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(qf_cpu_y, &sb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv160, &gpu_iv160, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&sb_gpu_y, qf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel340<<<grid, block>>>(offsetH, sb_gpu_y, eint,
                    gpu_iv160);
                }

                omega_tmp2[0] = cpu_iv160->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel341<<<grid, block>>>(d_gpu_h, gpu_iv160,
                    omega_tmp2[0] - 1, q_gpu_expanded);
                }

                if (b_cpu_csz[0] < -2147483647) {
                  nx = MIN_int32_T;
                } else {
                  nx = b_cpu_csz[0] - 1;
                }

                if (nx < 0) {
                  n = 0;
                } else {
                  n = nx + 1;
                }

                y_needsGpuEnsureCapacity = false;
                eint = jc_cpu_rows->size[0] * jc_cpu_rows->size[1];
                jc_cpu_rows->size[0] = 1;
                jc_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(jc_cpu_rows, eint, &kb_emlrtRTEI);
                if (n > 0) {
                  jc_cpu_rows->data[0] = 0;
                  y_needsGpuEnsureCapacity = true;
                  itime = 0;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    jc_cpu_rows->data[k + 1] = itime;
                  }
                }

                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = x_size_idx_1;
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (x_size_idx_1 != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                    dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(jc_cpu_rows, &o_gpu_rows,
                    !y_needsGpuEnsureCapacity);
                  gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&o_gpu_rows, jc_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel342<<<grid, block>>>(q_gpu_expanded,
                      o_gpu_rows, g_gpu_yCol, *gpu_csz, x_size_idx_1 - 1,
                      j_gpu_w);
                  }
                }
              }
            } else {
              if (static_cast<int32_T>(toler) == 0) {
                itime = d_cpu_h->size[0];
              } else {
                itime = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
              }

              eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
              kb_cpu_w->size[0] = itime;
              kb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel343<<<grid, block>>>(itime - 1, j_gpu_w);
              }

              x_data_outdatedOnGpu = false;
              checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              if (b_cpu_csz[0] == 0) {
                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = itime;
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel344<<<grid, block>>>(itime - 1, j_gpu_w);
                }
              } else if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel345<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f1);
                ec_wtcc_kernel346<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, *gpu_a_data);
                eint = w_cpu_yCol->size[0];
                w_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(w_cpu_yCol, eint, &ib_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(w_cpu_yCol, &h_gpu_yCol, true);
                ec_wtcc_kernel347<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_yCol, *gpu_a_data, h_gpu_yCol);
                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = itime;
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &ed_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel348<<<grid, block>>>(h_gpu_yCol, itime - 1,
                    j_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                     (d_cpu_h->size[0])) - 1U;
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                x_size_idx_1 = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  nx = MAX_int32_T;
                } else {
                  nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                eint = cd_cpu_expanded->size[0] * cd_cpu_expanded->size[1];
                cd_cpu_expanded->size[0] = nx - 1;
                cd_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_creal32_T(cd_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(cd_cpu_expanded, &r_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel349<<<grid, block>>>(eint, r_gpu_expanded);
                }

                n = b_cpu_csz[0];
                eint = kf_cpu_y->size[0] * kf_cpu_y->size[1];
                kf_cpu_y->size[0] = 1;
                kf_cpu_y->size[1] = b_cpu_csz[0];
                emxEnsureCapacity_int32_T(kf_cpu_y, eint, &kb_emlrtRTEI);
                kf_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  kf_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv162->size[0];
                cpu_iv162->size[0] = kf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv162, eint, &jb_emlrtRTEI);
                eint = kf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(kf_cpu_y, &tb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv162, &gpu_iv162, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&tb_gpu_y, kf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel350<<<grid, block>>>(offsetH, tb_gpu_y, eint,
                    gpu_iv162);
                }

                xt_size[0] = cpu_iv162->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel351<<<grid, block>>>(g_gpu_yCol, gpu_iv162,
                    xt_size[0] - 1, r_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                eint = ad_cpu_rows->size[0] * ad_cpu_rows->size[1];
                ad_cpu_rows->size[0] = 1;
                ad_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ad_cpu_rows, eint, &kb_emlrtRTEI);
                ad_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                c_omega_tmp1_needsGpuEnsureCapa = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  ad_cpu_rows->data[k + 1] = itime;
                }

                eint = kb_cpu_w->size[0] * kb_cpu_w->size[1];
                kb_cpu_w->size[0] = static_cast<int32_T>(N);
                kb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(kb_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nx = 0; nx < x_size_idx_1; nx++) {
                    eint = v_cpu_newIm->size[0];
                    v_cpu_newIm->size[0] = ad_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(v_cpu_newIm, eint, &jb_emlrtRTEI);
                    eint = ad_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                      2147483647U);
                    if (c_omega_tmp1_needsGpuEnsureCapa) {
                      gpuEmxEnsureCapacity_int32_T(ad_cpu_rows, &p_gpu_rows,
                        !y_needsGpuEnsureCapacity);
                    }

                    c_omega_tmp1_needsGpuEnsureCapa = false;
                    gpuEmxEnsureCapacity_creal32_T(v_cpu_newIm, &h_gpu_newIm,
                      true);
                    if (y_needsGpuEnsureCapacity) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&p_gpu_rows, ad_cpu_rows);
                    }

                    y_needsGpuEnsureCapacity = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel352<<<grid, block>>>(r_gpu_expanded, nx,
                        p_gpu_rows, eint, h_gpu_newIm);
                    }

                    wav_outdatedOnCpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (n = 0; n < cpu_lidx; n++) {
                      if (wav_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(v_cpu_newIm, &h_gpu_newIm);
                      }

                      if (b_fx_data_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += v_cpu_newIm->data[n].re * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                      wav_outdatedOnCpu = false;
                      b_fx_data_outdatedOnCpu = false;
                      cv_im += v_cpu_newIm->data[n].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                    }

                    if (a_data_outdatedOnGpu) {
                      gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w, true);
                    }

                    a_data_outdatedOnGpu = false;
                    ec_wtcc_kernel353<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nx, j_gpu_w);
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              ed_y = nullptr;
              m87 = emlrtCreateCharArray(2, &iv135[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m87, &rfmt[0]);
              emlrtAssign(&ed_y, m87);
              ld_y = nullptr;
              m91 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&ld_y, m91);
              emlrt_marshallIn(b_sprintf(ed_y, ld_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (kb_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              b_cpu_csz[itime] = kb_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_csz[itime] = kb_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel323<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *b_gpu_csz);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            nrefine = cpu_csz[0];
            cpu_csz[0] = cpu_csz[1];
            cpu_csz[1] = nrefine;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
              cpu_lidx = 1;
              pathlen = -1;
            } else {
              cpu_lidx = static_cast<int32_T>(b_m);
              pathlen = cpu_csz[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel324<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
              pathlen, nsubs, *gpu_csz);
            eint = tb_cpu_w->size[0] * tb_cpu_w->size[1];
            tb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            tb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(tb_cpu_w, eint, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
              &block, 2147483647U);
            if (a_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_creal32_T(kb_cpu_w, &j_gpu_w,
                !x_data_outdatedOnGpu);
            }

            gpuEmxEnsureCapacity_creal32_T(tb_cpu_w, &k_gpu_w, true);
            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyCpuToGpu_creal32_T(&j_gpu_w, kb_cpu_w);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel325<<<grid, block>>>(j_gpu_w, cpu_csz[0], cpu_lidx,
                eint, nrefine - 1, k_gpu_w, tb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = yf_cpu_y->size[0] * yf_cpu_y->size[1];
            yf_cpu_y->size[0] = b_cpu_csz[0];
            yf_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(yf_cpu_y, eint, &ed_emlrtRTEI);
            offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(yf_cpu_y, &ob_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel326<<<grid, block>>>(k_gpu_w, offsetH, ob_gpu_y);
            }

            Ly = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0]))
                           / b_m);
            if (!(b_cpu_csz[0] < Ly)) {
              if (Ly < 1.0) {
                nrefine = 0;
              } else {
                nrefine = static_cast<int32_T>(Ly);
              }

              n = cc_cpu_w->size[0] * cc_cpu_w->size[1];
              cc_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
              cc_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_creal32_T(cc_cpu_w, n, &jd_emlrtRTEI);
              eint = pathlen / cpu_lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(cc_cpu_w, &l_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel327<<<grid, block>>>(j_gpu_w, cpu_csz[0], cpu_lidx,
                  eint, cpu_csz[1] - 1, l_gpu_w, cc_cpu_w->size[0U]);
              }

              n = yf_cpu_y->size[0] * yf_cpu_y->size[1];
              yf_cpu_y->size[0] = nrefine;
              yf_cpu_y->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_creal32_T(yf_cpu_y, n, &gd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine
                - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(yf_cpu_y, &ob_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel328<<<grid, block>>>(l_gpu_w, b_cpu_csz[0],
                  nrefine - 1, b_cpu_csz[1] - 1, ob_gpu_y, yf_cpu_y->size[0U]);
              }
            }

            if (yf_cpu_y->size[0] * yf_cpu_y->size[1] == 0) {
              n = 0;
            } else {
              n = yf_cpu_y->size[0] * yf_cpu_y->size[1];
            }

            omega_tmp2[0] = yf_cpu_y->size[0] * yf_cpu_y->size[1];
            eint = hh_cpu_y->size[0] * hh_cpu_y->size[1];
            hh_cpu_y->size[0] = 1;
            hh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(hh_cpu_y, eint, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(hh_cpu_y, &pb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel329<<<grid, block>>>(ob_gpu_y, omega_tmp2[0] - 1,
                pb_gpu_y);
            }

            eint = df_cpu_y->size[0] * df_cpu_y->size[1];
            df_cpu_y->size[0] = n;
            df_cpu_y->size[1] = 1;
            emxEnsureCapacity_creal32_T(df_cpu_y, eint, &ld_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(df_cpu_y, &qb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel330<<<grid, block>>>(pb_gpu_y, n - 1, qb_gpu_y);
            }
          } else {
            if (!(toler - 1.0 >= 0.0)) {
              ic_y = nullptr;
              m53 = emlrtCreateCharArray(2, &iv117[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m53, &rfmt[0]);
              emlrtAssign(&ic_y, m53);
              rc_y = nullptr;
              m61 = emlrtCreateDoubleScalar(toler - 1.0);
              emlrtAssign(&rc_y, m61);
              emlrt_marshallIn(b_sprintf(ic_y, rc_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              b_cpu_csz[itime] = cpu_opts_x->size[itime];
            }

            nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            eint = k_cpu_yCol->size[0];
            k_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
            emxEnsureCapacity_creal32_T(k_cpu_yCol, eint, &yc_emlrtRTEI);
            eint = nx * static_cast<int32_T>(toler) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(k_cpu_yCol, &i_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel354<<<grid, block>>>(eint, i_gpu_yCol);
            }

            if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                   (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
                 ((static_cast<int32_T>(toler) < 0) && (nrefine *
                   static_cast<int32_T>(toler) > 1)))) {
              nrefine = 1;
              cpu_lidx = 0;
            } else {
              nrefine = static_cast<int32_T>(toler);
              cpu_lidx = nx * static_cast<int32_T>(toler);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1,
              nrefine)), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel355<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
                (cpu_lidx - 1, nrefine), i_gpu_yCol);
            }

            b_cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
            if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
              if (cpu_opts_x->size[1] < 1) {
                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = 1;
                fb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel356<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (m_gpu_w);
              } else {
                eint = cpu_opts_x->size[1];
                n = l_cpu_a->size[0];
                l_cpu_a->size[0] = cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(l_cpu_a, n, &fb_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(l_cpu_a, &j_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel363<<<grid, block>>>(i_gpu_yCol, eint - 1,
                    j_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                cpu_cv_re = d_cpu_h->data[0];
                eint = t_cpu_c->size[0];
                t_cpu_c->size[0] = l_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(t_cpu_c, eint, &hb_emlrtRTEI);
                eint = l_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(t_cpu_c, &f_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel364<<<grid, block>>>(eint, f_gpu_c);
                }

                if (l_cpu_a->size[0] == 1) {
                  cpu_cv_re = d_cpu_h->data[0];
                  eint = t_cpu_c->size[0];
                  t_cpu_c->size[0] = 1;
                  emxEnsureCapacity_creal32_T(t_cpu_c, eint, &hb_emlrtRTEI);
                  ec_wtcc_kernel365<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (j_gpu_a, cpu_cv_re, gpu_f, gpu_f1);
                  gpuEmxEnsureCapacity_creal32_T(t_cpu_c, &f_gpu_c, true);
                  ec_wtcc_kernel366<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (gpu_f1, gpu_f, f_gpu_c);
                } else {
                  itime = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(l_cpu_a->size[0]) + 1.0) - 1.0));
                  b_blockDims[0] = static_cast<int32_T>(std::floor
                    (static_cast<real_T>((static_cast<uint32_T>(l_cpu_a->size[0])
                    + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                     (itime)));
                  threadDims[0] = static_cast<int8_T>(itime);
                  x_size_idx_1 = l_cpu_a->size[0];
                  if (l_cpu_a->size[0] > 2147483646) {
                    nx = MAX_int32_T;
                  } else {
                    nx = l_cpu_a->size[0] + 1;
                  }

                  eint = ic_cpu_expanded->size[0];
                  ic_cpu_expanded->size[0] = nx - 1;
                  emxEnsureCapacity_creal32_T(ic_cpu_expanded, eint,
                    &jb_emlrtRTEI);
                  eint = l_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_creal32_T(ic_cpu_expanded,
                    &s_gpu_expanded, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel368<<<grid, block>>>(eint, s_gpu_expanded);
                  }

                  n = l_cpu_a->size[0];
                  eint = je_cpu_y->size[0] * je_cpu_y->size[1];
                  je_cpu_y->size[0] = 1;
                  je_cpu_y->size[1] = l_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(je_cpu_y, eint, &kb_emlrtRTEI);
                  je_cpu_y->data[0] = 1;
                  itime = 1;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    je_cpu_y->data[k + 1] = itime;
                  }

                  eint = cpu_iv140->size[0];
                  cpu_iv140->size[0] = je_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv140, eint, &jb_emlrtRTEI);
                  eint = je_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(je_cpu_y, &ub_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv140, &gpu_iv140, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&ub_gpu_y, je_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel369<<<grid, block>>>(ub_gpu_y, eint, gpu_iv140);
                  }

                  omega_tmp2[0] = cpu_iv140->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel370<<<grid, block>>>(j_gpu_a, gpu_iv140,
                      omega_tmp2[0] - 1, s_gpu_expanded);
                  }

                  eint = t_cpu_c->size[0];
                  t_cpu_c->size[0] = l_cpu_a->size[0];
                  emxEnsureCapacity_creal32_T(t_cpu_c, eint, &jb_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1),
                    dim3(static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                  gpuEmxEnsureCapacity_creal32_T(t_cpu_c, &f_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel371<<<grid, block>>>(s_gpu_expanded, cpu_cv_re,
                      x_size_idx_1 - 1, f_gpu_c);
                  }
                }

                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = 1;
                fb_cpu_w->size[1] = t_cpu_c->size[0];
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                offsetH = t_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel367<<<grid, block>>>(f_gpu_c, offsetH, m_gpu_w,
                    fb_cpu_w->size[0U]);
                }
              }
            } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
              if (b_cpu_csz[0] == 0) {
                itime = d_cpu_h->size[0];
              } else {
                itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                nrefine = 1;
              } else {
                nrefine = cpu_opts_x->size[1];
              }

              eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
              fb_cpu_w->size[0] = itime;
              fb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel372<<<grid, block>>>(eint, m_gpu_w);
              }

              if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = itime;
                fb_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                eint = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel373<<<grid, block>>>(eint, m_gpu_w);
                }
              } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                          (cpu_opts_x->size[1] == 1))) {
                ec_wtcc_kernel374<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f1);
                ec_wtcc_kernel375<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, *gpu_a_data);
                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = 1;
                fb_cpu_w->size[1] = 1;
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel376<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (i_gpu_yCol, *gpu_a_data, m_gpu_w);
              } else {
                r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                     (b_cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, r);
                cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                  (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
                c_blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                  (cpu_lidx));
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                b_blockDims[0] = eint;
                b_blockDims[1] = cpu_lidx;
                ix = cpu_opts_x->size[1];
                if (r < 2.147483648E+9) {
                  if (r >= -2.147483648E+9) {
                    x_size_idx_1 = static_cast<int32_T>(r);
                  } else {
                    x_size_idx_1 = MIN_int32_T;
                  }
                } else {
                  x_size_idx_1 = MAX_int32_T;
                }

                s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
                if (s >= -2.147483648E+9) {
                  offsetH = static_cast<int32_T>(s);
                } else {
                  offsetH = MIN_int32_T;
                }

                if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                     - x_size_idx_1)) {
                  nx = MIN_int32_T;
                } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                            - x_size_idx_1)) {
                  nx = MAX_int32_T;
                } else {
                  nx = x_size_idx_1 + b_cpu_csz[0];
                }

                if (nx >= -2147483647) {
                  nx--;
                }

                eint = pc_cpu_expanded->size[0] * pc_cpu_expanded->size[1];
                pc_cpu_expanded->size[0] = nx;
                emxEnsureCapacity_real32_T(pc_cpu_expanded, eint, &jb_emlrtRTEI);
                if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                  nx = MAX_int32_T;
                } else {
                  nx = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                }

                eint = pc_cpu_expanded->size[0] * pc_cpu_expanded->size[1];
                pc_cpu_expanded->size[1] = nx - 1;
                emxEnsureCapacity_real32_T(pc_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((cpu_opts_x->size
                  [1] + cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real32_T(pc_cpu_expanded, &t_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel377<<<grid, block>>>(eint, t_gpu_expanded);
                }

                n = d_cpu_h->size[0];
                eint = qe_cpu_y->size[0] * qe_cpu_y->size[1];
                qe_cpu_y->size[0] = 1;
                qe_cpu_y->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(qe_cpu_y, eint, &kb_emlrtRTEI);
                qe_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  qe_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv142->size[0];
                cpu_iv142->size[0] = qe_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv142, eint, &jb_emlrtRTEI);
                eint = qe_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(qe_cpu_y, &vb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv142, &gpu_iv142, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&vb_gpu_y, qe_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel378<<<grid, block>>>(offsetH, vb_gpu_y, eint,
                    gpu_iv142);
                }

                cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv142->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel379<<<grid, block>>>(d_gpu_h, cpu_lidx,
                    gpu_iv142, omega_tmp2[0] - 1, t_gpu_expanded,
                    pc_cpu_expanded->size[0U]);
                }

                if (b_cpu_csz[0] < -2147483647) {
                  nx = MIN_int32_T;
                } else {
                  nx = b_cpu_csz[0] - 1;
                }

                if (nx < 0) {
                  n = 0;
                } else {
                  n = nx + 1;
                }

                y_needsGpuEnsureCapacity = false;
                eint = ac_cpu_rows->size[0] * ac_cpu_rows->size[1];
                ac_cpu_rows->size[0] = 1;
                ac_cpu_rows->size[1] = n;
                emxEnsureCapacity_int32_T(ac_cpu_rows, eint, &kb_emlrtRTEI);
                if (n > 0) {
                  ac_cpu_rows->data[0] = 0;
                  y_needsGpuEnsureCapacity = true;
                  itime = 0;
                  for (k = 0; k <= n - 2; k++) {
                    itime++;
                    ac_cpu_rows->data[k + 1] = itime;
                  }
                }

                n = cpu_opts_x->size[1];
                eint = h_cpu_cols->size[0] * h_cpu_cols->size[1];
                h_cpu_cols->size[0] = 1;
                h_cpu_cols->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(h_cpu_cols, eint, &kb_emlrtRTEI);
                h_cpu_cols->data[0] = 0;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  h_cpu_cols->data[k + 1] = itime;
                }

                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = x_size_idx_1;
                fb_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (x_size_idx_1 != 0) {
                  if (c_blockDims[0] < 4.294967296E+9) {
                    if (c_blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(c_blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (c_blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = b_blockDims[0];
                  if (b_blockDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 -
                    1), dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3
                    (static_cast<uint32_T>(eint), static_cast<uint32_T>
                     (b_blockDims[1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(h_cpu_cols, &c_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(ac_cpu_rows, &q_gpu_rows,
                    !y_needsGpuEnsureCapacity);
                  gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                  a_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_cols, h_cpu_cols);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&q_gpu_rows, ac_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel380<<<grid, block>>>(t_gpu_expanded,
                      c_gpu_cols, q_gpu_rows, i_gpu_yCol, *gpu_csz, x_size_idx_1
                      - 1, ix - 1, m_gpu_w, pc_cpu_expanded->size[0U],
                      fb_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (b_cpu_csz[0] == 0) {
                itime = d_cpu_h->size[0];
              } else {
                itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                nrefine = 1;
              } else {
                nrefine = cpu_opts_x->size[1];
              }

              eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
              fb_cpu_w->size[0] = itime;
              fb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel381<<<grid, block>>>(eint, m_gpu_w);
              }

              if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = itime;
                fb_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                eint = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel382<<<grid, block>>>(eint, m_gpu_w);
                }
              } else if ((b_cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                         (d_cpu_h->size[0] == 1)) {
                ec_wtcc_kernel383<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (d_gpu_h, gpu_f1);
                ec_wtcc_kernel384<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, *gpu_a_data);
                eint = ab_cpu_yCol->size[0];
                ab_cpu_yCol->size[0] = 1;
                emxEnsureCapacity_creal32_T(ab_cpu_yCol, eint, &ib_emlrtRTEI);
                gpuEmxEnsureCapacity_creal32_T(ab_cpu_yCol, &j_gpu_yCol, true);
                ec_wtcc_kernel385<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (i_gpu_yCol, *gpu_a_data, j_gpu_yCol);
                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = itime;
                fb_cpu_w->size[1] = nrefine;
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &ed_emlrtRTEI);
                offsetH = itime * nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                a_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel386<<<grid, block>>>(j_gpu_yCol, offsetH,
                    m_gpu_w);
                }
              } else {
                N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                     (d_cpu_h->size[0])) - 1U;
                ix = cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                x_size_idx_1 = static_cast<int32_T>(N);
                offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  nx = MAX_int32_T;
                } else {
                  nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
                }

                eint = mc_cpu_expanded->size[0] * mc_cpu_expanded->size[1];
                mc_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_creal32_T(mc_cpu_expanded, eint, &jb_emlrtRTEI);
                if (cpu_opts_x->size[1] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = cpu_opts_x->size[1] + 1;
                }

                eint = mc_cpu_expanded->size[0] * mc_cpu_expanded->size[1];
                mc_cpu_expanded->size[1] = nx - 1;
                emxEnsureCapacity_creal32_T(mc_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                  cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(mc_cpu_expanded, &u_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel387<<<grid, block>>>(eint, u_gpu_expanded);
                }

                n = b_cpu_csz[0];
                eint = oe_cpu_y->size[0] * oe_cpu_y->size[1];
                oe_cpu_y->size[0] = 1;
                oe_cpu_y->size[1] = b_cpu_csz[0];
                emxEnsureCapacity_int32_T(oe_cpu_y, eint, &kb_emlrtRTEI);
                oe_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  oe_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv146->size[0];
                cpu_iv146->size[0] = oe_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv146, eint, &jb_emlrtRTEI);
                eint = oe_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(oe_cpu_y, &wb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv146, &gpu_iv146, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&wb_gpu_y, oe_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel388<<<grid, block>>>(offsetH, wb_gpu_y, eint,
                    gpu_iv146);
                }

                n = cpu_opts_x->size[1];
                eint = nf_cpu_y->size[0] * nf_cpu_y->size[1];
                nf_cpu_y->size[0] = 1;
                nf_cpu_y->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(nf_cpu_y, eint, &kb_emlrtRTEI);
                nf_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  nf_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv165->size[0];
                cpu_iv165->size[0] = nf_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv165, eint, &jb_emlrtRTEI);
                eint = nf_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(nf_cpu_y, &xb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv165, &gpu_iv165, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&xb_gpu_y, nf_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel389<<<grid, block>>>(xb_gpu_y, eint, gpu_iv165);
                }

                xt_size[0] = cpu_iv146->size[0];
                xt_size[1] = cpu_iv165->size[0];
                mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel390<<<grid, block>>>(i_gpu_yCol, xt_size[0],
                    gpu_iv165, gpu_iv146, xt_size[0] - 1, xt_size[1] - 1,
                    u_gpu_expanded, mc_cpu_expanded->size[0U]);
                }

                n = d_cpu_h->size[0];
                eint = gc_cpu_rows->size[0] * gc_cpu_rows->size[1];
                gc_cpu_rows->size[0] = 1;
                gc_cpu_rows->size[1] = d_cpu_h->size[0];
                emxEnsureCapacity_int32_T(gc_cpu_rows, eint, &kb_emlrtRTEI);
                gc_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                c_omega_tmp1_needsGpuEnsureCapa = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  gc_cpu_rows->data[k + 1] = itime;
                }

                eint = fb_cpu_w->size[0] * fb_cpu_w->size[1];
                fb_cpu_w->size[0] = static_cast<int32_T>(N);
                fb_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_creal32_T(fb_cpu_w, eint, &jb_emlrtRTEI);
                a_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  for (nrefine = 0; nrefine < ix; nrefine++) {
                    cpu_lidx = d_cpu_h->size[0];
                    for (nx = 0; nx < x_size_idx_1; nx++) {
                      eint = e_cpu_newIm->size[0];
                      e_cpu_newIm->size[0] = gc_cpu_rows->size[1];
                      emxEnsureCapacity_creal32_T(e_cpu_newIm, eint,
                        &jb_emlrtRTEI);
                      eint = gc_cpu_rows->size[1] - 1;
                      mwGetLaunchParameters1D(computeNumIters(eint), &grid,
                        &block, 2147483647U);
                      if (c_omega_tmp1_needsGpuEnsureCapa) {
                        gpuEmxEnsureCapacity_int32_T(gc_cpu_rows, &r_gpu_rows,
                          !y_needsGpuEnsureCapacity);
                      }

                      c_omega_tmp1_needsGpuEnsureCapa = false;
                      gpuEmxEnsureCapacity_creal32_T(e_cpu_newIm, &i_gpu_newIm,
                        true);
                      if (y_needsGpuEnsureCapacity) {
                        gpuEmxMemcpyCpuToGpu_int32_T(&r_gpu_rows, gc_cpu_rows);
                      }

                      y_needsGpuEnsureCapacity = false;
                      validLaunchParams = mwValidateLaunchParameters(grid, block);
                      if (validLaunchParams) {
                        ec_wtcc_kernel391<<<grid, block>>>(nrefine,
                          u_gpu_expanded, nx, r_gpu_rows, eint, i_gpu_newIm,
                          mc_cpu_expanded->size[0U]);
                      }

                      wav_outdatedOnCpu = true;
                      cpu_cv_re = 0.0F;
                      cv_im = 0.0F;
                      for (n = 0; n < cpu_lidx; n++) {
                        if (wav_outdatedOnCpu) {
                          gpuEmxMemcpyGpuToCpu_creal32_T(e_cpu_newIm,
                            &i_gpu_newIm);
                        }

                        if (b_fx_data_outdatedOnCpu) {
                          gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                        }

                        cpu_cv_re += e_cpu_newIm->data[n].re * d_cpu_h->data
                          [(d_cpu_h->size[0] - n) - 1];
                        wav_outdatedOnCpu = false;
                        b_fx_data_outdatedOnCpu = false;
                        cv_im += e_cpu_newIm->data[n].im * d_cpu_h->data
                          [(d_cpu_h->size[0] - n) - 1];
                      }

                      if (a_data_outdatedOnGpu) {
                        gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
                      }

                      a_data_outdatedOnGpu = false;
                      ec_wtcc_kernel392<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                        (cv_im, cpu_cv_re, nrefine, nx, m_gpu_w, fb_cpu_w->size
                         [0U]);
                    }
                  }
                }
              }
            }

            if (!(b_m - 1.0 >= 0.0)) {
              bd_y = nullptr;
              m74 = emlrtCreateCharArray(2, &iv128[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m74, &rfmt[0]);
              emlrtAssign(&bd_y, m74);
              id_y = nullptr;
              m80 = emlrtCreateDoubleScalar(b_m - 1.0);
              emlrtAssign(&id_y, m80);
              emlrt_marshallIn(b_sprintf(bd_y, id_y, &emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            nsubs = 2;
            if (fb_cpu_w->size[0] != 1) {
              nsubs = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              b_cpu_csz[itime] = fb_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_csz[itime] = fb_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - nsubs >= 0) {
              cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
                (nsubs))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel357<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                  *b_gpu_csz);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            nrefine = cpu_csz[0];
            cpu_csz[0] = cpu_csz[1];
            cpu_csz[1] = nrefine;
            if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
              cpu_lidx = 1;
              pathlen = -1;
            } else {
              cpu_lidx = static_cast<int32_T>(b_m);
              pathlen = cpu_csz[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_wtcc_kernel358<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
              pathlen, nsubs, *gpu_csz);
            eint = qb_cpu_w->size[0] * qb_cpu_w->size[1];
            qb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            qb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(qb_cpu_w, eint, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
              &block, 2147483647U);
            if (a_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_creal32_T(fb_cpu_w, &m_gpu_w, true);
            }

            gpuEmxEnsureCapacity_creal32_T(qb_cpu_w, &n_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel359<<<grid, block>>>(m_gpu_w, cpu_csz[0], cpu_lidx,
                eint, nrefine - 1, n_gpu_w, qb_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = df_cpu_y->size[0] * df_cpu_y->size[1];
            df_cpu_y->size[0] = b_cpu_csz[0];
            df_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(df_cpu_y, eint, &ed_emlrtRTEI);
            offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(df_cpu_y, &qb_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel360<<<grid, block>>>(n_gpu_w, offsetH, qb_gpu_y);
            }

            Ly = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                            toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
            if (!(b_cpu_csz[0] < Ly)) {
              if (Ly < 1.0) {
                nrefine = 0;
              } else {
                nrefine = static_cast<int32_T>(Ly);
              }

              n = yb_cpu_w->size[0] * yb_cpu_w->size[1];
              yb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
              yb_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_creal32_T(yb_cpu_w, n, &jd_emlrtRTEI);
              eint = pathlen / cpu_lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(yb_cpu_w, &o_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel361<<<grid, block>>>(m_gpu_w, cpu_csz[0], cpu_lidx,
                  eint, cpu_csz[1] - 1, o_gpu_w, yb_cpu_w->size[0U]);
              }

              n = df_cpu_y->size[0] * df_cpu_y->size[1];
              df_cpu_y->size[0] = nrefine;
              df_cpu_y->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_creal32_T(df_cpu_y, n, &gd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine
                - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(df_cpu_y, &qb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel362<<<grid, block>>>(o_gpu_w, b_cpu_csz[0],
                  nrefine - 1, b_cpu_csz[1] - 1, qb_gpu_y, df_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(halfh)) {
            eint = sf_cpu_y->size[0] * sf_cpu_y->size[1];
            sf_cpu_y->size[0] = 1;
            sf_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(sf_cpu_y, eint, &d_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(sf_cpu_y, &rb_gpu_y, true);
            l_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel331<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(rb_gpu_y);
          } else if (halfh < 1.0) {
            sf_cpu_y->size[0] = 1;
            sf_cpu_y->size[1] = 0;
          } else {
            eint = sf_cpu_y->size[0] * sf_cpu_y->size[1];
            sf_cpu_y->size[0] = 1;
            sf_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
            emxEnsureCapacity_real_T(sf_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(sf_cpu_y, &rb_gpu_y, true);
            l_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel333<<<grid, block>>>(static_cast<int32_T>(halfh -
                1.0), rb_gpu_y);
            }
          }

          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = static_cast<int32_T>(halfh);
          cpu_opts_x->size[1] = 1;
          emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &nd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) -
            1), &grid, &block, 2147483647U);
          if (l_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(sf_cpu_y, &rb_gpu_y, true);
          }

          gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel332<<<grid, block>>>(qb_gpu_y, rb_gpu_y, T,
              static_cast<int32_T>(halfh) - 1, gpu_opts_x);
          }
        } else {
          tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
          first_iteration = (cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_opts_x->size[0] *= cpu_opts_x->size[1];
            cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &uc_emlrtRTEI);
            e_omega_tmp1_needsGpuEnsureCapa = true;
          }

          if (!(toler - 1.0 >= 0.0)) {
            ec_y = nullptr;
            m52 = emlrtCreateCharArray(2, &iv116[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m52, &rfmt[0]);
            emlrtAssign(&ec_y, m52);
            mc_y = nullptr;
            m60 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&mc_y, m60);
            emlrt_marshallIn(b_sprintf(ec_y, mc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            nsubs = 0;
          } else {
            nsubs = 1;
            if (cpu_opts_x->size[0] != 1) {
              nsubs = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = cpu_opts_x->size[itime];
          }

          nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          eint = n_cpu_yCol->size[0];
          n_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(n_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(n_cpu_yCol, &k_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel423<<<grid, block>>>(eint, k_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = nx * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
            &grid, &block, 2147483647U);
          if (e_omega_tmp1_needsGpuEnsureCapa) {
            gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel424<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
              (cpu_lidx - 1, nrefine), k_gpu_yCol);
          }

          b_cpu_csz[nsubs] = cpu_opts_x->size[nsubs] * static_cast<int32_T>
            (toler);
          if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (b_cpu_csz[1] < 1) {
              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = 1;
              hb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel425<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(p_gpu_w);
            } else {
              n = o_cpu_a->size[0];
              o_cpu_a->size[0] = b_cpu_csz[1];
              emxEnsureCapacity_creal32_T(o_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_creal32_T(o_cpu_a, &k_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel437<<<grid, block>>>(k_gpu_yCol, b_cpu_csz[1] - 1,
                  k_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              eint = v_cpu_c->size[0];
              v_cpu_c->size[0] = o_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(v_cpu_c, eint, &hb_emlrtRTEI);
              eint = o_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &g_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel438<<<grid, block>>>(eint, g_gpu_c);
              }

              if (o_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                eint = v_cpu_c->size[0];
                v_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(v_cpu_c, eint, &hb_emlrtRTEI);
                ec_wtcc_kernel439<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (k_gpu_a, cpu_cv_re, gpu_f, gpu_f1);
                gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &g_gpu_c, true);
                ec_wtcc_kernel440<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, gpu_f, g_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (o_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(o_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = o_cpu_a->size[0];
                if (o_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = o_cpu_a->size[0] + 1;
                }

                eint = sc_cpu_expanded->size[0];
                sc_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_creal32_T(sc_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = o_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(sc_cpu_expanded, &ab_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel442<<<grid, block>>>(eint, ab_gpu_expanded);
                }

                n = o_cpu_a->size[0];
                eint = te_cpu_y->size[0] * te_cpu_y->size[1];
                te_cpu_y->size[0] = 1;
                te_cpu_y->size[1] = o_cpu_a->size[0];
                emxEnsureCapacity_int32_T(te_cpu_y, eint, &kb_emlrtRTEI);
                te_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  te_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv145->size[0];
                cpu_iv145->size[0] = te_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv145, eint, &jb_emlrtRTEI);
                eint = te_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(te_cpu_y, &gc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv145, &gpu_iv145, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&gc_gpu_y, te_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel443<<<grid, block>>>(gc_gpu_y, eint, gpu_iv145);
                }

                omega_tmp2[0] = cpu_iv145->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel444<<<grid, block>>>(k_gpu_a, gpu_iv145,
                    omega_tmp2[0] - 1, ab_gpu_expanded);
                }

                eint = v_cpu_c->size[0];
                v_cpu_c->size[0] = o_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(v_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(v_cpu_c, &g_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel445<<<grid, block>>>(ab_gpu_expanded, cpu_cv_re,
                    x_size_idx_1 - 1, g_gpu_c);
                }
              }

              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = 1;
              hb_cpu_w->size[1] = v_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = v_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel441<<<grid, block>>>(g_gpu_c, offsetH, p_gpu_w,
                  hb_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (b_cpu_csz[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = b_cpu_csz[1];
            }

            eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
            hb_cpu_w->size[0] = itime;
            hb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel446<<<grid, block>>>(eint, p_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = itime;
              hb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel447<<<grid, block>>>(eint, p_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                        (b_cpu_csz[1] == 1))) {
              ec_wtcc_kernel448<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel449<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = 1;
              hb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel450<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (k_gpu_yCol, *gpu_a_data, p_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(b_cpu_csz[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
                1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
                static_cast<real_T>(cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = b_cpu_csz[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = yc_cpu_expanded->size[0] * yc_cpu_expanded->size[1];
              yc_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(yc_cpu_expanded, eint, &jb_emlrtRTEI);
              if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz
                   [1])) {
                nx = MIN_int32_T;
              } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                          - b_cpu_csz[1])) {
                nx = MAX_int32_T;
              } else {
                nx = b_cpu_csz[1] + b_cpu_csz[1];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = yc_cpu_expanded->size[0] * yc_cpu_expanded->size[1];
              yc_cpu_expanded->size[1] = nx;
              emxEnsureCapacity_real32_T(yc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
                b_cpu_csz[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(yc_cpu_expanded, &bb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel451<<<grid, block>>>(eint, bb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = bf_cpu_y->size[0] * bf_cpu_y->size[1];
              bf_cpu_y->size[0] = 1;
              bf_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(bf_cpu_y, eint, &kb_emlrtRTEI);
              bf_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                bf_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv150->size[0];
              cpu_iv150->size[0] = bf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv150, eint, &jb_emlrtRTEI);
              eint = bf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(bf_cpu_y, &hc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv150, &gpu_iv150, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&hc_gpu_y, bf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel452<<<grid, block>>>(offsetH, hc_gpu_y, eint,
                  gpu_iv150);
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                cpu_lidx = static_cast<int32_T>(s);
              } else {
                cpu_lidx = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv150->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel453<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv150,
                  omega_tmp2[0] - 1, bb_gpu_expanded, yc_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = cc_cpu_rows->size[0] * cc_cpu_rows->size[1];
              cc_cpu_rows->size[0] = 1;
              cc_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(cc_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                cc_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  cc_cpu_rows->data[k + 1] = itime;
                }
              }

              if (b_cpu_csz[1] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[1] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              interval_outdatedOnGpu = false;
              eint = k_cpu_cols->size[0] * k_cpu_cols->size[1];
              k_cpu_cols->size[0] = 1;
              k_cpu_cols->size[1] = n;
              emxEnsureCapacity_int32_T(k_cpu_cols, eint, &kb_emlrtRTEI);
              if (n > 0) {
                k_cpu_cols->data[0] = 0;
                interval_outdatedOnGpu = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  k_cpu_cols->data[k + 1] = itime;
                }
              }

              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = x_size_idx_1;
              hb_cpu_w->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (c_blockDims[1] < 4.294967296E+9) {
                  if (c_blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(c_blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (c_blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                n = b_blockDims[1];
                if (b_blockDims[1] < 0) {
                  n = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                  static_cast<uint32_T>(n), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(k_cpu_cols, &d_gpu_cols,
                  !interval_outdatedOnGpu);
                gpuEmxEnsureCapacity_int32_T(cc_cpu_rows, &w_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (interval_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_cols, k_cpu_cols);
                }

                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&w_gpu_rows, cc_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel454<<<grid, block>>>(bb_gpu_expanded, d_gpu_cols,
                    w_gpu_rows, k_gpu_yCol, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                    p_gpu_w, yc_cpu_expanded->size[0U], hb_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
            }

            if (b_cpu_csz[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = b_cpu_csz[1];
            }

            eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
            hb_cpu_w->size[0] = itime;
            hb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel455<<<grid, block>>>(eint, p_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = itime;
              hb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel456<<<grid, block>>>(eint, p_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel457<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel458<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = cb_cpu_yCol->size[0];
              cb_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(cb_cpu_yCol, eint, &ib_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(cb_cpu_yCol, &l_gpu_yCol, true);
              ec_wtcc_kernel459<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (k_gpu_yCol, *gpu_a_data, l_gpu_yCol);
              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = itime;
              hb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel460<<<grid, block>>>(l_gpu_yCol, offsetH, p_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = b_cpu_csz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              eint = wc_cpu_expanded->size[0] * wc_cpu_expanded->size[1];
              wc_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_creal32_T(wc_cpu_expanded, eint, &jb_emlrtRTEI);
              if (b_cpu_csz[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = b_cpu_csz[1] + 1;
              }

              eint = wc_cpu_expanded->size[0] * wc_cpu_expanded->size[1];
              wc_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_creal32_T(wc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                b_cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(wc_cpu_expanded, &cb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel461<<<grid, block>>>(eint, cb_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = we_cpu_y->size[0] * we_cpu_y->size[1];
              we_cpu_y->size[0] = 1;
              we_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(we_cpu_y, eint, &kb_emlrtRTEI);
              we_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                we_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv153->size[0];
              cpu_iv153->size[0] = we_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv153, eint, &jb_emlrtRTEI);
              eint = we_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(we_cpu_y, &ic_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv153, &gpu_iv153, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ic_gpu_y, we_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel462<<<grid, block>>>(offsetH, ic_gpu_y, eint,
                  gpu_iv153);
              }

              if (b_cpu_csz[1] < 1) {
                n = 0;
              } else {
                n = b_cpu_csz[1];
              }

              fx_data_outdatedOnCpu = false;
              eint = wf_cpu_y->size[0] * wf_cpu_y->size[1];
              wf_cpu_y->size[0] = 1;
              wf_cpu_y->size[1] = n;
              emxEnsureCapacity_int32_T(wf_cpu_y, eint, &kb_emlrtRTEI);
              if (n > 0) {
                wf_cpu_y->data[0] = 1;
                fx_data_outdatedOnCpu = true;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  wf_cpu_y->data[k + 1] = itime;
                }
              }

              eint = cpu_iv170->size[0];
              cpu_iv170->size[0] = wf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv170, eint, &jb_emlrtRTEI);
              eint = wf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(wf_cpu_y, &jc_gpu_y,
                !fx_data_outdatedOnCpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv170, &gpu_iv170, true);
              if (fx_data_outdatedOnCpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&jc_gpu_y, wf_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel463<<<grid, block>>>(jc_gpu_y, eint, gpu_iv170);
              }

              xt_size[0] = cpu_iv153->size[0];
              xt_size[1] = cpu_iv170->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel464<<<grid, block>>>(k_gpu_yCol, xt_size[0],
                  gpu_iv170, gpu_iv153, xt_size[0] - 1, xt_size[1] - 1,
                  cb_gpu_expanded, wc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              eint = mc_cpu_rows->size[0] * mc_cpu_rows->size[1];
              mc_cpu_rows->size[0] = 1;
              mc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(mc_cpu_rows, eint, &kb_emlrtRTEI);
              mc_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                mc_cpu_rows->data[k + 1] = itime;
              }

              eint = hb_cpu_w->size[0] * hb_cpu_w->size[1];
              hb_cpu_w->size[0] = static_cast<int32_T>(N);
              hb_cpu_w->size[1] = b_cpu_csz[1];
              emxEnsureCapacity_creal32_T(hb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
                for (nrefine = 0; nrefine < ix; nrefine++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nx = 0; nx < x_size_idx_1; nx++) {
                    eint = k_cpu_newIm->size[0];
                    k_cpu_newIm->size[0] = mc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(k_cpu_newIm, eint, &jb_emlrtRTEI);
                    eint = mc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                      2147483647U);
                    if (c_omega_tmp1_needsGpuEnsureCapa) {
                      gpuEmxEnsureCapacity_int32_T(mc_cpu_rows, &x_gpu_rows,
                        !y_needsGpuEnsureCapacity);
                    }

                    c_omega_tmp1_needsGpuEnsureCapa = false;
                    gpuEmxEnsureCapacity_creal32_T(k_cpu_newIm, &l_gpu_newIm,
                      true);
                    if (y_needsGpuEnsureCapacity) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_rows, mc_cpu_rows);
                    }

                    y_needsGpuEnsureCapacity = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel465<<<grid, block>>>(nrefine,
                        cb_gpu_expanded, nx, x_gpu_rows, eint, l_gpu_newIm,
                        wc_cpu_expanded->size[0U]);
                    }

                    wav_outdatedOnCpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (n = 0; n < cpu_lidx; n++) {
                      if (wav_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(k_cpu_newIm, &l_gpu_newIm);
                      }

                      if (b_fx_data_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += k_cpu_newIm->data[n].re * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                      wav_outdatedOnCpu = false;
                      b_fx_data_outdatedOnCpu = false;
                      cv_im += k_cpu_newIm->data[n].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                    }

                    if (a_data_outdatedOnGpu) {
                      gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
                    }

                    a_data_outdatedOnGpu = false;
                    ec_wtcc_kernel466<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nrefine, nx, p_gpu_w, hb_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            ad_y = nullptr;
            m78 = emlrtCreateCharArray(2, &iv132[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m78, &rfmt[0]);
            emlrtAssign(&ad_y, m78);
            hd_y = nullptr;
            m85 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&hd_y, m85);
            emlrt_marshallIn(b_sprintf(ad_y, hd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (hb_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = hb_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = hb_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel426<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          nrefine = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = nrefine;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            cpu_lidx = 1;
            pathlen = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel427<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
            pathlen, nsubs, *gpu_csz);
          eint = vb_cpu_w->size[0] * vb_cpu_w->size[1];
          vb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          vb_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(vb_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(hb_cpu_w, &p_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(vb_cpu_w, &q_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel428<<<grid, block>>>(p_gpu_w, cpu_csz[0], cpu_lidx,
              eint, nrefine - 1, q_gpu_w, vb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = gf_cpu_y->size[0] * gf_cpu_y->size[1];
          gf_cpu_y->size[0] = b_cpu_csz[0];
          gf_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(gf_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(gf_cpu_y, &dc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel429<<<grid, block>>>(q_gpu_w, offsetH, dc_gpu_y);
          }

          Ly = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                          toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              nrefine = 0;
            } else {
              nrefine = static_cast<int32_T>(Ly);
            }

            n = fc_cpu_w->size[0] * fc_cpu_w->size[1];
            fc_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            fc_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_creal32_T(fc_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(fc_cpu_w, &r_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel430<<<grid, block>>>(p_gpu_w, cpu_csz[0], cpu_lidx,
                eint, cpu_csz[1] - 1, r_gpu_w, fc_cpu_w->size[0U]);
            }

            n = gf_cpu_y->size[0] * gf_cpu_y->size[1];
            gf_cpu_y->size[0] = nrefine;
            gf_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(gf_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(gf_cpu_y, &dc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel431<<<grid, block>>>(r_gpu_w, b_cpu_csz[0], nrefine
                - 1, b_cpu_csz[1] - 1, dc_gpu_y, gf_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = gf_cpu_y->size[0] * gf_cpu_y->size[1];
            eint = fh_cpu_y->size[0] * fh_cpu_y->size[1];
            fh_cpu_y->size[0] = 1;
            fh_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_creal32_T(fh_cpu_y, eint, &kd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(fh_cpu_y, &ec_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel432<<<grid, block>>>(dc_gpu_y, omega_tmp2[0] - 1,
                ec_gpu_y, fh_cpu_y->size[0U]);
            }

            eint = gf_cpu_y->size[0] * gf_cpu_y->size[1];
            gf_cpu_y->size[0] = 1;
            gf_cpu_y->size[1] = fh_cpu_y->size[1];
            emxEnsureCapacity_creal32_T(gf_cpu_y, eint, &md_emlrtRTEI);
            eint = fh_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(gf_cpu_y, &dc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel433<<<grid, block>>>(ec_gpu_y, eint, dc_gpu_y);
            }
          }

          if (std::isnan(tol)) {
            eint = bg_cpu_y->size[0] * bg_cpu_y->size[1];
            bg_cpu_y->size[0] = 1;
            bg_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(bg_cpu_y, eint, &d_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(bg_cpu_y, &fc_gpu_y, true);
            n_y_needsGpuEnsureCapacity = false;
            ec_wtcc_kernel434<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(fc_gpu_y);
          } else if (tol < 1.0) {
            bg_cpu_y->size[0] = 1;
            bg_cpu_y->size[1] = 0;
          } else {
            eint = bg_cpu_y->size[0] * bg_cpu_y->size[1];
            bg_cpu_y->size[0] = 1;
            bg_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
            emxEnsureCapacity_real_T(bg_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(bg_cpu_y, &fc_gpu_y, true);
            n_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel436<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
                fc_gpu_y);
            }
          }

          cpu_lidx = gf_cpu_y->size[1];
          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = bg_cpu_y->size[1];
          cpu_opts_x->size[1] = gf_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &nd_emlrtRTEI);
          eint = bg_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
            &block, 2147483647U);
          if (n_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(bg_cpu_y, &fc_gpu_y, true);
          }

          gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel435<<<grid, block>>>(dc_gpu_y, fc_gpu_y, T, eint,
              cpu_lidx - 1, gpu_opts_x, cpu_opts_x->size[0U], gf_cpu_y->size[0U]);
          }
        }
      }

      emxFree_creal32_T(&fc_cpu_w);
      emxFree_creal32_T(&hh_cpu_y);
      emxFree_creal32_T(&fh_cpu_y);
      emxFree_creal32_T(&cc_cpu_w);
      emxFree_creal32_T(&yb_cpu_w);
      emxFree_creal32_T(&vb_cpu_w);
      emxFree_creal32_T(&tb_cpu_w);
      emxFree_creal32_T(&qb_cpu_w);
      emxFree_creal32_T(&cb_cpu_yCol);
      emxFree_creal32_T(&ab_cpu_yCol);
      emxFree_creal32_T(&w_cpu_yCol);
      emxFree_creal32_T(&v_cpu_newIm);
      emxFree_creal32_T(&t_cpu_newIm);
      emxFree_creal32_T(&q_cpu_newIm);
      emxFree_creal32_T(&n_cpu_newIm);
      emxFree_creal32_T(&k_cpu_newIm);
      emxFree_creal32_T(&h_cpu_newIm);
      emxFree_creal32_T(&e_cpu_newIm);
      emxFree_int32_T(&od_cpu_rows);
      emxFree_int32_T(&md_cpu_rows);
      emxFree_int32_T(&jd_cpu_rows);
      emxFree_int32_T(&cpu_iv196);
      emxFree_int32_T(&gd_cpu_rows);
      emxFree_int32_T(&dd_cpu_rows);
      emxFree_int32_T(&cpu_iv192);
      emxFree_int32_T(&ad_cpu_rows);
      emxFree_int32_T(&wc_cpu_rows);
      emxFree_int32_T(&cpu_iv187);
      emxFree_int32_T(&sc_cpu_rows);
      emxFree_int32_T(&cpu_iv184);
      emxFree_int32_T(&cpu_iv183);
      emxFree_int32_T(&pc_cpu_rows);
      emxFree_int32_T(&k_cpu_cols);
      emxFree_int32_T(&cpu_iv178);
      emxFree_int32_T(&bh_cpu_y);
      emxFree_int32_T(&cpu_iv174);
      emxFree_int32_T(&mc_cpu_rows);
      emxFree_int32_T(&xg_cpu_y);
      emxFree_int32_T(&jc_cpu_rows);
      emxFree_int32_T(&h_cpu_cols);
      emxFree_int32_T(&cpu_iv172);
      emxFree_real32_T(&de_cpu_expanded);
      emxFree_creal32_T(&ae_cpu_expanded);
      emxFree_int32_T(&ug_cpu_y);
      emxFree_int32_T(&gc_cpu_rows);
      emxFree_int32_T(&rg_cpu_y);
      emxFree_int32_T(&cpu_iv170);
      emxFree_int32_T(&og_cpu_y);
      emxFree_real32_T(&xd_cpu_expanded);
      emxFree_creal32_T(&vd_cpu_expanded);
      emxFree_int32_T(&kg_cpu_y);
      emxFree_real32_T(&sd_cpu_expanded);
      emxFree_creal32_T(&pd_cpu_expanded);
      emxFree_int32_T(&cpu_iv165);
      emxFree_int32_T(&ig_cpu_y);
      emxFree_int32_T(&cc_cpu_rows);
      emxFree_int32_T(&cpu_iv162);
      emxFree_int32_T(&gg_cpu_y);
      emxFree_int32_T(&cpu_iv160);
      emxFree_real32_T(&ld_cpu_expanded);
      emxFree_creal32_T(&jd_cpu_expanded);
      emxFree_real_T(&bg_cpu_y);
      emxFree_int32_T(&ac_cpu_rows);
      emxFree_creal32_T(&yf_cpu_y);
      emxFree_int32_T(&wf_cpu_y);
      emxFree_int32_T(&cpu_iv153);
      emxFree_real_T(&sf_cpu_y);
      emxFree_int32_T(&cpu_iv150);
      emxFree_int32_T(&qf_cpu_y);
      emxFree_int32_T(&nf_cpu_y);
      emxFree_int32_T(&kf_cpu_y);
      emxFree_int32_T(&cpu_iv146);
      emxFree_int32_T(&cpu_iv145);
      emxFree_real32_T(&fd_cpu_expanded);
      emxFree_creal32_T(&cd_cpu_expanded);
      emxFree_int32_T(&cpu_iv142);
      emxFree_creal32_T(&gf_cpu_y);
      emxFree_creal32_T(&k_cpu_result);
      emxFree_int32_T(&cpu_iv140);
      emxFree_creal32_T(&df_cpu_y);
      emxFree_int32_T(&bf_cpu_y);
      emxFree_creal32_T(&h_cpu_result);
      emxFree_int32_T(&we_cpu_y);
      emxFree_int32_T(&te_cpu_y);
      emxFree_real32_T(&yc_cpu_expanded);
      emxFree_creal32_T(&wc_cpu_expanded);
      emxFree_int32_T(&qe_cpu_y);
      emxFree_int32_T(&oe_cpu_y);
      emxFree_creal32_T(&sc_cpu_expanded);
      emxFree_int32_T(&je_cpu_y);
      emxFree_real32_T(&pc_cpu_expanded);
      emxFree_creal32_T(&mc_cpu_expanded);
      emxFree_creal32_T(&ic_cpu_expanded);
      emxFree_creal32_T(&r_cpu_a);
      emxFree_creal32_T(&f_c);
      emxFree_creal32_T(&o_cpu_a);
      emxFree_creal32_T(&v_cpu_c);
      emxFree_creal32_T(&l_cpu_a);
      emxFree_creal32_T(&t_cpu_c);
      emxFree_creal32_T(&kb_cpu_w);
      emxFree_creal32_T(&hb_cpu_w);
      emxFree_creal32_T(&fb_cpu_w);
      emxFree_creal32_T(&q_cpu_yCol);
      emxFree_creal32_T(&n_cpu_yCol);
      emxFree_creal32_T(&k_cpu_yCol);
    }
  } else {
    if (cpu_opts_x->size[0] == 1) {
      halfh = std::ceil(toler / b_m);
      eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
      b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
      b_cpu_y1->size[1] = cpu_opts_x->size[1];
      emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &qc_emlrtRTEI);
      interval_outdatedOnGpu = true;
      nsubs = cpu_opts_x->size[1];
      if (cpu_opts_x->size[1] - 1 >= 0) {
        if ((static_cast<int32_T>(toler) == 0) || ((static_cast<int32_T>(toler) >
              0) && (static_cast<int32_T>(toler) < 1))) {
          i267 = 1;
          i273 = 0;
        } else {
          i267 = static_cast<int32_T>(toler);
          i273 = static_cast<int32_T>(toler);
        }

        c_p = (static_cast<int32_T>(toler) == 1);
        b_Ly = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                         b_m);
      }

      emxInit_creal32_T(&t_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&nb_cpu_w, 1, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&fe_cpu_y, 1, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&lc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&oc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ie_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&le_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&ne_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv138, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv139, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&wb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&xb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&b_cpu_newIm, 1, &jb_emlrtRTEI, true);
      for (b_nx = 0; b_nx < nsubs; b_nx++) {
        if (!(toler - 1.0 >= 0.0)) {
          ac_y = nullptr;
          m58 = emlrtCreateCharArray(2, &iv122[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m58, &rfmt[0]);
          emlrtAssign(&ac_y, m58);
          bc_y = nullptr;
          m67 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&bc_y, m67);
          emlrt_marshallIn(b_sprintf(ac_y, bc_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        eint = t_cpu_yCol->size[0];
        t_cpu_yCol->size[0] = static_cast<int32_T>(toler);
        emxEnsureCapacity_creal32_T(t_cpu_yCol, eint, &yc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) - 1),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_creal32_T(t_cpu_yCol, &m_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel497<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
            m_gpu_yCol);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(i273 - 1, i267)), &grid,
          &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel498<<<grid, block>>>(gpu_opts_x, b_nx, i267, div_s32
            (i273 - 1, i267), m_gpu_yCol);
        }

        if (c_p && (d_cpu_h->size[0] == 1)) {
          eint = nb_cpu_w->size[0];
          nb_cpu_w->size[0] = 1;
          emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &ed_emlrtRTEI);
          if (b_h_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
          }

          b_h_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
          a_data_outdatedOnGpu = false;
          ec_wtcc_kernel499<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(m_gpu_yCol,
            d_gpu_h, s_gpu_w);
        } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
          if (static_cast<int32_T>(toler) == 0) {
            itime = d_cpu_h->size[0] + static_cast<int32_T>(toler);
          } else {
            itime = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
          }

          eint = nb_cpu_w->size[0];
          nb_cpu_w->size[0] = itime;
          emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
          a_data_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel504<<<grid, block>>>(itime - 1, s_gpu_w);
          }

          if (static_cast<int32_T>(toler) != 0) {
            if ((d_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) == 1)) {
              ec_wtcc_kernel505<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (m_gpu_yCol, c_gpu_cfsposdft);
              eint = nb_cpu_w->size[0];
              nb_cpu_w->size[0] = 1;
              emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &ed_emlrtRTEI);
              if (b_h_needsGpuEnsureCapacity) {
                gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
              }

              b_h_needsGpuEnsureCapacity = false;
              ec_wtcc_kernel506<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (c_gpu_cfsposdft, d_gpu_h, gpu_f, gpu_f1);
              gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
              ec_wtcc_kernel507<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                gpu_f, s_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (static_cast<int32_T>(toler) <
                   MIN_int32_T - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (static_cast<int32_T>(toler) >
                          MAX_int32_T - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + static_cast<int32_T>(toler);
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = oc_cpu_expanded->size[0];
              oc_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(oc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(oc_cpu_expanded, &hb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel508<<<grid, block>>>(eint, hb_gpu_expanded);
              }

              eint = d_cpu_h->size[0];
              n = le_cpu_y->size[0] * le_cpu_y->size[1];
              le_cpu_y->size[0] = 1;
              le_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(le_cpu_y, n, &kb_emlrtRTEI);
              le_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= eint - 2; k++) {
                itime++;
                le_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv139->size[0];
              cpu_iv139->size[0] = le_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv139, eint, &jb_emlrtRTEI);
              eint = le_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(le_cpu_y, &qc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv139, &gpu_iv139, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&qc_gpu_y, le_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel509<<<grid, block>>>(offsetH, qc_gpu_y, eint,
                  gpu_iv139);
              }

              omega_tmp2[0] = cpu_iv139->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              if (b_h_needsGpuEnsureCapacity) {
                gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
              }

              b_h_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel510<<<grid, block>>>(d_gpu_h, gpu_iv139,
                  omega_tmp2[0] - 1, hb_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                nx = MIN_int32_T;
                nrefine = MIN_int32_T;
              } else {
                nx = static_cast<int32_T>(toler) - 1;
                nrefine = static_cast<int32_T>(toler) - 1;
              }

              eint = xb_cpu_rows->size[0] * xb_cpu_rows->size[1];
              xb_cpu_rows->size[0] = 1;
              xb_cpu_rows->size[1] = nrefine + 1;
              emxEnsureCapacity_int32_T(xb_cpu_rows, eint, &kb_emlrtRTEI);
              xb_cpu_rows->data[0] = 0;
              itime = 0;
              for (k = 0; k < nx; k++) {
                itime++;
                xb_cpu_rows->data[k + 1] = itime;
              }

              eint = nb_cpu_w->size[0];
              nb_cpu_w->size[0] = x_size_idx_1;
              emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &jb_emlrtRTEI);
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(N,
                1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U), &grid,
                &block);
              gpuEmxEnsureCapacity_int32_T(xb_cpu_rows, &db_gpu_rows, false);
              gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&db_gpu_rows, xb_cpu_rows);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel511<<<grid, block>>>(hb_gpu_expanded, db_gpu_rows,
                  m_gpu_yCol, toler, x_size_idx_1 - 1, s_gpu_w);
              }
            }
          }
        } else {
          if (static_cast<int32_T>(toler) == 0) {
            itime = static_cast<int32_T>(toler) + d_cpu_h->size[0];
          } else {
            itime = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
          }

          eint = nb_cpu_w->size[0];
          nb_cpu_w->size[0] = itime;
          emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &ed_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
          a_data_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel512<<<grid, block>>>(itime - 1, s_gpu_w);
          }

          if (static_cast<int32_T>(toler) != 0) {
            if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
              eint = nb_cpu_w->size[0];
              nb_cpu_w->size[0] = 1;
              emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &ed_emlrtRTEI);
              if (b_h_needsGpuEnsureCapacity) {
                gpuEmxEnsureCapacity_real32_T(d_cpu_h, &d_gpu_h, true);
              }

              b_h_needsGpuEnsureCapacity = false;
              gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
              ec_wtcc_kernel513<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (m_gpu_yCol, d_gpu_h, s_gpu_w);
            } else {
              r = (static_cast<real_T>(static_cast<int32_T>(toler)) +
                   static_cast<real_T>(d_cpu_h->size[0])) - 1.0;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((x_size_idx_1 < 0) && (d_cpu_h->size[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (d_cpu_h->size[0] > MAX_int32_T -
                          x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + d_cpu_h->size[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = lc_cpu_expanded->size[0];
              lc_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_creal32_T(lc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + d_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(lc_cpu_expanded, &ib_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel514<<<grid, block>>>(eint, ib_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              eint = ie_cpu_y->size[0] * ie_cpu_y->size[1];
              ie_cpu_y->size[0] = 1;
              ie_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(ie_cpu_y, eint, &kb_emlrtRTEI);
              ie_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ie_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv138->size[0];
              cpu_iv138->size[0] = ie_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv138, eint, &jb_emlrtRTEI);
              eint = ie_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(ie_cpu_y, &rc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv138, &gpu_iv138, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&rc_gpu_y, ie_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel515<<<grid, block>>>(offsetH, rc_gpu_y, eint,
                  gpu_iv138);
              }

              omega_tmp2[0] = cpu_iv138->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel516<<<grid, block>>>(m_gpu_yCol, gpu_iv138,
                  omega_tmp2[0] - 1, ib_gpu_expanded);
              }

              eint = d_cpu_h->size[0];
              n = wb_cpu_rows->size[0] * wb_cpu_rows->size[1];
              wb_cpu_rows->size[0] = 1;
              wb_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(wb_cpu_rows, n, &kb_emlrtRTEI);
              wb_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= eint - 2; k++) {
                itime++;
                wb_cpu_rows->data[k + 1] = itime;
              }

              eint = nb_cpu_w->size[0];
              nb_cpu_w->size[0] = x_size_idx_1;
              emxEnsureCapacity_creal32_T(nb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 - 1 >= 0) {
                i390 = d_cpu_h->size[0];
              }

              for (nx = 0; nx < x_size_idx_1; nx++) {
                eint = b_cpu_newIm->size[0];
                b_cpu_newIm->size[0] = wb_cpu_rows->size[1];
                emxEnsureCapacity_creal32_T(b_cpu_newIm, eint, &jb_emlrtRTEI);
                eint = wb_cpu_rows->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                if (c_omega_tmp1_needsGpuEnsureCapa) {
                  gpuEmxEnsureCapacity_int32_T(wb_cpu_rows, &eb_gpu_rows,
                    !y_needsGpuEnsureCapacity);
                }

                c_omega_tmp1_needsGpuEnsureCapa = false;
                gpuEmxEnsureCapacity_creal32_T(b_cpu_newIm, &o_gpu_newIm, true);
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&eb_gpu_rows, wb_cpu_rows);
                }

                y_needsGpuEnsureCapacity = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel517<<<grid, block>>>(ib_gpu_expanded, nx,
                    eb_gpu_rows, eint, o_gpu_newIm);
                }

                wav_outdatedOnCpu = true;
                cpu_cv_re = 0.0F;
                cv_im = 0.0F;
                for (n = 0; n < i390; n++) {
                  if (wav_outdatedOnCpu) {
                    gpuEmxMemcpyGpuToCpu_creal32_T(b_cpu_newIm, &o_gpu_newIm);
                  }

                  if (b_fx_data_outdatedOnCpu) {
                    gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                  }

                  cpu_cv_re += b_cpu_newIm->data[n].re * d_cpu_h->data
                    [(d_cpu_h->size[0] - n) - 1];
                  wav_outdatedOnCpu = false;
                  b_fx_data_outdatedOnCpu = false;
                  cv_im += b_cpu_newIm->data[n].im * d_cpu_h->data
                    [(d_cpu_h->size[0] - n) - 1];
                  b_h_needsGpuEnsureCapacity = true;
                }

                if (a_data_outdatedOnGpu) {
                  gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
                }

                a_data_outdatedOnGpu = false;
                ec_wtcc_kernel518<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cv_im,
                  cpu_cv_re, nx, s_gpu_w);
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          cc_y = nullptr;
          m77 = emlrtCreateCharArray(2, &iv131[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m77, &rfmt[0]);
          emlrtAssign(&cc_y, m77);
          dc_y = nullptr;
          m84 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&dc_y, m84);
          emlrt_marshallIn(b_sprintf(cc_y, dc_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        if (b_m == 0.0) {
          cpu_lidx = 1;
          nrefine = -1;
        } else {
          cpu_lidx = static_cast<int32_T>(b_m);
          nrefine = nb_cpu_w->size[0] - 1;
        }

        eint = fe_cpu_y->size[0];
        fe_cpu_y->size[0] = div_s32(nrefine, cpu_lidx) + 1;
        emxEnsureCapacity_creal32_T(fe_cpu_y, eint, &ed_emlrtRTEI);
        eint = nrefine / cpu_lidx;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(nb_cpu_w, &s_gpu_w, true);
        }

        gpuEmxEnsureCapacity_creal32_T(fe_cpu_y, &oc_gpu_y, true);
        p_y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel500<<<grid, block>>>(s_gpu_w, cpu_lidx, eint, oc_gpu_y);
        }

        if (!(div_s32(nrefine, cpu_lidx) + 1 < b_Ly)) {
          eint = fe_cpu_y->size[0];
          if (b_Ly < 1.0) {
            fe_cpu_y->size[0] = 0;
          } else {
            fe_cpu_y->size[0] = static_cast<int32_T>(b_Ly);
          }

          emxEnsureCapacity_creal32_T(fe_cpu_y, eint, &gd_emlrtRTEI);
          p_y_needsGpuEnsureCapacity = true;
        }

        if (std::isnan(halfh)) {
          eint = ne_cpu_y->size[0] * ne_cpu_y->size[1];
          ne_cpu_y->size[0] = 1;
          ne_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(ne_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(ne_cpu_y, &pc_gpu_y, true);
          j_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel501<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(pc_gpu_y);
        } else if (halfh < 1.0) {
          ne_cpu_y->size[0] = 1;
          ne_cpu_y->size[1] = 0;
        } else {
          eint = ne_cpu_y->size[0] * ne_cpu_y->size[1];
          ne_cpu_y->size[0] = 1;
          ne_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(ne_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(ne_cpu_y, &pc_gpu_y, true);
          j_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel503<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              pc_gpu_y);
          }
        }

        cpu_lidx = b_cpu_y1->size[0];
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
          2147483647U);
        if (p_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_creal32_T(fe_cpu_y, &oc_gpu_y, true);
        }

        if (j_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(ne_cpu_y, &pc_gpu_y, true);
        }

        j_y_needsGpuEnsureCapacity = false;
        if (interval_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        }

        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel502<<<grid, block>>>(oc_gpu_y, pc_gpu_y, T, b_nx,
            cpu_lidx - 1, gpu_y1, b_cpu_y1->size[0U]);
        }
      }

      emxFree_creal32_T(&b_cpu_newIm);
      emxFree_int32_T(&xb_cpu_rows);
      emxFree_int32_T(&wb_cpu_rows);
      emxFree_int32_T(&cpu_iv139);
      emxFree_int32_T(&cpu_iv138);
      emxFree_real_T(&ne_cpu_y);
      emxFree_int32_T(&le_cpu_y);
      emxFree_int32_T(&ie_cpu_y);
      emxFree_real32_T(&oc_cpu_expanded);
      emxFree_creal32_T(&lc_cpu_expanded);
      emxFree_creal32_T(&fe_cpu_y);
      emxFree_creal32_T(&nb_cpu_w);
      emxFree_creal32_T(&t_cpu_yCol);
    } else {
      emxInit_creal32_T(&b_cpu_xCol, 2, &uc_emlrtRTEI, true);
      emxInit_creal32_T(&m_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&p_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&eb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&s_cpu_yCol, 1, &se_emlrtRTEI, true);
      emxInit_creal32_T(&jb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&s_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&mb_cpu_w, 2, &ed_emlrtRTEI, true);
      emxInit_creal32_T(&n_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&x_cpu_c, 1, &ce_emlrtRTEI, true);
      emxInit_creal32_T(&q_cpu_a, 1, &fb_emlrtRTEI, true);
      emxInit_creal32_T(&gc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&hc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&kc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ge_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&he_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&rc_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&me_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&uc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&vc_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&se_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&g_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&ve_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ye_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&af_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv144, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&j_cpu_result, 1, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv149, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ff_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv152, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&bd_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ed_cpu_expanded, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv155, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&if_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&jf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_real_T(&mf_cpu_y, 2, &ue_emlrtRTEI, true);
      emxInit_int32_T(&pf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv158, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv159, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&uf_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&vf_cpu_y, 2, &ed_emlrtRTEI, true);
      emxInit_int32_T(&yb_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&hd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&id_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real_T(&dg_cpu_y, 2, &we_emlrtRTEI, true);
      emxInit_int32_T(&eg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv167, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv168, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv169, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ec_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&nd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&od_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&rd_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&ud_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&mg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ng_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&qg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv176, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&tg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv177, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&g_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&ce_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_real32_T(&fe_cpu_expanded, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv182, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ic_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&wg_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&lc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ah_cpu_y, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&oc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv189, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&j_cpu_cols, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv190, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&rc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv194, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv195, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&uc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&vc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&yc_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv202, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&fd_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&cpu_iv203, 1, &jb_emlrtRTEI, true);
      emxInit_int32_T(&id_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_int32_T(&ld_cpu_rows, 2, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&c_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&d_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&g_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&j_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&m_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&p_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&s_cpu_newIm, 1, &jb_emlrtRTEI, true);
      emxInit_creal32_T(&u_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&v_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&y_cpu_yCol, 1, &ib_emlrtRTEI, true);
      emxInit_creal32_T(&ob_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&pb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&sb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&dh_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&xb_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&bc_cpu_w, 2, &jd_emlrtRTEI, true);
      emxInit_creal32_T(&eh_cpu_y, 2, &kd_emlrtRTEI, true);
      emxInit_creal32_T(&ec_cpu_w, 2, &jd_emlrtRTEI, true);
      if ((toler == 1.0) && (b_m == 1.0)) {
        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = cpu_opts_x->size[0];
        b_cpu_y1->size[1] = cpu_opts_x->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &nc_emlrtRTEI);
        offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel521<<<grid, block>>>(gpu_opts_x, offsetH, gpu_y1);
        }
      } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
        if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
          pathlen = 0;
        } else {
          itime = cpu_opts_x->size[0];
          pathlen = cpu_opts_x->size[1];
          if (itime >= pathlen) {
            pathlen = itime;
          }
        }

        halfh = std::ceil(static_cast<real_T>(pathlen) * toler / b_m);
        if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
          if (!(toler - 1.0 >= 0.0)) {
            hc_y = nullptr;
            m69 = emlrtCreateCharArray(2, &iv126[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m69, &rfmt[0]);
            emlrtAssign(&hc_y, m69);
            pc_y = nullptr;
            m73 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&pc_y, m73);
            emlrt_marshallIn(b_sprintf(hc_y, pc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          eint = s_cpu_yCol->size[0];
          s_cpu_yCol->size[0] = static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(s_cpu_yCol, eint, &yc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(toler) -
            1), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(s_cpu_yCol, &n_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel522<<<grid, block>>>(static_cast<int32_T>(toler) - 1,
              n_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (static_cast<int32_T>(toler) < 1)) || ((
                 static_cast<int32_T>(toler) < 0) && (static_cast<int32_T>(toler)
                 > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel523<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
              (cpu_lidx - 1, nrefine), n_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] == 1)) {
            eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
            mb_cpu_w->size[0] = 1;
            mb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel524<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (n_gpu_yCol, d_gpu_h, t_gpu_w);
          } else if (d_cpu_h->size[0] > static_cast<int32_T>(toler)) {
            if (static_cast<int32_T>(toler) == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (d_cpu_h->size[0] + static_cast<int32_T>(toler)) - 1;
            }

            eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
            mb_cpu_w->size[0] = itime;
            mb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel536<<<grid, block>>>(itime - 1, t_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = itime;
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel537<<<grid, block>>>(itime - 1, t_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && (static_cast<int32_T>(toler) ==
                        1)) {
              ec_wtcc_kernel538<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel539<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = 1;
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel540<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (n_gpu_yCol, *gpu_a_data, t_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>(
                    static_cast<int32_T>(toler))) - 1.0;
              s = std::fmin(32.0, r);
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(static_cast<int32_T>(toler)) /
                             2.0) + std::floor((static_cast<real_T>(static_cast<
                int32_T>(toler)) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (static_cast<int32_T>(toler) <
                   MIN_int32_T - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (static_cast<int32_T>(toler) >
                          MAX_int32_T - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + static_cast<int32_T>(toler);
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = ed_cpu_expanded->size[0] * ed_cpu_expanded->size[1];
              ed_cpu_expanded->size[0] = nx;
              ed_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_real32_T(ed_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (x_size_idx_1 + static_cast<int32_T>(toler)) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(ed_cpu_expanded, &jb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel541<<<grid, block>>>(eint, jb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = pf_cpu_y->size[0] * pf_cpu_y->size[1];
              pf_cpu_y->size[0] = 1;
              pf_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(pf_cpu_y, eint, &kb_emlrtRTEI);
              pf_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                pf_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv167->size[0];
              cpu_iv167->size[0] = pf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv167, eint, &jb_emlrtRTEI);
              eint = pf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(pf_cpu_y, &wc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv167, &gpu_iv167, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&wc_gpu_y, pf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel542<<<grid, block>>>(offsetH, wc_gpu_y, eint,
                  gpu_iv167);
              }

              omega_tmp2[0] = cpu_iv167->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel543<<<grid, block>>>(d_gpu_h, gpu_iv167,
                  omega_tmp2[0] - 1, jb_gpu_expanded);
              }

              if (static_cast<int32_T>(toler) < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = static_cast<int32_T>(toler) - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = ic_cpu_rows->size[0] * ic_cpu_rows->size[1];
              ic_cpu_rows->size[0] = 1;
              ic_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(ic_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                ic_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  ic_cpu_rows->data[k + 1] = itime;
                }
              }

              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = x_size_idx_1;
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(0, x_size_idx_1 - 1),
                  dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_int32_T(ic_cpu_rows, &fb_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
                a_data_outdatedOnGpu = false;
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&fb_gpu_rows, ic_cpu_rows);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel544<<<grid, block>>>(jb_gpu_expanded,
                    fb_gpu_rows, n_gpu_yCol, toler, x_size_idx_1 - 1, t_gpu_w);
                }
              }
            }
          } else {
            if (static_cast<int32_T>(toler) == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (static_cast<int32_T>(toler) + d_cpu_h->size[0]) - 1;
            }

            eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
            mb_cpu_w->size[0] = itime;
            mb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel545<<<grid, block>>>(itime - 1, t_gpu_w);
            }

            if (static_cast<int32_T>(toler) == 0) {
              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = itime;
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel546<<<grid, block>>>(itime - 1, t_gpu_w);
              }
            } else if ((static_cast<int32_T>(toler) == 1) && (d_cpu_h->size[0] ==
                        1)) {
              ec_wtcc_kernel547<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel548<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = u_cpu_yCol->size[0];
              u_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(u_cpu_yCol, eint, &ib_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(u_cpu_yCol, &o_gpu_yCol, true);
              ec_wtcc_kernel549<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (n_gpu_yCol, *gpu_a_data, o_gpu_yCol);
              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = itime;
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &ed_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(itime - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel550<<<grid, block>>>(o_gpu_yCol, itime - 1,
                  t_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(static_cast<int32_T>(toler)) +
                   static_cast<uint32_T>(d_cpu_h->size[0])) - 1U;
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              eint = bd_cpu_expanded->size[0] * bd_cpu_expanded->size[1];
              bd_cpu_expanded->size[0] = nx - 1;
              bd_cpu_expanded->size[1] = 1;
              emxEnsureCapacity_creal32_T(bd_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = (static_cast<int32_T>(N) + d_cpu_h->size[0]) - 2;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(bd_cpu_expanded, &kb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel551<<<grid, block>>>(eint, kb_gpu_expanded);
              }

              n = static_cast<int32_T>(toler);
              eint = jf_cpu_y->size[0] * jf_cpu_y->size[1];
              jf_cpu_y->size[0] = 1;
              jf_cpu_y->size[1] = static_cast<int32_T>(toler);
              emxEnsureCapacity_int32_T(jf_cpu_y, eint, &kb_emlrtRTEI);
              jf_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                jf_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv169->size[0];
              cpu_iv169->size[0] = jf_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv169, eint, &jb_emlrtRTEI);
              eint = jf_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(jf_cpu_y, &xc_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv169, &gpu_iv169, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&xc_gpu_y, jf_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel552<<<grid, block>>>(offsetH, xc_gpu_y, eint,
                  gpu_iv169);
              }

              xt_size[0] = cpu_iv169->size[0];
              mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel553<<<grid, block>>>(n_gpu_yCol, gpu_iv169,
                  xt_size[0] - 1, kb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = yc_cpu_rows->size[0] * yc_cpu_rows->size[1];
              yc_cpu_rows->size[0] = 1;
              yc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(yc_cpu_rows, eint, &kb_emlrtRTEI);
              yc_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                yc_cpu_rows->data[k + 1] = itime;
              }

              eint = mb_cpu_w->size[0] * mb_cpu_w->size[1];
              mb_cpu_w->size[0] = static_cast<int32_T>(N);
              mb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(mb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                cpu_lidx = d_cpu_h->size[0];
                for (nx = 0; nx < x_size_idx_1; nx++) {
                  eint = s_cpu_newIm->size[0];
                  s_cpu_newIm->size[0] = yc_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(s_cpu_newIm, eint, &jb_emlrtRTEI);
                  eint = yc_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  if (c_omega_tmp1_needsGpuEnsureCapa) {
                    gpuEmxEnsureCapacity_int32_T(yc_cpu_rows, &gb_gpu_rows,
                      !y_needsGpuEnsureCapacity);
                  }

                  c_omega_tmp1_needsGpuEnsureCapa = false;
                  gpuEmxEnsureCapacity_creal32_T(s_cpu_newIm, &p_gpu_newIm, true);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&gb_gpu_rows, yc_cpu_rows);
                  }

                  y_needsGpuEnsureCapacity = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel554<<<grid, block>>>(kb_gpu_expanded, nx,
                      gb_gpu_rows, eint, p_gpu_newIm);
                  }

                  wav_outdatedOnCpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (n = 0; n < cpu_lidx; n++) {
                    if (wav_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(s_cpu_newIm, &p_gpu_newIm);
                    }

                    if (b_fx_data_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += s_cpu_newIm->data[n].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                    wav_outdatedOnCpu = false;
                    b_fx_data_outdatedOnCpu = false;
                    cv_im += s_cpu_newIm->data[n].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                  }

                  if (a_data_outdatedOnGpu) {
                    gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
                  }

                  a_data_outdatedOnGpu = false;
                  ec_wtcc_kernel555<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nx, t_gpu_w);
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            wc_y = nullptr;
            m90 = emlrtCreateCharArray(2, &iv137[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m90, &rfmt[0]);
            emlrtAssign(&wc_y, m90);
            xc_y = nullptr;
            m93 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&xc_y, m93);
            emlrt_marshallIn(b_sprintf(wc_y, xc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (mb_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = mb_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = mb_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel525<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          nrefine = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = nrefine;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            cpu_lidx = 1;
            pathlen = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel526<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
            pathlen, nsubs, *gpu_csz);
          eint = ob_cpu_w->size[0] * ob_cpu_w->size[1];
          ob_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          ob_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(ob_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(mb_cpu_w, &t_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(ob_cpu_w, &u_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel527<<<grid, block>>>(t_gpu_w, cpu_csz[0], cpu_lidx,
              eint, nrefine - 1, u_gpu_w, ob_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = vf_cpu_y->size[0] * vf_cpu_y->size[1];
          vf_cpu_y->size[0] = b_cpu_csz[0];
          vf_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(vf_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(vf_cpu_y, &sc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel528<<<grid, block>>>(u_gpu_w, offsetH, sc_gpu_y);
          }

          Ly = std::ceil((0.0 * toler + static_cast<real_T>(d_cpu_h->size[0])) /
                         b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              nrefine = 0;
            } else {
              nrefine = static_cast<int32_T>(Ly);
            }

            n = sb_cpu_w->size[0] * sb_cpu_w->size[1];
            sb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            sb_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_creal32_T(sb_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(sb_cpu_w, &v_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel529<<<grid, block>>>(t_gpu_w, cpu_csz[0], cpu_lidx,
                eint, cpu_csz[1] - 1, v_gpu_w, sb_cpu_w->size[0U]);
            }

            n = vf_cpu_y->size[0] * vf_cpu_y->size[1];
            vf_cpu_y->size[0] = nrefine;
            vf_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(vf_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(vf_cpu_y, &sc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel530<<<grid, block>>>(v_gpu_w, b_cpu_csz[0], nrefine
                - 1, b_cpu_csz[1] - 1, sc_gpu_y, vf_cpu_y->size[0U]);
            }
          }

          if (vf_cpu_y->size[0] * vf_cpu_y->size[1] == 0) {
            n = 0;
          } else {
            n = vf_cpu_y->size[0] * vf_cpu_y->size[1];
          }

          omega_tmp2[0] = vf_cpu_y->size[0] * vf_cpu_y->size[1];
          eint = dh_cpu_y->size[0] * dh_cpu_y->size[1];
          dh_cpu_y->size[0] = 1;
          dh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(dh_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(dh_cpu_y, &tc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel531<<<grid, block>>>(sc_gpu_y, omega_tmp2[0] - 1,
              tc_gpu_y);
          }

          eint = ye_cpu_y->size[0] * ye_cpu_y->size[1];
          ye_cpu_y->size[0] = n;
          ye_cpu_y->size[1] = 1;
          emxEnsureCapacity_creal32_T(ye_cpu_y, eint, &ld_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(n - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &uc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel532<<<grid, block>>>(tc_gpu_y, n - 1, uc_gpu_y);
          }
        } else {
          if (!(toler - 1.0 >= 0.0)) {
            gc_y = nullptr;
            m57 = emlrtCreateCharArray(2, &iv121[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m57, &rfmt[0]);
            emlrtAssign(&gc_y, m57);
            oc_y = nullptr;
            m66 = emlrtCreateDoubleScalar(toler - 1.0);
            emlrtAssign(&oc_y, m66);
            emlrt_marshallIn(b_sprintf(gc_y, oc_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = cpu_opts_x->size[itime];
          }

          nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          eint = m_cpu_yCol->size[0];
          m_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
          emxEnsureCapacity_creal32_T(m_cpu_yCol, eint, &yc_emlrtRTEI);
          eint = nx * static_cast<int32_T>(toler) - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(m_cpu_yCol, &p_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel556<<<grid, block>>>(eint, p_gpu_yCol);
          }

          if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>
                 (toler) > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) ||
               ((static_cast<int32_T>(toler) < 0) && (nrefine *
                 static_cast<int32_T>(toler) > 1)))) {
            nrefine = 1;
            cpu_lidx = 0;
          } else {
            nrefine = static_cast<int32_T>(toler);
            cpu_lidx = nx * static_cast<int32_T>(toler);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel557<<<grid, block>>>(gpu_opts_x, nrefine, div_s32
              (cpu_lidx - 1, nrefine), p_gpu_yCol);
          }

          b_cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(toler);
          if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
            if (cpu_opts_x->size[1] < 1) {
              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = 1;
              eb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel558<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(w_gpu_w);
            } else {
              eint = cpu_opts_x->size[1];
              n = n_cpu_a->size[0];
              n_cpu_a->size[0] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(n_cpu_a, n, &fb_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(n_cpu_a, &l_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel565<<<grid, block>>>(p_gpu_yCol, eint - 1, l_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
              cpu_cv_re = d_cpu_h->data[0];
              eint = s_cpu_c->size[0];
              s_cpu_c->size[0] = n_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(s_cpu_c, eint, &hb_emlrtRTEI);
              eint = n_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(s_cpu_c, &h_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel566<<<grid, block>>>(eint, h_gpu_c);
              }

              if (n_cpu_a->size[0] == 1) {
                cpu_cv_re = d_cpu_h->data[0];
                eint = s_cpu_c->size[0];
                s_cpu_c->size[0] = 1;
                emxEnsureCapacity_creal32_T(s_cpu_c, eint, &hb_emlrtRTEI);
                ec_wtcc_kernel567<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (l_gpu_a, cpu_cv_re, gpu_f, gpu_f1);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_c, &h_gpu_c, true);
                ec_wtcc_kernel568<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (gpu_f1, gpu_f, h_gpu_c);
              } else {
                itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (n_cpu_a->size[0]) + 1.0) - 1.0));
                b_blockDims[0] = static_cast<int32_T>(std::floor
                  (static_cast<real_T>((static_cast<uint32_T>(n_cpu_a->size[0])
                  + static_cast<uint32_T>(itime)) - 1U) / static_cast<real_T>
                   (itime)));
                threadDims[0] = static_cast<int8_T>(itime);
                x_size_idx_1 = n_cpu_a->size[0];
                if (n_cpu_a->size[0] > 2147483646) {
                  nx = MAX_int32_T;
                } else {
                  nx = n_cpu_a->size[0] + 1;
                }

                eint = gc_cpu_expanded->size[0];
                gc_cpu_expanded->size[0] = nx - 1;
                emxEnsureCapacity_creal32_T(gc_cpu_expanded, eint, &jb_emlrtRTEI);
                eint = n_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_creal32_T(gc_cpu_expanded, &lb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel570<<<grid, block>>>(eint, lb_gpu_expanded);
                }

                n = n_cpu_a->size[0];
                eint = ge_cpu_y->size[0] * ge_cpu_y->size[1];
                ge_cpu_y->size[0] = 1;
                ge_cpu_y->size[1] = n_cpu_a->size[0];
                emxEnsureCapacity_int32_T(ge_cpu_y, eint, &kb_emlrtRTEI);
                ge_cpu_y->data[0] = 1;
                itime = 1;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  ge_cpu_y->data[k + 1] = itime;
                }

                eint = cpu_iv144->size[0];
                cpu_iv144->size[0] = ge_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv144, eint, &jb_emlrtRTEI);
                eint = ge_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ge_cpu_y, &yc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv144, &gpu_iv144, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&yc_gpu_y, ge_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel571<<<grid, block>>>(yc_gpu_y, eint, gpu_iv144);
                }

                omega_tmp2[0] = cpu_iv144->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel572<<<grid, block>>>(l_gpu_a, gpu_iv144,
                    omega_tmp2[0] - 1, lb_gpu_expanded);
                }

                eint = s_cpu_c->size[0];
                s_cpu_c->size[0] = n_cpu_a->size[0];
                emxEnsureCapacity_creal32_T(s_cpu_c, eint, &jb_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                  static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
                gpuEmxEnsureCapacity_creal32_T(s_cpu_c, &h_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel573<<<grid, block>>>(lb_gpu_expanded, cpu_cv_re,
                    x_size_idx_1 - 1, h_gpu_c);
                }
              }

              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = 1;
              eb_cpu_w->size[1] = s_cpu_c->size[0];
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = s_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel569<<<grid, block>>>(h_gpu_c, offsetH, w_gpu_w,
                  eb_cpu_w->size[0U]);
              }
            }
          } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = cpu_opts_x->size[1];
            }

            eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
            eb_cpu_w->size[0] = itime;
            eb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel574<<<grid, block>>>(eint, w_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = itime;
              eb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel575<<<grid, block>>>(eint, w_gpu_w);
              }
            } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                        (cpu_opts_x->size[1] == 1))) {
              ec_wtcc_kernel576<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel577<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = 1;
              eb_cpu_w->size[1] = 1;
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              ec_wtcc_kernel578<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (p_gpu_yCol, *gpu_a_data, w_gpu_w);
            } else {
              r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                   (b_cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, r);
              cpu_lidx = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
              c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
              c_blockDims[1] = std::floor(static_cast<real_T>
                ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                  static_cast<uint32_T>(cpu_lidx)) - 1U) / static_cast<real_T>
                (cpu_lidx));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              b_blockDims[0] = eint;
              b_blockDims[1] = cpu_lidx;
              ix = cpu_opts_x->size[1];
              if (r < 2.147483648E+9) {
                if (r >= -2.147483648E+9) {
                  x_size_idx_1 = static_cast<int32_T>(r);
                } else {
                  x_size_idx_1 = MIN_int32_T;
                }
              } else {
                x_size_idx_1 = MAX_int32_T;
              }

              s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
              if (s >= -2.147483648E+9) {
                offsetH = static_cast<int32_T>(s);
              } else {
                offsetH = MIN_int32_T;
              }

              if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T
                   - x_size_idx_1)) {
                nx = MIN_int32_T;
              } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                          - x_size_idx_1)) {
                nx = MAX_int32_T;
              } else {
                nx = x_size_idx_1 + b_cpu_csz[0];
              }

              if (nx >= -2147483647) {
                nx--;
              }

              eint = kc_cpu_expanded->size[0] * kc_cpu_expanded->size[1];
              kc_cpu_expanded->size[0] = nx;
              emxEnsureCapacity_real32_T(kc_cpu_expanded, eint, &jb_emlrtRTEI);
              if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                nx = MAX_int32_T;
              } else {
                nx = cpu_opts_x->size[1] + cpu_opts_x->size[1];
              }

              eint = kc_cpu_expanded->size[0] * kc_cpu_expanded->size[1];
              kc_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_real32_T(kc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((cpu_opts_x->size[1]
                + cpu_opts_x->size[1]) - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real32_T(kc_cpu_expanded, &mb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel579<<<grid, block>>>(eint, mb_gpu_expanded);
              }

              n = d_cpu_h->size[0];
              eint = me_cpu_y->size[0] * me_cpu_y->size[1];
              me_cpu_y->size[0] = 1;
              me_cpu_y->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(me_cpu_y, eint, &kb_emlrtRTEI);
              me_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                me_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv149->size[0];
              cpu_iv149->size[0] = me_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv149, eint, &jb_emlrtRTEI);
              eint = me_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(me_cpu_y, &ad_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv149, &gpu_iv149, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ad_gpu_y, me_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel580<<<grid, block>>>(offsetH, ad_gpu_y, eint,
                  gpu_iv149);
              }

              cpu_lidx = static_cast<int32_T>(std::floor(static_cast<real_T>
                (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::floor
                ((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
              omega_tmp2[0] = cpu_iv149->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel581<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv149,
                  omega_tmp2[0] - 1, mb_gpu_expanded, kc_cpu_expanded->size[0U]);
              }

              if (b_cpu_csz[0] < -2147483647) {
                nx = MIN_int32_T;
              } else {
                nx = b_cpu_csz[0] - 1;
              }

              if (nx < 0) {
                n = 0;
              } else {
                n = nx + 1;
              }

              y_needsGpuEnsureCapacity = false;
              eint = yb_cpu_rows->size[0] * yb_cpu_rows->size[1];
              yb_cpu_rows->size[0] = 1;
              yb_cpu_rows->size[1] = n;
              emxEnsureCapacity_int32_T(yb_cpu_rows, eint, &kb_emlrtRTEI);
              if (n > 0) {
                yb_cpu_rows->data[0] = 0;
                y_needsGpuEnsureCapacity = true;
                itime = 0;
                for (k = 0; k <= n - 2; k++) {
                  itime++;
                  yb_cpu_rows->data[k + 1] = itime;
                }
              }

              n = cpu_opts_x->size[1];
              eint = g_cpu_cols->size[0] * g_cpu_cols->size[1];
              g_cpu_cols->size[0] = 1;
              g_cpu_cols->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(g_cpu_cols, eint, &kb_emlrtRTEI);
              g_cpu_cols->data[0] = 0;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                g_cpu_cols->data[k + 1] = itime;
              }

              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = x_size_idx_1;
              eb_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (x_size_idx_1 != 0) {
                if (c_blockDims[0] < 4.294967296E+9) {
                  if (c_blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(c_blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (c_blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                eint = b_blockDims[0];
                if (b_blockDims[0] < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                  dim3(N, static_cast<uint32_T>(c_blockDims[1]), 1U), dim3(
                  static_cast<uint32_T>(eint), static_cast<uint32_T>
                  (b_blockDims[1]), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(g_cpu_cols, &e_gpu_cols, false);
                gpuEmxEnsureCapacity_int32_T(yb_cpu_rows, &hb_gpu_rows,
                  !y_needsGpuEnsureCapacity);
                gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
                a_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&e_gpu_cols, g_cpu_cols);
                if (y_needsGpuEnsureCapacity) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&hb_gpu_rows, yb_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_wtcc_kernel582<<<grid, block>>>(mb_gpu_expanded, e_gpu_cols,
                    hb_gpu_rows, p_gpu_yCol, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                    w_gpu_w, kc_cpu_expanded->size[0U], eb_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (b_cpu_csz[0] == 0) {
              itime = d_cpu_h->size[0];
            } else {
              itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
            }

            if (cpu_opts_x->size[1] == 0) {
              nrefine = 1;
            } else {
              nrefine = cpu_opts_x->size[1];
            }

            eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
            eb_cpu_w->size[0] = itime;
            eb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel583<<<grid, block>>>(eint, w_gpu_w);
            }

            if ((b_cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = itime;
              eb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              eint = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel584<<<grid, block>>>(eint, w_gpu_w);
              }
            } else if ((b_cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                       (d_cpu_h->size[0] == 1)) {
              ec_wtcc_kernel585<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
                gpu_f1);
              ec_wtcc_kernel586<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                *gpu_a_data);
              eint = v_cpu_yCol->size[0];
              v_cpu_yCol->size[0] = 1;
              emxEnsureCapacity_creal32_T(v_cpu_yCol, eint, &ib_emlrtRTEI);
              gpuEmxEnsureCapacity_creal32_T(v_cpu_yCol, &q_gpu_yCol, true);
              ec_wtcc_kernel587<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (p_gpu_yCol, *gpu_a_data, q_gpu_yCol);
              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = itime;
              eb_cpu_w->size[1] = nrefine;
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &ed_emlrtRTEI);
              offsetH = itime * nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
              a_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel588<<<grid, block>>>(q_gpu_yCol, offsetH, w_gpu_w);
              }
            } else {
              N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                   (d_cpu_h->size[0])) - 1U;
              ix = cpu_opts_x->size[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              x_size_idx_1 = static_cast<int32_T>(N);
              offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
                (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                nx = MAX_int32_T;
              } else {
                nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
              }

              eint = hc_cpu_expanded->size[0] * hc_cpu_expanded->size[1];
              hc_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_creal32_T(hc_cpu_expanded, eint, &jb_emlrtRTEI);
              if (cpu_opts_x->size[1] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = cpu_opts_x->size[1] + 1;
              }

              eint = hc_cpu_expanded->size[0] * hc_cpu_expanded->size[1];
              hc_cpu_expanded->size[1] = nx - 1;
              emxEnsureCapacity_creal32_T(hc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
                cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(hc_cpu_expanded, &nb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel589<<<grid, block>>>(eint, nb_gpu_expanded);
              }

              n = b_cpu_csz[0];
              eint = he_cpu_y->size[0] * he_cpu_y->size[1];
              he_cpu_y->size[0] = 1;
              he_cpu_y->size[1] = b_cpu_csz[0];
              emxEnsureCapacity_int32_T(he_cpu_y, eint, &kb_emlrtRTEI);
              he_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                he_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv152->size[0];
              cpu_iv152->size[0] = he_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv152, eint, &jb_emlrtRTEI);
              eint = he_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(he_cpu_y, &bd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv152, &gpu_iv152, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&bd_gpu_y, he_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel590<<<grid, block>>>(offsetH, bd_gpu_y, eint,
                  gpu_iv152);
              }

              n = cpu_opts_x->size[1];
              eint = if_cpu_y->size[0] * if_cpu_y->size[1];
              if_cpu_y->size[0] = 1;
              if_cpu_y->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_int32_T(if_cpu_y, eint, &kb_emlrtRTEI);
              if_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                if_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv168->size[0];
              cpu_iv168->size[0] = if_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv168, eint, &jb_emlrtRTEI);
              eint = if_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(if_cpu_y, &cd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv168, &gpu_iv168, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&cd_gpu_y, if_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel591<<<grid, block>>>(cd_gpu_y, eint, gpu_iv168);
              }

              xt_size[0] = cpu_iv152->size[0];
              xt_size[1] = cpu_iv168->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel592<<<grid, block>>>(p_gpu_yCol, xt_size[0],
                  gpu_iv168, gpu_iv152, xt_size[0] - 1, xt_size[1] - 1,
                  nb_gpu_expanded, hc_cpu_expanded->size[0U]);
              }

              n = d_cpu_h->size[0];
              eint = fc_cpu_rows->size[0] * fc_cpu_rows->size[1];
              fc_cpu_rows->size[0] = 1;
              fc_cpu_rows->size[1] = d_cpu_h->size[0];
              emxEnsureCapacity_int32_T(fc_cpu_rows, eint, &kb_emlrtRTEI);
              fc_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              c_omega_tmp1_needsGpuEnsureCapa = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                fc_cpu_rows->data[k + 1] = itime;
              }

              eint = eb_cpu_w->size[0] * eb_cpu_w->size[1];
              eb_cpu_w->size[0] = static_cast<int32_T>(N);
              eb_cpu_w->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_creal32_T(eb_cpu_w, eint, &jb_emlrtRTEI);
              a_data_outdatedOnGpu = true;
              if (static_cast<int32_T>(N) != 0) {
                for (nrefine = 0; nrefine < ix; nrefine++) {
                  cpu_lidx = d_cpu_h->size[0];
                  for (nx = 0; nx < x_size_idx_1; nx++) {
                    eint = c_cpu_newIm->size[0];
                    c_cpu_newIm->size[0] = fc_cpu_rows->size[1];
                    emxEnsureCapacity_creal32_T(c_cpu_newIm, eint, &jb_emlrtRTEI);
                    eint = fc_cpu_rows->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                      2147483647U);
                    if (c_omega_tmp1_needsGpuEnsureCapa) {
                      gpuEmxEnsureCapacity_int32_T(fc_cpu_rows, &ib_gpu_rows,
                        !y_needsGpuEnsureCapacity);
                    }

                    c_omega_tmp1_needsGpuEnsureCapa = false;
                    gpuEmxEnsureCapacity_creal32_T(c_cpu_newIm, &q_gpu_newIm,
                      true);
                    if (y_needsGpuEnsureCapacity) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&ib_gpu_rows, fc_cpu_rows);
                    }

                    y_needsGpuEnsureCapacity = false;
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_wtcc_kernel593<<<grid, block>>>(nrefine,
                        nb_gpu_expanded, nx, ib_gpu_rows, eint, q_gpu_newIm,
                        hc_cpu_expanded->size[0U]);
                    }

                    wav_outdatedOnCpu = true;
                    cpu_cv_re = 0.0F;
                    cv_im = 0.0F;
                    for (n = 0; n < cpu_lidx; n++) {
                      if (wav_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_creal32_T(c_cpu_newIm, &q_gpu_newIm);
                      }

                      if (b_fx_data_outdatedOnCpu) {
                        gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                      }

                      cpu_cv_re += c_cpu_newIm->data[n].re * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                      wav_outdatedOnCpu = false;
                      b_fx_data_outdatedOnCpu = false;
                      cv_im += c_cpu_newIm->data[n].im * d_cpu_h->data
                        [(d_cpu_h->size[0] - n) - 1];
                    }

                    if (a_data_outdatedOnGpu) {
                      gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
                    }

                    a_data_outdatedOnGpu = false;
                    ec_wtcc_kernel594<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cv_im, cpu_cv_re, nrefine, nx, w_gpu_w, eb_cpu_w->size[0U]);
                  }
                }
              }
            }
          }

          if (!(b_m - 1.0 >= 0.0)) {
            yc_y = nullptr;
            m76 = emlrtCreateCharArray(2, &iv130[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m76, &rfmt[0]);
            emlrtAssign(&yc_y, m76);
            gd_y = nullptr;
            m83 = emlrtCreateDoubleScalar(b_m - 1.0);
            emlrtAssign(&gd_y, m83);
            emlrt_marshallIn(b_sprintf(yc_y, gd_y, &emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          nsubs = 2;
          if (eb_cpu_w->size[0] != 1) {
            nsubs = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            b_cpu_csz[itime] = eb_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_csz[itime] = eb_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - nsubs >= 0) {
            cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (nsubs))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel559<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
                *b_gpu_csz);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          nrefine = cpu_csz[0];
          cpu_csz[0] = cpu_csz[1];
          cpu_csz[1] = nrefine;
          if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
            cpu_lidx = 1;
            pathlen = -1;
          } else {
            cpu_lidx = static_cast<int32_T>(b_m);
            pathlen = cpu_csz[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_wtcc_kernel560<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
            pathlen, nsubs, *gpu_csz);
          eint = pb_cpu_w->size[0] * pb_cpu_w->size[1];
          pb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          pb_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(pb_cpu_w, eint, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
            &block, 2147483647U);
          if (a_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_creal32_T(eb_cpu_w, &w_gpu_w, true);
          }

          gpuEmxEnsureCapacity_creal32_T(pb_cpu_w, &x_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel561<<<grid, block>>>(w_gpu_w, cpu_csz[0], cpu_lidx,
              eint, nrefine - 1, x_gpu_w, pb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = ye_cpu_y->size[0] * ye_cpu_y->size[1];
          ye_cpu_y->size[0] = b_cpu_csz[0];
          ye_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(ye_cpu_y, eint, &ed_emlrtRTEI);
          offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &uc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel562<<<grid, block>>>(x_gpu_w, offsetH, uc_gpu_y);
          }

          Ly = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0) *
                          toler + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
          if (!(b_cpu_csz[0] < Ly)) {
            if (Ly < 1.0) {
              nrefine = 0;
            } else {
              nrefine = static_cast<int32_T>(Ly);
            }

            n = xb_cpu_w->size[0] * xb_cpu_w->size[1];
            xb_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
            xb_cpu_w->size[1] = cpu_csz[1];
            emxEnsureCapacity_creal32_T(xb_cpu_w, n, &jd_emlrtRTEI);
            eint = pathlen / cpu_lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(xb_cpu_w, &y_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel563<<<grid, block>>>(w_gpu_w, cpu_csz[0], cpu_lidx,
                eint, cpu_csz[1] - 1, y_gpu_w, xb_cpu_w->size[0U]);
            }

            n = ye_cpu_y->size[0] * ye_cpu_y->size[1];
            ye_cpu_y->size[0] = nrefine;
            ye_cpu_y->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(ye_cpu_y, n, &gd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine -
              1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(ye_cpu_y, &uc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel564<<<grid, block>>>(y_gpu_w, b_cpu_csz[0], nrefine
                - 1, b_cpu_csz[1] - 1, uc_gpu_y, ye_cpu_y->size[0U]);
            }
          }
        }

        if (std::isnan(halfh)) {
          eint = mf_cpu_y->size[0] * mf_cpu_y->size[1];
          mf_cpu_y->size[0] = 1;
          mf_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(mf_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(mf_cpu_y, &vc_gpu_y, true);
          k_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel533<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(vc_gpu_y);
        } else if (halfh < 1.0) {
          mf_cpu_y->size[0] = 1;
          mf_cpu_y->size[1] = 0;
        } else {
          eint = mf_cpu_y->size[0] * mf_cpu_y->size[1];
          mf_cpu_y->size[0] = 1;
          mf_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
          emxEnsureCapacity_real_T(mf_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh -
            1.0)), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(mf_cpu_y, &vc_gpu_y, true);
          k_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel535<<<grid, block>>>(static_cast<int32_T>(halfh - 1.0),
              vc_gpu_y);
          }
        }

        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = static_cast<int32_T>(halfh);
        b_cpu_y1->size[1] = 1;
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &nc_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh) - 1),
          &grid, &block, 2147483647U);
        if (k_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(mf_cpu_y, &vc_gpu_y, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel534<<<grid, block>>>(uc_gpu_y, vc_gpu_y, T, static_cast<
            int32_T>(halfh) - 1, gpu_y1);
        }
      } else {
        tol = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * toler / b_m);
        first_iteration = (cpu_opts_x->size[0] == 1);
        if (first_iteration) {
          eint = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
          b_cpu_xCol->size[0] = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          b_cpu_xCol->size[1] = 1;
          emxEnsureCapacity_creal32_T(b_cpu_xCol, eint, &uc_emlrtRTEI);
          offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(b_cpu_xCol, &gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel625<<<grid, block>>>(gpu_opts_x, offsetH, gpu_xCol);
          }
        } else {
          eint = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
          b_cpu_xCol->size[0] = cpu_opts_x->size[0];
          b_cpu_xCol->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_creal32_T(b_cpu_xCol, eint, &tc_emlrtRTEI);
          offsetH = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(b_cpu_xCol, &gpu_xCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel700<<<grid, block>>>(gpu_opts_x, offsetH, gpu_xCol);
          }
        }

        if (!(toler - 1.0 >= 0.0)) {
          qc_y = nullptr;
          m59 = emlrtCreateCharArray(2, &iv123[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m59, &rfmt[0]);
          emlrtAssign(&qc_y, m59);
          vc_y = nullptr;
          m68 = emlrtCreateDoubleScalar(toler - 1.0);
          emlrtAssign(&vc_y, m68);
          emlrt_marshallIn(b_sprintf(qc_y, vc_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nx = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
        if ((b_cpu_xCol->size[0] == 1) && (b_cpu_xCol->size[1] == 1)) {
          nsubs = 0;
        } else {
          nsubs = 1;
          if (b_cpu_xCol->size[0] != 1) {
            nsubs = 0;
          }
        }

        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = b_cpu_xCol->size[itime];
        }

        nrefine = b_cpu_xCol->size[0] * b_cpu_xCol->size[1];
        eint = p_cpu_yCol->size[0];
        p_cpu_yCol->size[0] = nx * static_cast<int32_T>(toler);
        emxEnsureCapacity_creal32_T(p_cpu_yCol, eint, &yc_emlrtRTEI);
        eint = nx * static_cast<int32_T>(toler) - 1;
        mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(p_cpu_yCol, &r_gpu_yCol, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel626<<<grid, block>>>(eint, r_gpu_yCol);
        }

        if ((static_cast<int32_T>(toler) == 0) || (((static_cast<int32_T>(toler)
               > 0) && (nrefine * static_cast<int32_T>(toler) < 1)) || ((
               static_cast<int32_T>(toler) < 0) && (nrefine * static_cast<
               int32_T>(toler) > 1)))) {
          nrefine = 1;
          cpu_lidx = 0;
        } else {
          nrefine = static_cast<int32_T>(toler);
          cpu_lidx = nx * static_cast<int32_T>(toler);
        }

        mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_lidx - 1, nrefine)),
          &grid, &block, 2147483647U);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel627<<<grid, block>>>(gpu_xCol, nrefine, div_s32(cpu_lidx
            - 1, nrefine), r_gpu_yCol);
        }

        b_cpu_csz[nsubs] = b_cpu_xCol->size[nsubs] * static_cast<int32_T>(toler);
        if ((b_cpu_csz[0] == 1) && (d_cpu_h->size[0] == 1)) {
          if (b_cpu_csz[1] < 1) {
            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = 1;
            jb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel628<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ab_gpu_w);
          } else {
            n = q_cpu_a->size[0];
            q_cpu_a->size[0] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(q_cpu_a, n, &fb_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_creal32_T(q_cpu_a, &m_gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel640<<<grid, block>>>(r_gpu_yCol, b_cpu_csz[1] - 1,
                m_gpu_a);
            }

            gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
            cpu_cv_re = d_cpu_h->data[0];
            eint = x_cpu_c->size[0];
            x_cpu_c->size[0] = q_cpu_a->size[0];
            emxEnsureCapacity_creal32_T(x_cpu_c, eint, &hb_emlrtRTEI);
            eint = q_cpu_a->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &i_gpu_c, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel641<<<grid, block>>>(eint, i_gpu_c);
            }

            if (q_cpu_a->size[0] == 1) {
              cpu_cv_re = d_cpu_h->data[0];
              eint = x_cpu_c->size[0];
              x_cpu_c->size[0] = 1;
              emxEnsureCapacity_creal32_T(x_cpu_c, eint, &hb_emlrtRTEI);
              ec_wtcc_kernel642<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(m_gpu_a,
                cpu_cv_re, gpu_f, gpu_f1);
              gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &i_gpu_c, true);
              ec_wtcc_kernel643<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
                gpu_f, i_gpu_c);
            } else {
              itime = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                (q_cpu_a->size[0]) + 1.0) - 1.0));
              b_blockDims[0] = static_cast<int32_T>(std::floor
                ((static_cast<real_T>(static_cast<uint32_T>(q_cpu_a->size[0]) +
                static_cast<uint32_T>(itime)) - 1.0) / static_cast<real_T>(itime)));
              threadDims[0] = static_cast<int8_T>(itime);
              x_size_idx_1 = q_cpu_a->size[0];
              if (q_cpu_a->size[0] > 2147483646) {
                nx = MAX_int32_T;
              } else {
                nx = q_cpu_a->size[0] + 1;
              }

              eint = rc_cpu_expanded->size[0];
              rc_cpu_expanded->size[0] = nx - 1;
              emxEnsureCapacity_creal32_T(rc_cpu_expanded, eint, &jb_emlrtRTEI);
              eint = q_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_creal32_T(rc_cpu_expanded, &sb_gpu_expanded,
                true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel645<<<grid, block>>>(eint, sb_gpu_expanded);
              }

              n = q_cpu_a->size[0];
              eint = se_cpu_y->size[0] * se_cpu_y->size[1];
              se_cpu_y->size[0] = 1;
              se_cpu_y->size[1] = q_cpu_a->size[0];
              emxEnsureCapacity_int32_T(se_cpu_y, eint, &kb_emlrtRTEI);
              se_cpu_y->data[0] = 1;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                se_cpu_y->data[k + 1] = itime;
              }

              eint = cpu_iv155->size[0];
              cpu_iv155->size[0] = se_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv155, eint, &jb_emlrtRTEI);
              eint = se_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(se_cpu_y, &kd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv155, &gpu_iv155, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&kd_gpu_y, se_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel646<<<grid, block>>>(kd_gpu_y, eint, gpu_iv155);
              }

              omega_tmp2[0] = cpu_iv155->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel647<<<grid, block>>>(m_gpu_a, gpu_iv155,
                  omega_tmp2[0] - 1, sb_gpu_expanded);
              }

              eint = x_cpu_c->size[0];
              x_cpu_c->size[0] = q_cpu_a->size[0];
              emxEnsureCapacity_creal32_T(x_cpu_c, eint, &jb_emlrtRTEI);
              mwApplyLaunchParameters(computeNumIters(x_size_idx_1 - 1), dim3(
                static_cast<uint32_T>(b_blockDims[0]), 1U, 1U), dim3(
                static_cast<uint32_T>(threadDims[0]), 1U, 1U), &grid, &block);
              gpuEmxEnsureCapacity_creal32_T(x_cpu_c, &i_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel648<<<grid, block>>>(sb_gpu_expanded, cpu_cv_re,
                  x_size_idx_1 - 1, i_gpu_c);
              }
            }

            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = 1;
            jb_cpu_w->size[1] = x_cpu_c->size[0];
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = x_cpu_c->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel644<<<grid, block>>>(i_gpu_c, offsetH, ab_gpu_w,
                jb_cpu_w->size[0U]);
            }
          }
        } else if (d_cpu_h->size[0] > b_cpu_csz[0]) {
          if (b_cpu_csz[0] == 0) {
            itime = d_cpu_h->size[0];
          } else {
            itime = (d_cpu_h->size[0] + b_cpu_csz[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
          jb_cpu_w->size[0] = itime;
          jb_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel649<<<grid, block>>>(eint, ab_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = itime;
            jb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel650<<<grid, block>>>(eint, ab_gpu_w);
            }
          } else if ((d_cpu_h->size[0] == 1) && ((b_cpu_csz[0] == 1) &&
                      (b_cpu_csz[1] == 1))) {
            ec_wtcc_kernel651<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f1);
            ec_wtcc_kernel652<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
              *gpu_a_data);
            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = 1;
            jb_cpu_w->size[1] = 1;
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            ec_wtcc_kernel653<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (r_gpu_yCol, *gpu_a_data, ab_gpu_w);
          } else {
            r = (static_cast<real_T>(d_cpu_h->size[0]) + static_cast<real_T>
                 (b_cpu_csz[0])) - 1.0;
            s = std::fmin(32.0, r);
            cpu_lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
              (b_cpu_csz[1]) + 1.0) - 1.0));
            c_blockDims[0] = std::floor((r + (s - 1.0)) / s);
            c_blockDims[1] = std::floor((((static_cast<real_T>(b_cpu_csz[1]) +
              1.0) - 1.0) + (static_cast<real_T>(cpu_lidx) - 1.0)) /
              static_cast<real_T>(cpu_lidx));
            if (s >= -2.147483648E+9) {
              eint = static_cast<int32_T>(s);
            } else {
              eint = MIN_int32_T;
            }

            b_blockDims[0] = eint;
            b_blockDims[1] = cpu_lidx;
            ix = b_cpu_csz[1];
            if (r < 2.147483648E+9) {
              if (r >= -2.147483648E+9) {
                x_size_idx_1 = static_cast<int32_T>(r);
              } else {
                x_size_idx_1 = MIN_int32_T;
              }
            } else {
              x_size_idx_1 = MAX_int32_T;
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[0]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[0]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              offsetH = static_cast<int32_T>(s);
            } else {
              offsetH = MIN_int32_T;
            }

            if ((x_size_idx_1 < 0) && (b_cpu_csz[0] < MIN_int32_T - x_size_idx_1))
            {
              nx = MIN_int32_T;
            } else if ((x_size_idx_1 > 0) && (b_cpu_csz[0] > MAX_int32_T
                        - x_size_idx_1)) {
              nx = MAX_int32_T;
            } else {
              nx = x_size_idx_1 + b_cpu_csz[0];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = vc_cpu_expanded->size[0] * vc_cpu_expanded->size[1];
            vc_cpu_expanded->size[0] = nx;
            emxEnsureCapacity_real32_T(vc_cpu_expanded, eint, &jb_emlrtRTEI);
            if ((b_cpu_csz[1] < 0) && (b_cpu_csz[1] < MIN_int32_T - b_cpu_csz[1]))
            {
              nx = MIN_int32_T;
            } else if ((b_cpu_csz[1] > 0) && (b_cpu_csz[1] > MAX_int32_T
                        - b_cpu_csz[1])) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + b_cpu_csz[1];
            }

            if (nx >= -2147483647) {
              nx--;
            }

            eint = vc_cpu_expanded->size[0] * vc_cpu_expanded->size[1];
            vc_cpu_expanded->size[1] = nx;
            emxEnsureCapacity_real32_T(vc_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((x_size_idx_1 + b_cpu_csz[0]) - 1) * ((b_cpu_csz[1] +
              b_cpu_csz[1]) - 1) - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real32_T(vc_cpu_expanded, &tb_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel654<<<grid, block>>>(eint, tb_gpu_expanded);
            }

            n = d_cpu_h->size[0];
            eint = af_cpu_y->size[0] * af_cpu_y->size[1];
            af_cpu_y->size[0] = 1;
            af_cpu_y->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(af_cpu_y, eint, &kb_emlrtRTEI);
            af_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              af_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv158->size[0];
            cpu_iv158->size[0] = af_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv158, eint, &jb_emlrtRTEI);
            eint = af_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(af_cpu_y, &ld_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv158, &gpu_iv158, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&ld_gpu_y, af_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel655<<<grid, block>>>(offsetH, ld_gpu_y, eint,
                gpu_iv158);
            }

            s = std::floor(static_cast<real_T>(b_cpu_csz[1]) / 2.0) + std::floor
              ((static_cast<real_T>(b_cpu_csz[1]) - 1.0) / 2.0);
            if (s >= -2.147483648E+9) {
              cpu_lidx = static_cast<int32_T>(s);
            } else {
              cpu_lidx = MIN_int32_T;
            }

            omega_tmp2[0] = cpu_iv158->size[0];
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel656<<<grid, block>>>(d_gpu_h, cpu_lidx, gpu_iv158,
                omega_tmp2[0] - 1, tb_gpu_expanded, vc_cpu_expanded->size[0U]);
            }

            if (b_cpu_csz[0] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[0] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            y_needsGpuEnsureCapacity = false;
            eint = ec_cpu_rows->size[0] * ec_cpu_rows->size[1];
            ec_cpu_rows->size[0] = 1;
            ec_cpu_rows->size[1] = n;
            emxEnsureCapacity_int32_T(ec_cpu_rows, eint, &kb_emlrtRTEI);
            if (n > 0) {
              ec_cpu_rows->data[0] = 0;
              y_needsGpuEnsureCapacity = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                ec_cpu_rows->data[k + 1] = itime;
              }
            }

            if (b_cpu_csz[1] < -2147483647) {
              nx = MIN_int32_T;
            } else {
              nx = b_cpu_csz[1] - 1;
            }

            if (nx < 0) {
              n = 0;
            } else {
              n = nx + 1;
            }

            interval_outdatedOnGpu = false;
            eint = j_cpu_cols->size[0] * j_cpu_cols->size[1];
            j_cpu_cols->size[0] = 1;
            j_cpu_cols->size[1] = n;
            emxEnsureCapacity_int32_T(j_cpu_cols, eint, &kb_emlrtRTEI);
            if (n > 0) {
              j_cpu_cols->data[0] = 0;
              interval_outdatedOnGpu = true;
              itime = 0;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                j_cpu_cols->data[k + 1] = itime;
              }
            }

            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = x_size_idx_1;
            jb_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((x_size_idx_1 != 0) && (b_cpu_csz[1] != 0)) {
              if (c_blockDims[0] < 4.294967296E+9) {
                if (c_blockDims[0] >= 0.0) {
                  N = static_cast<uint32_T>(c_blockDims[0]);
                } else {
                  N = 0U;
                }
              } else if (c_blockDims[0] >= 4.294967296E+9) {
                N = MAX_uint32_T;
              } else {
                N = 0U;
              }

              if (c_blockDims[1] < 4.294967296E+9) {
                if (c_blockDims[1] >= 0.0) {
                  b_u = static_cast<uint32_T>(c_blockDims[1]);
                } else {
                  b_u = 0U;
                }
              } else if (c_blockDims[1] >= 4.294967296E+9) {
                b_u = MAX_uint32_T;
              } else {
                b_u = 0U;
              }

              eint = b_blockDims[0];
              if (b_blockDims[0] < 0) {
                eint = 0;
              }

              n = b_blockDims[1];
              if (b_blockDims[1] < 0) {
                n = 0;
              }

              mwApplyLaunchParameters(computeNumIters(ix - 1, x_size_idx_1 - 1),
                dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                static_cast<uint32_T>(n), 1U), &grid, &block);
              gpuEmxEnsureCapacity_int32_T(j_cpu_cols, &f_gpu_cols,
                !interval_outdatedOnGpu);
              gpuEmxEnsureCapacity_int32_T(ec_cpu_rows, &nb_gpu_rows,
                !y_needsGpuEnsureCapacity);
              gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
              a_data_outdatedOnGpu = false;
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&f_gpu_cols, j_cpu_cols);
              }

              if (y_needsGpuEnsureCapacity) {
                gpuEmxMemcpyCpuToGpu_int32_T(&nb_gpu_rows, ec_cpu_rows);
              }

              checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_wtcc_kernel657<<<grid, block>>>(tb_gpu_expanded, f_gpu_cols,
                  nb_gpu_rows, r_gpu_yCol, *gpu_csz, x_size_idx_1 - 1, ix - 1,
                  ab_gpu_w, vc_cpu_expanded->size[0U], jb_cpu_w->size[0U]);
              }
            }
          }
        } else {
          if (b_cpu_csz[0] == 0) {
            itime = d_cpu_h->size[0];
          } else {
            itime = (b_cpu_csz[0] + d_cpu_h->size[0]) - 1;
          }

          if (b_cpu_csz[1] == 0) {
            nrefine = 1;
          } else {
            nrefine = b_cpu_csz[1];
          }

          eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
          jb_cpu_w->size[0] = itime;
          jb_cpu_w->size[1] = nrefine;
          emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
          eint = itime * nrefine - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel658<<<grid, block>>>(eint, ab_gpu_w);
          }

          if ((b_cpu_csz[0] == 0) || (b_cpu_csz[1] == 0)) {
            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = itime;
            jb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            eint = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel659<<<grid, block>>>(eint, ab_gpu_w);
            }
          } else if ((b_cpu_csz[0] == 1) && (b_cpu_csz[1] == 1) &&
                     (d_cpu_h->size[0] == 1)) {
            ec_wtcc_kernel660<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(d_gpu_h,
              gpu_f1);
            ec_wtcc_kernel661<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_f1,
              *gpu_a_data);
            eint = y_cpu_yCol->size[0];
            y_cpu_yCol->size[0] = 1;
            emxEnsureCapacity_creal32_T(y_cpu_yCol, eint, &ib_emlrtRTEI);
            gpuEmxEnsureCapacity_creal32_T(y_cpu_yCol, &s_gpu_yCol, true);
            ec_wtcc_kernel662<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
              (r_gpu_yCol, *gpu_a_data, s_gpu_yCol);
            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = itime;
            jb_cpu_w->size[1] = nrefine;
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &ed_emlrtRTEI);
            offsetH = itime * nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
            a_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel663<<<grid, block>>>(s_gpu_yCol, offsetH, ab_gpu_w);
            }
          } else {
            N = (static_cast<uint32_T>(b_cpu_csz[0]) + static_cast<uint32_T>
                 (d_cpu_h->size[0])) - 1U;
            ix = b_cpu_csz[1];
            if (N > 2147483647U) {
              N = 2147483647U;
            }

            x_size_idx_1 = static_cast<int32_T>(N);
            offsetH = static_cast<int32_T>(std::floor(static_cast<real_T>
              (d_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
              static_cast<real_T>(d_cpu_h->size[0]) - 1.0) / 2.0));
            if ((static_cast<int32_T>(N) > 0) && (d_cpu_h->size[0] > MAX_int32_T
                 - static_cast<int32_T>(N))) {
              nx = MAX_int32_T;
            } else {
              nx = static_cast<int32_T>(N) + d_cpu_h->size[0];
            }

            eint = uc_cpu_expanded->size[0] * uc_cpu_expanded->size[1];
            uc_cpu_expanded->size[0] = nx - 1;
            emxEnsureCapacity_creal32_T(uc_cpu_expanded, eint, &jb_emlrtRTEI);
            if (b_cpu_csz[1] > 2147483646) {
              nx = MAX_int32_T;
            } else {
              nx = b_cpu_csz[1] + 1;
            }

            eint = uc_cpu_expanded->size[0] * uc_cpu_expanded->size[1];
            uc_cpu_expanded->size[1] = nx - 1;
            emxEnsureCapacity_creal32_T(uc_cpu_expanded, eint, &jb_emlrtRTEI);
            eint = ((static_cast<int32_T>(N) + d_cpu_h->size[0]) - 1) *
              b_cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_creal32_T(uc_cpu_expanded, &ub_gpu_expanded,
              true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel664<<<grid, block>>>(eint, ub_gpu_expanded);
            }

            n = b_cpu_csz[0];
            eint = ve_cpu_y->size[0] * ve_cpu_y->size[1];
            ve_cpu_y->size[0] = 1;
            ve_cpu_y->size[1] = b_cpu_csz[0];
            emxEnsureCapacity_int32_T(ve_cpu_y, eint, &kb_emlrtRTEI);
            ve_cpu_y->data[0] = 1;
            itime = 1;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              ve_cpu_y->data[k + 1] = itime;
            }

            eint = cpu_iv159->size[0];
            cpu_iv159->size[0] = ve_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv159, eint, &jb_emlrtRTEI);
            eint = ve_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(ve_cpu_y, &md_gpu_y, false);
            gpuEmxEnsureCapacity_int32_T(cpu_iv159, &gpu_iv159, true);
            gpuEmxMemcpyCpuToGpu_int32_T(&md_gpu_y, ve_cpu_y);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel665<<<grid, block>>>(offsetH, md_gpu_y, eint,
                gpu_iv159);
            }

            if (b_cpu_csz[1] < 1) {
              n = 0;
            } else {
              n = b_cpu_csz[1];
            }

            fx_data_outdatedOnCpu = false;
            eint = uf_cpu_y->size[0] * uf_cpu_y->size[1];
            uf_cpu_y->size[0] = 1;
            uf_cpu_y->size[1] = n;
            emxEnsureCapacity_int32_T(uf_cpu_y, eint, &kb_emlrtRTEI);
            if (n > 0) {
              uf_cpu_y->data[0] = 1;
              fx_data_outdatedOnCpu = true;
              itime = 1;
              for (k = 0; k <= n - 2; k++) {
                itime++;
                uf_cpu_y->data[k + 1] = itime;
              }
            }

            eint = cpu_iv176->size[0];
            cpu_iv176->size[0] = uf_cpu_y->size[1];
            emxEnsureCapacity_int32_T(cpu_iv176, eint, &jb_emlrtRTEI);
            eint = uf_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(uf_cpu_y, &nd_gpu_y,
              !fx_data_outdatedOnCpu);
            gpuEmxEnsureCapacity_int32_T(cpu_iv176, &gpu_iv176, true);
            if (fx_data_outdatedOnCpu) {
              gpuEmxMemcpyCpuToGpu_int32_T(&nd_gpu_y, uf_cpu_y);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel666<<<grid, block>>>(nd_gpu_y, eint, gpu_iv176);
            }

            xt_size[0] = cpu_iv159->size[0];
            xt_size[1] = cpu_iv176->size[0];
            mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0] -
              1), &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_wtcc_kernel667<<<grid, block>>>(r_gpu_yCol, xt_size[0],
                gpu_iv176, gpu_iv159, xt_size[0] - 1, xt_size[1] - 1,
                ub_gpu_expanded, uc_cpu_expanded->size[0U]);
            }

            n = d_cpu_h->size[0];
            eint = lc_cpu_rows->size[0] * lc_cpu_rows->size[1];
            lc_cpu_rows->size[0] = 1;
            lc_cpu_rows->size[1] = d_cpu_h->size[0];
            emxEnsureCapacity_int32_T(lc_cpu_rows, eint, &kb_emlrtRTEI);
            lc_cpu_rows->data[0] = 0;
            y_needsGpuEnsureCapacity = true;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            itime = 0;
            for (k = 0; k <= n - 2; k++) {
              itime++;
              lc_cpu_rows->data[k + 1] = itime;
            }

            eint = jb_cpu_w->size[0] * jb_cpu_w->size[1];
            jb_cpu_w->size[0] = static_cast<int32_T>(N);
            jb_cpu_w->size[1] = b_cpu_csz[1];
            emxEnsureCapacity_creal32_T(jb_cpu_w, eint, &jb_emlrtRTEI);
            a_data_outdatedOnGpu = true;
            if ((static_cast<int32_T>(N) != 0) && (b_cpu_csz[1] != 0)) {
              for (nrefine = 0; nrefine < ix; nrefine++) {
                cpu_lidx = d_cpu_h->size[0];
                for (nx = 0; nx < x_size_idx_1; nx++) {
                  eint = g_cpu_newIm->size[0];
                  g_cpu_newIm->size[0] = lc_cpu_rows->size[1];
                  emxEnsureCapacity_creal32_T(g_cpu_newIm, eint, &jb_emlrtRTEI);
                  eint = lc_cpu_rows->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
                    2147483647U);
                  if (c_omega_tmp1_needsGpuEnsureCapa) {
                    gpuEmxEnsureCapacity_int32_T(lc_cpu_rows, &ob_gpu_rows,
                      !y_needsGpuEnsureCapacity);
                  }

                  c_omega_tmp1_needsGpuEnsureCapa = false;
                  gpuEmxEnsureCapacity_creal32_T(g_cpu_newIm, &t_gpu_newIm, true);
                  if (y_needsGpuEnsureCapacity) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&ob_gpu_rows, lc_cpu_rows);
                  }

                  y_needsGpuEnsureCapacity = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_wtcc_kernel668<<<grid, block>>>(nrefine, ub_gpu_expanded,
                      nx, ob_gpu_rows, eint, t_gpu_newIm, uc_cpu_expanded->size
                      [0U]);
                  }

                  wav_outdatedOnCpu = true;
                  cpu_cv_re = 0.0F;
                  cv_im = 0.0F;
                  for (n = 0; n < cpu_lidx; n++) {
                    if (wav_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_creal32_T(g_cpu_newIm, &t_gpu_newIm);
                    }

                    if (b_fx_data_outdatedOnCpu) {
                      gpuEmxMemcpyGpuToCpu_real32_T(d_cpu_h, &d_gpu_h);
                    }

                    cpu_cv_re += g_cpu_newIm->data[n].re * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                    wav_outdatedOnCpu = false;
                    b_fx_data_outdatedOnCpu = false;
                    cv_im += g_cpu_newIm->data[n].im * d_cpu_h->data
                      [(d_cpu_h->size[0] - n) - 1];
                  }

                  if (a_data_outdatedOnGpu) {
                    gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
                  }

                  a_data_outdatedOnGpu = false;
                  ec_wtcc_kernel669<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cv_im, cpu_cv_re, nrefine, nx, ab_gpu_w, jb_cpu_w->size[0U]);
                }
              }
            }
          }
        }

        if (!(b_m - 1.0 >= 0.0)) {
          nd_y = nullptr;
          m82 = emlrtCreateCharArray(2, &iv134[0]);
          emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m82, &rfmt[0]);
          emlrtAssign(&nd_y, m82);
          od_y = nullptr;
          m89 = emlrtCreateDoubleScalar(b_m - 1.0);
          emlrtAssign(&od_y, m89);
          emlrt_marshallIn(b_sprintf(nd_y, od_y, &emlrtMCI),
                           "<output of sprintf>", unusedExpr);
        }

        nsubs = 2;
        if (jb_cpu_w->size[0] != 1) {
          nsubs = 1;
        }

        interval_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = false;
        for (itime = 0; itime < 2; itime++) {
          b_cpu_csz[itime] = jb_cpu_w->size[itime];
          fx_data_outdatedOnCpu = true;
          cpu_csz[itime] = jb_cpu_w->size[itime];
          interval_outdatedOnGpu = true;
        }

        if (1 - nsubs >= 0) {
          cpu_lidx = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
            (nsubs))) / 2.0);
          mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*b_gpu_csz, cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel629<<<grid, block>>>(1 - nsubs, cpu_lidx - 1,
              *b_gpu_csz);
          }

          checkCudaError(cudaMemcpy(cpu_csz, *b_gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        nrefine = cpu_csz[0];
        cpu_csz[0] = cpu_csz[1];
        cpu_csz[1] = nrefine;
        if ((b_m == 0.0) || ((b_m > 0.0) && (cpu_csz[0] < 1))) {
          cpu_lidx = 1;
          pathlen = -1;
        } else {
          cpu_lidx = static_cast<int32_T>(b_m);
          pathlen = cpu_csz[0] - 1;
        }

        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(*gpu_csz, b_cpu_csz, 8UL,
            cudaMemcpyHostToDevice), __FILE__, __LINE__);
        }

        ec_wtcc_kernel630<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_lidx,
          pathlen, nsubs, *gpu_csz);
        eint = bc_cpu_w->size[0] * bc_cpu_w->size[1];
        bc_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
        bc_cpu_w->size[1] = nrefine;
        emxEnsureCapacity_creal32_T(bc_cpu_w, eint, &jd_emlrtRTEI);
        eint = pathlen / cpu_lidx;
        mwGetLaunchParameters1D(computeNumIters(nrefine - 1, eint), &grid,
          &block, 2147483647U);
        if (a_data_outdatedOnGpu) {
          gpuEmxEnsureCapacity_creal32_T(jb_cpu_w, &ab_gpu_w, true);
        }

        gpuEmxEnsureCapacity_creal32_T(bc_cpu_w, &bb_gpu_w, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel631<<<grid, block>>>(ab_gpu_w, cpu_csz[0], cpu_lidx,
            eint, nrefine - 1, bb_gpu_w, bc_cpu_w->size[0U]);
        }

        checkCudaError(cudaMemcpy(b_cpu_csz, *gpu_csz, 8UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        eint = ff_cpu_y->size[0] * ff_cpu_y->size[1];
        ff_cpu_y->size[0] = b_cpu_csz[0];
        ff_cpu_y->size[1] = b_cpu_csz[1];
        emxEnsureCapacity_creal32_T(ff_cpu_y, eint, &ed_emlrtRTEI);
        offsetH = b_cpu_csz[0] * b_cpu_csz[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(offsetH), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_creal32_T(ff_cpu_y, &hd_gpu_y, true);
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel632<<<grid, block>>>(bb_gpu_w, offsetH, hd_gpu_y);
        }

        Ly = std::ceil(((static_cast<real_T>(b_cpu_xCol->size[0]) - 1.0) * toler
                        + static_cast<real_T>(d_cpu_h->size[0])) / b_m);
        if (!(b_cpu_csz[0] < Ly)) {
          if (Ly < 1.0) {
            nrefine = 0;
          } else {
            nrefine = static_cast<int32_T>(Ly);
          }

          n = ec_cpu_w->size[0] * ec_cpu_w->size[1];
          ec_cpu_w->size[0] = div_s32(pathlen, cpu_lidx) + 1;
          ec_cpu_w->size[1] = cpu_csz[1];
          emxEnsureCapacity_creal32_T(ec_cpu_w, n, &jd_emlrtRTEI);
          eint = pathlen / cpu_lidx;
          mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, eint), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ec_cpu_w, &cb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel633<<<grid, block>>>(ab_gpu_w, cpu_csz[0], cpu_lidx,
              eint, cpu_csz[1] - 1, cb_gpu_w, ec_cpu_w->size[0U]);
          }

          n = ff_cpu_y->size[0] * ff_cpu_y->size[1];
          ff_cpu_y->size[0] = nrefine;
          ff_cpu_y->size[1] = b_cpu_csz[1];
          emxEnsureCapacity_creal32_T(ff_cpu_y, n, &gd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(b_cpu_csz[1] - 1, nrefine - 1),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ff_cpu_y, &hd_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel634<<<grid, block>>>(cb_gpu_w, b_cpu_csz[0], nrefine -
              1, b_cpu_csz[1] - 1, hd_gpu_y, ff_cpu_y->size[0U]);
          }
        }

        if (first_iteration) {
          omega_tmp2[0] = ff_cpu_y->size[0] * ff_cpu_y->size[1];
          eint = eh_cpu_y->size[0] * eh_cpu_y->size[1];
          eh_cpu_y->size[0] = 1;
          eh_cpu_y->size[1] = omega_tmp2[0];
          emxEnsureCapacity_creal32_T(eh_cpu_y, eint, &kd_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
            &block, 2147483647U);
          gpuEmxEnsureCapacity_creal32_T(eh_cpu_y, &id_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel635<<<grid, block>>>(hd_gpu_y, omega_tmp2[0] - 1,
              id_gpu_y, eh_cpu_y->size[0U]);
          }

          eint = ff_cpu_y->size[0] * ff_cpu_y->size[1];
          ff_cpu_y->size[0] = 1;
          ff_cpu_y->size[1] = eh_cpu_y->size[1];
          emxEnsureCapacity_creal32_T(ff_cpu_y, eint, &md_emlrtRTEI);
          eint = eh_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_creal32_T(ff_cpu_y, &hd_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel636<<<grid, block>>>(id_gpu_y, eint, hd_gpu_y);
          }
        }

        if (std::isnan(tol)) {
          eint = dg_cpu_y->size[0] * dg_cpu_y->size[1];
          dg_cpu_y->size[0] = 1;
          dg_cpu_y->size[1] = 1;
          emxEnsureCapacity_real_T(dg_cpu_y, eint, &d_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(dg_cpu_y, &jd_gpu_y, true);
          p_y_needsGpuEnsureCapacity = false;
          ec_wtcc_kernel637<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(jd_gpu_y);
        } else if (tol < 1.0) {
          dg_cpu_y->size[0] = 1;
          dg_cpu_y->size[1] = 0;
        } else {
          eint = dg_cpu_y->size[0] * dg_cpu_y->size[1];
          dg_cpu_y->size[0] = 1;
          dg_cpu_y->size[1] = static_cast<int32_T>(tol - 1.0) + 1;
          emxEnsureCapacity_real_T(dg_cpu_y, eint, &d_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(tol - 1.0)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(dg_cpu_y, &jd_gpu_y, true);
          p_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_wtcc_kernel639<<<grid, block>>>(static_cast<int32_T>(tol - 1.0),
              jd_gpu_y);
          }
        }

        cpu_lidx = ff_cpu_y->size[1];
        eint = b_cpu_y1->size[0] * b_cpu_y1->size[1];
        b_cpu_y1->size[0] = dg_cpu_y->size[1];
        b_cpu_y1->size[1] = ff_cpu_y->size[1];
        emxEnsureCapacity_creal32_T(b_cpu_y1, eint, &nc_emlrtRTEI);
        eint = dg_cpu_y->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(cpu_lidx - 1, eint), &grid,
          &block, 2147483647U);
        if (p_y_needsGpuEnsureCapacity) {
          gpuEmxEnsureCapacity_real_T(dg_cpu_y, &jd_gpu_y, true);
        }

        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_wtcc_kernel638<<<grid, block>>>(hd_gpu_y, jd_gpu_y, T, eint,
            cpu_lidx - 1, gpu_y1, b_cpu_y1->size[0U], ff_cpu_y->size[0U]);
        }
      }

      emxFree_creal32_T(&ec_cpu_w);
      emxFree_creal32_T(&eh_cpu_y);
      emxFree_creal32_T(&bc_cpu_w);
      emxFree_creal32_T(&xb_cpu_w);
      emxFree_creal32_T(&dh_cpu_y);
      emxFree_creal32_T(&sb_cpu_w);
      emxFree_creal32_T(&pb_cpu_w);
      emxFree_creal32_T(&ob_cpu_w);
      emxFree_creal32_T(&y_cpu_yCol);
      emxFree_creal32_T(&v_cpu_yCol);
      emxFree_creal32_T(&u_cpu_yCol);
      emxFree_creal32_T(&s_cpu_newIm);
      emxFree_creal32_T(&p_cpu_newIm);
      emxFree_creal32_T(&m_cpu_newIm);
      emxFree_creal32_T(&j_cpu_newIm);
      emxFree_creal32_T(&g_cpu_newIm);
      emxFree_creal32_T(&d_cpu_newIm);
      emxFree_creal32_T(&c_cpu_newIm);
      emxFree_int32_T(&ld_cpu_rows);
      emxFree_int32_T(&id_cpu_rows);
      emxFree_int32_T(&cpu_iv203);
      emxFree_int32_T(&fd_cpu_rows);
      emxFree_int32_T(&cd_cpu_rows);
      emxFree_int32_T(&cpu_iv202);
      emxFree_int32_T(&yc_cpu_rows);
      emxFree_int32_T(&vc_cpu_rows);
      emxFree_int32_T(&uc_cpu_rows);
      emxFree_int32_T(&cpu_iv195);
      emxFree_int32_T(&cpu_iv194);
      emxFree_int32_T(&rc_cpu_rows);
      emxFree_int32_T(&cpu_iv190);
      emxFree_int32_T(&j_cpu_cols);
      emxFree_int32_T(&cpu_iv189);
      emxFree_int32_T(&oc_cpu_rows);
      emxFree_int32_T(&ah_cpu_y);
      emxFree_int32_T(&lc_cpu_rows);
      emxFree_int32_T(&wg_cpu_y);
      emxFree_int32_T(&ic_cpu_rows);
      emxFree_int32_T(&cpu_iv182);
      emxFree_real32_T(&fe_cpu_expanded);
      emxFree_creal32_T(&ce_cpu_expanded);
      emxFree_int32_T(&g_cpu_cols);
      emxFree_int32_T(&cpu_iv177);
      emxFree_int32_T(&tg_cpu_y);
      emxFree_int32_T(&cpu_iv176);
      emxFree_int32_T(&qg_cpu_y);
      emxFree_int32_T(&fc_cpu_rows);
      emxFree_int32_T(&ng_cpu_y);
      emxFree_int32_T(&mg_cpu_y);
      emxFree_real32_T(&ud_cpu_expanded);
      emxFree_creal32_T(&rd_cpu_expanded);
      emxFree_real32_T(&od_cpu_expanded);
      emxFree_creal32_T(&nd_cpu_expanded);
      emxFree_int32_T(&ec_cpu_rows);
      emxFree_int32_T(&cpu_iv169);
      emxFree_int32_T(&cpu_iv168);
      emxFree_int32_T(&fg_cpu_y);
      emxFree_int32_T(&cpu_iv167);
      emxFree_int32_T(&eg_cpu_y);
      emxFree_real_T(&dg_cpu_y);
      emxFree_real32_T(&id_cpu_expanded);
      emxFree_creal32_T(&hd_cpu_expanded);
      emxFree_int32_T(&yb_cpu_rows);
      emxFree_creal32_T(&vf_cpu_y);
      emxFree_int32_T(&uf_cpu_y);
      emxFree_int32_T(&cpu_iv159);
      emxFree_int32_T(&cpu_iv158);
      emxFree_int32_T(&pf_cpu_y);
      emxFree_real_T(&mf_cpu_y);
      emxFree_int32_T(&jf_cpu_y);
      emxFree_int32_T(&if_cpu_y);
      emxFree_int32_T(&cpu_iv155);
      emxFree_real32_T(&ed_cpu_expanded);
      emxFree_creal32_T(&bd_cpu_expanded);
      emxFree_int32_T(&cpu_iv152);
      emxFree_creal32_T(&ff_cpu_y);
      emxFree_int32_T(&cpu_iv149);
      emxFree_creal32_T(&j_cpu_result);
      emxFree_int32_T(&cpu_iv144);
      emxFree_int32_T(&af_cpu_y);
      emxFree_creal32_T(&ye_cpu_y);
      emxFree_int32_T(&ve_cpu_y);
      emxFree_creal32_T(&g_cpu_result);
      emxFree_int32_T(&se_cpu_y);
      emxFree_real32_T(&vc_cpu_expanded);
      emxFree_creal32_T(&uc_cpu_expanded);
      emxFree_int32_T(&me_cpu_y);
      emxFree_creal32_T(&rc_cpu_expanded);
      emxFree_int32_T(&he_cpu_y);
      emxFree_int32_T(&ge_cpu_y);
      emxFree_real32_T(&kc_cpu_expanded);
      emxFree_creal32_T(&hc_cpu_expanded);
      emxFree_creal32_T(&gc_cpu_expanded);
      emxFree_creal32_T(&q_cpu_a);
      emxFree_creal32_T(&x_cpu_c);
      emxFree_creal32_T(&n_cpu_a);
      emxFree_creal32_T(&mb_cpu_w);
      emxFree_creal32_T(&s_cpu_c);
      emxFree_creal32_T(&jb_cpu_w);
      emxFree_creal32_T(&s_cpu_yCol);
      emxFree_creal32_T(&eb_cpu_w);
      emxFree_creal32_T(&p_cpu_yCol);
      emxFree_creal32_T(&m_cpu_yCol);
      emxFree_creal32_T(&b_cpu_xCol);
    }

    if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
      N = static_cast<uint32_T>(b_cpu_y1->size[0]);
      eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = cpu_crossCFS->size[0];
      cpu_opts_x->size[1] = b_cpu_y1->size[0];
      emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &nd_emlrtRTEI);
      eint = cpu_crossCFS->size[0] * static_cast<int32_T>(N) - 1;
      mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
      }

      gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel519<<<grid, block>>>(gpu_y1, eint, gpu_opts_x);
      }
    } else {
      eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
      cpu_opts_x->size[0] = b_cpu_y1->size[1];
      cpu_opts_x->size[1] = b_cpu_y1->size[0];
      emxEnsureCapacity_creal32_T(cpu_opts_x, eint, &nd_emlrtRTEI);
      offsetH = b_cpu_y1->size[0] - 1;
      eint = b_cpu_y1->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(offsetH, eint), &grid, &block,
        2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal32_T(b_cpu_y1, &gpu_y1, true);
      }

      gpuEmxEnsureCapacity_creal32_T(cpu_opts_x, &gpu_opts_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_wtcc_kernel520<<<grid, block>>>(gpu_y1, eint, offsetH, gpu_opts_x,
          cpu_opts_x->size[0U], b_cpu_y1->size[0U]);
      }
    }
  }

  emxFree_creal32_T(&b_cpu_y1);
  emxFree_real32_T(&d_cpu_h);
  emxFree_creal32_T(&cpu_crossCFS);

  //  Convert wavelet to phase angle
  // 'ec_wtcc:40' y = angle(y);
  nx = cpu_opts_x->size[0] * cpu_opts_x->size[1];
  for (itime = 0; itime < 2; itime++) {
    xSize[itime] = static_cast<uint32_T>(cpu_opts_x->size[itime]);
  }

  eint = yy[0].f1->size[0] * yy[0].f1->size[1];
  yy[0].f1->size[0] = static_cast<int32_T>(xSize[0]);
  yy[0].f1->size[1] = static_cast<int32_T>(xSize[1]);
  emxEnsureCapacity_real32_T(yy[0].f1, eint, &n_emlrtRTEI);
  for (k = 0; k < nx; k++) {
    if (h_needsGpuEnsureCapacity) {
      gpuEmxMemcpyGpuToCpu_creal32_T(cpu_opts_x, &gpu_opts_x);
    }

    h_needsGpuEnsureCapacity = false;
    yy[0].f1->data[k] = rt_atan2f_snf(cpu_opts_x->data[k].im, cpu_opts_x->data[k]
      .re);
  }

  emxFree_creal32_T(&cpu_opts_x);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
  gpuEmxFree_real32_T(&gpu_x);
  checkCudaError(mwCudaFree(gpu_dc6), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_dc), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_lidx), __FILE__, __LINE__);
  gpuEmxFree_int32_T(&gpu_omega_tmp1);
  gpuEmxFree_real_T(&gpu_omega_tmp2);
  checkCudaError(mwCudaFree(*gpu_wav), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_wname), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_fb_Omega);
  checkCudaError(mwCudaFree(*gpu_interval), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_subs), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_fb_Scales);
  checkCudaError(mwCudaFree(*gpu_x_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*b_gpu_x_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_xt_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_y);
  gpuEmxFree_real_T(&b_gpu_y);
  checkCudaError(mwCudaFree(*gpu_y_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&hh_gpu_y);
  checkCudaError(mwCudaFree(*d_gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&ih_gpu_y);
  checkCudaError(mwCudaFree(*c_gpu_a_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_somega);
  checkCudaError(mwCudaFree(*gpu_dv8_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv2_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*c_gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_expnt);
  gpuEmxFree_real_T(&gpu_daughter);
  gpuEmxFree_real_T(&gc_gpu_w);
  checkCudaError(mwCudaFree(*b_gpu_fx_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*b_gpu_a_data), __FILE__, __LINE__);
  gpuEmxFree_real32_T(&gpu_psihat);
  gpuEmxFree_real_T(&gh_gpu_y);
  checkCudaError(mwCudaFree(*gpu_dv15_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv9_data), __FILE__, __LINE__);
  gpuEmxFree_real32_T(&gpu_xv);
  checkCudaError(mwCudaFree(*gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_creal32_T(&gpu_xposdft);
  gpuEmxFree_real32_T(&b_gpu_x);
  checkCudaError(mwCudaFree(*b_gpu_csz), __FILE__, __LINE__);
  gpuEmxFree_creal32_T(&gpu_cfsposdft);
  gpuEmxFree_creal32_T(&gpu_cfspos);
  checkCudaError(mwCudaFree(c_gpu_cfsposdft), __FILE__, __LINE__);
  gpuEmxFree_real32_T(&b_gpu_psihat);
  gpuEmxFree_real32_T(&b_gpu_xv);
  gpuEmxFree_creal32_T(&b_gpu_xposdft);
  gpuEmxFree_real32_T(&c_gpu_x);
  gpuEmxFree_creal32_T(&b_gpu_cfsposdft);
  gpuEmxFree_creal32_T(&b_gpu_cfspos);
  gpuEmxFree_real32_T(&c_gpu_y);
  gpuEmxFree_real32_T(&gpu_cfs1);
  gpuEmxFree_int32_T(&b_gpu_omega_tmp1);
  gpuEmxFree_real_T(&b_gpu_omega_tmp2);
  gpuEmxFree_real_T(&gpu_omega);
  gpuEmxFree_creal32_T(&gpu_cfsDFT);
  gpuEmxFree_real_T(&gpu_Fmat);
  gpuEmxFree_creal32_T(&d_gpu_x);
  gpuEmxFree_creal32_T(&d_gpu_y);
  gpuEmxFree_real32_T(&gpu_smooth);
  gpuEmxFree_real32_T(&gpu_a);
  gpuEmxFree_real32_T(&gpu_c);
  gpuEmxFree_real32_T(&fe_gpu_expanded);
  gpuEmxFree_int32_T(&eh_gpu_y);
  gpuEmxFree_real32_T(&ee_gpu_expanded);
  gpuEmxFree_int32_T(&dh_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv8);
  gpuEmxFree_int32_T(&gpu_iv9);
  gpuEmxFree_int32_T(&fh_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv10);
  gpuEmxFree_int32_T(&pd_gpu_rows);
  gpuEmxFree_real32_T(&g_gpu_smooth);
  gpuEmxFree_real32_T(&h_gpu_smooth);
  gpuEmxFree_real32_T(&e_gpu_y);
  gpuEmxFree_real32_T(&gpu_cfs2);
  gpuEmxFree_int32_T(&c_gpu_omega_tmp1);
  gpuEmxFree_real_T(&c_gpu_omega_tmp2);
  gpuEmxFree_real_T(&b_gpu_omega);
  gpuEmxFree_creal32_T(&b_gpu_cfsDFT);
  gpuEmxFree_real_T(&b_gpu_Fmat);
  gpuEmxFree_creal32_T(&e_gpu_x);
  gpuEmxFree_creal32_T(&f_gpu_y);
  gpuEmxFree_real32_T(&b_gpu_smooth);
  gpuEmxFree_real32_T(&b_gpu_a);
  gpuEmxFree_real32_T(&b_gpu_c);
  gpuEmxFree_real32_T(&de_gpu_expanded);
  gpuEmxFree_int32_T(&bh_gpu_y);
  gpuEmxFree_real32_T(&ce_gpu_expanded);
  gpuEmxFree_int32_T(&ah_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv11);
  gpuEmxFree_int32_T(&gpu_iv12);
  gpuEmxFree_int32_T(&ch_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv13);
  gpuEmxFree_int32_T(&od_gpu_rows);
  gpuEmxFree_real32_T(&e_gpu_smooth);
  gpuEmxFree_real32_T(&f_gpu_smooth);
  gpuEmxFree_creal32_T(&gpu_crossCFS);
  gpuEmxFree_int32_T(&d_gpu_omega_tmp1);
  gpuEmxFree_real_T(&d_gpu_omega_tmp2);
  gpuEmxFree_real_T(&c_gpu_omega);
  gpuEmxFree_creal32_T(&c_gpu_cfsDFT);
  gpuEmxFree_real_T(&c_gpu_Fmat);
  gpuEmxFree_creal32_T(&f_gpu_x);
  gpuEmxFree_creal32_T(&c_gpu_smooth);
  gpuEmxFree_creal32_T(&c_gpu_a);
  gpuEmxFree_creal32_T(&c_gpu_c);
  gpuEmxFree_creal32_T(&be_gpu_expanded);
  gpuEmxFree_int32_T(&xg_gpu_y);
  gpuEmxFree_creal32_T(&ae_gpu_expanded);
  gpuEmxFree_int32_T(&wg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv15);
  gpuEmxFree_int32_T(&gpu_iv16);
  gpuEmxFree_int32_T(&yg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv17);
  gpuEmxFree_int32_T(&nd_gpu_rows);
  gpuEmxFree_creal32_T(&w_gpu_newIm);
  gpuEmxFree_creal32_T(&d_gpu_smooth);
  checkCudaError(mwCudaFree(*gpu_a_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_cv_re), __FILE__, __LINE__);
  gpuEmxFree_real32_T(&g_gpu_y);
  gpuEmxFree_real32_T(&h_gpu_y);
  gpuEmxFree_real32_T(&gpu_wtc);
  gpuEmxFree_real_T(&gpu_h);
  gpuEmxFree_real_T(&gpu_dv23);
  gpuEmxFree_real_T(&gpu_m);
  gpuEmxFree_real_T(&gpu_h1);
  gpuEmxFree_real_T(&gpu_k);
  gpuEmxFree_real_T(&gpu_G);
  gpuEmxFree_real32_T(&gpu_opts_filter);
  gpuEmxFree_real_T(&gpu_sinc1A);
  gpuEmxFree_real_T(&gpu_sinc2A);
  gpuEmxFree_real_T(&gpu_sinc3A);
  gpuEmxFree_real32_T(&b_gpu_h);
  gpuEmxFree_real_T(&gpu_sinc4A);
  gpuEmxFree_uint32_T(&k_gpu_y);
  gpuEmxFree_real_T(&gpu_b);
  gpuEmxFree_int32_T(&gpu_iv18);
  gpuEmxFree_real_T(&gpu_dv25);
  gpuEmxFree_real_T(&gpu_dv26);
  gpuEmxFree_real_T(&i_gpu_y);
  gpuEmxFree_real_T(&j_gpu_y);
  gpuEmxFree_real32_T(&b_gpu_y1);
  gpuEmxFree_real32_T(&b_gpu_xCol);
  gpuEmxFree_real32_T(&x_gpu_yCol);
  gpuEmxFree_real32_T(&u_gpu_yCol);
  gpuEmxFree_real32_T(&cb_gpu_yCol);
  gpuEmxFree_real32_T(&y_gpu_yCol);
  gpuEmxFree_real32_T(&v_gpu_yCol);
  gpuEmxFree_real32_T(&db_gpu_yCol);
  gpuEmxFree_real32_T(&l_gpu_x);
  gpuEmxFree_real32_T(&i_gpu_x);
  gpuEmxFree_real32_T(&o_gpu_x);
  gpuEmxFree_real32_T(&w_gpu_yCol);
  gpuEmxFree_real32_T(&t_gpu_yCol);
  gpuEmxFree_real32_T(&bb_gpu_yCol);
  gpuEmxFree_real32_T(&m_gpu_x);
  gpuEmxFree_real32_T(&j_gpu_x);
  gpuEmxFree_real32_T(&ac_gpu_w);
  gpuEmxFree_real32_T(&pb_gpu_w);
  gpuEmxFree_real32_T(&gb_gpu_w);
  gpuEmxFree_real_T(&gpu_b0);
  gpuEmxFree_real32_T(&p_gpu_x);
  gpuEmxFree_real32_T(&sb_gpu_w);
  gpuEmxFree_real32_T(&jb_gpu_w);
  gpuEmxFree_real_T(&d_gpu_a);
  gpuEmxFree_real32_T(&dc_gpu_w);
  gpuEmxFree_real32_T(&k_gpu_x);
  gpuEmxFree_real32_T(&h_gpu_x);
  gpuEmxFree_real32_T(&n_gpu_x);
  gpuEmxFree_real32_T(&mb_gpu_w);
  gpuEmxFree_real32_T(&db_gpu_w);
  gpuEmxFree_int32_T(&b_gpu_jpvt);
  gpuEmxFree_real32_T(&u_gpu_c);
  gpuEmxFree_real32_T(&p_gpu_c);
  gpuEmxFree_real32_T(&k_gpu_c);
  gpuEmxFree_real_T(&b_gpu_tau);
  gpuEmxFree_real32_T(&wb_gpu_w);
  gpuEmxFree_real32_T(&ab_gpu_yCol);
  gpuEmxFree_real32_T(&p_gpu_a);
  gpuEmxFree_real32_T(&n_gpu_a);
  gpuEmxFree_real32_T(&r_gpu_a);
  gpuEmxFree_real32_T(&vb_gpu_w);
  gpuEmxFree_real32_T(&r_gpu_c);
  gpuEmxFree_real32_T(&m_gpu_c);
  gpuEmxFree_int32_T(&b_gpu_IPIV);
  gpuEmxFree_real32_T(&w_gpu_c);
  gpuEmxFree_real32_T(&sf_gpu_y);
  gpuEmxFree_real32_T(&q_gpu_a);
  gpuEmxFree_real32_T(&o_gpu_a);
  gpuEmxFree_real32_T(&s_gpu_a);
  gpuEmxFree_real32_T(&id_gpu_expanded);
  gpuEmxFree_real32_T(&v_gpu_c);
  gpuEmxFree_real32_T(&hd_gpu_expanded);
  gpuEmxFree_real32_T(&ld_gpu_expanded);
  gpuEmxFree_int32_T(&vf_gpu_y);
  gpuEmxFree_real32_T(&q_gpu_c);
  gpuEmxFree_real32_T(&l_gpu_c);
  gpuEmxFree_real32_T(&x_gpu_c);
  gpuEmxFree_int32_T(&uf_gpu_y);
  gpuEmxFree_real32_T(&s_gpu_c);
  gpuEmxFree_real32_T(&n_gpu_c);
  gpuEmxFree_real32_T(&nd_gpu_expanded);
  gpuEmxFree_real_T(&tf_gpu_y);
  gpuEmxFree_real32_T(&sc_gpu_expanded);
  gpuEmxFree_real32_T(&cc_gpu_expanded);
  gpuEmxFree_real32_T(&md_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv41);
  gpuEmxFree_real32_T(&uc_gpu_expanded);
  gpuEmxFree_real32_T(&ec_gpu_expanded);
  gpuEmxFree_int32_T(&dg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv42);
  gpuEmxFree_real32_T(&tc_gpu_expanded);
  gpuEmxFree_real32_T(&dc_gpu_expanded);
  gpuEmxFree_int32_T(&fg_gpu_y);
  gpuEmxFree_int32_T(&xc_gpu_rows);
  gpuEmxFree_int32_T(&ye_gpu_y);
  gpuEmxFree_int32_T(&yd_gpu_y);
  gpuEmxFree_real_T(&q_gpu_x);
  gpuEmxFree_real32_T(&sd_gpu_expanded);
  gpuEmxFree_int32_T(&wc_gpu_rows);
  gpuEmxFree_real32_T(&ad_gpu_expanded);
  gpuEmxFree_real32_T(&jc_gpu_expanded);
  gpuEmxFree_int32_T(&eg_gpu_y);
  gpuEmxFree_int32_T(&bf_gpu_y);
  gpuEmxFree_int32_T(&be_gpu_y);
  gpuEmxFree_real32_T(&ud_gpu_expanded);
  gpuEmxFree_int32_T(&af_gpu_y);
  gpuEmxFree_int32_T(&ae_gpu_y);
  gpuEmxFree_real32_T(&td_gpu_expanded);
  gpuEmxFree_real32_T(&cd_gpu_expanded);
  gpuEmxFree_real32_T(&lc_gpu_expanded);
  gpuEmxFree_int32_T(&og_gpu_y);
  gpuEmxFree_real32_T(&bd_gpu_expanded);
  gpuEmxFree_real32_T(&kc_gpu_expanded);
  gpuEmxFree_real32_T(&k_gpu_result);
  gpuEmxFree_int32_T(&kf_gpu_y);
  gpuEmxFree_int32_T(&ke_gpu_y);
  gpuEmxFree_real32_T(&t_gpu_c);
  gpuEmxFree_real32_T(&o_gpu_c);
  gpuEmxFree_real32_T(&j_gpu_c);
  gpuEmxFree_int32_T(&qg_gpu_y);
  gpuEmxFree_int32_T(&mf_gpu_y);
  gpuEmxFree_int32_T(&me_gpu_y);
  gpuEmxFree_real32_T(&yf_gpu_y);
  gpuEmxFree_real32_T(&i_gpu_result);
  gpuEmxFree_real32_T(&g_gpu_result);
  gpuEmxFree_int32_T(&pg_gpu_y);
  gpuEmxFree_int32_T(&lf_gpu_y);
  gpuEmxFree_int32_T(&le_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv47);
  gpuEmxFree_real32_T(&ue_gpu_y);
  gpuEmxFree_real32_T(&ud_gpu_y);
  gpuEmxFree_real32_T(&l_gpu_result);
  gpuEmxFree_int32_T(&gpu_iv43);
  gpuEmxFree_int32_T(&gpu_iv44);
  gpuEmxFree_int32_T(&gpu_iv52);
  gpuEmxFree_real32_T(&j_gpu_result);
  gpuEmxFree_real32_T(&h_gpu_result);
  gpuEmxFree_real32_T(&lg_gpu_y);
  gpuEmxFree_real32_T(&hf_gpu_y);
  gpuEmxFree_real32_T(&he_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv55);
  gpuEmxFree_int32_T(&gpu_iv45);
  gpuEmxFree_int32_T(&gpu_iv46);
  gpuEmxFree_real32_T(&kd_gpu_expanded);
  gpuEmxFree_real32_T(&rc_gpu_expanded);
  gpuEmxFree_real32_T(&bc_gpu_expanded);
  gpuEmxFree_real32_T(&jd_gpu_expanded);
  gpuEmxFree_real32_T(&qc_gpu_expanded);
  gpuEmxFree_real32_T(&ac_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv58);
  gpuEmxFree_int32_T(&gpu_iv48);
  gpuEmxFree_int32_T(&gpu_iv50);
  gpuEmxFree_int32_T(&gg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv49);
  gpuEmxFree_int32_T(&gpu_iv51);
  gpuEmxFree_int32_T(&cg_gpu_y);
  gpuEmxFree_int32_T(&xe_gpu_y);
  gpuEmxFree_int32_T(&xd_gpu_y);
  gpuEmxFree_real_T(&ag_gpu_y);
  gpuEmxFree_int32_T(&cf_gpu_y);
  gpuEmxFree_int32_T(&ce_gpu_y);
  gpuEmxFree_int32_T(&bg_gpu_y);
  gpuEmxFree_int32_T(&we_gpu_y);
  gpuEmxFree_int32_T(&wd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv61);
  gpuEmxFree_int32_T(&gpu_iv53);
  gpuEmxFree_int32_T(&gpu_iv54);
  gpuEmxFree_int32_T(&gpu_iv62);
  gpuEmxFree_real_T(&ve_gpu_y);
  gpuEmxFree_real_T(&vd_gpu_y);
  gpuEmxFree_int32_T(&rg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv56);
  gpuEmxFree_int32_T(&gpu_iv57);
  gpuEmxFree_real32_T(&wf_gpu_y);
  gpuEmxFree_int32_T(&nf_gpu_y);
  gpuEmxFree_int32_T(&ne_gpu_y);
  gpuEmxFree_int32_T(&bd_gpu_rows);
  gpuEmxFree_real32_T(&se_gpu_y);
  gpuEmxFree_real32_T(&sd_gpu_y);
  gpuEmxFree_real32_T(&pd_gpu_expanded);
  gpuEmxFree_int32_T(&kc_gpu_rows);
  gpuEmxFree_int32_T(&vb_gpu_rows);
  gpuEmxFree_real32_T(&od_gpu_expanded);
  gpuEmxFree_real_T(&jf_gpu_y);
  gpuEmxFree_real_T(&je_gpu_y);
  gpuEmxFree_real_T(&ng_gpu_y);
  gpuEmxFree_real32_T(&wc_gpu_expanded);
  gpuEmxFree_real32_T(&gc_gpu_expanded);
  gpuEmxFree_int32_T(&ig_gpu_y);
  gpuEmxFree_real32_T(&vc_gpu_expanded);
  gpuEmxFree_real32_T(&fc_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv70);
  gpuEmxFree_creal32_T(&gpu_opts_x);
  gpuEmxFree_int32_T(&gpu_iv63);
  gpuEmxFree_int32_T(&gpu_iv64);
  gpuEmxFree_int32_T(&hg_gpu_y);
  gpuEmxFree_int32_T(&ef_gpu_y);
  gpuEmxFree_int32_T(&ee_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv71);
  gpuEmxFree_int32_T(&gpu_iv65);
  gpuEmxFree_int32_T(&gpu_iv66);
  gpuEmxFree_int32_T(&gpu_iv72);
  gpuEmxFree_int32_T(&qc_gpu_rows);
  gpuEmxFree_int32_T(&cc_gpu_rows);
  gpuEmxFree_int32_T(&hd_gpu_rows);
  gpuEmxFree_int32_T(&df_gpu_y);
  gpuEmxFree_int32_T(&de_gpu_y);
  gpuEmxFree_real32_T(&wd_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv68);
  gpuEmxFree_int32_T(&gpu_iv69);
  gpuEmxFree_real32_T(&vd_gpu_expanded);
  gpuEmxFree_real32_T(&ed_gpu_expanded);
  gpuEmxFree_real32_T(&nc_gpu_expanded);
  gpuEmxFree_real32_T(&rd_gpu_expanded);
  gpuEmxFree_real32_T(&dd_gpu_expanded);
  gpuEmxFree_real32_T(&mc_gpu_expanded);
  gpuEmxFree_real32_T(&qd_gpu_expanded);
  gpuEmxFree_int32_T(&pf_gpu_y);
  gpuEmxFree_int32_T(&pe_gpu_y);
  gpuEmxFree_int32_T(&tg_gpu_y);
  gpuEmxFree_real32_T(&yc_gpu_expanded);
  gpuEmxFree_real32_T(&ic_gpu_expanded);
  gpuEmxFree_int32_T(&kg_gpu_y);
  gpuEmxFree_real32_T(&xc_gpu_expanded);
  gpuEmxFree_real32_T(&hc_gpu_expanded);
  gpuEmxFree_int32_T(&cd_gpu_rows);
  gpuEmxFree_int32_T(&of_gpu_y);
  gpuEmxFree_int32_T(&oe_gpu_y);
  gpuEmxFree_int32_T(&sg_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv73);
  gpuEmxFree_int32_T(&gpu_iv74);
  gpuEmxFree_int32_T(&gpu_iv79);
  gpuEmxFree_int32_T(&gf_gpu_y);
  gpuEmxFree_int32_T(&ge_gpu_y);
  gpuEmxFree_int32_T(&jg_gpu_y);
  gpuEmxFree_int32_T(&lc_gpu_rows);
  gpuEmxFree_int32_T(&wb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv80);
  gpuEmxFree_int32_T(&ff_gpu_y);
  gpuEmxFree_int32_T(&fe_gpu_y);
  gpuEmxFree_int32_T(&k_gpu_cols);
  gpuEmxFree_real32_T(&gd_gpu_expanded);
  gpuEmxFree_real32_T(&pc_gpu_expanded);
  gpuEmxFree_real32_T(&yd_gpu_expanded);
  gpuEmxFree_real32_T(&fd_gpu_expanded);
  gpuEmxFree_real32_T(&oc_gpu_expanded);
  gpuEmxFree_real32_T(&xd_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv75);
  gpuEmxFree_int32_T(&gpu_iv76);
  gpuEmxFree_int32_T(&gpu_iv85);
  gpuEmxFree_int32_T(&i_gpu_cols);
  gpuEmxFree_int32_T(&g_gpu_cols);
  gpuEmxFree_int32_T(&yc_gpu_rows);
  gpuEmxFree_int32_T(&ic_gpu_rows);
  gpuEmxFree_int32_T(&tb_gpu_rows);
  gpuEmxFree_int32_T(&vg_gpu_y);
  gpuEmxFree_int32_T(&rf_gpu_y);
  gpuEmxFree_int32_T(&re_gpu_y);
  gpuEmxFree_int32_T(&id_gpu_rows);
  gpuEmxFree_int32_T(&rc_gpu_rows);
  gpuEmxFree_int32_T(&dc_gpu_rows);
  gpuEmxFree_int32_T(&ug_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv77);
  gpuEmxFree_int32_T(&gpu_iv78);
  gpuEmxFree_int32_T(&ed_gpu_rows);
  gpuEmxFree_int32_T(&qf_gpu_y);
  gpuEmxFree_int32_T(&qe_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv93);
  gpuEmxFree_int32_T(&gpu_iv81);
  gpuEmxFree_int32_T(&gpu_iv83);
  gpuEmxFree_int32_T(&l_gpu_cols);
  gpuEmxFree_int32_T(&j_gpu_cols);
  gpuEmxFree_int32_T(&h_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv94);
  gpuEmxFree_int32_T(&nc_gpu_rows);
  gpuEmxFree_int32_T(&yb_gpu_rows);
  gpuEmxFree_int32_T(&dd_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv86);
  gpuEmxFree_int32_T(&gpu_iv88);
  gpuEmxFree_int32_T(&gpu_iv98);
  gpuEmxFree_int32_T(&gpu_iv87);
  gpuEmxFree_int32_T(&gpu_iv89);
  gpuEmxFree_int32_T(&gpu_iv99);
  gpuEmxFree_int32_T(&mc_gpu_rows);
  gpuEmxFree_int32_T(&xb_gpu_rows);
  gpuEmxFree_int32_T(&kd_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv90);
  gpuEmxFree_int32_T(&gpu_iv91);
  gpuEmxFree_int32_T(&gd_gpu_rows);
  gpuEmxFree_int32_T(&tc_gpu_rows);
  gpuEmxFree_int32_T(&fc_gpu_rows);
  gpuEmxFree_int32_T(&ad_gpu_rows);
  gpuEmxFree_int32_T(&jc_gpu_rows);
  gpuEmxFree_int32_T(&ub_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv106);
  gpuEmxFree_int32_T(&gpu_iv96);
  gpuEmxFree_int32_T(&gpu_iv97);
  gpuEmxFree_int32_T(&jd_gpu_rows);
  gpuEmxFree_int32_T(&sc_gpu_rows);
  gpuEmxFree_int32_T(&ec_gpu_rows);
  gpuEmxFree_int32_T(&fd_gpu_rows);
  gpuEmxFree_int32_T(&pc_gpu_rows);
  gpuEmxFree_int32_T(&bc_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv107);
  gpuEmxFree_int32_T(&gpu_iv100);
  gpuEmxFree_int32_T(&gpu_iv102);
  gpuEmxFree_int32_T(&md_gpu_rows);
  gpuEmxFree_int32_T(&oc_gpu_rows);
  gpuEmxFree_int32_T(&ac_gpu_rows);
  gpuEmxFree_int32_T(&ld_gpu_rows);
  gpuEmxFree_int32_T(&vc_gpu_rows);
  gpuEmxFree_int32_T(&hc_gpu_rows);
  gpuEmxFree_real32_T(&xb_gpu_w);
  gpuEmxFree_int32_T(&uc_gpu_rows);
  gpuEmxFree_int32_T(&gc_gpu_rows);
  gpuEmxFree_real32_T(&bc_gpu_w);
  gpuEmxFree_real32_T(&qb_gpu_w);
  gpuEmxFree_real32_T(&hb_gpu_w);
  gpuEmxFree_real32_T(&yb_gpu_w);
  gpuEmxFree_real32_T(&nb_gpu_w);
  gpuEmxFree_real32_T(&eb_gpu_w);
  gpuEmxFree_real32_T(&xf_gpu_y);
  gpuEmxFree_real32_T(&tb_gpu_w);
  gpuEmxFree_real32_T(&kb_gpu_w);
  gpuEmxFree_real32_T(&cc_gpu_w);
  gpuEmxFree_real32_T(&rb_gpu_w);
  gpuEmxFree_real32_T(&ib_gpu_w);
  gpuEmxFree_real32_T(&ec_gpu_w);
  gpuEmxFree_real32_T(&ob_gpu_w);
  gpuEmxFree_real32_T(&fb_gpu_w);
  gpuEmxFree_real32_T(&mg_gpu_y);
  gpuEmxFree_real32_T(&if_gpu_y);
  gpuEmxFree_real32_T(&ie_gpu_y);
  gpuEmxFree_real32_T(&fc_gpu_w);
  gpuEmxFree_real32_T(&te_gpu_y);
  gpuEmxFree_real32_T(&td_gpu_y);
  gpuEmxFree_real32_T(&ub_gpu_w);
  gpuEmxFree_real32_T(&lb_gpu_w);
  checkCudaError(mwCudaFree(*gpu_csz), __FILE__, __LINE__);
  gpuEmxFree_real_T(&c_gpu_h);
  gpuEmxFree_real_T(&gpu_dv27);
  gpuEmxFree_real_T(&b_gpu_m);
  gpuEmxFree_real_T(&b_gpu_h1);
  gpuEmxFree_real_T(&b_gpu_k);
  gpuEmxFree_real_T(&b_gpu_G);
  gpuEmxFree_real32_T(&b_gpu_opts_filter);
  gpuEmxFree_real_T(&b_gpu_sinc1A);
  gpuEmxFree_real_T(&b_gpu_sinc2A);
  gpuEmxFree_real_T(&b_gpu_sinc3A);
  gpuEmxFree_real32_T(&d_gpu_h);
  gpuEmxFree_real_T(&b_gpu_sinc4A);
  gpuEmxFree_uint32_T(&n_gpu_y);
  gpuEmxFree_real_T(&b_gpu_b);
  gpuEmxFree_int32_T(&gpu_iv92);
  gpuEmxFree_real_T(&gpu_dv29);
  gpuEmxFree_real_T(&gpu_dv31);
  gpuEmxFree_real_T(&l_gpu_y);
  gpuEmxFree_real_T(&m_gpu_y);
  gpuEmxFree_creal32_T(&gpu_y1);
  gpuEmxFree_creal32_T(&gpu_xCol);
  gpuEmxFree_creal32_T(&i_gpu_yCol);
  gpuEmxFree_creal32_T(&c_gpu_yCol);
  gpuEmxFree_creal32_T(&p_gpu_yCol);
  gpuEmxFree_creal32_T(&k_gpu_yCol);
  gpuEmxFree_creal32_T(&e_gpu_yCol);
  gpuEmxFree_creal32_T(&r_gpu_yCol);
  gpuEmxFree_creal32_T(&g_gpu_yCol);
  gpuEmxFree_creal32_T(&gpu_yCol);
  gpuEmxFree_creal32_T(&w_gpu_w);
  gpuEmxFree_creal32_T(&m_gpu_w);
  gpuEmxFree_creal32_T(&d_gpu_w);
  gpuEmxFree_creal32_T(&n_gpu_yCol);
  gpuEmxFree_creal32_T(&p_gpu_w);
  gpuEmxFree_creal32_T(&g_gpu_w);
  gpuEmxFree_creal32_T(&ab_gpu_w);
  gpuEmxFree_creal32_T(&j_gpu_w);
  gpuEmxFree_creal32_T(&gpu_w);
  gpuEmxFree_real_T(&b_gpu_b0);
  gpuEmxFree_creal32_T(&h_gpu_c);
  gpuEmxFree_creal32_T(&f_gpu_c);
  gpuEmxFree_creal32_T(&d_gpu_c);
  gpuEmxFree_real_T(&e_gpu_a);
  gpuEmxFree_creal32_T(&t_gpu_w);
  gpuEmxFree_creal32_T(&j_gpu_a);
  gpuEmxFree_creal32_T(&g_gpu_a);
  gpuEmxFree_creal32_T(&l_gpu_a);
  gpuEmxFree_creal32_T(&g_gpu_c);
  gpuEmxFree_creal32_T(&e_gpu_c);
  gpuEmxFree_int32_T(&gpu_jpvt);
  gpuEmxFree_creal32_T(&i_gpu_c);
  gpuEmxFree_creal32_T(&k_gpu_a);
  gpuEmxFree_creal32_T(&h_gpu_a);
  gpuEmxFree_real_T(&gpu_tau);
  gpuEmxFree_creal32_T(&m_gpu_a);
  gpuEmxFree_creal32_T(&m_gpu_yCol);
  gpuEmxFree_creal32_T(&lb_gpu_expanded);
  gpuEmxFree_creal32_T(&s_gpu_w);
  gpuEmxFree_creal32_T(&i_gpu_a);
  gpuEmxFree_creal32_T(&f_gpu_a);
  gpuEmxFree_int32_T(&gpu_IPIV);
  gpuEmxFree_creal32_T(&nb_gpu_expanded);
  gpuEmxFree_creal32_T(&oc_gpu_y);
  gpuEmxFree_creal32_T(&s_gpu_expanded);
  gpuEmxFree_creal32_T(&c_gpu_expanded);
  gpuEmxFree_real32_T(&mb_gpu_expanded);
  gpuEmxFree_creal32_T(&ib_gpu_expanded);
  gpuEmxFree_creal32_T(&u_gpu_expanded);
  gpuEmxFree_creal32_T(&e_gpu_expanded);
  gpuEmxFree_int32_T(&yc_gpu_y);
  gpuEmxFree_real32_T(&hb_gpu_expanded);
  gpuEmxFree_real32_T(&t_gpu_expanded);
  gpuEmxFree_real32_T(&d_gpu_expanded);
  gpuEmxFree_int32_T(&bd_gpu_y);
  gpuEmxFree_int32_T(&rc_gpu_y);
  gpuEmxFree_int32_T(&ub_gpu_y);
  gpuEmxFree_int32_T(&u_gpu_y);
  gpuEmxFree_creal32_T(&sb_gpu_expanded);
  gpuEmxFree_int32_T(&qc_gpu_y);
  gpuEmxFree_creal32_T(&ab_gpu_expanded);
  gpuEmxFree_creal32_T(&j_gpu_expanded);
  gpuEmxFree_int32_T(&ad_gpu_y);
  gpuEmxFree_real_T(&pc_gpu_y);
  gpuEmxFree_int32_T(&wb_gpu_y);
  gpuEmxFree_int32_T(&w_gpu_y);
  gpuEmxFree_creal32_T(&ub_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv138);
  gpuEmxFree_int32_T(&vb_gpu_y);
  gpuEmxFree_int32_T(&v_gpu_y);
  gpuEmxFree_real32_T(&tb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv139);
  gpuEmxFree_creal32_T(&cb_gpu_expanded);
  gpuEmxFree_creal32_T(&l_gpu_expanded);
  gpuEmxFree_int32_T(&kd_gpu_y);
  gpuEmxFree_int32_T(&eb_gpu_rows);
  gpuEmxFree_real32_T(&bb_gpu_expanded);
  gpuEmxFree_real32_T(&k_gpu_expanded);
  gpuEmxFree_real_T(&g_gpu_x);
  gpuEmxFree_creal32_T(&e_gpu_result);
  gpuEmxFree_int32_T(&db_gpu_rows);
  gpuEmxFree_int32_T(&gc_gpu_y);
  gpuEmxFree_int32_T(&gb_gpu_y);
  gpuEmxFree_int32_T(&md_gpu_y);
  gpuEmxFree_creal32_T(&o_gpu_newIm);
  gpuEmxFree_int32_T(&ic_gpu_y);
  gpuEmxFree_int32_T(&ib_gpu_y);
  gpuEmxFree_creal32_T(&uc_gpu_y);
  gpuEmxFree_creal32_T(&c_gpu_result);
  gpuEmxFree_creal32_T(&gpu_result);
  gpuEmxFree_int32_T(&ld_gpu_y);
  gpuEmxFree_int32_T(&hc_gpu_y);
  gpuEmxFree_int32_T(&hb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv144);
  gpuEmxFree_creal32_T(&qb_gpu_y);
  gpuEmxFree_creal32_T(&q_gpu_y);
  gpuEmxFree_creal32_T(&f_gpu_result);
  gpuEmxFree_int32_T(&gpu_iv140);
  gpuEmxFree_int32_T(&gpu_iv141);
  gpuEmxFree_int32_T(&gpu_iv149);
  gpuEmxFree_creal32_T(&d_gpu_result);
  gpuEmxFree_creal32_T(&b_gpu_result);
  gpuEmxFree_creal32_T(&hd_gpu_y);
  gpuEmxFree_creal32_T(&dc_gpu_y);
  gpuEmxFree_creal32_T(&db_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv152);
  gpuEmxFree_int32_T(&gpu_iv142);
  gpuEmxFree_int32_T(&gpu_iv143);
  gpuEmxFree_creal32_T(&kb_gpu_expanded);
  gpuEmxFree_creal32_T(&r_gpu_expanded);
  gpuEmxFree_creal32_T(&b_gpu_expanded);
  gpuEmxFree_real32_T(&jb_gpu_expanded);
  gpuEmxFree_real32_T(&q_gpu_expanded);
  gpuEmxFree_real32_T(&gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv155);
  gpuEmxFree_int32_T(&gpu_iv145);
  gpuEmxFree_int32_T(&gpu_iv147);
  gpuEmxFree_int32_T(&cd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv146);
  gpuEmxFree_int32_T(&gpu_iv148);
  gpuEmxFree_int32_T(&xc_gpu_y);
  gpuEmxFree_int32_T(&tb_gpu_y);
  gpuEmxFree_int32_T(&t_gpu_y);
  gpuEmxFree_real_T(&vc_gpu_y);
  gpuEmxFree_int32_T(&xb_gpu_y);
  gpuEmxFree_int32_T(&x_gpu_y);
  gpuEmxFree_int32_T(&wc_gpu_y);
  gpuEmxFree_int32_T(&sb_gpu_y);
  gpuEmxFree_int32_T(&s_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv158);
  gpuEmxFree_int32_T(&gpu_iv150);
  gpuEmxFree_int32_T(&gpu_iv151);
  gpuEmxFree_int32_T(&gpu_iv159);
  gpuEmxFree_real_T(&rb_gpu_y);
  gpuEmxFree_real_T(&r_gpu_y);
  gpuEmxFree_int32_T(&nd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv153);
  gpuEmxFree_int32_T(&gpu_iv154);
  gpuEmxFree_creal32_T(&sc_gpu_y);
  gpuEmxFree_int32_T(&jc_gpu_y);
  gpuEmxFree_int32_T(&jb_gpu_y);
  gpuEmxFree_int32_T(&hb_gpu_rows);
  gpuEmxFree_creal32_T(&ob_gpu_y);
  gpuEmxFree_creal32_T(&o_gpu_y);
  gpuEmxFree_creal32_T(&pb_gpu_expanded);
  gpuEmxFree_int32_T(&q_gpu_rows);
  gpuEmxFree_int32_T(&c_gpu_rows);
  gpuEmxFree_real32_T(&ob_gpu_expanded);
  gpuEmxFree_real_T(&fc_gpu_y);
  gpuEmxFree_real_T(&fb_gpu_y);
  gpuEmxFree_real_T(&jd_gpu_y);
  gpuEmxFree_creal32_T(&w_gpu_expanded);
  gpuEmxFree_creal32_T(&g_gpu_expanded);
  gpuEmxFree_int32_T(&ed_gpu_y);
  gpuEmxFree_real32_T(&v_gpu_expanded);
  gpuEmxFree_real32_T(&f_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv167);
  gpuEmxFree_int32_T(&gpu_iv160);
  gpuEmxFree_int32_T(&gpu_iv161);
  gpuEmxFree_int32_T(&dd_gpu_y);
  gpuEmxFree_int32_T(&ac_gpu_y);
  gpuEmxFree_int32_T(&ab_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv168);
  gpuEmxFree_int32_T(&gpu_iv162);
  gpuEmxFree_int32_T(&gpu_iv163);
  gpuEmxFree_int32_T(&gpu_iv169);
  gpuEmxFree_int32_T(&w_gpu_rows);
  gpuEmxFree_int32_T(&i_gpu_rows);
  gpuEmxFree_int32_T(&nb_gpu_rows);
  gpuEmxFree_int32_T(&yb_gpu_y);
  gpuEmxFree_int32_T(&y_gpu_y);
  gpuEmxFree_creal32_T(&wb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv165);
  gpuEmxFree_int32_T(&gpu_iv166);
  gpuEmxFree_real32_T(&vb_gpu_expanded);
  gpuEmxFree_creal32_T(&eb_gpu_expanded);
  gpuEmxFree_creal32_T(&n_gpu_expanded);
  gpuEmxFree_creal32_T(&rb_gpu_expanded);
  gpuEmxFree_real32_T(&db_gpu_expanded);
  gpuEmxFree_real32_T(&m_gpu_expanded);
  gpuEmxFree_real32_T(&qb_gpu_expanded);
  gpuEmxFree_int32_T(&lc_gpu_y);
  gpuEmxFree_int32_T(&lb_gpu_y);
  gpuEmxFree_int32_T(&pd_gpu_y);
  gpuEmxFree_creal32_T(&y_gpu_expanded);
  gpuEmxFree_creal32_T(&i_gpu_expanded);
  gpuEmxFree_int32_T(&gd_gpu_y);
  gpuEmxFree_real32_T(&x_gpu_expanded);
  gpuEmxFree_real32_T(&h_gpu_expanded);
  gpuEmxFree_int32_T(&ib_gpu_rows);
  gpuEmxFree_int32_T(&kc_gpu_y);
  gpuEmxFree_int32_T(&kb_gpu_y);
  gpuEmxFree_int32_T(&od_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv170);
  gpuEmxFree_int32_T(&gpu_iv171);
  gpuEmxFree_int32_T(&gpu_iv176);
  gpuEmxFree_int32_T(&cc_gpu_y);
  gpuEmxFree_int32_T(&cb_gpu_y);
  gpuEmxFree_int32_T(&fd_gpu_y);
  gpuEmxFree_int32_T(&r_gpu_rows);
  gpuEmxFree_int32_T(&d_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv177);
  gpuEmxFree_int32_T(&bc_gpu_y);
  gpuEmxFree_int32_T(&bb_gpu_y);
  gpuEmxFree_int32_T(&e_gpu_cols);
  checkCudaError(mwCudaFree(gpu_f), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_f1), __FILE__, __LINE__);
  gpuEmxFree_creal32_T(&gb_gpu_expanded);
  gpuEmxFree_creal32_T(&p_gpu_expanded);
  gpuEmxFree_creal32_T(&yb_gpu_expanded);
  gpuEmxFree_real32_T(&fb_gpu_expanded);
  gpuEmxFree_real32_T(&o_gpu_expanded);
  gpuEmxFree_real32_T(&xb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv172);
  gpuEmxFree_int32_T(&gpu_iv173);
  gpuEmxFree_int32_T(&gpu_iv182);
  gpuEmxFree_int32_T(&c_gpu_cols);
  gpuEmxFree_int32_T(&gpu_cols);
  gpuEmxFree_int32_T(&fb_gpu_rows);
  gpuEmxFree_int32_T(&o_gpu_rows);
  gpuEmxFree_int32_T(&gpu_rows);
  gpuEmxFree_int32_T(&rd_gpu_y);
  gpuEmxFree_int32_T(&nc_gpu_y);
  gpuEmxFree_int32_T(&nb_gpu_y);
  gpuEmxFree_int32_T(&ob_gpu_rows);
  gpuEmxFree_int32_T(&x_gpu_rows);
  gpuEmxFree_int32_T(&j_gpu_rows);
  gpuEmxFree_int32_T(&qd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv174);
  gpuEmxFree_int32_T(&gpu_iv175);
  gpuEmxFree_int32_T(&kb_gpu_rows);
  gpuEmxFree_int32_T(&mc_gpu_y);
  gpuEmxFree_int32_T(&mb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv189);
  gpuEmxFree_int32_T(&gpu_iv178);
  gpuEmxFree_int32_T(&gpu_iv180);
  gpuEmxFree_int32_T(&f_gpu_cols);
  gpuEmxFree_int32_T(&d_gpu_cols);
  gpuEmxFree_int32_T(&b_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv190);
  gpuEmxFree_int32_T(&t_gpu_rows);
  gpuEmxFree_int32_T(&f_gpu_rows);
  gpuEmxFree_int32_T(&jb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv183);
  gpuEmxFree_int32_T(&gpu_iv185);
  gpuEmxFree_int32_T(&gpu_iv194);
  gpuEmxFree_int32_T(&gpu_iv184);
  gpuEmxFree_int32_T(&gpu_iv186);
  gpuEmxFree_int32_T(&gpu_iv195);
  gpuEmxFree_int32_T(&s_gpu_rows);
  gpuEmxFree_int32_T(&e_gpu_rows);
  gpuEmxFree_int32_T(&qb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv187);
  gpuEmxFree_int32_T(&gpu_iv188);
  gpuEmxFree_int32_T(&mb_gpu_rows);
  gpuEmxFree_int32_T(&ab_gpu_rows);
  gpuEmxFree_int32_T(&l_gpu_rows);
  gpuEmxFree_int32_T(&gb_gpu_rows);
  gpuEmxFree_int32_T(&p_gpu_rows);
  gpuEmxFree_int32_T(&b_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv202);
  gpuEmxFree_int32_T(&gpu_iv192);
  gpuEmxFree_int32_T(&gpu_iv193);
  gpuEmxFree_int32_T(&pb_gpu_rows);
  gpuEmxFree_int32_T(&y_gpu_rows);
  gpuEmxFree_int32_T(&k_gpu_rows);
  gpuEmxFree_int32_T(&lb_gpu_rows);
  gpuEmxFree_int32_T(&v_gpu_rows);
  gpuEmxFree_int32_T(&h_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv203);
  gpuEmxFree_int32_T(&gpu_iv196);
  gpuEmxFree_int32_T(&gpu_iv198);
  gpuEmxFree_int32_T(&sb_gpu_rows);
  gpuEmxFree_int32_T(&u_gpu_rows);
  gpuEmxFree_int32_T(&g_gpu_rows);
  gpuEmxFree_int32_T(&rb_gpu_rows);
  gpuEmxFree_int32_T(&cb_gpu_rows);
  gpuEmxFree_int32_T(&n_gpu_rows);
  gpuEmxFree_creal32_T(&q_gpu_newIm);
  gpuEmxFree_int32_T(&bb_gpu_rows);
  gpuEmxFree_int32_T(&m_gpu_rows);
  gpuEmxFree_creal32_T(&r_gpu_newIm);
  gpuEmxFree_creal32_T(&i_gpu_newIm);
  gpuEmxFree_creal32_T(&b_gpu_newIm);
  gpuEmxFree_creal32_T(&t_gpu_newIm);
  gpuEmxFree_creal32_T(&j_gpu_newIm);
  gpuEmxFree_creal32_T(&c_gpu_newIm);
  gpuEmxFree_creal32_T(&u_gpu_newIm);
  gpuEmxFree_creal32_T(&l_gpu_newIm);
  gpuEmxFree_creal32_T(&e_gpu_newIm);
  gpuEmxFree_creal32_T(&s_gpu_newIm);
  gpuEmxFree_creal32_T(&m_gpu_newIm);
  gpuEmxFree_creal32_T(&f_gpu_newIm);
  gpuEmxFree_creal32_T(&v_gpu_newIm);
  gpuEmxFree_creal32_T(&k_gpu_newIm);
  gpuEmxFree_creal32_T(&d_gpu_newIm);
  gpuEmxFree_creal32_T(&p_gpu_newIm);
  gpuEmxFree_creal32_T(&n_gpu_newIm);
  gpuEmxFree_creal32_T(&g_gpu_newIm);
  gpuEmxFree_creal32_T(&o_gpu_yCol);
  gpuEmxFree_creal32_T(&h_gpu_newIm);
  gpuEmxFree_creal32_T(&gpu_newIm);
  gpuEmxFree_creal32_T(&q_gpu_yCol);
  gpuEmxFree_creal32_T(&h_gpu_yCol);
  gpuEmxFree_creal32_T(&b_gpu_yCol);
  gpuEmxFree_creal32_T(&s_gpu_yCol);
  gpuEmxFree_creal32_T(&j_gpu_yCol);
  gpuEmxFree_creal32_T(&d_gpu_yCol);
  gpuEmxFree_creal32_T(&u_gpu_w);
  gpuEmxFree_creal32_T(&l_gpu_yCol);
  gpuEmxFree_creal32_T(&f_gpu_yCol);
  gpuEmxFree_creal32_T(&x_gpu_w);
  gpuEmxFree_creal32_T(&n_gpu_w);
  gpuEmxFree_creal32_T(&e_gpu_w);
  gpuEmxFree_creal32_T(&v_gpu_w);
  gpuEmxFree_creal32_T(&k_gpu_w);
  gpuEmxFree_creal32_T(&b_gpu_w);
  gpuEmxFree_creal32_T(&tc_gpu_y);
  gpuEmxFree_creal32_T(&q_gpu_w);
  gpuEmxFree_creal32_T(&h_gpu_w);
  gpuEmxFree_creal32_T(&y_gpu_w);
  gpuEmxFree_creal32_T(&o_gpu_w);
  gpuEmxFree_creal32_T(&f_gpu_w);
  gpuEmxFree_creal32_T(&bb_gpu_w);
  gpuEmxFree_creal32_T(&l_gpu_w);
  gpuEmxFree_creal32_T(&c_gpu_w);
  gpuEmxFree_creal32_T(&id_gpu_y);
  gpuEmxFree_creal32_T(&ec_gpu_y);
  gpuEmxFree_creal32_T(&eb_gpu_y);
  gpuEmxFree_creal32_T(&cb_gpu_w);
  gpuEmxFree_creal32_T(&pb_gpu_y);
  gpuEmxFree_creal32_T(&p_gpu_y);
  gpuEmxFree_creal32_T(&r_gpu_w);
  gpuEmxFree_creal32_T(&i_gpu_w);
}

void ec_wtcc_api(ec_wtccStackData *SD, const mxArray * const prhs[6], int32_T
                 nlhs, const mxArray *plhs[2])
{
  cell_wrap_0 xx[1];
  cell_wrap_0 yy[1];
  emxArray_real32_T *x;
  real32_T (*ds)[2];
  real32_T (*fLims)[2];
  real32_T fVoices;
  real32_T fs;
  uint16_T (*c)[2];
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  // Marshall function inputs
  emxInit_real32_T(&x, 2, &xe_emlrtRTEI, true);
  x->canFreeData = false;
  emlrt_marshallIn(emlrtAlias(prhs[0]), "x", x);
  c = b_emlrt_marshallIn(emlrtAlias(prhs[1]), "c");
  fs = c_emlrt_marshallIn(emlrtAliasP(prhs[2]), "fs");
  fLims = d_emlrt_marshallIn(emlrtAlias(prhs[3]), "fLims");
  fVoices = c_emlrt_marshallIn(emlrtAliasP(prhs[4]), "fVoices");
  ds = d_emlrt_marshallIn(emlrtAlias(prhs[5]), "ds");

  // Invoke the target function
  emxInitMatrix_cell_wrap_0(xx, &xe_emlrtRTEI, true);
  emxInitMatrix_cell_wrap_0(yy, &xe_emlrtRTEI, true);
  ec_wtcc(SD, x, *c, fs, *fLims, fVoices, *ds, xx, yy);
  emxFree_real32_T(&x);

  // Marshall function outputs
  plhs[0] = emlrt_marshallOut(xx);
  emxFreeMatrix_cell_wrap_0(xx);
  if (nlhs > 1) {
    plhs[1] = emlrt_marshallOut(yy);
  }

  emxFreeMatrix_cell_wrap_0(yy);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

void ec_wtcc_atexit()
{
  mexFunctionCreateRootTLS();
  try {
    emlrtPushHeapReferenceStackR2021a(emlrtRootTLSGlobal, false, nullptr, (void *)
      &emlrtExitTimeCleanupDtorFcn, nullptr, nullptr, nullptr);
    emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
    emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
    emlrtExitTimeCleanup(&emlrtContextGlobal);
  } catch (...) {
    emlrtCleanupOnException((emlrtCTX *)emlrtRootTLSGlobal);
    throw;
  }

  cusolverDestroyWorkspace();
  cusolverEnsureDestruction();
  mwCudaFree(*global_gpu_cv);
  mwCudaFree(*global_gpu_table100);
}

void ec_wtcc_initialize()
{
  emlrtInitGPU(emlrtRootTLSGlobal);
  cudaGetLastError();
  mexFunctionCreateRootTLS();
  emlrtClearAllocCountR2012b(emlrtRootTLSGlobal, false, 0U, nullptr);
  emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "distrib_computing_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "wavelet_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "signal_toolbox", 2);
  cublasEnsureInitialization(CUBLAS_POINTER_MODE_HOST);
  cusolverEnsureInitialization();
  if (emlrtFirstTimeR2012b(emlrtRootTLSGlobal)) {
    ec_wtcc_once();
  }
}

void ec_wtcc_terminate()
{
  cudaError_t errCode;
  errCode = cudaGetLastError();
  if (errCode != cudaSuccess) {
    emlrtThinCUDAError(static_cast<uint32_T>(errCode), (char_T *)
                       cudaGetErrorName(errCode), (char_T *)cudaGetErrorString
                       (errCode), (char_T *)"SafeBuild", emlrtRootTLSGlobal);
  }

  emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
  cublasEnsureDestruction();
}

// End of code generation (ec_wtcc.cu)
