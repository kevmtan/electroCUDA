//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// ec_cwt.cu
//
// Code generation for function 'ec_cwt'
//

// Include files
#include "ec_cwt.h"
#include "_coder_ec_cwt_mex.h"
#include "ec_cwt_types.h"
#include "rt_nonfinite.h"
#include "MWCUBLASUtils.hpp"
#include "MWCUFFTPlanManager.hpp"
#include "MWCUSOLVERUtils.hpp"
#include "MWCudaDimUtility.hpp"
#include "MWCudaMemoryFunctions.hpp"
#include "MWErrorCodeUtils.hpp"
#include "MWLaunchParametersUtilities.hpp"
#include "cufft.h"
#include "lapacke.h"
#include "math_constants.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include <algorithm>
#include <cfloat>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>

// Type Definitions
struct emxArray_int32_T
{
  int32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_creal_T
{
  creal_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_uint32_T
{
  uint32_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_ptrdiff_t
{
  ptrdiff_t *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

struct emxArray_char_T
{
  char_T *data;
  int32_T *size;
  int32_T allocatedSize;
  int32_T numDimensions;
  boolean_T canFreeData;
};

// Variable Definitions
emlrtCTX emlrtRootTLSGlobal{ nullptr };

emlrtContext emlrtContextGlobal{ true, // bFirstTime
  false,                               // bInitialized
  131643U,                             // fVersionInfo
  nullptr,                             // fErrorFunction
  "ec_cwt",                            // fFunctionName
  nullptr,                             // fRTCallStack
  false,                               // bDebugMode

  { 3334663369U, 2606893378U, 3553281593U, 3751928550U },// fSigWrd
  nullptr                              // fSigMem
};

static emlrtMCInfo emlrtMCI{ 53,       // lineNo
  14,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo b_emlrtMCI{ 55,     // lineNo
  15,                                  // colNo
  "nonConstPrint",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/strfun/sprintf.m"// pName
};

static emlrtMCInfo c_emlrtMCI{ 14,     // lineNo
  25,                                  // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtMCInfo d_emlrtMCI{ 14,     // lineNo
  9,                                   // colNo
  "warning",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/warning.m"// pName
};

static emlrtMCInfo e_emlrtMCI{ 53,     // lineNo
  19,                                  // colNo
  "flt2str",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/shared/coder/coder/lib/+coder/+internal/flt2str.m"// pName
};

static emlrtRTEInfo emlrtRTEI{ 999,    // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo b_emlrtRTEI{ 1000, // lineNo
  17,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo c_emlrtRTEI{ 1009, // lineNo
  13,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo d_emlrtRTEI{ 28,   // lineNo
  9,                                   // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo e_emlrtRTEI{ 129,  // lineNo
  6,                                   // colNo
  "applyBinaryScalarFunction",         // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyBinaryScalarFunction.m"// pName
};

static emlrtRTEInfo f_emlrtRTEI{ 23,   // lineNo
  1,                                   // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo g_emlrtRTEI{ 18,   // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo h_emlrtRTEI{ 60,   // lineNo
  20,                                  // colNo
  "bsxfun",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/bsxfun.m"// pName
};

static emlrtRTEInfo i_emlrtRTEI{ 18,   // lineNo
  5,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo j_emlrtRTEI{ 31,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo k_emlrtRTEI{ 30,   // lineNo
  21,                                  // colNo
  "applyScalarFunction",               // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/applyScalarFunction.m"// pName
};

static emlrtRTEInfo l_emlrtRTEI{ 33,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo m_emlrtRTEI{ 25,   // lineNo
  5,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo n_emlrtRTEI{ 31,   // lineNo
  23,                                  // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo o_emlrtRTEI{ 31,   // lineNo
  1,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo p_emlrtRTEI{ 34,   // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo q_emlrtRTEI{ 33,   // lineNo
  1,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo r_emlrtRTEI{ 956,  // lineNo
  13,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo s_emlrtRTEI{ 41,   // lineNo
  1,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo t_emlrtRTEI{ 25,   // lineNo
  1,                                   // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo u_emlrtRTEI{ 1,    // lineNo
  22,                                  // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo v_emlrtRTEI{ 135,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo w_emlrtRTEI{ 143,  // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo x_emlrtRTEI{ 1,    // lineNo
  1,                                   // colNo
  "cuFFTNDCallback",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/cuFFTNDCallback.p"// pName
};

static emlrtRTEInfo y_emlrtRTEI{ 138,  // lineNo
  19,                                  // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo ab_emlrtRTEI{ 138, // lineNo
  6,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo bb_emlrtRTEI{ 161, // lineNo
  1,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo cb_emlrtRTEI{ 180, // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo db_emlrtRTEI{ 37,  // lineNo
  5,                                   // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo eb_emlrtRTEI{ 43,  // lineNo
  9,                                   // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo fb_emlrtRTEI{ 154, // lineNo
  1,                                   // colNo
  "resample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/resample.m"// pName
};

static emlrtRTEInfo gb_emlrtRTEI{ 37,  // lineNo
  20,                                  // colNo
  "kaiser",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/kaiser.m"// pName
};

static emlrtRTEInfo hb_emlrtRTEI{ 816, // lineNo
  63,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ib_emlrtRTEI{ 245, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo jb_emlrtRTEI{ 243, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo kb_emlrtRTEI{ 816, // lineNo
  17,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo lb_emlrtRTEI{ 247, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo mb_emlrtRTEI{ 258, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo nb_emlrtRTEI{ 274, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ob_emlrtRTEI{ 275, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo pb_emlrtRTEI{ 276, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo qb_emlrtRTEI{ 777, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo rb_emlrtRTEI{ 277, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo sb_emlrtRTEI{ 286, // lineNo
  5,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo tb_emlrtRTEI{ 778, // lineNo
  15,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ub_emlrtRTEI{ 281, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo vb_emlrtRTEI{ 341, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo wb_emlrtRTEI{ 347, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo xb_emlrtRTEI{ 345, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo yb_emlrtRTEI{ 76,  // lineNo
  9,                                   // colNo
  "eml_mtimes_helper",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static emlrtRTEInfo ac_emlrtRTEI{ 38,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo bc_emlrtRTEI{ 21,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo cc_emlrtRTEI{ 341, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo dc_emlrtRTEI{ 31,  // lineNo
  29,                                  // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo ec_emlrtRTEI{ 41,  // lineNo
  9,                                   // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo fc_emlrtRTEI{ 61,  // lineNo
  9,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo gc_emlrtRTEI{ 27,  // lineNo
  23,                                  // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo hc_emlrtRTEI{ 49,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo ic_emlrtRTEI{ 47,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo jc_emlrtRTEI{ 1,   // lineNo
  21,                                  // colNo
  "flipud",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/elmat/flipud.m"// pName
};

static emlrtRTEInfo kc_emlrtRTEI{ 92,  // lineNo
  22,                                  // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo lc_emlrtRTEI{ 91,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo mc_emlrtRTEI{ 105, // lineNo
  1,                                   // colNo
  "xgeqp3",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+lapack/xgeqp3.m"// pName
};

static emlrtRTEInfo nc_emlrtRTEI{ 161, // lineNo
  9,                                   // colNo
  "resample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/resample.m"// pName
};

static emlrtRTEInfo oc_emlrtRTEI{ 68,  // lineNo
  9,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo pc_emlrtRTEI{ 353, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo qc_emlrtRTEI{ 355, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo rc_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "upfirdnGPUImpl",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+codegenable/+gpu/upfirdnGPUImpl.p"// pName
};

static emlrtRTEInfo sc_emlrtRTEI{ 119, // lineNo
  5,                                   // colNo
  "qrsolve",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/qrsolve.m"// pName
};

static emlrtRTEInfo tc_emlrtRTEI{ 49,  // lineNo
  31,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo uc_emlrtRTEI{ 71,  // lineNo
  5,                                   // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo vc_emlrtRTEI{ 158, // lineNo
  24,                                  // colNo
  "mtimes",                            // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/eml/+coder/+internal/+blas/mtimes.m"// pName
};

static emlrtRTEInfo wc_emlrtRTEI{ 75,  // lineNo
  5,                                   // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo xc_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "stencil_codegen",                   // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+gpucoder/+internal/stencil_codegen.p"// pName
};

static emlrtRTEInfo ad_emlrtRTEI{ 172, // lineNo
  20,                                  // colNo
  "colon",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/ops/colon.m"// pName
};

static emlrtRTEInfo bd_emlrtRTEI{ 91,  // lineNo
  14,                                  // colNo
  "downsample",                        // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/downsample.m"// pName
};

static emlrtRTEInfo cd_emlrtRTEI{ 83,  // lineNo
  13,                                  // colNo
  "upfirdn",                           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/eml/upfirdn.m"// pName
};

static emlrtRTEInfo dd_emlrtRTEI{ 17,  // lineNo
  5,                                   // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo ed_emlrtRTEI{ 13,  // lineNo
  1,                                   // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo fd_emlrtRTEI{ 1276,// lineNo
  30,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo gd_emlrtRTEI{ 1276,// lineNo
  25,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo hd_emlrtRTEI{ 16,  // lineNo
  5,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo id_emlrtRTEI{ 16,  // lineNo
  5,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo jd_emlrtRTEI{ 26,  // lineNo
  9,                                   // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo kd_emlrtRTEI{ 21,  // lineNo
  1,                                   // colNo
  "morsebpfilters",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/morsebpfilters.m"// pName
};

static emlrtRTEInfo ld_emlrtRTEI{ 34,  // lineNo
  42,                                  // colNo
  "wavbpfilters",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/wavbpfilters.m"// pName
};

static emlrtRTEInfo md_emlrtRTEI{ 32,  // lineNo
  18,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo nd_emlrtRTEI{ 32,  // lineNo
  13,                                  // colNo
  "getCWTScales",                      // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/+wavelet/+internal/+cwt/getCWTScales.m"// pName
};

static emlrtRTEInfo od_emlrtRTEI{ 934, // lineNo
  26,                                  // colNo
  "cwtfilterbank",                     // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/cwtfilterbank.m"// pName
};

static emlrtRTEInfo pd_emlrtRTEI{ 151, // lineNo
  5,                                   // colNo
  "wt",                                // fName
  "/usr/local/MATLAB/R2024a/toolbox/wavelet/wavelet/@cwtfilterbank/wt.m"// pName
};

static emlrtRTEInfo qd_emlrtRTEI{ 37,  // lineNo
  11,                                  // colNo
  "ec_cwt",                            // fName
  "/home/kt/Gdrive/Git/electroCUDA/src/cuda/ec_cwt.m"// pName
};

static emlrtRTEInfo rd_emlrtRTEI{ 816, // lineNo
  22,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo sd_emlrtRTEI{ 253, // lineNo
  20,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo td_emlrtRTEI{ 274, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ud_emlrtRTEI{ 275, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo vd_emlrtRTEI{ 276, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo wd_emlrtRTEI{ 778, // lineNo
  27,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo xd_emlrtRTEI{ 277, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo yd_emlrtRTEI{ 778, // lineNo
  13,                                  // colNo
  "ResampleParser",                    // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/ResampleParser.m"// pName
};

static emlrtRTEInfo ae_emlrtRTEI{ 15,  // lineNo
  9,                                   // colNo
  "uniformResampleKernel",             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformResampleKernel.m"// pName
};

static emlrtRTEInfo be_emlrtRTEI{ 295, // lineNo
  33,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ce_emlrtRTEI{ 355, // lineNo
  17,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo de_emlrtRTEI{ 297, // lineNo
  46,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ee_emlrtRTEI{ 27,  // lineNo
  1,                                   // colNo
  "xgetrfs_gpu",                       // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+lapack/xgetrfs_gpu.m"// pName
};

static emlrtRTEInfo fe_emlrtRTEI{ 88,  // lineNo
  5,                                   // colNo
  "upsample",                          // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/upsample.m"// pName
};

static emlrtRTEInfo ge_emlrtRTEI{ 298, // lineNo
  39,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo he_emlrtRTEI{ 49,  // lineNo
  13,                                  // colNo
  "conv2",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/eml/lib/matlab/datafun/conv2.m"// pName
};

static emlrtRTEInfo ie_emlrtRTEI{ 22,  // lineNo
  23,                                  // colNo
  "uniformScalarVectorCore",           // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformScalarVectorCore.m"// pName
};

static emlrtRTEInfo je_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "gpu_conv2_kernel",                  // fName
  "/usr/local/MATLAB/R2024a/toolbox/gpucoder/gpucoder/+coder/+internal/+images/gpu_conv2_kernel.p"// pName
};

static emlrtRTEInfo ke_emlrtRTEI{ 14,  // lineNo
  15,                                  // colNo
  "uniformMatrixCore",                 // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/+signal/+internal/+resample/uniformMatrixCore.m"// pName
};

static emlrtRTEInfo le_emlrtRTEI{ 1,   // lineNo
  1,                                   // colNo
  "_coder_ec_cwt_api",                 // fName
  ""                                   // pName
};

static emlrtRTEInfo me_emlrtRTEI{ 297, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo ne_emlrtRTEI{ 297, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo oe_emlrtRTEI{ 295, // lineNo
  13,                                  // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static emlrtRTEInfo pe_emlrtRTEI{ 295, // lineNo
  9,                                   // colNo
  "firls",                             // fName
  "/usr/local/MATLAB/R2024a/toolbox/signal/signal/firls.m"// pName
};

static char_T (*global_gpu_cv)[128];
static real_T (*global_gpu_table100)[100];
static boolean_T gpuConstsCopied_ec_cwt;

// Function Declarations
static int64_T b_computeEndIdx(int64_T start, int64_T end, int64_T stride);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real_T *ret);
static real_T (*b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2];
static real_T (*b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId))[2];
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23]);
static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret);
static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location);
static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString);
static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location);
static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5);
static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5);
static void binary_expand_op_2(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3);
static void binary_expand_op_3(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3);
static void binary_expand_op_4(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3);
static void binary_expand_op_5(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2]);
static real_T c_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId);
static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line);
namespace coder
{
  namespace internal
  {
    static void warning();
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride);
static uint64_T computeNumIters(int32_T ub);
static uint64_T computeNumIters(int32_T ub, int32_T b_ub);
static uint64_T computeNumIters(int64_T ub);
static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line);
static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line);
static real_T (*d_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId))[2];
static int32_T div_s32(int32_T numerator, int32_T denominator);
static
#ifdef __CUDACC__

__device__
#endif

int32_T div_s32_device(int32_T numerator, int32_T denominator);
static __global__ void ec_cwt_kernel1(creal_T *dc1, creal_T *dc6);
static __global__ void ec_cwt_kernel10(emxArray_real_T fb_Omega);
static __global__ void ec_cwt_kernel100(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel101(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel102(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel103(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel104(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel105(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel106(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel107(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel108(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel109(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel11(const emxArray_real_T omega_tmp2, const
  int32_T b, emxArray_real_T fb_Omega);
static __global__ void ec_cwt_kernel110(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv32);
static __global__ void ec_cwt_kernel111(const emxArray_real_T a, const
  emxArray_int32_T iv32, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel112(const real_T q_ok, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel113(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel114(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel115(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel116(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel117(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv34);
static __global__ void ec_cwt_kernel118(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv34, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel119(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel12(const int32_T nrefine, const int32_T lidx,
  const emxArray_real_T omega_tmp2, const int32_T dim, emxArray_real_T fb_Omega,
  int32_T omega_tmp2_dim1);
static __global__ void ec_cwt_kernel120(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel121(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel122(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel123(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel124(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv39);
static __global__ void ec_cwt_kernel125(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv57);
static __global__ void ec_cwt_kernel126(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv57, const emxArray_int32_T iv39,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel127(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel13(emxArray_real_T y);
static __global__ void ec_cwt_kernel14(const emxArray_real_T y, const real_T s,
  const int32_T b, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel15(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_cwt_kernel156(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel157(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel158(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel159(emxArray_real_T w);
static __global__ void ec_cwt_kernel16(const emxArray_real_T somega, const
  int32_T b, emxArray_real_T absomega);
static __global__ void ec_cwt_kernel160(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel161(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel162(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel163(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel164(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel165(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel166(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y, int32_T y_dim0);
static __global__ void ec_cwt_kernel167(const emxArray_real_T y, const int32_T
  b_y, emxArray_real_T c_y);
static __global__ void ec_cwt_kernel168(emxArray_real_T y);
static __global__ void ec_cwt_kernel169(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T c_y, const int32_T b,
  emxArray_real_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_cwt_kernel17(const emxArray_real_T absomega, const
  int32_T b_absomega, emxArray_real_T powscales);
static __global__ void ec_cwt_kernel170(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel171(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel172(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel173(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel174(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel175(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel176(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv38);
static __global__ void ec_cwt_kernel177(const emxArray_real_T a, const
  emxArray_int32_T iv38, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel178(const real_T r, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel179(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel18(const int32_T b, emxArray_real_T absomega);
static __global__ void ec_cwt_kernel180(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel181(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel182(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel183(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv42);
static __global__ void ec_cwt_kernel184(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv42, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel185(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel186(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel187(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel188(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel189(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel19(const emxArray_real_T powscales, const
  emxArray_real_T absomega, const int32_T b_absomega, emxArray_real_T x);
static __global__ void ec_cwt_kernel190(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv45);
static __global__ void ec_cwt_kernel191(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv62);
static __global__ void ec_cwt_kernel192(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv62, const emxArray_int32_T iv45,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel193(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel2(const char_T cv[128], char_T wname[5],
  char_T wav[5], char_T b_dim0, char_T b_dim1, char_T b_dim2, char_T b_dim3,
  char_T b_dim4);
static __global__ void ec_cwt_kernel20(const int32_T b, emxArray_real_T x);
static __global__ void ec_cwt_kernel21(const emxArray_real_T somega, const
  emxArray_real_T x, const int32_T b_x, emxArray_real_T daughter);
static __global__ void ec_cwt_kernel22(const emxArray_real_T fb_Scales, const
  int32_T b_fb_Scales, emxArray_real_T f);
static __global__ void ec_cwt_kernel222(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel223(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel224(const real_T cf, int32_T csz[2]);
static __global__ void ec_cwt_kernel225(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel226(const emxArray_real_T h, const
  emxArray_real_T yCol, real_T *r, emxArray_real_T a);
static __global__ void ec_cwt_kernel227(const real_T *r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel228(const emxArray_real_T c, emxArray_real_T
  w);
static __global__ void ec_cwt_kernel229(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel23(const real_T fs, const int32_T i,
  emxArray_real_T f);
static __global__ void ec_cwt_kernel230(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel231(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel232(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel233(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel234(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel235(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel236(const emxArray_real_T y, const int32_T
  xt_size, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel237(emxArray_real_T y);
static __global__ void ec_cwt_kernel238(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T b, emxArray_real_T opts_x);
static __global__ void ec_cwt_kernel239(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel24(const emxArray_real_T f, const int32_T
  b_f, emxArray_real_T freqs);
static __global__ void ec_cwt_kernel240(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel241(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel242(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel243(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel244(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv51);
static __global__ void ec_cwt_kernel245(const emxArray_real_T h, const
  emxArray_int32_T iv51, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel246(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel247(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel248(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel249(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel25(const int32_T y_size_idx_1, const
  emxArray_real_T x, const int32_T b_x, emxArray_real_T xv, int32_T x_dim0);
static __global__ void ec_cwt_kernel250(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel251(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv53);
static __global__ void ec_cwt_kernel252(const emxArray_real_T yCol, const
  emxArray_int32_T iv53, const int32_T xt_size, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel253(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b,
  emxArray_real_T w, int32_T h_dim0);
static __global__ void ec_cwt_kernel254(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel255(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel256(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel257(emxArray_real_T w);
static __global__ void ec_cwt_kernel258(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel259(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel26(const int32_T y_size_idx_1, const
  emxArray_real_T x, const int32_T b, emxArray_real_T b_x, int32_T x_dim0);
static __global__ void ec_cwt_kernel260(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel261(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel262(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel263(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel264(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel265(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel266(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel267(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel268(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel269(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv31);
static __global__ void ec_cwt_kernel27(const int32_T fb_SignalPad, const int32_T
  b, emxArray_real_T x);
static __global__ void ec_cwt_kernel270(const emxArray_real_T a, const
  emxArray_int32_T iv31, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel271(const real_T q_ok, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel272(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel273(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel274(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel275(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel276(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv33);
static __global__ void ec_cwt_kernel277(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv33, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel278(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel279(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel28(const emxArray_real_T x, const int32_T b,
  emxArray_real_T xv);
static __global__ void ec_cwt_kernel280(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel281(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel282(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel283(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv37);
static __global__ void ec_cwt_kernel284(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv56);
static __global__ void ec_cwt_kernel285(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv56, const emxArray_int32_T iv37,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel286(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel29(const emxArray_real_T xv, const int32_T
  b_xv, emxArray_creal_T xposdft);
static __global__ void ec_cwt_kernel3(real_T interval[650]);
static __global__ void ec_cwt_kernel30(const emxArray_creal_T xposdft, const
  emxArray_real_T daughter, const int32_T lidx, const int32_T cfsposdft, const
  int32_T nw, emxArray_creal_T b_cfsposdft, int32_T daughter_dim0, int32_T
  cfsposdft_dim0);
static __global__ void ec_cwt_kernel31(const int32_T xSize, emxArray_creal_T
  cfspos);
static __global__ void ec_cwt_kernel315(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel316(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel317(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel318(emxArray_real_T w);
static __global__ void ec_cwt_kernel319(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel32(const emxArray_creal_T cfspos, const
  int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel320(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel321(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel322(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel323(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel324(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel325(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y, int32_T y_dim0);
static __global__ void ec_cwt_kernel326(const emxArray_real_T y, const int32_T
  b_y, emxArray_real_T c_y);
static __global__ void ec_cwt_kernel327(emxArray_real_T y);
static __global__ void ec_cwt_kernel328(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T c_y, const int32_T b,
  emxArray_real_T opts_x, int32_T opts_x_dim0, int32_T y_dim0);
static __global__ void ec_cwt_kernel329(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel33(const emxArray_real_T y, const int32_T
  b_y, const int32_T c_y, emxArray_real_T xCh, int32_T xCh_dim0, int32_T y_dim0);
static __global__ void ec_cwt_kernel330(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel331(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel332(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel333(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel334(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel335(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv36);
static __global__ void ec_cwt_kernel336(const emxArray_real_T a, const
  emxArray_int32_T iv36, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel337(const real_T r, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel338(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel339(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel34(const emxArray_real_T xCh, const int32_T
  b, emxArray_real_T opts_x);
static __global__ void ec_cwt_kernel340(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel341(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel342(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv41);
static __global__ void ec_cwt_kernel343(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv41, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel344(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel345(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel346(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel347(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel348(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel349(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv44);
static __global__ void ec_cwt_kernel35(const int32_T b, emxArray_real_T m);
static __global__ void ec_cwt_kernel350(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv61);
static __global__ void ec_cwt_kernel351(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv61, const emxArray_int32_T iv44,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel352(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel36(const emxArray_real_T m, const int32_T
  b_m, emxArray_real_T k);
static __global__ void ec_cwt_kernel37(const int32_T k, emxArray_real_T G);
static __global__ void ec_cwt_kernel38(const int32_T k, emxArray_real_T b);
static __global__ void ec_cwt_kernel381(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel382(const emxArray_real_T opts_x, const
  int32_T nx, const int32_T i36, const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel383(const emxArray_real_T h, const
  emxArray_real_T yCol, emxArray_real_T w);
static __global__ void ec_cwt_kernel384(const emxArray_real_T w, const int32_T
  nrefine, const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel385(emxArray_real_T y);
static __global__ void ec_cwt_kernel386(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T nx, const int32_T b,
  emxArray_real_T b_y1, int32_T y1_dim0);
static __global__ void ec_cwt_kernel387(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel388(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel389(const emxArray_real_T yCol, real_T *r);
static __global__ void ec_cwt_kernel39(const real_T tol, const emxArray_real_T k,
  const int32_T b_k, emxArray_real_T dv20);
static __global__ void ec_cwt_kernel390(const real_T *r, const emxArray_real_T h,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel391(const int32_T b, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel392(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv30);
static __global__ void ec_cwt_kernel393(const emxArray_real_T h, const
  emxArray_int32_T iv30, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel394(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T rows, const real_T cf, const
  int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel395(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel396(const emxArray_real_T h, const
  emxArray_real_T yCol, emxArray_real_T w);
static __global__ void ec_cwt_kernel397(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel398(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv29);
static __global__ void ec_cwt_kernel399(const emxArray_real_T yCol, const
  emxArray_int32_T iv29, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel4(real_T interval[650]);
static __global__ void ec_cwt_kernel40(const real_T tol, const emxArray_real_T k,
  const int32_T b, emxArray_real_T dv21, emxArray_real_T dv20);
static __global__ void ec_cwt_kernel400(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b,
  emxArray_real_T w, int32_T h_dim0);
static __global__ void ec_cwt_kernel401(const emxArray_real_T b_y1, const
  int32_T xCh, emxArray_real_T opts_x);
static __global__ void ec_cwt_kernel402(const emxArray_real_T b_y1, const
  int32_T c_y1, const int32_T d_y1, emxArray_real_T opts_x, int32_T opts_x_dim0,
  int32_T y1_dim0);
static __global__ void ec_cwt_kernel403(const emxArray_real_T opts_x, const
  int32_T b_opts_x, emxArray_real_T b_y1);
static __global__ void ec_cwt_kernel404(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel405(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel406(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T x);
static __global__ void ec_cwt_kernel407(const emxArray_real_T h, const
  emxArray_real_T yCol, emxArray_real_T w);
static __global__ void ec_cwt_kernel408(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel409(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel41(const int32_T b, emxArray_real_T dv21);
static __global__ void ec_cwt_kernel410(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel411(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel412(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel413(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel414(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel415(const emxArray_real_T y, const int32_T
  xt_size, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel416(emxArray_real_T y);
static __global__ void ec_cwt_kernel417(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T b, emxArray_real_T b_y1);
static __global__ void ec_cwt_kernel418(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel419(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel42(const emxArray_real_T k, const
  emxArray_real_T dv21, const emxArray_real_T dv20, const real_T a, const
  int32_T b, emxArray_real_T b_b);
static __global__ void ec_cwt_kernel420(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel421(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel422(const int32_T b, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel423(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv58);
static __global__ void ec_cwt_kernel424(const emxArray_real_T h, const
  emxArray_int32_T iv58, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel425(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T rows, const real_T cf, const
  int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel426(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel427(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel428(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel429(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel43(const real_T tol, const emxArray_real_T k,
  const int32_T b_k, emxArray_real_T y);
static __global__ void ec_cwt_kernel430(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv60);
static __global__ void ec_cwt_kernel431(const emxArray_real_T yCol, const
  emxArray_int32_T iv60, const int32_T xt_size, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel432(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b,
  emxArray_real_T w, int32_T h_dim0);
static __global__ void ec_cwt_kernel433(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel434(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel435(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel436(emxArray_real_T w);
static __global__ void ec_cwt_kernel437(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel438(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel439(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel44(const real_T tol, const emxArray_real_T k,
  const int32_T b, emxArray_real_T y, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel440(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel441(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel442(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel443(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel444(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel445(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel446(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel447(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel448(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv35);
static __global__ void ec_cwt_kernel449(const emxArray_real_T a, const
  emxArray_int32_T iv35, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel45(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel450(const real_T q_ok, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel451(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel452(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel453(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel454(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel455(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv40);
static __global__ void ec_cwt_kernel456(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv40, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel457(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel458(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel459(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel46(const emxArray_real_T y, const real_T r,
  const emxArray_real_T b_y, const real_T a, const int32_T b, emxArray_real_T
  b_b);
static __global__ void ec_cwt_kernel460(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel461(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel462(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv43);
static __global__ void ec_cwt_kernel463(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv59);
static __global__ void ec_cwt_kernel464(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv59, const emxArray_int32_T iv43,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel465(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel47(const real_T r, const real_T b_r, const
  int32_T lidx, const int32_T nsubs, const int32_T b, emxArray_real_T sinc4A,
  emxArray_real_T sinc3A, emxArray_real_T sinc2A, emxArray_real_T sinc1A);
static __global__ void ec_cwt_kernel48(const emxArray_real_T sinc4A, const
  emxArray_real_T sinc2A, const real_T r, const emxArray_real_T sinc3A, const
  emxArray_real_T sinc1A, const real_T b_r, const int32_T lidx, const int32_T b,
  const int32_T c, emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_cwt_kernel49(const real_T intDsq, emxArray_real_T b0);
static __global__ void ec_cwt_kernel494(const emxArray_real_T opts_x, const
  int32_T b_opts_x, emxArray_real_T xCol);
static __global__ void ec_cwt_kernel495(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel496(const emxArray_real_T xCol, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel497(const emxArray_real_T yCol, const
  int32_T csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel498(emxArray_real_T w);
static __global__ void ec_cwt_kernel499(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel5(const int32_T ix, real_T interval[650]);
static __global__ void ec_cwt_kernel50(const emxArray_real_T b, const int32_T c,
  emxArray_real_T b0);
static __global__ void ec_cwt_kernel500(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel501(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel502(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel503(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel504(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel505(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y, int32_T y_dim0);
static __global__ void ec_cwt_kernel506(const emxArray_real_T y, const int32_T
  b_y, emxArray_real_T c_y);
static __global__ void ec_cwt_kernel507(emxArray_real_T y);
static __global__ void ec_cwt_kernel508(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T c_y, const int32_T b,
  emxArray_real_T b_y1, int32_T y1_dim0, int32_T y_dim0);
static __global__ void ec_cwt_kernel509(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel51(const emxArray_real_T b0, const int32_T
  b_b0, emxArray_real_T b);
static __global__ void ec_cwt_kernel510(const emxArray_real_T yCol, const
  int32_T b, emxArray_real_T a);
static __global__ void ec_cwt_kernel511(const int32_T a, emxArray_real_T c);
static __global__ void ec_cwt_kernel512(const real_T r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel513(const emxArray_real_T c, const int32_T
  b_c, emxArray_real_T w, int32_T w_dim0);
static __global__ void ec_cwt_kernel514(const int32_T a, emxArray_real_T
  expanded);
static __global__ void ec_cwt_kernel515(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv46);
static __global__ void ec_cwt_kernel516(const emxArray_real_T a, const
  emxArray_int32_T iv46, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel517(const real_T r, const emxArray_real_T
  expanded, const int32_T b, emxArray_real_T c);
static __global__ void ec_cwt_kernel518(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel519(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel52(const int32_T G, emxArray_real_T a);
static __global__ void ec_cwt_kernel520(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel521(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel522(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv49);
static __global__ void ec_cwt_kernel523(const emxArray_real_T h, const int32_T
  nrefine, const emxArray_int32_T iv49, const int32_T omega_tmp2,
  emxArray_real_T expanded, int32_T expanded_dim0);
static __global__ void ec_cwt_kernel524(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T cols, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, const int32_T c, emxArray_real_T
  w, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel525(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel526(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel527(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel528(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel529(const int32_T dim, const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv50);
static __global__ void ec_cwt_kernel53(const emxArray_real_T a, const int32_T
  lidx, const int32_T nrefine, const int32_T dim, emxArray_real_T h);
static __global__ void ec_cwt_kernel530(const emxArray_int32_T y, const int32_T
  b_y, emxArray_int32_T iv67);
static __global__ void ec_cwt_kernel531(const emxArray_real_T yCol, const
  int32_T xt_size_dim0, const emxArray_int32_T iv67, const emxArray_int32_T iv50,
  const int32_T xt_size, const int32_T b_xt_size, emxArray_real_T expanded,
  int32_T expanded_dim0);
static __global__ void ec_cwt_kernel532(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b, const int32_T
  c, emxArray_real_T w, int32_T h_dim0, int32_T expanded_dim0, int32_T w_dim0);
static __global__ void ec_cwt_kernel54(const emxArray_real_T a, const int32_T
  lidx, const int32_T nrefine, const int32_T nw, emxArray_real_T h);
static __global__ void ec_cwt_kernel55(const int32_T b, emxArray_real_T dv18);
static __global__ void ec_cwt_kernel56(const emxArray_real_T dv18, const
  emxArray_real_T h, const int32_T b_h, emxArray_real_T h1);
static __global__ void ec_cwt_kernel561(const emxArray_real_T opts_x, const
  int32_T b_opts_x, emxArray_real_T xCol);
static __global__ void ec_cwt_kernel562(const int32_T b, emxArray_uint32_T y);
static __global__ void ec_cwt_kernel563(const creal_T *dc6, const real_T
  table100[100], const creal_T dc7, const creal_T *dc1, const int32_T nw, const
  int32_T lidx, const int32_T nrefine, const int32_T i, const int64_T b,
  emxArray_real_T dv18, real_T q1_dim0, real_T q1_dim1, real_T q1_dim2, real_T
  q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6, real_T q1_dim7,
  real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3, real_T p1_dim4,
  real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0, real_T q2_dim1,
  real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5, real_T q2_dim6,
  real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2, real_T p2_dim3,
  real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7, real_T q4_dim0,
  real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4, real_T q4_dim5,
  real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1, real_T p4_dim2,
  real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6, real_T p4_dim7,
  real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3, real_T c_dim4,
  real_T c_dim5, real_T c_dim6);
static __global__ void ec_cwt_kernel564(const emxArray_real_T a, const int32_T
  b_a, emxArray_real_T x);
static __global__ void ec_cwt_kernel565(const emxArray_real_T x, const int32_T b,
  emxArray_real_T h);
static __global__ void ec_cwt_kernel566(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_cwt_kernel567(const int32_T omega_tmp2,
  emxArray_real_T a);
static __global__ void ec_cwt_kernel568(const int32_T G, emxArray_int32_T jpvt);
static __global__ void ec_cwt_kernel569(const int32_T b, const int32_T nsubs,
  emxArray_real_T G, int32_T G_dim0);
static __global__ void ec_cwt_kernel57(const real_T r, const emxArray_real_T h1,
  const real_T cf, const int32_T b_h1, emxArray_real_T opts_filter);
static __global__ void ec_cwt_kernel570(const int32_T b, emxArray_real_T tau);
static __global__ void ec_cwt_kernel571(const int32_T i, const int64_T b,
  emxArray_real_T tau);
static __global__ void ec_cwt_kernel572(const int32_T nsubs, emxArray_int32_T
  jpvt);
static __global__ void ec_cwt_kernel573(const int32_T G, emxArray_real_T a);
static __global__ void ec_cwt_kernel574(const int32_T omega_tmp2,
  emxArray_real_T b);
static __global__ void ec_cwt_kernel575(const emxArray_real_T b, const
  emxArray_int32_T jpvt, const int32_T nsubs, emxArray_real_T a);
static __global__ void ec_cwt_kernel576(const emxArray_real_T b, const int32_T
  b_b, emxArray_real_T a);
static __global__ void ec_cwt_kernel577(emxArray_real_T a);
static __global__ void ec_cwt_kernel578(const int32_T b, emxArray_real_T m);
static __global__ void ec_cwt_kernel579(const emxArray_real_T xCh, const int32_T
  b_xCh, emxArray_real_T opts_x);
static __global__ void ec_cwt_kernel58(const int32_T halfh, emxArray_real_T h);
static __global__ void ec_cwt_kernel580(const emxArray_real_T xCh, const int32_T
  b_xCh, const int32_T c_xCh, emxArray_real_T opts_x, int32_T opts_x_dim0,
  int32_T xCh_dim0);
static __global__ void ec_cwt_kernel581(const real_T cfsposdft_re, const
  emxArray_creal_T cfsposdft, const int32_T b_cfsposdft, emxArray_creal_T cfspos);
static __global__ void ec_cwt_kernel582(const int32_T b, emxArray_creal_T
  xposdft, uint32_T xSize_dim1);
static __global__ void ec_cwt_kernel583(const emxArray_real_T fb_Omega, const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T somega, int32_T somega_dim0);
static __global__ void ec_cwt_kernel584(const emxArray_real_T somega, const
  int32_T b_somega, emxArray_real_T w);
static __global__ void ec_cwt_kernel585(const emxArray_real_T w, const int32_T
  b_w, emxArray_real_T expnt);
static __global__ void ec_cwt_kernel586(const int32_T b, emxArray_real_T expnt);
static __global__ void ec_cwt_kernel587(const emxArray_real_T w, const int32_T b,
  emxArray_real_T y);
static __global__ void ec_cwt_kernel588(const emxArray_real_T y, const
  emxArray_real_T expnt, const int32_T b_expnt, emxArray_real_T daughter);
static __global__ void ec_cwt_kernel589(const int32_T nrefine, emxArray_real_T
  daughter);
static __global__ void ec_cwt_kernel59(const emxArray_uint32_T y, const real_T
  halfh, const int32_T b_y, emxArray_int32_T iv6);
static __global__ void ec_cwt_kernel590(const emxArray_real_T fb_Scales, const
  int32_T b_fb_Scales, emxArray_real_T f);
static __global__ void ec_cwt_kernel591(const emxArray_real_T fb_Omega, const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, const int32_T b,
  emxArray_real_T somega, int32_T somega_dim0);
static __global__ void ec_cwt_kernel592(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel593(const char_T cv[128], char_T wav[5],
  char_T wname[5], char_T b_dim0, char_T b_dim1, char_T b_dim2, char_T b_dim3,
  char_T b_dim4);
static __global__ void ec_cwt_kernel594(real_T interval[650]);
static __global__ void ec_cwt_kernel595(real_T interval[650]);
static __global__ void ec_cwt_kernel596(const int32_T ix, real_T interval[650]);
static __global__ void ec_cwt_kernel597(real_T interval[650]);
static __global__ void ec_cwt_kernel598(real_T interval[650]);
static __global__ void ec_cwt_kernel599(const int32_T ix, real_T interval[650]);
static __global__ void ec_cwt_kernel6(real_T interval[650]);
static __global__ void ec_cwt_kernel60(const emxArray_real_T opts_filter, const
  emxArray_int32_T iv6, const int32_T b_iv6, emxArray_real_T h);
static __global__ void ec_cwt_kernel600(emxArray_real_T y);
static __global__ void ec_cwt_kernel601(const emxArray_real_T y, const real_T r,
  const int32_T b, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel602(const emxArray_real_T y, const real_T
  halfh, const int32_T b_y, emxArray_real_T fb_Scales);
static __global__ void ec_cwt_kernel603(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel604(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_cwt_kernel605(const real_T x_data[9735], const int32_T
  b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel606(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_cwt_kernel607(const real_T x_data[9735], const int32_T
  b, real_T dv16_data[9735]);
static __global__ void ec_cwt_kernel608(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel609(const real_T y_data[9735], const int32_T
  b, real_T x_data[9735]);
static __global__ void ec_cwt_kernel61(const emxArray_real_T opts_x, const
  int32_T b_opts_x, emxArray_real_T b_y1);
static __global__ void ec_cwt_kernel610(const real_T xt_data[9735], const real_T
  x_data[9735], const real_T dv16_data[9735], const int32_T dv16_size, real_T
  fx_data[9735]);
static __global__ void ec_cwt_kernel611(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_cwt_kernel612(const real_T x_data[9735], const int32_T
  b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel613(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_cwt_kernel614(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel615(const real_T x_data[9735], const int32_T
  b, real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel616(const real_T x_data[9735], const real_T
  y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_cwt_kernel617(const real_T a_data[9735], const int32_T
  b, real_T dv13_data[9735]);
static __global__ void ec_cwt_kernel618(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel619(const real_T y_data[9735], const int32_T
  b, real_T x_data[9735]);
static __global__ void ec_cwt_kernel62(const emxArray_real_T b_y1, const int32_T
  b, emxArray_real_T opts_x);
static __global__ void ec_cwt_kernel620(const real_T xt_data[9735], const real_T
  x_data[9735], const real_T dv13_data[9735], const int32_T dv13_size, real_T
  fx_data[9735]);
static __global__ void ec_cwt_kernel621(const int32_T b, emxArray_int32_T
  omega_tmp1);
static __global__ void ec_cwt_kernel622(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_cwt_kernel623(const real_T x_data[9735], const int32_T
  b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel624(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_cwt_kernel625(const real_T x_data[9735], const int32_T
  b, real_T dv10_data[9735]);
static __global__ void ec_cwt_kernel626(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel627(const real_T y_data[9735], const int32_T
  b, real_T x_data[9735]);
static __global__ void ec_cwt_kernel628(const real_T xt_data[9735], const real_T
  x_data[9735], const real_T dv10_data[9735], const int32_T dv10_size, real_T
  fx_data[9735]);
static __global__ void ec_cwt_kernel629(const real_T interval[650], const
  int32_T b, real_T subs[1298]);
static __global__ void ec_cwt_kernel63(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel630(const real_T x_data[9735], const int32_T
  b, real_T xt_data[9735], real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel631(const int32_T b, real_T fx_data[9735]);
static __global__ void ec_cwt_kernel632(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel633(const real_T x_data[9735], const int32_T
  b, real_T b_x_data[9735]);
static __global__ void ec_cwt_kernel634(const real_T x_data[9735], const real_T
  y_data[9735], const int32_T y_size, real_T a_data[9735]);
static __global__ void ec_cwt_kernel635(const real_T a_data[9735], const int32_T
  b, real_T dv4_data[9735]);
static __global__ void ec_cwt_kernel636(const real_T x_data[9735], const int32_T
  b, real_T y_data[9735]);
static __global__ void ec_cwt_kernel637(const real_T y_data[9735], const int32_T
  b, real_T x_data[9735]);
static __global__ void ec_cwt_kernel638(const real_T xt_data[9735], const real_T
  x_data[9735], const real_T dv4_data[9735], const int32_T dv4_size, real_T
  fx_data[9735]);
static __global__ void ec_cwt_kernel64(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel65(const real_T cf, int32_T csz[2]);
static __global__ void ec_cwt_kernel66(const emxArray_real_T yCol, const int32_T
  csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel67(const emxArray_real_T h, const
  emxArray_real_T yCol, real_T *r, emxArray_real_T a);
static __global__ void ec_cwt_kernel68(const real_T *r, const emxArray_real_T a,
  emxArray_real_T c);
static __global__ void ec_cwt_kernel69(const emxArray_real_T c, emxArray_real_T
  w);
static __global__ void ec_cwt_kernel7(real_T interval[650]);
static __global__ void ec_cwt_kernel70(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static __global__ void ec_cwt_kernel71(const int32_T lidx, const int32_T nw,
  const int32_T dim, int32_T csz[2]);
static __global__ void ec_cwt_kernel72(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel73(const emxArray_real_T w, const int32_T
  xt_size, emxArray_real_T y);
static __global__ void ec_cwt_kernel74(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T lidx, const int32_T b, const int32_T c,
  emxArray_real_T b_w, int32_T w_dim0);
static __global__ void ec_cwt_kernel75(const emxArray_real_T w, const int32_T
  xt_size_dim0, const int32_T b, const int32_T c, emxArray_real_T y, int32_T
  y_dim0);
static __global__ void ec_cwt_kernel76(const emxArray_real_T y, const int32_T
  omega_tmp2, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel77(const emxArray_real_T y, const int32_T
  xt_size, emxArray_real_T b_y);
static __global__ void ec_cwt_kernel78(emxArray_real_T y);
static __global__ void ec_cwt_kernel79(const emxArray_real_T y, const
  emxArray_real_T b_y, const real_T tol, const int32_T b, emxArray_real_T b_y1);
static __global__ void ec_cwt_kernel8(const int32_T ix, real_T interval[650]);
static __global__ void ec_cwt_kernel80(const int32_T b, emxArray_real_T y);
static __global__ void ec_cwt_kernel81(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel82(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel83(const emxArray_real_T yCol, const
  emxArray_real_T h, emxArray_real_T w);
static __global__ void ec_cwt_kernel84(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel85(const int32_T dim, const emxArray_int32_T
  y, const int32_T b_y, emxArray_int32_T iv52);
static __global__ void ec_cwt_kernel86(const emxArray_real_T h, const
  emxArray_int32_T iv52, const int32_T omega_tmp2, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel87(const emxArray_real_T yCol, const
  emxArray_real_T expanded, const emxArray_int32_T rows, const int32_T csz[2],
  const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel88(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel89(const int32_T b, emxArray_real_T w);
static __global__ void ec_cwt_kernel9(const real_T fc, const emxArray_int32_T
  omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T omega_tmp2);
static __global__ void ec_cwt_kernel90(const emxArray_real_T c, const int32_T b,
  emxArray_real_T w);
static __global__ void ec_cwt_kernel91(const int32_T y_size_idx_1,
  emxArray_real_T expanded);
static __global__ void ec_cwt_kernel92(const int32_T dim, const emxArray_int32_T
  y, const int32_T b_y, emxArray_int32_T iv54);
static __global__ void ec_cwt_kernel93(const emxArray_real_T yCol, const
  emxArray_int32_T iv54, const int32_T xt_size, emxArray_real_T expanded);
static __global__ void ec_cwt_kernel94(const emxArray_real_T expanded, const
  emxArray_int32_T rows, const emxArray_real_T h, const int32_T b,
  emxArray_real_T w, int32_T h_dim0);
static __global__ void ec_cwt_kernel95(const int32_T b, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel96(const emxArray_real_T opts_x, const
  int32_T nw, const int32_T omega_tmp2, emxArray_real_T yCol);
static __global__ void ec_cwt_kernel97(const emxArray_real_T yCol, const int32_T
  csz, emxArray_real_T x);
static __global__ void ec_cwt_kernel98(emxArray_real_T w);
static __global__ void ec_cwt_kernel99(const int32_T nsubs, const int32_T b,
  int32_T lshift[2]);
static void ec_cwt_once();
static void emlrtExitTimeCleanupDtorFcn(const void *r);
static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real_T *y);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real_T *y);
static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier);
static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId);
static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y);
static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23]);
static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23]);
static const mxArray *emlrt_marshallOut(const cell_wrap_0 u_data[], const
  int32_T u_size[2]);
static const mxArray *emlrt_marshallOut(const emxArray_real_T *u);
static void emxEnsureCapacity_cell_wrap_0(cell_wrap_0 data[65534], const int32_T
  size[2], int32_T oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_creal_T(emxArray_creal_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation);
static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation);
static void emxExpand_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex, const emlrtRTEInfo *srcLocation);
static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct);
static void emxFree_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray);
static void emxFree_char_T(emxArray_char_T **pEmxArray);
static void emxFree_creal_T(emxArray_creal_T **pEmxArray);
static void emxFree_int32_T(emxArray_int32_T **pEmxArray);
static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray);
static void emxFree_real_T(emxArray_real_T **pEmxArray);
static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray);
static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush);
static void emxInit_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray);
static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_creal_T(emxArray_creal_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush);
static void emxTrim_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex);
static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
  m3, emlrtMCInfo *location);
static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
  *location);
static void gpuEmxEnsureCapacity_creal_T(const emxArray_creal_T *cpu,
  emxArray_creal_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy);
static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy);
static void gpuEmxFree_creal_T(emxArray_creal_T *gpu);
static void gpuEmxFree_int32_T(emxArray_int32_T *gpu);
static void gpuEmxFree_real_T(emxArray_real_T *gpu);
static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu);
static void gpuEmxMemcpyCpuToGpu_creal_T(emxArray_creal_T *gpu, const
  emxArray_creal_T *cpu);
static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu);
static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu);
static void gpuEmxMemcpyGpuToCpu_creal_T(emxArray_creal_T *cpu, emxArray_creal_T
  *gpu);
static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu);
static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu);
static void gpuEmxReset_creal_T(emxArray_creal_T *gpu);
static void gpuEmxReset_int32_T(emxArray_int32_T *gpu);
static void gpuEmxReset_real_T(emxArray_real_T *gpu);
static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu);
static const mxArray *length(const mxArray *m1, emlrtMCInfo *location);
static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString);
static real_T rt_powd_snf(real_T u0, real_T u1);
static real_T rt_remd_snf(real_T u0, real_T u1);

// Function Definitions
static int64_T b_computeEndIdx(int64_T start, int64_T end, int64_T stride)
{
  int64_T newEnd;
  newEnd = -1L;
  if ((stride > 0L) && (start <= end)) {
    newEnd = (end - start) / stride;
  } else if ((stride < 0L) && (end <= start)) {
    newEnd = (start - end) / -stride;
  }

  return newEnd;
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_char_T *ret)
{
  static const int32_T dims[2]{ 1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ false, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0], &bv[0], &iv[0]);
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_char_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  emlrtImportArrayR2015b(emlrtRootTLSGlobal, src, &ret->data[0], 1, false);
  emlrtDestroyArray(&src);
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, emxArray_real_T *ret)
{
  static const int32_T dims[2]{ -1, -1 };

  int32_T iv[2];
  int32_T i;
  boolean_T bv[2]{ true, true };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "double", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret->allocatedSize = iv[0] * iv[1];
  i = ret->size[0] * ret->size[1];
  ret->size[0] = iv[0];
  ret->size[1] = iv[1];
  emxEnsureCapacity_real_T(ret, i, static_cast<emlrtRTEInfo *>(nullptr));
  ret->data = static_cast<real_T *>(emlrtMxGetData(src));
  ret->canFreeData = false;
  emlrtDestroyArray(&src);
}

static real_T (*b_emlrt_marshallIn(const mxArray *b_nullptr, const char_T
  *identifier))[2]
{
  emlrtMsgIdentifier thisId;
  real_T (*y)[2];
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = b_emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId);
  emlrtDestroyArray(&b_nullptr);
  return y;
}
static real_T (*b_emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
*parentId))[2]
{
  real_T (*y)[2];
  y = d_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static void b_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId, char_T ret[23])
{
  static const int32_T dims[2]{ 1, 23 };

  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "char", false, 2U, (
    const void *)&dims[0]);
  emlrtImportCharArrayR2015b(emlrtRootTLSGlobal, src, &ret[0], 23);
  emlrtDestroyArray(&src);
}

static void b_feval(const mxArray *m, const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = m;
  pArrays[1] = m1;
  emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 0, nullptr, 2, &pArrays[0], "feval",
                        true, location);
}

static void b_raiseCudaError(int32_T errCode, const char_T *file, uint32_T
  b_line, const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  fn = static_cast<char_T *>(calloc(len + 1UL, 1UL));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static const mxArray *b_sprintf(const mxArray *m1, const mxArray *m2,
  emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "sprintf", true, location);
}

static void binary_expand_op(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, real_T in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &me_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in3->size[0] == 1) {
    b_in1->size[0] = in1->size[0];
  } else {
    b_in1->size[0] = in3->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &me_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  if (in3->size[0] == 1) {
    b = in1->size[0];
  } else {
    b = in3->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + (in2 * in3->data[i * stride_1_0]
      - in4 * in5->data[i * stride_1_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &ne_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_1(emxArray_real_T *in1, real_T in2, const
  emxArray_real_T *in3, const emxArray_real_T *in4, const emxArray_real_T *in5)
{
  emxArray_real_T *b_in1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_1_0;
  int32_T stride_2_0;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_real_T(&b_in1, 1, &oe_emlrtRTEI, true);
  i = b_in1->size[0];
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b_in1->size[0] = in1->size[0];
  } else if (in5->size[0] == 1) {
    b_in1->size[0] = in3->size[0];
  } else {
    b_in1->size[0] = in5->size[0];
  }

  emxEnsureCapacity_real_T(b_in1, i, &oe_emlrtRTEI);
  stride_0_0 = (in1->size[0] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_2_0 = (in5->size[0] != 1);
  if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  if (b == 1) {
    b = in1->size[0];
  } else if (in5->size[0] == 1) {
    b = in3->size[0];
  } else {
    b = in5->size[0];
  }

  for (i = 0; i < b; i++) {
    b_in1->data[i] = in1->data[i * stride_0_0] + in2 * (in3->data[i * stride_1_0]
      - in4->data[i * stride_1_0]) / (in5->data[i * stride_2_0] * in5->data[i *
      stride_2_0]);
  }

  i = in1->size[0];
  in1->size[0] = b_in1->size[0];
  emxEnsureCapacity_real_T(in1, i, &pe_emlrtRTEI);
  for (i = 0; i < b_in1->size[0]; i++) {
    in1->data[i] = b_in1->data[i];
  }

  emxFree_real_T(&b_in1);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

static void binary_expand_op_2(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_real_T(in1, i, &o_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = 0.0050536085896138528 * in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1] * static_cast<real_T>(in3->data[i1 *
        stride_1_0 + in3->size[0] * aux_1_1] > 0.0);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_3(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_real_T(in1, i, &n_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = 20.0 * in2->data[i1 * stride_0_0 +
        in2->size[0] * aux_0_1] - in3->data[i1 * stride_1_0 + in3->size[0] *
        aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_4(emxArray_real_T *in1, const emxArray_real_T *in2,
  const emxArray_real_T *in3)
{
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T b;
  int32_T i;
  int32_T stride_0_0;
  int32_T stride_0_1;
  int32_T stride_1_0;
  int32_T stride_1_1;
  i = in1->size[0] * in1->size[1];
  if (in3->size[0] == 1) {
    in1->size[0] = in2->size[0];
  } else {
    in1->size[0] = in3->size[0];
  }

  if (in3->size[1] == 1) {
    in1->size[1] = in2->size[1];
  } else {
    in1->size[1] = in3->size[1];
  }

  emxEnsureCapacity_real_T(in1, i, &p_emlrtRTEI);
  stride_0_0 = (in2->size[0] != 1);
  stride_0_1 = (in2->size[1] != 1);
  stride_1_0 = (in3->size[0] != 1);
  stride_1_1 = (in3->size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3->size[1] == 1) {
    b = in2->size[1];
  } else {
    b = in3->size[1];
  }

  for (i = 0; i < b; i++) {
    int32_T c;
    if (in3->size[0] == 1) {
      c = in2->size[0];
    } else {
      c = in3->size[0];
    }

    for (int32_T i1{0}; i1 < c; i1++) {
      in1->data[i1 + in1->size[0] * i] = 5.43656365691809 * in2->data[i1 *
        stride_0_0 + in2->size[0] * aux_0_1] * static_cast<real_T>(in3->data[i1 *
        stride_1_0 + in3->size[0] * aux_1_1] < 0.99999999999999978);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

static void binary_expand_op_5(real_T in1_data[], int32_T in1_size[2], const
  real_T in2_data[], const int32_T in2_size[2], const real_T in3_data[], const
  int32_T in3_size[2], const real_T in4_data[], const int32_T in4_size[2])
{
  int32_T stride_0_1;
  int32_T stride_1_1;
  in1_size[0] = 1;
  in1_size[1] = in4_size[1];
  stride_0_1 = (in2_size[1] != 1);
  stride_1_1 = (in3_size[1] != 1);
  for (int32_T i{0}; i < in4_size[1]; i++) {
    in1_data[i] = in2_data[i * stride_0_1] * in3_data[i * stride_1_1] *
      in4_data[i];
  }
}

static real_T c_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier
  *msgId)
{
  static const int32_T dims{ 0 };

  real_T ret;
  emlrtCheckBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "double", false, 0U, (
    const void *)&dims);
  ret = *static_cast<real_T *>(emlrtMxGetData(src));
  emlrtDestroyArray(&src);
  return ret;
}

static void checkCudaError(cudaError_t errCode, const char_T *file, uint32_T
  b_line)
{
  if (errCode != cudaSuccess) {
    b_raiseCudaError(errCode, file, b_line, cudaGetErrorName(errCode),
                     cudaGetErrorString(errCode));
  }
}

//
//
namespace coder
{
  namespace internal
  {
    static void warning()
    {
      static const int32_T iv[2]{ 1, 7 };

      static const int32_T iv1[2]{ 1, 7 };

      static const int32_T iv2[2]{ 1, 39 };

      static const char_T msgID[39]{ 's', 'i', 'g', 'n', 'a', 'l', ':', 'c', 'h',
        'e', 'c', 'k', '_', 'o', 'r', 'd', 'e', 'r', ':', 'I', 'n', 'v', 'a',
        'l', 'i', 'd', 'O', 'r', 'd', 'e', 'r', 'R', 'o', 'u', 'n', 'd', 'i',
        'n', 'g' };

      static const char_T b_u[7]{ 'm', 'e', 's', 's', 'a', 'g', 'e' };

      static const char_T u[7]{ 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

      const mxArray *b_y;
      const mxArray *c_y;
      const mxArray *m;
      const mxArray *m1;
      const mxArray *m2;
      const mxArray *y;
      y = nullptr;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &u[0]);
      emlrtAssign(&y, m);
      b_y = nullptr;
      m1 = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m1, &b_u[0]);
      emlrtAssign(&b_y, m1);
      c_y = nullptr;
      m2 = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 39, m2, &msgID[0]);
      emlrtAssign(&c_y, m2);
      b_feval(y, feval(b_y, c_y, &c_emlrtMCI), &d_emlrtMCI);
    }
  }
}

static int64_T computeEndIdx(int64_T start, int64_T end, int64_T stride)
{
  int64_T newEnd;
  newEnd = -1L;
  if ((stride > 0L) && (start <= end)) {
    newEnd = (end - start) / stride;
  } else if ((stride < 0L) && (end <= start)) {
    newEnd = (start - end) / -stride;
  }

  return newEnd;
}

static uint64_T computeNumIters(int32_T ub, int32_T b_ub)
{
  uint64_T n;
  uint64_T numIters;
  n = 0UL;
  if (ub >= 0) {
    n = static_cast<uint64_T>(ub + 1);
  }

  numIters = n;
  n = 0UL;
  if (b_ub >= 0) {
    n = static_cast<uint64_T>(b_ub + 1);
  }

  numIters *= n;
  return numIters;
}

static uint64_T computeNumIters(int32_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0) {
    numIters = static_cast<uint64_T>(ub + 1);
  }

  return numIters;
}

static uint64_T computeNumIters(int64_T ub)
{
  uint64_T numIters;
  numIters = 0UL;
  if (ub >= 0L) {
    numIters = static_cast<uint64_T>(ub + 1L);
  }

  return numIters;
}

static void cublasCheck(cublasStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUBLAS_STATUS_SUCCESS) {
    cublasGetErrorName(errCode, &errName);
    cublasGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static void cusolverCheck(cusolverStatus_t errCode, const char_T *file, uint32_T
  b_line)
{
  const char *errName;
  const char *errString;
  if (errCode != CUSOLVER_STATUS_SUCCESS) {
    cusolverGetErrorName(errCode, &errName);
    cusolverGetErrorString(errCode, &errString);
    raiseCudaError(errCode, file, b_line, errName, errString);
  }
}

static real_T (*d_emlrt_marshallIn(const mxArray *src, const emlrtMsgIdentifier *
  msgId))[2]
{
  static const int32_T dims[2]{ 1, 2 };

  real_T (*ret)[2];
  int32_T iv[2];
  boolean_T bv[2]{ false, false };

  emlrtCheckVsBuiltInR2012b(emlrtRootTLSGlobal, msgId, src, "double", false, 2U,
    (const void *)&dims[0], &bv[0], &iv[0]);
  ret = (real_T (*)[2])emlrtMxGetData(src);
  emlrtDestroyArray(&src);
  return ret;
}
static int32_T div_s32(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    emlrtDivisionByZeroErrorR2012b(nullptr, emlrtRootTLSGlobal);
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static __device__ int32_T div_s32_device(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    uint32_T b;
    uint32_T tempAbsQuotient;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<uint32_T>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<uint32_T>(numerator);
    }

    if (denominator < 0) {
      b = ~static_cast<uint32_T>(denominator) + 1U;
    } else {
      b = static_cast<uint32_T>(denominator);
    }

    tempAbsQuotient /= b;
    if (static_cast<int32_T>(numerator < 0) != static_cast<int32_T>(denominator <
         0)) {
      quotient = -static_cast<int32_T>(tempAbsQuotient);
    } else {
      quotient = static_cast<int32_T>(tempAbsQuotient);
    }
  }

  return quotient;
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel1(creal_T *dc1,
  creal_T *dc6)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    dc6->re = CUDART_INF;
    dc1->re = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel10(emxArray_real_T
  fb_Omega)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    fb_Omega.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel100(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel101(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel102(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel103(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel104(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel105(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel106(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel107(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel108(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel109(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel11(const
  emxArray_real_T omega_tmp2, const int32_T b, emxArray_real_T fb_Omega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Omega.data[itime + 1] = omega_tmp2.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel110(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv32)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv32.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel111(const
  emxArray_real_T a, const emxArray_int32_T iv32, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv32.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel112(const real_T
  q_ok, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * q_ok;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel113(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel114(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel115(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel116(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel117(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv34)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv34.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel118(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv34, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv34.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel119(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if (kk > 2147483646 - nw) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel12(const int32_T
  nrefine, const int32_T lidx, const emxArray_real_T omega_tmp2, const int32_T
  dim, emxArray_real_T fb_Omega, int32_T omega_tmp2_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dim);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Omega.data[(itime + omega_tmp2_dim1) + 1] = -omega_tmp2.data[lidx +
      nrefine * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel120(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel121(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel122(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel123(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel124(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv39)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv39.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel125(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv57)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv57.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel126(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv57,
  const emxArray_int32_T iv39, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv39.data[kk] + expanded_dim0 * iv57.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel127(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel13(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel14(const
  emxArray_real_T y, const real_T s, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(s, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel15(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel156(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel157(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel158(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel159(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel16(const
  emxArray_real_T somega, const int32_T b, emxArray_real_T absomega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    absomega.data[k] = fabs(somega.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel160(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel161(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel162(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel163(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel164(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel165(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel166(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel167(const
  emxArray_real_T y, const int32_T b_y, emxArray_real_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel168(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel169(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  c_y, const int32_T b, emxArray_real_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(tol +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel17(const
  emxArray_real_T absomega, const int32_T b_absomega, emxArray_real_T powscales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_absomega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    powscales.data[itime] = absomega.data[itime] * absomega.data[itime] *
      absomega.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel170(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel171(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel172(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel173(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel174(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel175(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel176(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv38)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv38.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel177(const
  emxArray_real_T a, const emxArray_int32_T iv38, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv38.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel178(const real_T
  r, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel179(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel18(const int32_T
  b, emxArray_real_T absomega)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    absomega.data[k] = log(absomega.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel180(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel181(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel182(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel183(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv42)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv42.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel184(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv42, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv42.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel185(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if ((nw + 1 < 0) && (kk < MAX_int32_T - nw)) {
          kk = MIN_int32_T;
        } else if ((nw + 1 > 0) && (kk > 2147483646 - nw)) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel186(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel187(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel188(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel189(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel19(const
  emxArray_real_T powscales, const emxArray_real_T absomega, const int32_T
  b_absomega, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_absomega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = 20.0 * absomega.data[itime] - powscales.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel190(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv45)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv45.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel191(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv62)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv62.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel192(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv62,
  const emxArray_int32_T iv45, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv45.data[kk] + expanded_dim0 * iv62.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel193(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel2(const char_T cv
  [128], char_T wname[5], char_T wav[5], char_T b_dim0, char_T b_dim1, char_T
  b_dim2, char_T b_dim3, char_T b_dim4)
{
  __shared__ char_T b_shared[5];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    b_shared[0] = b_dim0;
    b_shared[1] = b_dim1;
    b_shared[2] = b_dim2;
    b_shared[3] = b_dim3;
    b_shared[4] = b_dim4;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 5) {
    wav[k] = cv[static_cast<int32_T>(b_shared[k])];
    wname[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(b_shared[k])])];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel20(const int32_T
  b, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x.data[k] = exp(x.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel21(const
  emxArray_real_T somega, const emxArray_real_T x, const int32_T b_x,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 0.0050536085896138528 * x.data[itime] *
      static_cast<real_T>(somega.data[itime] > 0.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel22(const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, emxArray_real_T f)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_fb_Scales);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    f.data[itime] = 1.8820720577620569 / fb_Scales.data[itime] /
      6.2831853071795862;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel222(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel223(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel224(const real_T cf,
  int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(cf);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel225(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel226(const
  emxArray_real_T h, const emxArray_real_T yCol, real_T *r, emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *r = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel227(const real_T *r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * *r;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel228(const
  emxArray_real_T c, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    w.data[0] = c.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel229(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel23(const real_T
  fs, const int32_T i, emxArray_real_T f)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(i);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    f.data[itime] *= fs;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel230(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel231(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel232(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel233(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel234(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel235(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel236(const
  emxArray_real_T y, const int32_T xt_size, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel237(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel238(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  b, emxArray_real_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = y.data[static_cast<int32_T>(tol + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel239(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel24(const
  emxArray_real_T f, const int32_T b_f, emxArray_real_T freqs)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_f);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    freqs.data[itime] = f.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel240(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel241(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel242(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel243(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel244(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv51)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv51.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel245(const
  emxArray_real_T h, const emxArray_int32_T iv51, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv51.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel246(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    for (int32_T m{0}; m < icounter; m++) {
      int32_T kk;
      kk = rows.data[m];
      if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
        kk = MIN_int32_T;
      } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * yCol.data[(icounter - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel247(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel248(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel249(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel25(const int32_T
  y_size_idx_1, const emxArray_real_T x, const int32_T b_x, emxArray_real_T xv,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime + x_dim0 * y_size_idx_1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel250(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel251(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv53)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv53.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel252(const
  emxArray_real_T yCol, const emxArray_int32_T iv53, const int32_T xt_size,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv53.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel253(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, emxArray_real_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel254(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel255(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel256(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel257(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel258(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel259(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel26(const int32_T
  y_size_idx_1, const emxArray_real_T x, const int32_T b, emxArray_real_T b_x,
  int32_T x_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_x.data[itime] = x.data[itime + x_dim0 * y_size_idx_1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel260(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel261(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel262(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel263(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel264(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel265(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel266(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel267(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel268(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel269(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv31)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv31.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel27(const int32_T
  fb_SignalPad, const int32_T b, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T icounter;
    int32_T itime;
    icounter = static_cast<int32_T>(idx);
    itime = (fb_SignalPad - icounter) - 1;
    i2Map = x.data[icounter];
    x.data[icounter] = x.data[itime];
    x.data[itime] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel270(const
  emxArray_real_T a, const emxArray_int32_T iv31, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv31.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel271(const real_T
  q_ok, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * q_ok;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel272(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel273(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel274(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel275(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel276(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv33)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv33.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel277(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv33, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv33.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel278(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if (kk > 2147483646 - nw) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel279(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel28(const
  emxArray_real_T x, const int32_T b, emxArray_real_T xv)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xv.data[itime] = x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel280(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel281(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel282(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel283(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv37)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv37.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel284(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv56)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv56.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel285(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv56,
  const emxArray_int32_T iv37, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv37.data[kk] + expanded_dim0 * iv56.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel286(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel29(const
  emxArray_real_T xv, const int32_T b_xv, emxArray_creal_T xposdft)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xv);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xposdft.data[itime].re = xv.data[itime];
    xposdft.data[itime].im = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel3(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel30(const
  emxArray_creal_T xposdft, const emxArray_real_T daughter, const int32_T lidx,
  const int32_T cfsposdft, const int32_T nw, emxArray_creal_T b_cfsposdft,
  int32_T daughter_dim0, int32_T cfsposdft_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(nw) + 1UL) * (static_cast<uint64_T>(cfsposdft)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    int32_T itime;
    int32_T k;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(cfsposdft) + 1UL));
    k = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) /
      (static_cast<uint64_T>(cfsposdft) + 1UL));
    itime = lidx * k + 1;
    icounter = static_cast<int32_T>(daughter_dim0 != 1);
    b_cfsposdft.data[kk + cfsposdft_dim0 * k].re = daughter.data[icounter * kk +
      daughter_dim0 * (itime - 1)] * xposdft.data[k].re;
    b_cfsposdft.data[kk + cfsposdft_dim0 * k].im = daughter.data[icounter * kk +
      daughter_dim0 * (itime - 1)] * xposdft.data[k].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel31(const int32_T
  xSize, emxArray_creal_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xSize);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    cfspos.data[itime].re = 0.0;
    cfspos.data[itime].im = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel315(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel316(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel317(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel318(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel319(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel32(const
  emxArray_creal_T cfspos, const int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = hypot(cfspos.data[k].re, cfspos.data[k].im);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel320(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel321(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel322(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel323(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel324(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel325(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel326(const
  emxArray_real_T y, const int32_T b_y, emxArray_real_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel327(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel328(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  c_y, const int32_T b, emxArray_real_T opts_x, int32_T opts_x_dim0, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = y.data[(static_cast<int32_T>(tol +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel329(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel33(const
  emxArray_real_T y, const int32_T b_y, const int32_T c_y, emxArray_real_T xCh,
  int32_T xCh_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_y) + 1UL) * (static_cast<uint64_T>(b_y) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_y) + 1UL));
    xCh.data[kk + xCh_dim0 * itime] = y.data[itime + y_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel330(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel331(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel332(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel333(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel334(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel335(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv36)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv36.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel336(const
  emxArray_real_T a, const emxArray_int32_T iv36, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv36.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel337(const real_T
  r, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel338(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel339(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel34(const
  emxArray_real_T xCh, const int32_T b, emxArray_real_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = xCh.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel340(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel341(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel342(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv41)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv41.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel343(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv41, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv41.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel344(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if ((nw + 1 < 0) && (kk < MAX_int32_T - nw)) {
          kk = MIN_int32_T;
        } else if ((nw + 1 > 0) && (kk > 2147483646 - nw)) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel345(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel346(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel347(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel348(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel349(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv44)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv44.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel35(const int32_T
  b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime) + 0.5;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel350(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv61)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv61.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel351(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv61,
  const emxArray_int32_T iv44, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv44.data[kk] + expanded_dim0 * iv61.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel352(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel36(const
  emxArray_real_T m, const int32_T b_m, emxArray_real_T k)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_m);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    k.data[itime] = m.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel37(const int32_T
  k, emxArray_real_T G)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    G.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel38(const int32_T
  k, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel381(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel382(const
  emxArray_real_T opts_x, const int32_T nx, const int32_T i36, const int32_T b,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[i36 * itime] = opts_x.data[nx];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel383(const
  emxArray_real_T h, const emxArray_real_T yCol, emxArray_real_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel384(const
  emxArray_real_T w, const int32_T nrefine, const int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[nrefine * itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel385(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel386(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  nx, const int32_T b, emxArray_real_T b_y1, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime + y1_dim0 * nx] = y.data[static_cast<int32_T>(tol +
      b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel387(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel388(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel389(const
  emxArray_real_T yCol, real_T *r)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    *r = yCol.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel39(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T dv20)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv20.data[itime] = 6.2831853071795862 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel390(const real_T *r,
  const emxArray_real_T h, emxArray_real_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = h.data[0] * *r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel391(const int32_T
  b, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel392(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv30)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv30.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel393(const
  emxArray_real_T h, const emxArray_int32_T iv30, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv30.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel394(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  rows, const real_T cf, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    tkd1mtk = 0.0;
    icounter = static_cast<int32_T>(cf);
    for (int32_T m{0}; m < icounter; m++) {
      int32_T kk;
      kk = rows.data[m];
      if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
        kk = MIN_int32_T;
      } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * yCol.data[(static_cast<int32_T>(cf) - m)
        - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel395(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel396(const
  emxArray_real_T h, const emxArray_real_T yCol, emxArray_real_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel397(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel398(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv29)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv29.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel399(const
  emxArray_real_T yCol, const emxArray_int32_T iv29, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv29.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(128, 1) void ec_cwt_kernel4(real_T interval
  [650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel40(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T dv21,
  emxArray_real_T dv20)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    dv20.data[b_k] = cos(dv20.data[b_k]);
    dv21.data[b_k] = 6.2831853071795862 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel400(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, emxArray_real_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
        kk = MIN_int32_T;
      } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel401(const
  emxArray_real_T b_y1, const int32_T xCh, emxArray_real_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xCh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel402(const
  emxArray_real_T b_y1, const int32_T c_y1, const int32_T d_y1, emxArray_real_T
  opts_x, int32_T opts_x_dim0, int32_T y1_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(d_y1) + 1UL) * (static_cast<uint64_T>(c_y1) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y1) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y1) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = b_y1.data[itime + y1_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel403(const
  emxArray_real_T opts_x, const int32_T b_opts_x, emxArray_real_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel404(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel405(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel406(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel407(const
  emxArray_real_T h, const emxArray_real_T yCol, emxArray_real_T w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = yCol.data[0] * h.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel408(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel409(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel41(const int32_T
  b, emxArray_real_T dv21)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv21.data[k] = cos(dv21.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel410(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel411(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel412(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel413(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel414(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel415(const
  emxArray_real_T y, const int32_T xt_size, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel416(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel417(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  b, emxArray_real_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(tol + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel418(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel419(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel42(const
  emxArray_real_T k, const emxArray_real_T dv21, const emxArray_real_T dv20,
  const real_T a, const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * (dv20.data[itime] - dv21.data[itime]) / (k.data[itime]
      * k.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel420(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel421(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel422(const int32_T
  b, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel423(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv58)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv58.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel424(const
  emxArray_real_T h, const emxArray_int32_T iv58, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv58.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel425(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  rows, const real_T cf, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = static_cast<int32_T>(cf);
    for (int32_T m{0}; m < icounter; m++) {
      int32_T kk;
      kk = rows.data[m];
      if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
        kk = MIN_int32_T;
      } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * yCol.data[(static_cast<int32_T>(cf) - m)
        - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel426(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel427(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel428(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel429(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel43(const real_T
  tol, const emxArray_real_T k, const int32_T b_k, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_k);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = 2.0 * k.data[itime] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel430(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv60)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv60.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel431(const
  emxArray_real_T yCol, const emxArray_int32_T iv60, const int32_T xt_size,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv60.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel432(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, emxArray_real_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel433(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel434(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel435(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel436(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel437(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel438(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel439(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel44(const real_T
  tol, const emxArray_real_T k, const int32_T b, emxArray_real_T y,
  emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T b_k;
    b_k = static_cast<int32_T>(idx);
    if (fabs(b_y.data[b_k]) < 1.0020841800044864E-292) {
      b_y.data[b_k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * b_y.data[b_k];
      i2Map = sin(i2Map) / i2Map;
      b_y.data[b_k] = i2Map;
    }

    y.data[b_k] = 2.0 * k.data[b_k] * tol;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel440(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel441(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel442(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel443(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel444(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel445(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel446(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel447(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel448(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv35)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv35.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel449(const
  emxArray_real_T a, const emxArray_int32_T iv35, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv35.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel45(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    if (fabs(y.data[k]) < 1.0020841800044864E-292) {
      y.data[k] = 1.0;
    } else {
      real_T i2Map;
      i2Map = 3.1415926535897931 * y.data[k];
      i2Map = sin(i2Map) / i2Map;
      y.data[k] = i2Map;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel450(const real_T
  q_ok, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * q_ok;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel451(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel452(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel453(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel454(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel455(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv40)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv40.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel456(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv40, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv40.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel457(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if (kk > 2147483646 - nw) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel458(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel459(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel46(const
  emxArray_real_T y, const real_T r, const emxArray_real_T b_y, const real_T a,
  const int32_T b, emxArray_real_T b_b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_b.data[itime] += a * b_y.data[itime] - r * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel460(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel461(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel462(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv43)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv43.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel463(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv59)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv59.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel464(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv59,
  const emxArray_int32_T iv43, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv43.data[kk] + expanded_dim0 * iv59.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel465(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel47(const real_T r,
  const real_T b_r, const int32_T lidx, const int32_T nsubs, const int32_T b,
  emxArray_real_T sinc4A, emxArray_real_T sinc3A, emxArray_real_T sinc2A,
  emxArray_real_T sinc1A)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T ack;
    real_T bb;
    real_T i2Map;
    real_T tkd1mtk;
    int32_T icounter;
    uint32_T i1Map;
    icounter = static_cast<int32_T>(idx);
    i1Map = (static_cast<uint32_T>(icounter) + static_cast<uint32_T>(nsubs)) +
      1U;
    tkd1mtk = (static_cast<real_T>(icounter) + 1.0) - static_cast<real_T>(lidx);
    ack = b_r * static_cast<real_T>(i1Map);
    i2Map = r * static_cast<real_T>(i1Map);
    bb = b_r * tkd1mtk;
    tkd1mtk *= r;
    if (fabs(ack) < 1.0020841800044864E-292) {
      sinc1A.data[icounter] = 1.0;
    } else {
      ack *= 3.1415926535897931;
      sinc1A.data[icounter] = sin(ack) / ack;
    }

    if (fabs(i2Map) < 1.0020841800044864E-292) {
      sinc2A.data[icounter] = 1.0;
    } else {
      i2Map *= 3.1415926535897931;
      sinc2A.data[icounter] = sin(i2Map) / i2Map;
    }

    if (fabs(bb) < 1.0020841800044864E-292) {
      sinc3A.data[icounter] = 1.0;
    } else {
      bb *= 3.1415926535897931;
      sinc3A.data[icounter] = sin(bb) / bb;
    }

    if (fabs(tkd1mtk) < 1.0020841800044864E-292) {
      sinc4A.data[icounter] = 1.0;
    } else {
      tkd1mtk *= 3.1415926535897931;
      sinc4A.data[icounter] = sin(tkd1mtk) / tkd1mtk;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel48(const
  emxArray_real_T sinc4A, const emxArray_real_T sinc2A, const real_T r, const
  emxArray_real_T sinc3A, const emxArray_real_T sinc1A, const real_T b_r, const
  int32_T lidx, const int32_T b, const int32_T c, emxArray_real_T G, int32_T
  G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T icounter;
    int32_T itime;
    uint32_T i1Map;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    icounter = static_cast<int32_T>((idx - static_cast<uint64_T>(itime)) / (
      static_cast<uint64_T>(b) + 1UL));
    i1Map = (static_cast<uint32_T>(itime) + static_cast<uint32_T>(icounter)) +
      1U;
    i2Map = static_cast<real_T>(itime - icounter) + static_cast<real_T>(lidx);
    G.data[itime + G_dim0 * icounter] += 0.25 * (b_r * (sinc1A.data[static_cast<
      int32_T>(i1Map) - 1] + sinc3A.data[static_cast<int32_T>(i2Map) - 1]) - r *
      (sinc2A.data[static_cast<int32_T>(i1Map) - 1] + sinc4A.data
       [static_cast<int32_T>(i2Map) - 1]));
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel49(const real_T
  intDsq, emxArray_real_T b0)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    b0.data[0] = intDsq;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel494(const
  emxArray_real_T opts_x, const int32_T b_opts_x, emxArray_real_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel495(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel496(const
  emxArray_real_T xCol, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = xCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel497(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel498(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel499(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel5(const int32_T ix,
  real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[ix];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel50(const
  emxArray_real_T b, const int32_T c, emxArray_real_T b0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b0.data[itime + 1] = b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel500(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel501(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel502(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel503(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel504(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel505(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y, int32_T
  y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[y_dim0 * itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel506(const
  emxArray_real_T y, const int32_T b_y, emxArray_real_T c_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel507(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel508(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  c_y, const int32_T b, emxArray_real_T b_y1, int32_T y1_dim0, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>(c_y) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(c_y) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(c_y) + 1UL));
    b_y1.data[kk + y1_dim0 * itime] = y.data[(static_cast<int32_T>(tol +
      b_y.data[kk]) + y_dim0 * itime) - 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel509(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel51(const
  emxArray_real_T b0, const int32_T b_b0, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b0);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = b0.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel510(const
  emxArray_real_T yCol, const int32_T b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel511(const int32_T
  a, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    c.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel512(const real_T r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel513(const
  emxArray_real_T c, const int32_T b_c, emxArray_real_T w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_c);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[w_dim0 * itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel514(const int32_T
  a, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel515(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv46)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv46.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel516(const
  emxArray_real_T a, const emxArray_int32_T iv46, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv46.data[itime]] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel517(const real_T
  r, const emxArray_real_T expanded, const int32_T b, emxArray_real_T c)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T ierr;
    ierr = static_cast<int32_T>(idx);
    c.data[ierr] = expanded.data[ierr] * r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel518(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel519(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel52(const int32_T
  G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel520(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel521(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel522(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv49)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv49.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel523(const
  emxArray_real_T h, const int32_T nrefine, const emxArray_int32_T iv49, const
  int32_T omega_tmp2, emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv49.data[itime] + expanded_dim0 * nrefine] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel524(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  cols, const emxArray_int32_T rows, const int32_T csz[2], const int32_T b,
  const int32_T c, emxArray_real_T w, int32_T expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    int32_T itime;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    itime = csz[1];
    for (int32_T i{0}; i < itime; i++) {
      for (int32_T m{0}; m < icounter; m++) {
        int32_T k;
        int32_T kk;
        kk = rows.data[m];
        if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
          k = MIN_int32_T;
        } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
          k = MAX_int32_T;
        } else {
          k = (ierr + kk) + 1;
        }

        kk = cols.data[i];
        if ((nw + 1 < 0) && (kk < MAX_int32_T - nw)) {
          kk = MIN_int32_T;
        } else if ((nw + 1 > 0) && (kk > 2147483646 - nw)) {
          kk = MAX_int32_T;
        } else {
          kk = (nw + kk) + 1;
        }

        tkd1mtk += expanded.data[(k + expanded_dim0 * (kk - 1)) - 1] *
          yCol.data[((icounter - m) + csz[0] * ((csz[1] - i) - 1)) - 1];
      }
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel525(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel526(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel527(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel528(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel529(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv50)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv50.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel53(const
  emxArray_real_T a, const int32_T lidx, const int32_T nrefine, const int32_T
  dim, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dim);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = a.data[nrefine + lidx * itime] / 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel530(const
  emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv67)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv67.data[itime] = y.data[itime] - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel531(const
  emxArray_real_T yCol, const int32_T xt_size_dim0, const emxArray_int32_T iv67,
  const emxArray_int32_T iv50, const int32_T xt_size, const int32_T b_xt_size,
  emxArray_real_T expanded, int32_T expanded_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b_xt_size) + 1UL) * (static_cast<uint64_T>
    (xt_size) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv50.data[kk] + expanded_dim0 * iv67.data[itime]] =
      yCol.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel532(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, const int32_T c, emxArray_real_T w, int32_T h_dim0, int32_T
  expanded_dim0, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    int32_T nw;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    nw = static_cast<int32_T>((idx - static_cast<uint64_T>(ierr)) / (
      static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[(kk + expanded_dim0 * nw) - 1] * h.data[(h_dim0 -
        m) - 1];
    }

    w.data[ierr + w_dim0 * nw] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel54(const
  emxArray_real_T a, const int32_T lidx, const int32_T nrefine, const int32_T nw,
  emxArray_real_T h)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    h.data[div_s32_device(nw - nrefine, lidx) + 1] = a.data[0];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel55(const int32_T
  b, emxArray_real_T dv18)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    dv18.data[itime] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel56(const
  emxArray_real_T dv18, const emxArray_real_T h, const int32_T b_h,
  emxArray_real_T h1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h1.data[itime] = h.data[itime] * dv18.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel561(const
  emxArray_real_T opts_x, const int32_T b_opts_x, emxArray_real_T xCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    xCol.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel562(const int32_T
  b, emxArray_uint32_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<uint32_T>(itime) + 1U;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel563(const creal_T
  *dc6, const real_T table100[100], const creal_T dc7, const creal_T *dc1, const
  int32_T nw, const int32_T lidx, const int32_T nrefine, const int32_T i, const
  int64_T b, emxArray_real_T dv18, real_T q1_dim0, real_T q1_dim1, real_T
  q1_dim2, real_T q1_dim3, real_T q1_dim4, real_T q1_dim5, real_T q1_dim6,
  real_T q1_dim7, real_T p1_dim0, real_T p1_dim1, real_T p1_dim2, real_T p1_dim3,
  real_T p1_dim4, real_T p1_dim5, real_T p1_dim6, real_T p1_dim7, real_T q2_dim0,
  real_T q2_dim1, real_T q2_dim2, real_T q2_dim3, real_T q2_dim4, real_T q2_dim5,
  real_T q2_dim6, real_T q2_dim7, real_T p2_dim0, real_T p2_dim1, real_T p2_dim2,
  real_T p2_dim3, real_T p2_dim4, real_T p2_dim5, real_T p2_dim6, real_T p2_dim7,
  real_T q4_dim0, real_T q4_dim1, real_T q4_dim2, real_T q4_dim3, real_T q4_dim4,
  real_T q4_dim5, real_T q4_dim6, real_T q4_dim7, real_T p4_dim0, real_T p4_dim1,
  real_T p4_dim2, real_T p4_dim3, real_T p4_dim4, real_T p4_dim5, real_T p4_dim6,
  real_T p4_dim7, real_T c_dim0, real_T c_dim1, real_T c_dim2, real_T c_dim3,
  real_T c_dim4, real_T c_dim5, real_T c_dim6)
{
  __shared__ real_T p1_shared[8];
  __shared__ real_T p2_shared[8];
  __shared__ real_T p4_shared[8];
  __shared__ real_T q1_shared[8];
  __shared__ real_T q2_shared[8];
  __shared__ real_T q4_shared[8];
  __shared__ real_T c_shared[7];
  creal_T z;
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  int32_T icounter;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    p1_shared[0] = p1_dim0;
    p1_shared[1] = p1_dim1;
    p1_shared[2] = p1_dim2;
    p1_shared[3] = p1_dim3;
    p1_shared[4] = p1_dim4;
    p1_shared[5] = p1_dim5;
    p1_shared[6] = p1_dim6;
    p1_shared[7] = p1_dim7;
    q1_shared[0] = q1_dim0;
    q1_shared[1] = q1_dim1;
    q1_shared[2] = q1_dim2;
    q1_shared[3] = q1_dim3;
    q1_shared[4] = q1_dim4;
    q1_shared[5] = q1_dim5;
    q1_shared[6] = q1_dim6;
    q1_shared[7] = q1_dim7;
    p2_shared[0] = p2_dim0;
    p2_shared[1] = p2_dim1;
    p2_shared[2] = p2_dim2;
    p2_shared[3] = p2_dim3;
    p2_shared[4] = p2_dim4;
    p2_shared[5] = p2_dim5;
    p2_shared[6] = p2_dim6;
    p2_shared[7] = p2_dim7;
    q2_shared[0] = q2_dim0;
    q2_shared[1] = q2_dim1;
    q2_shared[2] = q2_dim2;
    q2_shared[3] = q2_dim3;
    q2_shared[4] = q2_dim4;
    q2_shared[5] = q2_dim5;
    q2_shared[6] = q2_dim6;
    q2_shared[7] = q2_dim7;
    p4_shared[0] = p4_dim0;
    p4_shared[1] = p4_dim1;
    p4_shared[2] = p4_dim2;
    p4_shared[3] = p4_dim3;
    p4_shared[4] = p4_dim4;
    p4_shared[5] = p4_dim5;
    p4_shared[6] = p4_dim6;
    p4_shared[7] = p4_dim7;
    q4_shared[0] = q4_dim0;
    q4_shared[1] = q4_dim1;
    q4_shared[2] = q4_dim2;
    q4_shared[3] = q4_dim3;
    q4_shared[4] = q4_dim4;
    q4_shared[5] = q4_dim5;
    q4_shared[6] = q4_dim6;
    q4_shared[7] = q4_dim7;
    c_shared[0] = c_dim0;
    c_shared[1] = c_dim1;
    c_shared[2] = c_dim2;
    c_shared[3] = c_dim3;
    c_shared[4] = c_dim4;
    c_shared[5] = c_dim5;
    c_shared[6] = c_dim6;
  }

  __syncthreads();
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    creal_T tmp;
    creal_T zd;
    int64_T k;
    real_T tkd1mtk;
    k = static_cast<int64_T>(idx);
    tkd1mtk = static_cast<real_T>(nrefine + (((static_cast<int32_T>(static_cast<
      int64_T>(i) + k) - lidx) - 1) << 1)) / (static_cast<real_T>(nw) - 1.0);
    zd.re = 5.0 * sqrt((1.0 - tkd1mtk) * (tkd1mtk + 1.0));
    if (isnan(zd.re)) {
      tmp = *dc1;
    } else {
      creal_T dk;
      creal_T p1;
      creal_T pt;
      real_T aa;
      real_T ack;
      real_T ak;
      real_T az;
      real_T b_atol;
      real_T bb;
      real_T fkk;
      real_T i2Map;
      real_T im;
      int32_T b_nw;
      int32_T ierr;
      boolean_T guard1;
      ierr = 0;
      tkd1mtk = hypot(zd.re, 0.0);
      if (tkd1mtk > 1.0737418235E+9) {
        ierr = 4;
      } else if (tkd1mtk > 32767.999992370605) {
        ierr = 3;
      }

      tmp.re = 0.0;
      tmp.im = 0.0;
      az = hypot(zd.re, 0.0);
      guard1 = false;
      if (az <= 2.0) {
        b_nw = 0;
        fkk = hypot(zd.re, 0.0);
        if (fkk == 0.0) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else if (fkk < 2.2250738585072014E-305) {
          tmp.re = 1.0;
          tmp.im = 0.0;
        } else {
          pt.re = 0.5 * zd.re;
          if (fkk > 4.7170688552396617E-153) {
            dk.re = pt.re * pt.re;
            ack = hypot(dk.re, 0.0);
          } else {
            dk.re = 0.0;
            ack = 0.0;
          }

          i2Map = pt.re;
          if (log(i2Map) * 0.0 > -700.92179369444591) {
            b_atol = 2.2204460492503131E-16 * ack;
            pt.re = 1.0;
            pt.im = 0.0;
            if (!static_cast<int32_T>(ack < 2.2204460492503131E-16)) {
              p1.re = 1.0;
              p1.im = 0.0;
              ak = 3.0;
              i2Map = 1.0;
              aa = 2.0;
              do {
                tkd1mtk = 1.0 / i2Map;
                fkk = p1.re * dk.re - p1.im * 0.0;
                im = p1.re * 0.0 + p1.im * dk.re;
                p1.re = tkd1mtk * fkk;
                p1.im = tkd1mtk * im;
                pt.re += p1.re;
                pt.im += p1.im;
                i2Map += ak;
                ak += 2.0;
                aa = aa * ack * tkd1mtk;
              } while (!!static_cast<int32_T>(aa > b_atol));
            }

            tkd1mtk = pt.re - pt.im * 0.0;
            bb = pt.re * 0.0 + pt.im;
            tmp.re = tkd1mtk - bb * 0.0;
            tmp.im = tkd1mtk * 0.0 + bb;
          } else {
            b_nw = 1;
            if (ack > 0.0) {
              b_nw = -1;
            }
          }
        }

        if (b_nw < 0) {
          icounter = 1;
        } else {
          icounter = b_nw;
        }

        if ((1 - icounter != 0) && (b_nw < 0)) {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        if (az < 21.784271729432426) {
          creal_T ck;
          creal_T cs1;
          creal_T cs2;
          int32_T b_i;
          boolean_T errflag;
          boolean_T exitg1;
          b_nw = 0;
          fkk = hypot(zd.re, 0.0);
          aa = floor(fkk);
          ck.re = (aa + 1.0) / zd.re;
          cs2.re = 2.0 / zd.re;
          p1.re = 0.0;
          p1.im = 0.0;
          cs1.re = 1.0;
          cs1.im = 0.0;
          ack = ((aa + 1.0) + 1.0) / fkk;
          tkd1mtk = ack + sqrt(ack * ack - 1.0);
          i2Map = tkd1mtk * tkd1mtk;
          bb = (i2Map + i2Map) / ((i2Map - 1.0) * (tkd1mtk - 1.0)) /
            2.2204460492503131E-16;
          ak = aa + 1.0;
          errflag = true;
          icounter = 0;
          b_i = 1;
          exitg1 = false;
          while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) && (b_i
                  < 81)) {
            icounter++;
            pt = cs1;
            tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
            i2Map = ck.re * cs1.im + 0.0 * cs1.re;
            cs1.re = p1.re - tkd1mtk;
            cs1.im = p1.im - i2Map;
            p1 = pt;
            ck.re += cs2.re;
            if (hypot(cs1.re, cs1.im) > bb * ak * ak) {
              errflag = false;
              exitg1 = true;
            } else {
              ak++;
              b_i++;
            }
          }

          if (errflag) {
            b_nw = -2;
          } else {
            int32_T itime;
            int32_T kk;
            boolean_T guard2;
            icounter++;
            kk = 0;
            guard2 = false;
            if (static_cast<int32_T>(aa) <= 0) {
              p1.re = 0.0;
              p1.im = 0.0;
              cs1.re = 1.0;
              cs1.im = 0.0;
              ck.re = 1.0 / zd.re;
              bb = sqrt(1.0 / fkk / 2.2204460492503131E-16);
              itime = 1;
              errflag = true;
              b_i = 1;
              exitg1 = false;
              while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                     (b_i < 81)) {
                kk++;
                pt = cs1;
                tkd1mtk = ck.re * cs1.re - 0.0 * cs1.im;
                i2Map = ck.re * cs1.im + 0.0 * cs1.re;
                cs1.re = p1.re - tkd1mtk;
                cs1.im = p1.im - i2Map;
                p1 = pt;
                ck.re += cs2.re;
                i2Map = hypot(cs1.re, cs1.im);
                if (i2Map >= bb * ak * ak) {
                  if (itime == 2) {
                    errflag = false;
                    exitg1 = true;
                  } else {
                    ack = hypot(ck.re, 0.0);
                    tkd1mtk = fmin(ack + sqrt(ack * ack - 1.0), i2Map / hypot
                                   (pt.re, pt.im));
                    bb *= sqrt(tkd1mtk / (tkd1mtk * tkd1mtk - 1.0));
                    itime = 2;
                    b_i++;
                  }
                } else {
                  b_i++;
                }
              }

              if (errflag) {
                b_nw = -2;
              } else {
                guard2 = true;
              }
            } else {
              guard2 = true;
            }

            if (guard2) {
              itime = icounter + static_cast<int32_T>(aa);
              kk++;
              if (itime >= kk) {
                kk = itime;
              }

              fkk = static_cast<real_T>(kk);
              p1.re = 0.0;
              p1.im = 0.0;
              cs1 = dc7;
              bb = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  bb = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) + (static_cast<real_T>
                    (kk) + 1.0) * ((static_cast<real_T>(kk) + 1.0) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  bb = -log(static_cast<real_T>(kk) + 1.0) +
                    (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  bb = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  bb = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((static_cast<
                    real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  bb = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  bb = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              tkd1mtk = static_cast<real_T>(kk) + 1.0;
              if (!static_cast<int32_T>(static_cast<real_T>(kk) + 1.0 < 0.0)) {
                if (static_cast<real_T>(kk) + 1.0 <= 2.2204460492503131E-16) {
                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (static_cast<real_T>(kk) + 1.0) +
                      p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (static_cast<real_T>(kk) + 1.0) +
                      q1_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) +
                    (static_cast<real_T>(kk) + 1.0) * ((static_cast<real_T>(kk)
                    + 1.0) * (i2Map / tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 0.6796875) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p2_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q2_shared[b_i];
                  }

                  tkd1mtk = -log(static_cast<real_T>(kk) + 1.0) + (((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * ((((
                    static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                    tkd1mtk) + 0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 100.0) {
                  tkd1mtk = table100[kk];
                } else if (static_cast<real_T>(kk) + 1.0 <= 1.5) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * (((static_cast<real_T>(kk) + 1.0) - 0.5) -
                                     0.5) + p1_shared[b_i];
                    tkd1mtk = tkd1mtk * (((static_cast<real_T>(kk) + 1.0) - 0.5)
                                         - 0.5) + q1_shared[b_i];
                  }

                  tkd1mtk = (((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) *
                    ((((static_cast<real_T>(kk) + 1.0) - 0.5) - 0.5) * (i2Map /
                      tkd1mtk) - 0.57721566490153287);
                } else if (static_cast<real_T>(kk) + 1.0 <= 4.0) {
                  tkd1mtk = 1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 2.0) +
                      p2_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 2.0)
                      + q2_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 2.0) * (((
                    static_cast<real_T>(kk) + 1.0) - 2.0) * (i2Map / tkd1mtk) +
                    0.42278433509846713);
                } else if (static_cast<real_T>(kk) + 1.0 <= 12.0) {
                  tkd1mtk = -1.0;
                  i2Map = 0.0;
                  for (b_i = 0; b_i < 8; b_i++) {
                    i2Map = i2Map * ((static_cast<real_T>(kk) + 1.0) - 4.0) +
                      p4_shared[b_i];
                    tkd1mtk = tkd1mtk * ((static_cast<real_T>(kk) + 1.0) - 4.0)
                      + q4_shared[b_i];
                  }

                  tkd1mtk = ((static_cast<real_T>(kk) + 1.0) - 4.0) * (i2Map /
                    tkd1mtk) + 1.791759469228055;
                } else {
                  tkd1mtk = 0.0057083835261;
                  i2Map = 1.0 / ((static_cast<real_T>(kk) + 1.0) * (static_cast<
                    real_T>(kk) + 1.0));
                  for (b_i = 0; b_i < 6; b_i++) {
                    tkd1mtk = tkd1mtk * i2Map + c_shared[b_i];
                  }

                  tkd1mtk /= static_cast<real_T>(kk) + 1.0;
                  i2Map = log(static_cast<real_T>(kk) + 1.0);
                  tkd1mtk = ((tkd1mtk + 0.91893853320467278) - 0.5 * i2Map) + (
                    static_cast<real_T>(kk) + 1.0) * (i2Map - 1.0);
                }
              }

              bb = exp(bb - tkd1mtk);
              dk.re = 0.0;
              dk.im = 0.0;
              for (b_i = 0; b_i < kk; b_i++) {
                pt = cs1;
                tkd1mtk = fkk * cs2.re;
                ack = fkk * 0.0;
                i2Map = tkd1mtk * cs1.re - ack * cs1.im;
                ack = tkd1mtk * cs1.im + ack * cs1.re;
                cs1.re = p1.re + i2Map;
                cs1.im = p1.im + ack;
                p1 = pt;
                ack = bb * (1.0 - 0.0 / fkk);
                dk.re += (ack + bb) * pt.re;
                dk.im += (ack + bb) * pt.im;
                bb = ack;
                fkk--;
              }

              tmp = cs1;
              pt.re = log(cs2.re);
              fkk = 0.0 * pt.re;
              im = 0.0 * pt.re;
              pt.re = fkk + zd.re;
              cs1.re += dk.re;
              cs1.im += dk.im;
              p1.re = 1.0 / hypot(cs1.re, cs1.im);
              if (pt.re == 0.0) {
                pt.re = cos(im);
                pt.im = sin(im);
              } else if (im == 0.0) {
                i2Map = pt.re;
                pt.re = exp(i2Map);
                pt.im = 0.0;
              } else {
                pt.re = CUDART_NAN;
                pt.im = CUDART_NAN;
              }

              i2Map = pt.re * p1.re - pt.im * 0.0;
              tkd1mtk = pt.re * 0.0 + pt.im * p1.re;
              bb = cs1.re * p1.re + cs1.im * 0.0;
              ack = cs1.re * 0.0 - cs1.im * p1.re;
              pt.re = i2Map * bb - tkd1mtk * ack;
              pt.im = i2Map * ack + tkd1mtk * bb;
              fkk = tmp.re * pt.re - tmp.im * pt.im;
              im = tmp.re * pt.im + tmp.im * pt.re;
              tmp.re = fkk;
              tmp.im = im;
            }
          }

          if (b_nw < 0) {
            if (b_nw == -2) {
              icounter = -2;
            } else {
              icounter = -1;
            }
          } else {
            icounter = 0;
          }
        } else {
          b_nw = 0;
          i2Map = sqrt(0.15915494309189535 / zd.re);
          if (zd.re > 700.92179369444591) {
            b_nw = -1;
            tmp = *dc1;
          } else {
            creal_T ck;
            creal_T cs1;
            creal_T cs2;
            int32_T b_i;
            boolean_T errflag;
            boolean_T exitg1;
            if (zd.re == 0.0) {
              pt.re = 1.0;
            } else {
              pt.re = exp(zd.re);
            }

            p1.re = i2Map * pt.re;
            p1.im = i2Map * 0.0;
            pt.re = 8.0 * zd.re;
            pt.im = 0.0;
            ack = 8.0 * hypot(zd.re, 0.0);
            i2Map = -1.0;
            b_atol = 2.2204460492503131E-16 / ack;
            tkd1mtk = 1.0;
            cs1.re = 1.0;
            cs1.im = 0.0;
            cs2.re = 1.0;
            cs2.im = 0.0;
            ck.re = 1.0;
            ck.im = 0.0;
            ak = 0.0;
            aa = 1.0;
            bb = ack;
            dk = pt;
            errflag = true;
            b_i = 1;
            exitg1 = false;
            while ((static_cast<boolean_T>(!static_cast<int32_T>(exitg1))) &&
                   (b_i < 46)) {
              ck.re *= i2Map;
              ck.im *= i2Map;
              if (ck.im == 0.0) {
                fkk = ck.re / dk.re;
                im = 0.0;
              } else if (ck.re == 0.0) {
                fkk = 0.0;
                im = CUDART_NAN;
              } else {
                fkk = ck.re / dk.re;
                im = CUDART_NAN;
              }

              ck.re = fkk;
              ck.im = im;
              cs2.re += fkk;
              cs2.im += im;
              tkd1mtk = -tkd1mtk;
              cs1.re += fkk * tkd1mtk;
              cs1.im += im * tkd1mtk;
              dk.re += pt.re;
              aa = aa * fabs(i2Map) / bb;
              bb += ack;
              ak += 8.0;
              i2Map -= ak;
              if (aa <= b_atol) {
                errflag = false;
                exitg1 = true;
              } else {
                b_i++;
              }
            }

            if (errflag) {
              b_nw = -2;
            } else {
              if (zd.re + zd.re < 700.92179369444591) {
                pt.re = -2.0 * zd.re;
                if (pt.re == 0.0) {
                  pt.re = 1.0;
                  pt.im = -0.0;
                } else {
                  i2Map = pt.re;
                  pt.re = exp(i2Map);
                  pt.im = 0.0;
                }

                fkk = pt.re * cs2.re - pt.im * cs2.im;
                im = pt.re * cs2.im + pt.im * cs2.re;
                cs1.re += fkk * 0.0 - im * 0.0;
                cs1.im += fkk * 0.0 + im * 0.0;
              }

              tmp.re = cs1.re * p1.re - cs1.im * p1.im;
              tmp.im = cs1.re * p1.im + cs1.im * p1.re;
            }
          }

          if (b_nw < 0) {
            if (b_nw == -2) {
              icounter = -2;
            } else {
              icounter = -1;
            }
          } else {
            icounter = 0;
          }
        }
      }

      if (icounter < 0) {
        if (icounter == -2) {
          ierr = 5;
        } else {
          ierr = 2;
        }
      }

      if (ierr == 5) {
        tmp = *dc1;
      } else if (ierr == 2) {
        tmp = *dc6;
      }

      if (zd.re > 0.0) {
        i2Map = tmp.re;
        tmp.re = i2Map;
        tmp.im = 0.0;
      }
    }

    if (tmp.im == 0.0) {
      z.re = tmp.re / 27.239871823604449;
      z.im = 0.0;
    } else if (tmp.re == 0.0) {
      z.re = 0.0;
      z.im = CUDART_NAN;
    } else {
      z.re = tmp.re / 27.239871823604449;
      z.im = CUDART_NAN;
    }

    dv18.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = hypot
      (z.re, z.im);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel564(const
  emxArray_real_T a, const int32_T b_a, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_a);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = a.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel565(const
  emxArray_real_T x, const int32_T b, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.5 * x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel566(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = b.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel567(const int32_T
  omega_tmp2, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel568(const int32_T
  G, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    jpvt.data[itime] = 0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel569(const int32_T
  b, const int32_T nsubs, emxArray_real_T G, int32_T G_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(nsubs) + 1UL) * (static_cast<uint64_T>(b) +
    1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    int32_T icounter;
    i = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    icounter = static_cast<int32_T>((idx - static_cast<uint64_T>(i)) / (
      static_cast<uint64_T>(b) + 1UL));
    G.data[icounter * G_dim0 + i] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel57(const real_T r,
  const emxArray_real_T h1, const real_T cf, const int32_T b_h1, emxArray_real_T
  opts_filter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_h1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_filter.data[itime] = cf * h1.data[itime] / r;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel570(const int32_T
  b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    tau.data[k] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel571(const int32_T
  i, const int64_T b, emxArray_real_T tau)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int64_T k;
    k = static_cast<int64_T>(idx);
    tau.data[static_cast<int32_T>(static_cast<int64_T>(i) + k) - 1] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel572(const int32_T
  nsubs, emxArray_int32_T jpvt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    jpvt.data[k] = k + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel573(const int32_T
  G, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(G);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel574(const int32_T
  omega_tmp2, emxArray_real_T b)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b.data[itime] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel575(const
  emxArray_real_T b, const emxArray_int32_T jpvt, const int32_T nsubs,
  emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nsubs);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    a.data[jpvt.data[i] - 1] = b.data[i];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel576(const
  emxArray_real_T b, const int32_T b_b, emxArray_real_T a)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a.data[itime] = 4.0 * b.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel577(emxArray_real_T
  a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] /= 2.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel578(const int32_T
  b, emxArray_real_T m)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    m.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel579(const
  emxArray_real_T xCh, const int32_T b_xCh, emxArray_real_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_xCh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = xCh.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel58(const int32_T
  halfh, emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(halfh);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel580(const
  emxArray_real_T xCh, const int32_T b_xCh, const int32_T c_xCh, emxArray_real_T
  opts_x, int32_T opts_x_dim0, int32_T xCh_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c_xCh) + 1UL) * (static_cast<uint64_T>(b_xCh)
    + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_xCh) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_xCh) + 1UL));
    opts_x.data[kk + opts_x_dim0 * itime] = xCh.data[itime + xCh_dim0 * kk];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel581(const real_T
  cfsposdft_re, const emxArray_creal_T cfsposdft, const int32_T b_cfsposdft,
  emxArray_creal_T cfspos)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_cfsposdft);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    i2Map = cfsposdft.data[itime].re;
    tkd1mtk = cfsposdft.data[itime].im;
    if (tkd1mtk == 0.0) {
      cfspos.data[itime].re = i2Map / cfsposdft_re;
      cfspos.data[itime].im = 0.0;
    } else if (i2Map == 0.0) {
      cfspos.data[itime].re = 0.0;
      cfspos.data[itime].im = tkd1mtk / cfsposdft_re;
    } else {
      cfspos.data[itime].re = i2Map / cfsposdft_re;
      cfspos.data[itime].im = tkd1mtk / cfsposdft_re;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel582(const int32_T
  b, emxArray_creal_T xposdft, uint32_T xSize_dim1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].re = xposdft.data[i
      + 1].re;
    xposdft.data[(static_cast<int32_T>(xSize_dim1) - i) - 1].im =
      -xposdft.data[i + 1].im;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel583(const
  emxArray_real_T fb_Omega, const emxArray_real_T fb_Scales, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T somega, int32_T somega_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_fb_Scales) + 1UL));
    somega.data[kk + somega_dim0 * itime] = fb_Scales.data[kk] *
      fb_Omega.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel584(const
  emxArray_real_T somega, const int32_T b_somega, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_somega);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = (somega.data[itime] - 5.0) / 0.6;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel585(const
  emxArray_real_T w, const int32_T b_w, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_w);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expnt.data[itime] = -1.0 / (1.0 - w.data[itime] * w.data[itime]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel586(const int32_T
  b, emxArray_real_T expnt)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    expnt.data[k] = exp(expnt.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel587(const
  emxArray_real_T w, const int32_T b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y.data[k] = fabs(w.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel588(const
  emxArray_real_T y, const emxArray_real_T expnt, const int32_T b_expnt,
  emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_expnt);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    daughter.data[itime] = 5.43656365691809 * expnt.data[itime] *
      static_cast<real_T>(y.data[itime] < 0.99999999999999978);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel589(const int32_T
  nrefine, emxArray_real_T daughter)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(nrefine);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T i;
    i = static_cast<int32_T>(idx);
    if (isnan(daughter.data[i])) {
      daughter.data[i] = 0.0;
    }
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel59(const
  emxArray_uint32_T y, const real_T halfh, const int32_T b_y, emxArray_int32_T
  iv6)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    iv6.data[itime] = static_cast<int32_T>(halfh + static_cast<real_T>
      (y.data[itime]));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel590(const
  emxArray_real_T fb_Scales, const int32_T b_fb_Scales, emxArray_real_T f)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_fb_Scales);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    f.data[itime] = 0.79577471545947676 / fb_Scales.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel591(const
  emxArray_real_T fb_Omega, const emxArray_real_T fb_Scales, const int32_T
  b_fb_Scales, const int32_T b, emxArray_real_T somega, int32_T somega_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(b) + 1UL) * (static_cast<uint64_T>
    (b_fb_Scales) + 1UL) - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b_fb_Scales) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b_fb_Scales) + 1UL));
    somega.data[kk + somega_dim0 * itime] = fb_Scales.data[kk] *
      fb_Omega.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel592(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel593(const char_T
  cv[128], char_T wav[5], char_T wname[5], char_T b_dim0, char_T b_dim1, char_T
  b_dim2, char_T b_dim3, char_T b_dim4)
{
  __shared__ char_T b_shared[5];
  int32_T k;
  if (mwGetThreadIndexWithinBlock() == 0U) {
    b_shared[0] = b_dim0;
    b_shared[1] = b_dim1;
    b_shared[2] = b_dim2;
    b_shared[3] = b_dim3;
    b_shared[4] = b_dim4;
  }

  __syncthreads();
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 5) {
    wname[k] = cv[static_cast<int32_T>(b_shared[k])];
    wav[k] = cv[static_cast<int32_T>(cv[static_cast<int32_T>(b_shared[k])])];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel594(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_cwt_kernel595(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel596(const int32_T
  ix, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[ix];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel597(real_T
  interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(128, 1) void ec_cwt_kernel598(real_T
  interval[650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel599(const int32_T
  ix, real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[ix];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel6(real_T interval
  [650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[0] = 0.0;
    interval[1] = 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel60(const
  emxArray_real_T opts_filter, const emxArray_int32_T iv6, const int32_T b_iv6,
  emxArray_real_T h)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_iv6);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    h.data[iv6.data[itime] - 1] = opts_filter.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel600(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel601(const
  emxArray_real_T y, const real_T r, const int32_T b, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_y.data[k] = pow(r, y.data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel602(const
  emxArray_real_T y, const real_T halfh, const int32_T b_y, emxArray_real_T
  fb_Scales)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fb_Scales.data[itime] = halfh * y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel603(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel604(const real_T
  interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel605(const real_T
  x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel606(const int32_T
  b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel607(const real_T
  x_data[9735], const int32_T b, real_T dv16_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv16_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel608(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel609(const real_T
  y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel61(const
  emxArray_real_T opts_x, const int32_T b_opts_x, emxArray_real_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_opts_x);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel610(const real_T
  xt_data[9735], const real_T x_data[9735], const real_T dv16_data[9735], const
  int32_T dv16_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv16_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv16_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel611(const real_T
  interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel612(const real_T
  x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel613(const int32_T
  b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel614(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel615(const real_T
  x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel616(const real_T
  x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T a_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel617(const real_T
  a_data[9735], const int32_T b, real_T dv13_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv13_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel618(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel619(const real_T
  y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel62(const
  emxArray_real_T b_y1, const int32_T b, emxArray_real_T opts_x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    opts_x.data[itime] = b_y1.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel620(const real_T
  xt_data[9735], const real_T x_data[9735], const real_T dv13_data[9735], const
  int32_T dv13_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv13_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv13_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel621(const int32_T
  b, emxArray_int32_T omega_tmp1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp1.data[itime] = itime + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel622(const real_T
  interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel623(const real_T
  x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel624(const int32_T
  b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel625(const real_T
  x_data[9735], const int32_T b, real_T dv10_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    dv10_data[k] = pow(x_data[k], 40.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel626(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel627(const real_T
  y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel628(const real_T
  xt_data[9735], const real_T x_data[9735], const real_T dv10_data[9735], const
  int32_T dv10_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv10_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv10_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel629(const real_T
  interval[650], const int32_T b, real_T subs[1298])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    subs[k << 1] = interval[k];
    subs[(k << 1) + 1] = interval[k + 1];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel63(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel630(const real_T
  x_data[9735], const int32_T b, real_T xt_data[9735], real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    real_T tkd1mtk;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = x_data[k];
    tkd1mtk = i2Map / (1.0 - i2Map);
    b_x_data[k] = tkd1mtk * tkd1mtk;
    xt_data[k] = 2.0 * tkd1mtk / ((1.0 - i2Map) * (1.0 - i2Map));
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel631(const int32_T
  b, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel632(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 19.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel633(const real_T
  x_data[9735], const int32_T b, real_T b_x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    b_x_data[k] = pow(x_data[k], 22.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel634(const real_T
  x_data[9735], const real_T y_data[9735], const int32_T y_size, real_T a_data
  [9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    a_data[itime] = 20.0 * y_data[itime] - 3.0 * x_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel635(const real_T
  a_data[9735], const int32_T b, real_T dv4_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T i2Map;
    int32_T k;
    k = static_cast<int32_T>(idx);
    i2Map = a_data[k];
    dv4_data[k] = i2Map * i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel636(const real_T
  x_data[9735], const int32_T b, real_T y_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    y_data[k] = pow(x_data[k], 3.0);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel637(const real_T
  y_data[9735], const int32_T b, real_T x_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T k;
    k = static_cast<int32_T>(idx);
    x_data[k] = exp(-2.0 * y_data[k]);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel638(const real_T
  xt_data[9735], const real_T x_data[9735], const real_T dv4_data[9735], const
  int32_T dv4_size, real_T fx_data[9735])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(dv4_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    fx_data[itime] = dv4_data[itime] * x_data[itime] * xt_data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel64(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel65(const real_T cf,
  int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[0] = static_cast<int32_T>(cf);
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel66(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel67(const
  emxArray_real_T h, const emxArray_real_T yCol, real_T *r, emxArray_real_T a)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    a.data[0] = yCol.data[0];
    *r = h.data[0];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel68(const real_T *r,
  const emxArray_real_T a, emxArray_real_T c)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    c.data[0] = a.data[0] * *r;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel69(const
  emxArray_real_T c, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    w.data[0] = c.data[0];
  }
}

static __global__ __launch_bounds__(128, 1) void ec_cwt_kernel7(real_T interval
  [650])
{
  int32_T k;
  k = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (k < 648) {
    interval[k + 2] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel70(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel71(const int32_T
  lidx, const int32_T nw, const int32_T dim, int32_T csz[2])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    csz[dim - 1] = div_s32_device(nw, lidx) + 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel72(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel73(const
  emxArray_real_T w, const int32_T xt_size, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = w.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel74(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T lidx, const
  int32_T b, const int32_T c, emxArray_real_T b_w, int32_T w_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    b_w.data[kk + w_dim0 * itime] = w.data[lidx * kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel75(const
  emxArray_real_T w, const int32_T xt_size_dim0, const int32_T b, const int32_T
  c, emxArray_real_T y, int32_T y_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = (static_cast<uint64_T>(c) + 1UL) * (static_cast<uint64_T>(b) + 1UL)
    - 1UL;
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    kk = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    itime = static_cast<int32_T>((idx - static_cast<uint64_T>(kk)) / (
      static_cast<uint64_T>(b) + 1UL));
    y.data[kk + y_dim0 * itime] = w.data[kk + xt_size_dim0 * itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel76(const
  emxArray_real_T y, const int32_T omega_tmp2, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel77(const
  emxArray_real_T y, const int32_T xt_size, emxArray_real_T b_y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y.data[itime] = y.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel78(emxArray_real_T
  y)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    y.data[0] = CUDART_NAN;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel79(const
  emxArray_real_T y, const emxArray_real_T b_y, const real_T tol, const int32_T
  b, emxArray_real_T b_y1)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    b_y1.data[itime] = y.data[static_cast<int32_T>(tol + b_y.data[itime]) - 1];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel8(const int32_T ix,
  real_T interval[650])
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    interval[1] = interval[ix];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel80(const int32_T
  b, emxArray_real_T y)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    y.data[itime] = static_cast<real_T>(itime) + 1.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel81(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel82(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel83(const
  emxArray_real_T yCol, const emxArray_real_T h, emxArray_real_T w)
{
  int32_T i;
  i = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (i < 1) {
    real_T i2Map;
    i2Map = h.data[0] * yCol.data[0];
    w.data[0] = i2Map;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel84(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel85(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv52)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv52.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel86(const
  emxArray_real_T h, const emxArray_int32_T iv52, const int32_T omega_tmp2,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[iv52.data[itime]] = h.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel87(const
  emxArray_real_T yCol, const emxArray_real_T expanded, const emxArray_int32_T
  rows, const int32_T csz[2], const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T icounter;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    icounter = csz[0];
    for (int32_T m{0}; m < icounter; m++) {
      int32_T kk;
      kk = rows.data[m];
      if ((ierr + 1 < 0) && (kk < MAX_int32_T - ierr)) {
        kk = MIN_int32_T;
      } else if ((ierr + 1 > 0) && (kk > 2147483646 - ierr)) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * yCol.data[(icounter - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel88(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel89(const int32_T
  b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel9(const real_T fc,
  const emxArray_int32_T omega_tmp1, const int32_T b_omega_tmp1, emxArray_real_T
  omega_tmp2)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_omega_tmp1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    omega_tmp2.data[itime] = static_cast<real_T>(omega_tmp1.data[itime]) * fc;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel90(const
  emxArray_real_T c, const int32_T b, emxArray_real_T w)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    w.data[itime] = c.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel91(const int32_T
  y_size_idx_1, emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(y_size_idx_1);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    expanded.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel92(const int32_T
  dim, const emxArray_int32_T y, const int32_T b_y, emxArray_int32_T iv54)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b_y);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    int32_T kk;
    itime = static_cast<int32_T>(idx);
    kk = y.data[itime];
    if ((dim < 0) && (kk < MIN_int32_T - dim)) {
      kk = MIN_int32_T;
    } else if ((dim > 0) && (kk > MAX_int32_T - dim)) {
      kk = MAX_int32_T;
    } else {
      kk += dim;
    }

    iv54.data[itime] = kk - 1;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel93(const
  emxArray_real_T yCol, const emxArray_int32_T iv54, const int32_T xt_size,
  emxArray_real_T expanded)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(xt_size);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx % (static_cast<uint64_T>(xt_size) + 1UL));
    expanded.data[iv54.data[itime]] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel94(const
  emxArray_real_T expanded, const emxArray_int32_T rows, const emxArray_real_T h,
  const int32_T b, emxArray_real_T w, int32_T h_dim0)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    real_T tkd1mtk;
    int32_T ierr;
    ierr = static_cast<int32_T>(idx % (static_cast<uint64_T>(b) + 1UL));
    tkd1mtk = 0.0;
    for (int32_T m{0}; m < h_dim0; m++) {
      int32_T kk;
      kk = rows.data[m];
      if (kk > 2147483646 - ierr) {
        kk = MAX_int32_T;
      } else {
        kk = (ierr + kk) + 1;
      }

      tkd1mtk += expanded.data[kk - 1] * h.data[(h_dim0 - m) - 1];
    }

    w.data[ierr] = tkd1mtk;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel95(const int32_T
  b, emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[itime] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel96(const
  emxArray_real_T opts_x, const int32_T nw, const int32_T omega_tmp2,
  emxArray_real_T yCol)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(omega_tmp2);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    yCol.data[nw * itime] = opts_x.data[itime];
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel97(const
  emxArray_real_T yCol, const int32_T csz, emxArray_real_T x)
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(csz);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T itime;
    itime = static_cast<int32_T>(idx);
    x.data[itime] = yCol.data[itime];
  }
}

static __global__ __launch_bounds__(32, 1) void ec_cwt_kernel98(emxArray_real_T
  w)
{
  int32_T tmpIdx;
  tmpIdx = static_cast<int32_T>(mwGetGlobalThreadIndex());
  if (tmpIdx < 1) {
    w.data[0] = 0.0;
  }
}

static __global__ __launch_bounds__(1024, 1) void ec_cwt_kernel99(const int32_T
  nsubs, const int32_T b, int32_T lshift[2])
{
  uint64_T gStride;
  uint64_T gThreadId;
  uint64_T loopEnd;
  gThreadId = mwGetGlobalThreadIndex();
  gStride = mwGetTotalThreadsLaunched();
  loopEnd = static_cast<uint64_T>(b);
  for (uint64_T idx{gThreadId}; idx <= loopEnd; idx += gStride) {
    int32_T icounter;
    icounter = lshift[0];
    lshift[0] = lshift[1 - nsubs];
    lshift[1 - nsubs] = icounter;
  }
}

static void ec_cwt_once()
{
  mex_InitInfAndNan();
  checkCudaError(mwCudaMalloc(&global_gpu_cv, sizeof(char_T [128])), __FILE__,
                 __LINE__);
  checkCudaError(mwCudaMalloc(&global_gpu_table100, sizeof(real_T [100])),
                 __FILE__, __LINE__);
}

static void emlrtExitTimeCleanupDtorFcn(const void *r)
{
  emlrtExitTimeCleanup(&emlrtContextGlobal);
}

static void emlrt_marshallIn(const mxArray *b_nullptr, const char_T *identifier,
  emxArray_real_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(b_nullptr), &thisId, y);
  emlrtDestroyArray(&b_nullptr);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_char_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *tmpStr, const char_T *identifier,
  emxArray_char_T *y)
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(tmpStr), &thisId, y);
  emlrtDestroyArray(&tmpStr);
}

static real_T emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId)
{
  real_T y;
  y = c_emlrt_marshallIn(emlrtAlias(u), parentId);
  emlrtDestroyArray(&u);
  return y;
}

static real_T emlrt_marshallIn(const mxArray *a__output_of_length_, const char_T
  *identifier)
{
  emlrtMsgIdentifier thisId;
  real_T y;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  y = emlrt_marshallIn(emlrtAlias(a__output_of_length_), &thisId);
  emlrtDestroyArray(&a__output_of_length_);
  return y;
}

static void emlrt_marshallIn(const mxArray *a__output_of_sprintf_, const char_T *
  identifier, char_T y[23])
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = const_cast<const char_T *>(identifier);
  thisId.fParent = nullptr;
  thisId.bParentIsCell = false;
  emlrt_marshallIn(emlrtAlias(a__output_of_sprintf_), &thisId, y);
  emlrtDestroyArray(&a__output_of_sprintf_);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, char_T y[23])
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static void emlrt_marshallIn(const mxArray *u, const emlrtMsgIdentifier
  *parentId, emxArray_real_T *y)
{
  b_emlrt_marshallIn(emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static const mxArray *emlrt_marshallOut(const cell_wrap_0 u_data[], const
  int32_T u_size[2])
{
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T *pData;
  int32_T iv[2];
  int32_T n;
  y = nullptr;
  emlrtAssign(&y, emlrtCreateCellArrayR2014a(2, &u_size[0]));
  n = u_size[1];
  for (int32_T i{0}; i < n; i++) {
    int32_T i1;
    int32_T loopUpperBound;
    b_y = nullptr;
    iv[0] = u_data[i].f1->size[0];
    iv[1] = u_data[i].f1->size[1];
    m = emlrtCreateNumericArray(2, &iv[0], mxDOUBLE_CLASS, mxREAL);
    pData = emlrtMxGetPr(m);
    i1 = 0;
    loopUpperBound = u_data[i].f1->size[1];
    for (int32_T b_i{0}; b_i < loopUpperBound; b_i++) {
      int32_T b_loopUpperBound;
      b_loopUpperBound = u_data[i].f1->size[0];
      for (int32_T c_i{0}; c_i < b_loopUpperBound; c_i++) {
        pData[i1 + c_i] = u_data[i].f1->data[c_i + u_data[i].f1->size[0] * b_i];
      }

      if (u_data[i].f1->size[0] - 1 >= 0) {
        i1 += u_data[i].f1->size[0];
      }
    }

    emlrtAssign(&b_y, m);
    emlrtSetCell(y, i, b_y);
  }

  return y;
}

static const mxArray *emlrt_marshallOut(const emxArray_real_T *u)
{
  static const int32_T iv[1]{ 0 };

  const mxArray *m;
  const mxArray *y;
  y = nullptr;
  m = emlrtCreateNumericArray(1, (const void *)&iv[0], mxDOUBLE_CLASS, mxREAL);
  emlrtMxSetData((mxArray *)m, &u->data[0]);
  emlrtSetDimensions((mxArray *)m, &u->size[0], 1);
  emlrtAssign(&y, m);
  return y;
}

static void emxEnsureCapacity_cell_wrap_0(cell_wrap_0 data[65534], const int32_T
  size[2], int32_T oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T newNumel;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = size[0] * size[1];
  if (oldNumel > newNumel) {
    emxTrim_cell_wrap_0_1x65534(data, newNumel, oldNumel);
  } else if (oldNumel < newNumel) {
    emxExpand_cell_wrap_0_1x65534(data, oldNumel, newNumel, srcLocation);
  }
}

static void emxEnsureCapacity_char_T(emxArray_char_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(char_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<char_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<char_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_creal_T(emxArray_creal_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(creal_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<creal_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<creal_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_int32_T(emxArray_int32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(int32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<int32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<int32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_ptrdiff_t(emxArray_ptrdiff_t *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(ptrdiff_t));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<ptrdiff_t *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<ptrdiff_t *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_real_T(emxArray_real_T *emxArray, int32_T oldNumel,
  const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(real_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<real_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<real_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxEnsureCapacity_uint32_T(emxArray_uint32_T *emxArray, int32_T
  oldNumel, const emlrtRTEInfo *srcLocation)
{
  int32_T i;
  int32_T newNumel;
  void *newData;
  if (oldNumel < 0) {
    oldNumel = 0;
  }

  newNumel = 1;
  for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel = static_cast<int32_T>(emlrtSizeMulR2012b((size_t)
      static_cast<uint32_T>(newNumel), (size_t)static_cast<uint32_T>
      (emxArray->size[i]), srcLocation, emlrtRootTLSGlobal));
  }

  if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
      i = 16;
    }

    while (i < newNumel) {
      if (i > 1073741823) {
        i = MAX_int32_T;
      } else {
        i *= 2;
      }
    }

    newData = emlrtMallocMex(static_cast<uint32_T>(i) * sizeof(uint32_T));
    if (newData == nullptr) {
      emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
    }

    if (emxArray->data != nullptr) {
      std::copy(emxArray->data, emxArray->data + static_cast<uint32_T>(oldNumel),
                static_cast<uint32_T *>(newData));
      if (emxArray->canFreeData) {
        emlrtFreeMex(emxArray->data);
      }
    }

    emxArray->data = static_cast<uint32_T *>(newData);
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
  }
}

static void emxExpand_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex, const emlrtRTEInfo *srcLocation)
{
  int64_T b;
  b = b_computeEndIdx(static_cast<int64_T>(fromIndex), static_cast<int64_T>
                      (toIndex - 1), 1L);
  for (int64_T i{0L}; i <= b; i++) {
    emxInitStruct_cell_wrap_0(&data[static_cast<int32_T>(fromIndex + i)],
      srcLocation, false);
  }
}

static void emxFreeStruct_cell_wrap_0(cell_wrap_0 *pStruct)
{
  emxFree_real_T(&pStruct->f1);
}

static void emxFree_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray)
{
  int32_T numEl;
  numEl = pEmxArray->size[0] * pEmxArray->size[1];
  for (int32_T i{0}; i < numEl; i++) {
    emxFreeStruct_cell_wrap_0(&pEmxArray->data[i]);
  }
}

static void emxFree_char_T(emxArray_char_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_char_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_char_T *>(nullptr);
  }
}

static void emxFree_creal_T(emxArray_creal_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_creal_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<creal_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_creal_T *>(nullptr);
  }
}

static void emxFree_int32_T(emxArray_int32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_int32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_int32_T *>(nullptr);
  }
}

static void emxFree_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_ptrdiff_t *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<ptrdiff_t *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_ptrdiff_t *>(nullptr);
  }
}

static void emxFree_real_T(emxArray_real_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_real_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) && (*pEmxArray)
        ->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_real_T *>(nullptr);
  }
}

static void emxFree_uint32_T(emxArray_uint32_T **pEmxArray)
{
  if (*pEmxArray != static_cast<emxArray_uint32_T *>(nullptr)) {
    if (((*pEmxArray)->data != static_cast<uint32_T *>(nullptr)) && (*pEmxArray
        )->canFreeData) {
      emlrtFreeMex((*pEmxArray)->data);
    }

    emlrtFreeMex((*pEmxArray)->size);
    emlrtRemoveHeapReference(emlrtRootTLSGlobal, (void *)pEmxArray);
    emlrtFreeEmxArray(*pEmxArray);
    *pEmxArray = static_cast<emxArray_uint32_T *>(nullptr);
  }
}

static void emxInitStruct_cell_wrap_0(cell_wrap_0 *pStruct, const emlrtRTEInfo
  *srcLocation, boolean_T doPush)
{
  emxInit_real_T(&pStruct->f1, 2, srcLocation, doPush);
}

static void emxInit_cell_wrap_0_1x65534(emxArray_cell_wrap_0_1x65534 *pEmxArray)
{
  pEmxArray->size[0] = 0;
  pEmxArray->size[1] = 0;
}

static void emxInit_char_T(emxArray_char_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_char_T *emxArray;
  *pEmxArray = static_cast<emxArray_char_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_char_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_char_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<char_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_creal_T(emxArray_creal_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_creal_T *emxArray;
  *pEmxArray = static_cast<emxArray_creal_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_creal_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_creal_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<creal_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_int32_T(emxArray_int32_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_int32_T *emxArray;
  *pEmxArray = static_cast<emxArray_int32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_int32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_int32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<int32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_ptrdiff_t(emxArray_ptrdiff_t **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_ptrdiff_t *emxArray;
  *pEmxArray = static_cast<emxArray_ptrdiff_t *>(emlrtMallocEmxArray(sizeof
    (emxArray_ptrdiff_t)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_ptrdiff_t, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<ptrdiff_t *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_real_T(emxArray_real_T **pEmxArray, int32_T numDimensions,
  const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_real_T *emxArray;
  *pEmxArray = static_cast<emxArray_real_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_real_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_real_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<real_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxInit_uint32_T(emxArray_uint32_T **pEmxArray, int32_T
  numDimensions, const emlrtRTEInfo *srcLocation, boolean_T doPush)
{
  emxArray_uint32_T *emxArray;
  *pEmxArray = static_cast<emxArray_uint32_T *>(emlrtMallocEmxArray(sizeof
    (emxArray_uint32_T)));
  if ((void *)*pEmxArray == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  if (doPush) {
    emlrtPushHeapReferenceStackEmxArray(emlrtRootTLSGlobal, false, (void *)
      pEmxArray, (void *)&emxFree_uint32_T, nullptr, nullptr, nullptr);
  }

  emxArray = *pEmxArray;
  emxArray->data = static_cast<uint32_T *>(nullptr);
  emxArray->numDimensions = numDimensions;
  emxArray->size = static_cast<int32_T *>(emlrtMallocMex(sizeof(int32_T) *
    static_cast<uint32_T>(numDimensions)));
  if ((void *)emxArray->size == nullptr) {
    emlrtHeapAllocationErrorR2012b(srcLocation, emlrtRootTLSGlobal);
  }

  emxArray->allocatedSize = 0;
  emxArray->canFreeData = true;
  for (int32_T i{0}; i < numDimensions; i++) {
    emxArray->size[i] = 0;
  }
}

static void emxTrim_cell_wrap_0_1x65534(cell_wrap_0 data[65534], int32_T
  fromIndex, int32_T toIndex)
{
  int64_T b;
  b = b_computeEndIdx(static_cast<int64_T>(fromIndex), static_cast<int64_T>
                      (toIndex - 1), 1L);
  for (int64_T i{0L}; i <= b; i++) {
    emxFreeStruct_cell_wrap_0(&data[static_cast<int32_T>(fromIndex + i)]);
  }
}

static const mxArray *feval(const mxArray *m1, const mxArray *m2, const mxArray *
  m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 3, &pArrays[0],
    "feval", true, location);
}

static const mxArray *feval(const mxArray *m1, const mxArray *m2, emlrtMCInfo
  *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 2, &pArrays[0],
    "feval", true, location);
}

static void gpuEmxEnsureCapacity_creal_T(const emxArray_creal_T *cpu,
  emxArray_creal_T *gpu, boolean_T needsCopy)
{
  creal_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (creal_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(creal_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_int32_T(const emxArray_int32_T *cpu,
  emxArray_int32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  int32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (int32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(int32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_real_T(const emxArray_real_T *cpu,
  emxArray_real_T *gpu, boolean_T needsCopy)
{
  real_T *newData;
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (real_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(real_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxEnsureCapacity_uint32_T(const emxArray_uint32_T *cpu,
  emxArray_uint32_T *gpu, boolean_T needsCopy)
{
  int32_T i;
  int32_T totalSizeCpu;
  int32_T totalSizeGpu;
  uint32_T *newData;
  if (gpu->numDimensions == 0) {
    gpu->numDimensions = cpu->numDimensions;
    gpu->size = static_cast<int32_T *>(emlrtCallocMex(static_cast<uint32_T>
      (gpu->numDimensions), sizeof(int32_T)));
  }

  totalSizeCpu = 1;
  totalSizeGpu = 1;
  for (i = 0; i < cpu->numDimensions; i++) {
    totalSizeGpu *= gpu->size[i];
    totalSizeCpu *= cpu->size[i];
    gpu->size[i] = cpu->size[i];
  }

  if (gpu->allocatedSize < totalSizeCpu) {
    i = cpu->allocatedSize;
    if (i < totalSizeCpu) {
      i = totalSizeCpu;
    }

    checkCudaError(mwCudaMalloc(&newData, static_cast<uint32_T>(i) * sizeof
      (uint32_T)), __FILE__, __LINE__);
    needsCopy = (needsCopy && gpu->canFreeData);
    if (needsCopy) {
      checkCudaError(cudaMemcpy(newData, gpu->data, static_cast<uint32_T>
        (totalSizeGpu) * sizeof(uint32_T), cudaMemcpyDeviceToDevice), __FILE__,
                     __LINE__);
    }

    if (gpu->canFreeData) {
      checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
    }

    gpu->data = newData;
    gpu->allocatedSize = i;
    gpu->canFreeData = true;
  }
}

static void gpuEmxFree_creal_T(emxArray_creal_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_int32_T(emxArray_int32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_real_T(emxArray_real_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxFree_uint32_T(emxArray_uint32_T *gpu)
{
  if (gpu->data != (void *)4207599121UL) {
    checkCudaError(mwCudaFree(gpu->data), __FILE__, __LINE__);
  }

  emlrtFreeMex(gpu->size);
}

static void gpuEmxMemcpyCpuToGpu_creal_T(emxArray_creal_T *gpu, const
  emxArray_creal_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_int32_T(emxArray_int32_T *gpu, const
  emxArray_int32_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyCpuToGpu_real_T(emxArray_real_T *gpu, const
  emxArray_real_T *cpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(gpu->data, cpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyHostToDevice), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_creal_T(emxArray_creal_T *cpu, emxArray_creal_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(creal_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_int32_T(emxArray_int32_T *cpu, emxArray_int32_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(int32_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxMemcpyGpuToCpu_real_T(emxArray_real_T *cpu, emxArray_real_T
  *gpu)
{
  int32_T actualSize;
  actualSize = 1;
  for (int32_T i{0}; i < cpu->numDimensions; i++) {
    actualSize *= cpu->size[i];
  }

  checkCudaError(cudaMemcpy(cpu->data, gpu->data, static_cast<uint32_T>
    (actualSize) * sizeof(real_T), cudaMemcpyDeviceToHost), __FILE__, __LINE__);
}

static void gpuEmxReset_creal_T(emxArray_creal_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_creal_T));
}

static void gpuEmxReset_int32_T(emxArray_int32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_int32_T));
}

static void gpuEmxReset_real_T(emxArray_real_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_real_T));
}

static void gpuEmxReset_uint32_T(emxArray_uint32_T *gpu)
{
  std::memset(gpu, 0, sizeof(emxArray_uint32_T));
}

static const mxArray *length(const mxArray *m1, emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 1, &m, 1, &pArray, "length",
    true, location);
}

static void raiseCudaError(int32_T errCode, const char_T *file, uint32_T b_line,
  const char_T *errorName, const char_T *errorString)
{
  emlrtRTEInfo rtInfo;
  uint64_T len;
  char_T *brk;
  char_T *fn;
  char_T *pn;
  len = strlen(file);
  pn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  fn = static_cast<char_T *>(std::calloc(static_cast<uint32_T>(len + 1UL), 1U));
  memcpy(pn, file, len);
  memcpy(fn, file, len);
  brk = strrchr(fn, '.');
  *brk = '\x00';
  brk = strrchr(fn, '/');
  if (brk == nullptr) {
    brk = strrchr(fn, '\\');
  }

  if (brk == nullptr) {
    brk = fn;
  } else {
    brk++;
  }

  rtInfo.lineNo = static_cast<int32_T>(b_line);
  rtInfo.colNo = 0;
  rtInfo.fName = brk;
  rtInfo.pName = pn;
  emlrtCUDAError(static_cast<uint32_T>(errCode), (char_T *)errorName, (char_T *)
                 errorString, &rtInfo, emlrtRootTLSGlobal);
}

static real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else {
    real_T b;
    real_T c;
    b = std::abs(u0);
    c = std::abs(u1);
    if (std::isinf(u1)) {
      if (b == 1.0) {
        y = 1.0;
      } else if (b > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (c == 0.0) {
      y = 1.0;
    } else if (c == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }

  return y;
}

static real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
    y = rtNaN;
  } else if (std::isinf(u1)) {
    y = u0;
  } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {
    real_T q;
    q = std::abs(u0 / u1);
    if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {
      y = 0.0 * u0;
    } else {
      y = std::fmod(u0, u1);
    }
  } else {
    y = std::fmod(u0, u1);
  }

  return y;
}

void b_ec_cwt_api(ec_cwtStackData *SD, const mxArray * const prhs[5], int32_T
                  nlhs, const mxArray *plhs[2])
{
  emxArray_real_T *freqs;
  emxArray_real_T *x;
  real_T (*ds)[2];
  real_T (*fLims)[2];
  real_T fOctave;
  real_T fs;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  // Marshall function inputs
  emxInit_real_T(&x, 2, &le_emlrtRTEI, true);
  x->canFreeData = false;
  emlrt_marshallIn(emlrtAlias(prhs[0]), "x", x);
  fs = emlrt_marshallIn(emlrtAliasP(prhs[1]), "fs");
  fLims = b_emlrt_marshallIn(emlrtAlias(prhs[2]), "fLims");
  fOctave = emlrt_marshallIn(emlrtAliasP(prhs[3]), "fOctave");
  ds = b_emlrt_marshallIn(emlrtAlias(prhs[4]), "ds");

  // Invoke the target function
  emxInit_cell_wrap_0_1x65534(&SD->f1.y);
  emxInit_real_T(&freqs, 1, &le_emlrtRTEI, true);
  ec_cwt(SD, x, fs, *fLims, fOctave, *ds, SD->f1.y.data, SD->f1.y.size, freqs);
  emxFree_real_T(&x);

  // Marshall function outputs
  plhs[0] = emlrt_marshallOut(SD->f1.y.data, SD->f1.y.size);
  emxFree_cell_wrap_0_1x65534(&SD->f1.y);
  if (nlhs > 1) {
    freqs->canFreeData = false;
    plhs[1] = emlrt_marshallOut(freqs);
  }

  emxFree_real_T(&freqs);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

//
// function [y,freqs] = ec_cwt(x,fs,fLims,fOctave,ds)
void ec_cwt(ec_cwtStackData *SD, const emxArray_real_T *cpu_x, real_T fs, const
            real_T fLims[2], real_T fOctave, const real_T ds[2], cell_wrap_0
            y_data[], int32_T y_size[2], emxArray_real_T *cpu_freqs)
{
  static const creal_T dc7{ 1.0020841800044864E-289,// re
    0.0                                // im
  };

  static creal_T cpu_dc1{ 0.0,         // re
    0.0                                // im
  };

  static creal_T cpu_dc6{ 0.0,         // re
    0.0                                // im
  };

  static const real_T cpu_table100[100]{ 0.0, 0.0, 0.69314718055994529,
    1.791759469228055, 3.1780538303479458, 4.7874917427820458,
    6.5792512120101012, 8.5251613610654147, 10.604602902745251,
    12.801827480081469, 15.104412573075516, 17.502307845873887,
    19.987214495661885, 22.552163853123425, 25.19122118273868, 27.89927138384089,
    30.671860106080672, 33.505073450136891, 36.395445208033053,
    39.339884187199495, 42.335616460753485, 45.380138898476908,
    48.471181351835227, 51.606675567764377, 54.784729398112319,
    58.003605222980518, 61.261701761002, 64.557538627006338, 67.88974313718154,
    71.257038967168015, 74.658236348830158, 78.0922235533153, 81.557959456115043,
    85.054467017581516, 88.580827542197682, 92.1361756036871, 95.7196945421432,
    99.330612454787428, 102.96819861451381, 106.63176026064346,
    110.32063971475739, 114.03421178146171, 117.77188139974507,
    121.53308151543864, 125.3172711493569, 129.12393363912722,
    132.95257503561632, 136.80272263732635, 140.67392364823425,
    144.5657439463449, 148.47776695177302, 152.40959258449735, 156.3608363030788,
    160.3311282166309, 164.32011226319517, 168.32744544842765,
    172.35279713916279, 176.39584840699735, 180.45629141754378,
    184.53382886144948, 188.6281734236716, 192.7390472878449, 196.86618167289,
    201.00931639928152, 205.1681994826412, 209.34258675253685,
    213.53224149456327, 217.73693411395422, 221.95644181913033,
    226.1905483237276, 230.43904356577696, 234.70172344281826,
    238.97838956183432, 243.26884900298271, 247.57291409618688,
    251.89040220972319, 256.22113555000954, 260.56494097186322,
    264.92164979855278, 269.29109765101981, 273.67312428569369,
    278.06757344036612, 282.4742926876304, 286.893133295427, 291.32395009427029,
    295.76660135076065, 300.22094864701415, 304.68685676566872,
    309.1641935801469, 313.65282994987905, 318.1526396202093, 322.66349912672615,
    327.1852877037752, 331.71788719692847, 336.26118197919845, 340.815058870799,
    345.37940706226686, 349.95411804077025, 354.53908551944079,
    359.1342053695754 };

  static const real_T NODES[15]{ -0.99145537112081261, -0.94910791234275849,
    -0.8648644233597691, -0.74153118559939435, -0.58608723546769115,
    -0.40584515137739718, -0.20778495500789851, 0.0, 0.20778495500789851,
    0.40584515137739718, 0.58608723546769115, 0.74153118559939435,
    0.8648644233597691, 0.94910791234275849, 0.99145537112081261 };

  static const real_T dv5[15]{ 0.022935322010529221, 0.063092092629978544,
    0.1047900103222502, 0.14065325971552589, 0.16900472663926791,
    0.19035057806478539, 0.20443294007529891, 0.20948214108472779,
    0.20443294007529891, 0.19035057806478539, 0.16900472663926791,
    0.14065325971552589, 0.1047900103222502, 0.063092092629978544,
    0.022935322010529221 };

  static const real_T dv6[15]{ 0.022935322010529221, -0.066392873538891159,
    0.1047900103222502, -0.13905213177375081, 0.16900472663926791,
    -0.19147947244033353, 0.20443294007529891, -0.20847704258874161,
    0.20443294007529891, -0.19147947244033353, 0.16900472663926791,
    -0.13905213177375081, 0.1047900103222502, -0.066392873538891159,
    0.022935322010529221 };

  static const real_T p1[8]{ 4.9452353592967269, 201.8112620856775,
    2290.8383738313464, 11319.672059033808, 28557.246356716354,
    38484.962284437934, 26377.487876241954, 7225.8139797002877 };

  static const real_T p2[8]{ 4.974607845568932, 542.4138599891071,
    15506.938649783649, 184793.29044456323, 1.0882047694688288E+6,
    3.33815296798703E+6, 5.1066616789273527E+6, 3.0741090548505397E+6 };

  static const real_T p4[8]{ 14745.0216605994, 2.4268133694867045E+6,
    1.2147555740450932E+8, 2.6634324496309772E+9, 2.9403789566345539E+10,
    1.7026657377653989E+11, 4.926125793377431E+11, 5.6062518562239514E+11 };

  static const real_T q1[8]{ 67.482125503037778, 1113.3323938571993,
    7738.7570569353984, 27639.870744033407, 54993.102062261576,
    61611.221800660023, 36351.2759150194, 8785.5363024310136 };

  static const real_T q2[8]{ 183.03283993705926, 7765.0493214450062,
    133190.38279660742, 1.1367058213219696E+6, 5.2679641174379466E+6,
    1.3467014543111017E+7, 1.7827365303532742E+7, 9.5330955918443538E+6 };

  static const real_T q4[8]{ 2690.5301758708993, 639388.56543000927,
    4.1355999302413881E+7, 1.120872109616148E+9, 1.4886137286788137E+10,
    1.0168035862724382E+11, 3.4174763455073773E+11, 4.4631581874197131E+11 };

  static const real_T c[7]{ -0.001910444077728, 0.00084171387781295,
    -0.00059523799130430121, 0.0007936507935003503, -0.0027777777777776816,
    0.083333333333333329, 0.0057083835261 };

  static const int32_T iv[2]{ 1, 7 };

  static const int32_T iv1[2]{ 1, 2 };

  static const int32_T iv10[2]{ 1, 7 };

  static const int32_T iv12[2]{ 1, 7 };

  static const int32_T iv13[2]{ 1, 7 };

  static const int32_T iv14[2]{ 1, 7 };

  static const int32_T iv15[2]{ 1, 7 };

  static const int32_T iv16[2]{ 1, 7 };

  static const int32_T iv17[2]{ 1, 7 };

  static const int32_T iv19[2]{ 1, 7 };

  static const int32_T iv2[2]{ 1, 7 };

  static const int32_T iv20[2]{ 1, 7 };

  static const int32_T iv21[2]{ 1, 7 };

  static const int32_T iv22[2]{ 1, 7 };

  static const int32_T iv23[2]{ 1, 7 };

  static const int32_T iv24[2]{ 1, 7 };

  static const int32_T iv25[2]{ 1, 7 };

  static const int32_T iv26[2]{ 1, 7 };

  static const int32_T iv27[2]{ 1, 7 };

  static const int32_T iv28[2]{ 1, 7 };

  static const int32_T iv3[2]{ 1, 5 };

  static const int32_T iv7[2]{ 1, 7 };

  static const int32_T iv8[2]{ 1, 7 };

  static const int32_T iv9[2]{ 1, 7 };

  static const char_T cpu_cv[128]{ '\x00', '\x01', '\x02', '\x03', '\x04',
    '\x05', '\x06', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\x0e', '\x0f',
    '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18',
    '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '\"', '#',
    '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'a',
    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}',
    '~', '\x7f' };

  static const char_T b[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n' };

  static const char_T cv1[10]{ 'r', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'o', 'n'
  };

  static const char_T rfmt[7]{ '%', '2', '3', '.', '1', '5', 'e' };

  static const char_T u[7]{ 's', 'p', 'r', 'i', 'n', 't', 'f' };

  static const char_T b_formatSpec[5]{ '%', '2', '.', '2', 'f' };

  static const char_T c_b[5]{ 'M', 'o', 'r', 's', 'e' };

  static const char_T cv2[5]{ 'M', 'o', 'r', 's', 'e' };

  static const char_T cv3[5]{ 'm', 'o', 'r', 's', 'e' };

  static const char_T formatSpec[2]{ '%', 'f' };

  static const int8_T A[4]{ 1, 1, 0, 0 };

  dim3 block;
  dim3 grid;
  emxArray_char_T *d_tmpStr;
  emxArray_char_T *tmpStr;
  emxArray_creal_T gpu_cfspos;
  emxArray_creal_T gpu_cfsposdft;
  emxArray_creal_T gpu_xposdft;
  emxArray_creal_T *cpu_cfspos;
  emxArray_creal_T *cpu_cfsposdft;
  emxArray_creal_T *cpu_xposdft;
  emxArray_int32_T ab_gpu_rows;
  emxArray_int32_T ab_gpu_y;
  emxArray_int32_T ac_gpu_y;
  emxArray_int32_T b_gpu_cols;
  emxArray_int32_T b_gpu_rows;
  emxArray_int32_T bb_gpu_rows;
  emxArray_int32_T bb_gpu_y;
  emxArray_int32_T bc_gpu_y;
  emxArray_int32_T c_gpu_cols;
  emxArray_int32_T c_gpu_rows;
  emxArray_int32_T cb_gpu_rows;
  emxArray_int32_T cb_gpu_y;
  emxArray_int32_T cc_gpu_y;
  emxArray_int32_T cd_gpu_y;
  emxArray_int32_T d_gpu_cols;
  emxArray_int32_T d_gpu_rows;
  emxArray_int32_T db_gpu_rows;
  emxArray_int32_T db_gpu_y;
  emxArray_int32_T dc_gpu_y;
  emxArray_int32_T dd_gpu_y;
  emxArray_int32_T e_gpu_cols;
  emxArray_int32_T e_gpu_rows;
  emxArray_int32_T eb_gpu_rows;
  emxArray_int32_T eb_gpu_y;
  emxArray_int32_T ec_gpu_y;
  emxArray_int32_T ed_gpu_y;
  emxArray_int32_T f_gpu_cols;
  emxArray_int32_T f_gpu_rows;
  emxArray_int32_T fb_gpu_rows;
  emxArray_int32_T fb_gpu_y;
  emxArray_int32_T fc_gpu_y;
  emxArray_int32_T fd_gpu_y;
  emxArray_int32_T g_gpu_rows;
  emxArray_int32_T gb_gpu_rows;
  emxArray_int32_T gd_gpu_y;
  emxArray_int32_T gpu_IPIV;
  emxArray_int32_T gpu_cols;
  emxArray_int32_T gpu_iv29;
  emxArray_int32_T gpu_iv30;
  emxArray_int32_T gpu_iv31;
  emxArray_int32_T gpu_iv32;
  emxArray_int32_T gpu_iv33;
  emxArray_int32_T gpu_iv34;
  emxArray_int32_T gpu_iv35;
  emxArray_int32_T gpu_iv36;
  emxArray_int32_T gpu_iv37;
  emxArray_int32_T gpu_iv38;
  emxArray_int32_T gpu_iv39;
  emxArray_int32_T gpu_iv40;
  emxArray_int32_T gpu_iv41;
  emxArray_int32_T gpu_iv42;
  emxArray_int32_T gpu_iv43;
  emxArray_int32_T gpu_iv44;
  emxArray_int32_T gpu_iv45;
  emxArray_int32_T gpu_iv46;
  emxArray_int32_T gpu_iv49;
  emxArray_int32_T gpu_iv50;
  emxArray_int32_T gpu_iv51;
  emxArray_int32_T gpu_iv52;
  emxArray_int32_T gpu_iv53;
  emxArray_int32_T gpu_iv54;
  emxArray_int32_T gpu_iv56;
  emxArray_int32_T gpu_iv57;
  emxArray_int32_T gpu_iv58;
  emxArray_int32_T gpu_iv59;
  emxArray_int32_T gpu_iv6;
  emxArray_int32_T gpu_iv60;
  emxArray_int32_T gpu_iv61;
  emxArray_int32_T gpu_iv62;
  emxArray_int32_T gpu_iv63;
  emxArray_int32_T gpu_iv64;
  emxArray_int32_T gpu_iv65;
  emxArray_int32_T gpu_iv66;
  emxArray_int32_T gpu_iv67;
  emxArray_int32_T gpu_iv68;
  emxArray_int32_T gpu_iv69;
  emxArray_int32_T gpu_iv71;
  emxArray_int32_T gpu_iv73;
  emxArray_int32_T gpu_iv74;
  emxArray_int32_T gpu_iv75;
  emxArray_int32_T gpu_iv76;
  emxArray_int32_T gpu_iv77;
  emxArray_int32_T gpu_iv78;
  emxArray_int32_T gpu_iv79;
  emxArray_int32_T gpu_iv80;
  emxArray_int32_T gpu_iv81;
  emxArray_int32_T gpu_iv83;
  emxArray_int32_T gpu_iv84;
  emxArray_int32_T gpu_iv85;
  emxArray_int32_T gpu_iv86;
  emxArray_int32_T gpu_iv87;
  emxArray_int32_T gpu_iv89;
  emxArray_int32_T gpu_iv93;
  emxArray_int32_T gpu_iv94;
  emxArray_int32_T gpu_jpvt;
  emxArray_int32_T gpu_omega_tmp1;
  emxArray_int32_T gpu_rows;
  emxArray_int32_T h_gpu_rows;
  emxArray_int32_T hb_gpu_rows;
  emxArray_int32_T hd_gpu_y;
  emxArray_int32_T i_gpu_rows;
  emxArray_int32_T ib_gpu_rows;
  emxArray_int32_T ic_gpu_y;
  emxArray_int32_T id_gpu_y;
  emxArray_int32_T j_gpu_rows;
  emxArray_int32_T jb_gpu_rows;
  emxArray_int32_T jc_gpu_y;
  emxArray_int32_T jd_gpu_y;
  emxArray_int32_T k_gpu_rows;
  emxArray_int32_T k_gpu_y;
  emxArray_int32_T kb_gpu_rows;
  emxArray_int32_T kb_gpu_y;
  emxArray_int32_T l_gpu_rows;
  emxArray_int32_T l_gpu_y;
  emxArray_int32_T lb_gpu_rows;
  emxArray_int32_T lb_gpu_y;
  emxArray_int32_T m_gpu_rows;
  emxArray_int32_T m_gpu_y;
  emxArray_int32_T mb_gpu_rows;
  emxArray_int32_T mb_gpu_y;
  emxArray_int32_T n_gpu_rows;
  emxArray_int32_T n_gpu_y;
  emxArray_int32_T nb_gpu_rows;
  emxArray_int32_T nb_gpu_y;
  emxArray_int32_T o_gpu_rows;
  emxArray_int32_T o_gpu_y;
  emxArray_int32_T ob_gpu_rows;
  emxArray_int32_T ob_gpu_y;
  emxArray_int32_T oc_gpu_y;
  emxArray_int32_T p_gpu_rows;
  emxArray_int32_T p_gpu_y;
  emxArray_int32_T pb_gpu_rows;
  emxArray_int32_T pb_gpu_y;
  emxArray_int32_T pc_gpu_y;
  emxArray_int32_T q_gpu_rows;
  emxArray_int32_T q_gpu_y;
  emxArray_int32_T qb_gpu_rows;
  emxArray_int32_T qb_gpu_y;
  emxArray_int32_T qc_gpu_y;
  emxArray_int32_T r_gpu_rows;
  emxArray_int32_T r_gpu_y;
  emxArray_int32_T rb_gpu_rows;
  emxArray_int32_T rb_gpu_y;
  emxArray_int32_T rc_gpu_y;
  emxArray_int32_T s_gpu_rows;
  emxArray_int32_T s_gpu_y;
  emxArray_int32_T sb_gpu_rows;
  emxArray_int32_T sb_gpu_y;
  emxArray_int32_T sc_gpu_y;
  emxArray_int32_T t_gpu_rows;
  emxArray_int32_T t_gpu_y;
  emxArray_int32_T tb_gpu_y;
  emxArray_int32_T tc_gpu_y;
  emxArray_int32_T u_gpu_rows;
  emxArray_int32_T uc_gpu_y;
  emxArray_int32_T v_gpu_rows;
  emxArray_int32_T vc_gpu_y;
  emxArray_int32_T w_gpu_rows;
  emxArray_int32_T wc_gpu_y;
  emxArray_int32_T x_gpu_rows;
  emxArray_int32_T x_gpu_y;
  emxArray_int32_T xb_gpu_y;
  emxArray_int32_T xc_gpu_y;
  emxArray_int32_T y_gpu_rows;
  emxArray_int32_T y_gpu_y;
  emxArray_int32_T yb_gpu_y;
  emxArray_int32_T *ab_cpu_rows;
  emxArray_int32_T *ab_cpu_y;
  emxArray_int32_T *ad_cpu_y;
  emxArray_int32_T *b_cpu_cols;
  emxArray_int32_T *b_cpu_rows;
  emxArray_int32_T *bb_cpu_rows;
  emxArray_int32_T *bb_cpu_y;
  emxArray_int32_T *bd_cpu_y;
  emxArray_int32_T *c_cpu_cols;
  emxArray_int32_T *c_cpu_rows;
  emxArray_int32_T *cb_cpu_rows;
  emxArray_int32_T *cc_cpu_y;
  emxArray_int32_T *cd_cpu_y;
  emxArray_int32_T *cpu_IPIV;
  emxArray_int32_T *cpu_cols;
  emxArray_int32_T *cpu_iv29;
  emxArray_int32_T *cpu_iv30;
  emxArray_int32_T *cpu_iv31;
  emxArray_int32_T *cpu_iv32;
  emxArray_int32_T *cpu_iv33;
  emxArray_int32_T *cpu_iv34;
  emxArray_int32_T *cpu_iv35;
  emxArray_int32_T *cpu_iv36;
  emxArray_int32_T *cpu_iv37;
  emxArray_int32_T *cpu_iv38;
  emxArray_int32_T *cpu_iv39;
  emxArray_int32_T *cpu_iv40;
  emxArray_int32_T *cpu_iv41;
  emxArray_int32_T *cpu_iv42;
  emxArray_int32_T *cpu_iv43;
  emxArray_int32_T *cpu_iv44;
  emxArray_int32_T *cpu_iv45;
  emxArray_int32_T *cpu_iv46;
  emxArray_int32_T *cpu_iv49;
  emxArray_int32_T *cpu_iv50;
  emxArray_int32_T *cpu_iv51;
  emxArray_int32_T *cpu_iv52;
  emxArray_int32_T *cpu_iv53;
  emxArray_int32_T *cpu_iv54;
  emxArray_int32_T *cpu_iv56;
  emxArray_int32_T *cpu_iv57;
  emxArray_int32_T *cpu_iv58;
  emxArray_int32_T *cpu_iv59;
  emxArray_int32_T *cpu_iv6;
  emxArray_int32_T *cpu_iv60;
  emxArray_int32_T *cpu_iv61;
  emxArray_int32_T *cpu_iv62;
  emxArray_int32_T *cpu_iv63;
  emxArray_int32_T *cpu_iv64;
  emxArray_int32_T *cpu_iv65;
  emxArray_int32_T *cpu_iv66;
  emxArray_int32_T *cpu_iv67;
  emxArray_int32_T *cpu_iv68;
  emxArray_int32_T *cpu_iv69;
  emxArray_int32_T *cpu_iv71;
  emxArray_int32_T *cpu_iv73;
  emxArray_int32_T *cpu_iv74;
  emxArray_int32_T *cpu_iv75;
  emxArray_int32_T *cpu_iv76;
  emxArray_int32_T *cpu_iv77;
  emxArray_int32_T *cpu_iv78;
  emxArray_int32_T *cpu_iv79;
  emxArray_int32_T *cpu_iv80;
  emxArray_int32_T *cpu_iv81;
  emxArray_int32_T *cpu_iv83;
  emxArray_int32_T *cpu_iv84;
  emxArray_int32_T *cpu_iv85;
  emxArray_int32_T *cpu_iv86;
  emxArray_int32_T *cpu_iv87;
  emxArray_int32_T *cpu_iv89;
  emxArray_int32_T *cpu_iv93;
  emxArray_int32_T *cpu_iv94;
  emxArray_int32_T *cpu_jpvt;
  emxArray_int32_T *cpu_omega_tmp1;
  emxArray_int32_T *cpu_rows;
  emxArray_int32_T *d_cpu_cols;
  emxArray_int32_T *d_cpu_rows;
  emxArray_int32_T *db_cpu_rows;
  emxArray_int32_T *db_cpu_y;
  emxArray_int32_T *dd_cpu_y;
  emxArray_int32_T *e_cpu_cols;
  emxArray_int32_T *e_cpu_rows;
  emxArray_int32_T *eb_cpu_rows;
  emxArray_int32_T *ed_cpu_y;
  emxArray_int32_T *f_cpu_cols;
  emxArray_int32_T *f_cpu_rows;
  emxArray_int32_T *fb_cpu_rows;
  emxArray_int32_T *fb_cpu_y;
  emxArray_int32_T *fc_cpu_y;
  emxArray_int32_T *fd_cpu_y;
  emxArray_int32_T *g_cpu_rows;
  emxArray_int32_T *gb_cpu_rows;
  emxArray_int32_T *gb_cpu_y;
  emxArray_int32_T *gd_cpu_y;
  emxArray_int32_T *h_cpu_rows;
  emxArray_int32_T *hb_cpu_rows;
  emxArray_int32_T *hc_cpu_y;
  emxArray_int32_T *i_cpu_rows;
  emxArray_int32_T *ib_cpu_rows;
  emxArray_int32_T *ic_cpu_y;
  emxArray_int32_T *j_cpu_rows;
  emxArray_int32_T *jb_cpu_rows;
  emxArray_int32_T *jc_cpu_y;
  emxArray_int32_T *k_cpu_rows;
  emxArray_int32_T *k_cpu_y;
  emxArray_int32_T *kb_cpu_rows;
  emxArray_int32_T *kb_cpu_y;
  emxArray_int32_T *kc_cpu_y;
  emxArray_int32_T *l_cpu_rows;
  emxArray_int32_T *l_cpu_y;
  emxArray_int32_T *lb_cpu_rows;
  emxArray_int32_T *lb_cpu_y;
  emxArray_int32_T *m_cpu_rows;
  emxArray_int32_T *mb_cpu_rows;
  emxArray_int32_T *mb_cpu_y;
  emxArray_int32_T *mc_cpu_y;
  emxArray_int32_T *n_cpu_rows;
  emxArray_int32_T *n_cpu_y;
  emxArray_int32_T *nb_cpu_rows;
  emxArray_int32_T *nb_cpu_y;
  emxArray_int32_T *nc_cpu_y;
  emxArray_int32_T *o_cpu_rows;
  emxArray_int32_T *o_cpu_y;
  emxArray_int32_T *ob_cpu_rows;
  emxArray_int32_T *ob_cpu_y;
  emxArray_int32_T *oc_cpu_y;
  emxArray_int32_T *p_cpu_rows;
  emxArray_int32_T *p_cpu_y;
  emxArray_int32_T *pb_cpu_rows;
  emxArray_int32_T *pb_cpu_y;
  emxArray_int32_T *pc_cpu_y;
  emxArray_int32_T *q_cpu_rows;
  emxArray_int32_T *q_cpu_y;
  emxArray_int32_T *qb_cpu_rows;
  emxArray_int32_T *qb_cpu_y;
  emxArray_int32_T *qc_cpu_y;
  emxArray_int32_T *r_cpu_rows;
  emxArray_int32_T *r_cpu_y;
  emxArray_int32_T *rb_cpu_rows;
  emxArray_int32_T *rc_cpu_y;
  emxArray_int32_T *s_cpu_rows;
  emxArray_int32_T *s_cpu_y;
  emxArray_int32_T *sb_cpu_rows;
  emxArray_int32_T *sc_cpu_y;
  emxArray_int32_T *t_cpu_rows;
  emxArray_int32_T *t_cpu_y;
  emxArray_int32_T *tc_cpu_y;
  emxArray_int32_T *u_cpu_rows;
  emxArray_int32_T *u_cpu_y;
  emxArray_int32_T *ub_cpu_y;
  emxArray_int32_T *uc_cpu_y;
  emxArray_int32_T *v_cpu_rows;
  emxArray_int32_T *v_cpu_y;
  emxArray_int32_T *vb_cpu_y;
  emxArray_int32_T *vc_cpu_y;
  emxArray_int32_T *w_cpu_rows;
  emxArray_int32_T *w_cpu_y;
  emxArray_int32_T *wb_cpu_y;
  emxArray_int32_T *wc_cpu_y;
  emxArray_int32_T *x_cpu_rows;
  emxArray_int32_T *x_cpu_y;
  emxArray_int32_T *xc_cpu_y;
  emxArray_int32_T *y_cpu_rows;
  emxArray_int32_T *y_cpu_y;
  emxArray_int32_T *yb_cpu_y;
  emxArray_int32_T *yc_cpu_y;
  emxArray_ptrdiff_t *jpvt_t;
  emxArray_real_T ab_gpu_expanded;
  emxArray_real_T ab_gpu_w;
  emxArray_real_T ad_gpu_y;
  emxArray_real_T b_gpu_a;
  emxArray_real_T b_gpu_c;
  emxArray_real_T b_gpu_expanded;
  emxArray_real_T b_gpu_h;
  emxArray_real_T b_gpu_result;
  emxArray_real_T b_gpu_somega;
  emxArray_real_T b_gpu_w;
  emxArray_real_T b_gpu_x;
  emxArray_real_T b_gpu_y;
  emxArray_real_T b_gpu_yCol;
  emxArray_real_T bb_gpu_expanded;
  emxArray_real_T bb_gpu_w;
  emxArray_real_T bd_gpu_y;
  emxArray_real_T c_gpu_a;
  emxArray_real_T c_gpu_c;
  emxArray_real_T c_gpu_expanded;
  emxArray_real_T c_gpu_result;
  emxArray_real_T c_gpu_w;
  emxArray_real_T c_gpu_x;
  emxArray_real_T c_gpu_y;
  emxArray_real_T c_gpu_yCol;
  emxArray_real_T cb_gpu_expanded;
  emxArray_real_T cb_gpu_w;
  emxArray_real_T d_gpu_a;
  emxArray_real_T d_gpu_c;
  emxArray_real_T d_gpu_expanded;
  emxArray_real_T d_gpu_result;
  emxArray_real_T d_gpu_w;
  emxArray_real_T d_gpu_x;
  emxArray_real_T d_gpu_y;
  emxArray_real_T d_gpu_yCol;
  emxArray_real_T db_gpu_expanded;
  emxArray_real_T db_gpu_w;
  emxArray_real_T e_gpu_a;
  emxArray_real_T e_gpu_c;
  emxArray_real_T e_gpu_expanded;
  emxArray_real_T e_gpu_result;
  emxArray_real_T e_gpu_w;
  emxArray_real_T e_gpu_x;
  emxArray_real_T e_gpu_y;
  emxArray_real_T e_gpu_yCol;
  emxArray_real_T eb_gpu_expanded;
  emxArray_real_T f_gpu_a;
  emxArray_real_T f_gpu_c;
  emxArray_real_T f_gpu_expanded;
  emxArray_real_T f_gpu_result;
  emxArray_real_T f_gpu_w;
  emxArray_real_T f_gpu_x;
  emxArray_real_T f_gpu_yCol;
  emxArray_real_T fb_gpu_expanded;
  emxArray_real_T g_gpu_a;
  emxArray_real_T g_gpu_c;
  emxArray_real_T g_gpu_expanded;
  emxArray_real_T g_gpu_w;
  emxArray_real_T g_gpu_x;
  emxArray_real_T g_gpu_y;
  emxArray_real_T g_gpu_yCol;
  emxArray_real_T gb_gpu_expanded;
  emxArray_real_T gb_gpu_y;
  emxArray_real_T gc_gpu_y;
  emxArray_real_T gpu_G;
  emxArray_real_T gpu_a;
  emxArray_real_T gpu_absomega;
  emxArray_real_T gpu_b;
  emxArray_real_T gpu_b0;
  emxArray_real_T gpu_c;
  emxArray_real_T gpu_daughter;
  emxArray_real_T gpu_dv18;
  emxArray_real_T gpu_dv20;
  emxArray_real_T gpu_dv21;
  emxArray_real_T gpu_expanded;
  emxArray_real_T gpu_expnt;
  emxArray_real_T gpu_f;
  emxArray_real_T gpu_fb_Omega;
  emxArray_real_T gpu_fb_Scales;
  emxArray_real_T gpu_freqs;
  emxArray_real_T gpu_h;
  emxArray_real_T gpu_h1;
  emxArray_real_T gpu_k;
  emxArray_real_T gpu_m;
  emxArray_real_T gpu_omega_tmp2;
  emxArray_real_T gpu_opts_filter;
  emxArray_real_T gpu_opts_x;
  emxArray_real_T gpu_powscales;
  emxArray_real_T gpu_result;
  emxArray_real_T gpu_sinc1A;
  emxArray_real_T gpu_sinc2A;
  emxArray_real_T gpu_sinc3A;
  emxArray_real_T gpu_sinc4A;
  emxArray_real_T gpu_somega;
  emxArray_real_T gpu_tau;
  emxArray_real_T gpu_w;
  emxArray_real_T gpu_x;
  emxArray_real_T gpu_xCh;
  emxArray_real_T gpu_xCol;
  emxArray_real_T gpu_xv;
  emxArray_real_T gpu_y;
  emxArray_real_T gpu_y1;
  emxArray_real_T gpu_yCol;
  emxArray_real_T h_gpu_a;
  emxArray_real_T h_gpu_c;
  emxArray_real_T h_gpu_expanded;
  emxArray_real_T h_gpu_w;
  emxArray_real_T h_gpu_x;
  emxArray_real_T h_gpu_y;
  emxArray_real_T h_gpu_yCol;
  emxArray_real_T hb_gpu_expanded;
  emxArray_real_T hb_gpu_y;
  emxArray_real_T hc_gpu_y;
  emxArray_real_T i_gpu_a;
  emxArray_real_T i_gpu_c;
  emxArray_real_T i_gpu_expanded;
  emxArray_real_T i_gpu_w;
  emxArray_real_T i_gpu_x;
  emxArray_real_T i_gpu_y;
  emxArray_real_T i_gpu_yCol;
  emxArray_real_T ib_gpu_expanded;
  emxArray_real_T ib_gpu_y;
  emxArray_real_T j_gpu_c;
  emxArray_real_T j_gpu_expanded;
  emxArray_real_T j_gpu_w;
  emxArray_real_T j_gpu_x;
  emxArray_real_T j_gpu_y;
  emxArray_real_T j_gpu_yCol;
  emxArray_real_T jb_gpu_expanded;
  emxArray_real_T jb_gpu_y;
  emxArray_real_T k_gpu_c;
  emxArray_real_T k_gpu_expanded;
  emxArray_real_T k_gpu_w;
  emxArray_real_T k_gpu_x;
  emxArray_real_T kb_gpu_expanded;
  emxArray_real_T kc_gpu_y;
  emxArray_real_T kd_gpu_y;
  emxArray_real_T l_gpu_c;
  emxArray_real_T l_gpu_expanded;
  emxArray_real_T l_gpu_w;
  emxArray_real_T l_gpu_x;
  emxArray_real_T lb_gpu_expanded;
  emxArray_real_T lc_gpu_y;
  emxArray_real_T ld_gpu_y;
  emxArray_real_T m_gpu_c;
  emxArray_real_T m_gpu_expanded;
  emxArray_real_T m_gpu_w;
  emxArray_real_T m_gpu_x;
  emxArray_real_T mb_gpu_expanded;
  emxArray_real_T mc_gpu_y;
  emxArray_real_T md_gpu_y;
  emxArray_real_T n_gpu_c;
  emxArray_real_T n_gpu_expanded;
  emxArray_real_T n_gpu_w;
  emxArray_real_T nb_gpu_expanded;
  emxArray_real_T nc_gpu_y;
  emxArray_real_T o_gpu_c;
  emxArray_real_T o_gpu_expanded;
  emxArray_real_T o_gpu_w;
  emxArray_real_T ob_gpu_expanded;
  emxArray_real_T p_gpu_c;
  emxArray_real_T p_gpu_expanded;
  emxArray_real_T p_gpu_w;
  emxArray_real_T pb_gpu_expanded;
  emxArray_real_T q_gpu_c;
  emxArray_real_T q_gpu_expanded;
  emxArray_real_T q_gpu_w;
  emxArray_real_T qb_gpu_expanded;
  emxArray_real_T r_gpu_expanded;
  emxArray_real_T r_gpu_w;
  emxArray_real_T rb_gpu_expanded;
  emxArray_real_T s_gpu_expanded;
  emxArray_real_T s_gpu_w;
  emxArray_real_T sb_gpu_expanded;
  emxArray_real_T t_gpu_expanded;
  emxArray_real_T t_gpu_w;
  emxArray_real_T tb_gpu_expanded;
  emxArray_real_T u_gpu_expanded;
  emxArray_real_T u_gpu_w;
  emxArray_real_T u_gpu_y;
  emxArray_real_T ub_gpu_expanded;
  emxArray_real_T ub_gpu_y;
  emxArray_real_T v_gpu_expanded;
  emxArray_real_T v_gpu_w;
  emxArray_real_T v_gpu_y;
  emxArray_real_T vb_gpu_expanded;
  emxArray_real_T vb_gpu_y;
  emxArray_real_T w_gpu_expanded;
  emxArray_real_T w_gpu_w;
  emxArray_real_T w_gpu_y;
  emxArray_real_T wb_gpu_expanded;
  emxArray_real_T wb_gpu_y;
  emxArray_real_T x_gpu_expanded;
  emxArray_real_T x_gpu_w;
  emxArray_real_T xb_gpu_expanded;
  emxArray_real_T y_gpu_expanded;
  emxArray_real_T y_gpu_w;
  emxArray_real_T yb_gpu_expanded;
  emxArray_real_T yc_gpu_y;
  emxArray_real_T *ab_cpu_expanded;
  emxArray_real_T *ab_cpu_w;
  emxArray_real_T *ac_cpu_y;
  emxArray_real_T *b_cpu_a;
  emxArray_real_T *b_cpu_c;
  emxArray_real_T *b_cpu_expanded;
  emxArray_real_T *b_cpu_h;
  emxArray_real_T *b_cpu_result;
  emxArray_real_T *b_cpu_somega;
  emxArray_real_T *b_cpu_w;
  emxArray_real_T *b_cpu_x;
  emxArray_real_T *b_cpu_y;
  emxArray_real_T *b_cpu_yCol;
  emxArray_real_T *bb_cpu_expanded;
  emxArray_real_T *bb_cpu_w;
  emxArray_real_T *bc_cpu_y;
  emxArray_real_T *c_cpu_a;
  emxArray_real_T *c_cpu_c;
  emxArray_real_T *c_cpu_expanded;
  emxArray_real_T *c_cpu_result;
  emxArray_real_T *c_cpu_w;
  emxArray_real_T *c_cpu_x;
  emxArray_real_T *c_cpu_y;
  emxArray_real_T *c_cpu_yCol;
  emxArray_real_T *cb_cpu_expanded;
  emxArray_real_T *cb_cpu_w;
  emxArray_real_T *cb_cpu_y;
  emxArray_real_T *cpu_G;
  emxArray_real_T *cpu_a;
  emxArray_real_T *cpu_absomega;
  emxArray_real_T *cpu_b;
  emxArray_real_T *cpu_b0;
  emxArray_real_T *cpu_c;
  emxArray_real_T *cpu_daughter;
  emxArray_real_T *cpu_dv18;
  emxArray_real_T *cpu_dv20;
  emxArray_real_T *cpu_dv21;
  emxArray_real_T *cpu_expanded;
  emxArray_real_T *cpu_expnt;
  emxArray_real_T *cpu_f;
  emxArray_real_T *cpu_fb_Omega;
  emxArray_real_T *cpu_fb_Scales;
  emxArray_real_T *cpu_h;
  emxArray_real_T *cpu_h1;
  emxArray_real_T *cpu_k;
  emxArray_real_T *cpu_m;
  emxArray_real_T *cpu_omega_tmp2;
  emxArray_real_T *cpu_opts_filter;
  emxArray_real_T *cpu_opts_x;
  emxArray_real_T *cpu_powscales;
  emxArray_real_T *cpu_result;
  emxArray_real_T *cpu_sinc1A;
  emxArray_real_T *cpu_sinc2A;
  emxArray_real_T *cpu_sinc3A;
  emxArray_real_T *cpu_sinc4A;
  emxArray_real_T *cpu_somega;
  emxArray_real_T *cpu_tau;
  emxArray_real_T *cpu_w;
  emxArray_real_T *cpu_xCh;
  emxArray_real_T *cpu_xCol;
  emxArray_real_T *cpu_xv;
  emxArray_real_T *cpu_y;
  emxArray_real_T *cpu_y1;
  emxArray_real_T *cpu_yCol;
  emxArray_real_T *d_cpu_a;
  emxArray_real_T *d_cpu_c;
  emxArray_real_T *d_cpu_expanded;
  emxArray_real_T *d_cpu_result;
  emxArray_real_T *d_cpu_w;
  emxArray_real_T *d_cpu_x;
  emxArray_real_T *d_cpu_y;
  emxArray_real_T *d_cpu_yCol;
  emxArray_real_T *db_cpu_expanded;
  emxArray_real_T *db_cpu_w;
  emxArray_real_T *dc_cpu_y;
  emxArray_real_T *e_cpu_a;
  emxArray_real_T *e_cpu_c;
  emxArray_real_T *e_cpu_expanded;
  emxArray_real_T *e_cpu_result;
  emxArray_real_T *e_cpu_w;
  emxArray_real_T *e_cpu_x;
  emxArray_real_T *e_cpu_y;
  emxArray_real_T *e_cpu_yCol;
  emxArray_real_T *eb_cpu_expanded;
  emxArray_real_T *eb_cpu_y;
  emxArray_real_T *ec_cpu_y;
  emxArray_real_T *f_cpu_a;
  emxArray_real_T *f_cpu_c;
  emxArray_real_T *f_cpu_expanded;
  emxArray_real_T *f_cpu_result;
  emxArray_real_T *f_cpu_w;
  emxArray_real_T *f_cpu_x;
  emxArray_real_T *f_cpu_y;
  emxArray_real_T *f_cpu_yCol;
  emxArray_real_T *fb_cpu_expanded;
  emxArray_real_T *g_cpu_a;
  emxArray_real_T *g_cpu_c;
  emxArray_real_T *g_cpu_expanded;
  emxArray_real_T *g_cpu_w;
  emxArray_real_T *g_cpu_x;
  emxArray_real_T *g_cpu_yCol;
  emxArray_real_T *gb_cpu_expanded;
  emxArray_real_T *gc_cpu_y;
  emxArray_real_T *h_cpu_a;
  emxArray_real_T *h_cpu_c;
  emxArray_real_T *h_cpu_expanded;
  emxArray_real_T *h_cpu_w;
  emxArray_real_T *h_cpu_x;
  emxArray_real_T *h_cpu_y;
  emxArray_real_T *h_cpu_yCol;
  emxArray_real_T *hb_cpu_expanded;
  emxArray_real_T *hb_cpu_y;
  emxArray_real_T *hd_cpu_y;
  emxArray_real_T *i_cpu_a;
  emxArray_real_T *i_cpu_c;
  emxArray_real_T *i_cpu_expanded;
  emxArray_real_T *i_cpu_w;
  emxArray_real_T *i_cpu_x;
  emxArray_real_T *i_cpu_y;
  emxArray_real_T *i_cpu_yCol;
  emxArray_real_T *ib_cpu_expanded;
  emxArray_real_T *ib_cpu_y;
  emxArray_real_T *id_cpu_y;
  emxArray_real_T *j_cpu_c;
  emxArray_real_T *j_cpu_expanded;
  emxArray_real_T *j_cpu_w;
  emxArray_real_T *j_cpu_x;
  emxArray_real_T *j_cpu_y;
  emxArray_real_T *j_cpu_yCol;
  emxArray_real_T *jb_cpu_expanded;
  emxArray_real_T *jb_cpu_y;
  emxArray_real_T *jd_cpu_y;
  emxArray_real_T *k_cpu_c;
  emxArray_real_T *k_cpu_expanded;
  emxArray_real_T *k_cpu_w;
  emxArray_real_T *k_cpu_x;
  emxArray_real_T *kb_cpu_expanded;
  emxArray_real_T *kd_cpu_y;
  emxArray_real_T *l_cpu_c;
  emxArray_real_T *l_cpu_expanded;
  emxArray_real_T *l_cpu_w;
  emxArray_real_T *l_cpu_x;
  emxArray_real_T *lb_cpu_expanded;
  emxArray_real_T *lc_cpu_y;
  emxArray_real_T *ld_cpu_y;
  emxArray_real_T *m_cpu_c;
  emxArray_real_T *m_cpu_expanded;
  emxArray_real_T *m_cpu_w;
  emxArray_real_T *m_cpu_x;
  emxArray_real_T *m_cpu_y;
  emxArray_real_T *mb_cpu_expanded;
  emxArray_real_T *md_cpu_y;
  emxArray_real_T *n_cpu_c;
  emxArray_real_T *n_cpu_expanded;
  emxArray_real_T *n_cpu_w;
  emxArray_real_T *nb_cpu_expanded;
  emxArray_real_T *o_cpu_c;
  emxArray_real_T *o_cpu_expanded;
  emxArray_real_T *o_cpu_w;
  emxArray_real_T *ob_cpu_expanded;
  emxArray_real_T *p_cpu_c;
  emxArray_real_T *p_cpu_expanded;
  emxArray_real_T *p_cpu_w;
  emxArray_real_T *pb_cpu_expanded;
  emxArray_real_T *q_cpu_c;
  emxArray_real_T *q_cpu_expanded;
  emxArray_real_T *q_cpu_w;
  emxArray_real_T *qb_cpu_expanded;
  emxArray_real_T *r_cpu_expanded;
  emxArray_real_T *r_cpu_w;
  emxArray_real_T *rb_cpu_expanded;
  emxArray_real_T *rb_cpu_y;
  emxArray_real_T *s_cpu_expanded;
  emxArray_real_T *s_cpu_w;
  emxArray_real_T *sb_cpu_expanded;
  emxArray_real_T *sb_cpu_y;
  emxArray_real_T *t_cpu_expanded;
  emxArray_real_T *t_cpu_w;
  emxArray_real_T *tb_cpu_expanded;
  emxArray_real_T *tb_cpu_y;
  emxArray_real_T *u_cpu_expanded;
  emxArray_real_T *u_cpu_w;
  emxArray_real_T *ub_cpu_expanded;
  emxArray_real_T *v_cpu_expanded;
  emxArray_real_T *v_cpu_w;
  emxArray_real_T *vb_cpu_expanded;
  emxArray_real_T *w_cpu_expanded;
  emxArray_real_T *w_cpu_w;
  emxArray_real_T *wb_cpu_expanded;
  emxArray_real_T *x_cpu_expanded;
  emxArray_real_T *x_cpu_w;
  emxArray_real_T *xb_cpu_expanded;
  emxArray_real_T *xb_cpu_y;
  emxArray_real_T *y_cpu_expanded;
  emxArray_real_T *y_cpu_w;
  emxArray_real_T *yb_cpu_expanded;
  emxArray_uint32_T f_gpu_y;
  emxArray_uint32_T *g_cpu_y;
  const mxArray *ab_y;
  const mxArray *b_tmpStr;
  const mxArray *b_y;
  const mxArray *bb_y;
  const mxArray *c_tmpStr;
  const mxArray *c_y;
  const mxArray *cb_y;
  const mxArray *d_y;
  const mxArray *db_y;
  const mxArray *e_y;
  const mxArray *eb_y;
  const mxArray *f_y;
  const mxArray *fb_y;
  const mxArray *g_y;
  const mxArray *gb_y;
  const mxArray *h_y;
  const mxArray *hb_y;
  const mxArray *i_y;
  const mxArray *ib_y;
  const mxArray *j_y;
  const mxArray *jb_y;
  const mxArray *k_y;
  const mxArray *kb_y;
  const mxArray *l_y;
  const mxArray *lb_y;
  const mxArray *m;
  const mxArray *m1;
  const mxArray *m11;
  const mxArray *m12;
  const mxArray *m13;
  const mxArray *m14;
  const mxArray *m15;
  const mxArray *m16;
  const mxArray *m17;
  const mxArray *m18;
  const mxArray *m19;
  const mxArray *m2;
  const mxArray *m20;
  const mxArray *m21;
  const mxArray *m22;
  const mxArray *m23;
  const mxArray *m24;
  const mxArray *m25;
  const mxArray *m27;
  const mxArray *m28;
  const mxArray *m29;
  const mxArray *m3;
  const mxArray *m30;
  const mxArray *m31;
  const mxArray *m32;
  const mxArray *m33;
  const mxArray *m34;
  const mxArray *m35;
  const mxArray *m36;
  const mxArray *m37;
  const mxArray *m38;
  const mxArray *m39;
  const mxArray *m4;
  const mxArray *m40;
  const mxArray *m41;
  const mxArray *m42;
  const mxArray *m43;
  const mxArray *m44;
  const mxArray *m45;
  const mxArray *m46;
  const mxArray *m47;
  const mxArray *m5;
  const mxArray *m6;
  const mxArray *m7;
  const mxArray *m8;
  const mxArray *m9;
  const mxArray *m_y;
  const mxArray *mb_y;
  const mxArray *n_y;
  const mxArray *nb_y;
  const mxArray *o_y;
  const mxArray *ob_y;
  const mxArray *p_y;
  const mxArray *pb_y;
  const mxArray *q_y;
  const mxArray *qb_y;
  const mxArray *r_y;
  const mxArray *rb_y;
  const mxArray *s_y;
  const mxArray *sb_y;
  const mxArray *t_y;
  const mxArray *tb_y;
  const mxArray *u_y;
  const mxArray *ub_y;
  const mxArray *v_y;
  const mxArray *w_y;
  const mxArray *x_y;
  const mxArray *y;
  const mxArray *y_y;
  creal_T *gpu_dc1;
  creal_T *gpu_dc6;
  real_T cpu_dv13_data[9735];
  real_T cpu_fx_data[9735];
  real_T (*b_gpu_a_data)[9735];
  real_T (*b_gpu_fx_data)[9735];
  real_T (*b_gpu_x_data)[9735];
  real_T (*c_gpu_fx_data)[9735];
  real_T (*d_gpu_fx_data)[9735];
  real_T (*gpu_a_data)[9735];
  real_T (*gpu_dv10_data)[9735];
  real_T (*gpu_dv13_data)[9735];
  real_T (*gpu_dv16_data)[9735];
  real_T (*gpu_dv4_data)[9735];
  real_T (*gpu_fx_data)[9735];
  real_T (*gpu_x_data)[9735];
  real_T (*gpu_xt_data)[9735];
  real_T (*gpu_y_data)[9735];
  real_T cpu_subs[1298];
  real_T (*gpu_subs)[1298];
  real_T cpu_interval[650];
  real_T (*gpu_interval)[650];
  real_T errsub[649];
  real_T qsub[649];
  real_T NyquistRange[2];
  real_T fb_FrequencyLimits[2];
  real_T Ly;
  real_T a;
  real_T b_cpu_r;
  real_T cf;
  real_T cpu_r;
  real_T d;
  real_T err_ok;
  real_T fc;
  real_T halfh;
  real_T intDsq;
  real_T intFsq;
  real_T omegac;
  real_T q_ok;
  real_T r;
  real_T s;
  real_T tau;
  real_T tol;
  real_T *b_gpu_r;
  real_T *gpu_r;
  int32_T a_size[2];
  int32_T b_a_size[2];
  int32_T b_xt_size[2];
  int32_T dv13_size[2];
  int32_T dv14_size[2];
  int32_T dv4_size[2];
  int32_T dv7_size[2];
  int32_T fx_size[2];
  int32_T xt_size[2];
  int32_T (*gpu_csz)[2];
  int32_T (*gpu_lshift)[2];
  int32_T b_nx;
  int32_T cpu_nrefine;
  int32_T csz_idx_0;
  int32_T dim;
  int32_T eint;
  int32_T exitg1;
  int32_T exponent;
  int32_T fb_CutOff;
  int32_T fb_SignalPad;
  int32_T i36;
  int32_T i39;
  int32_T itime;
  int32_T ix;
  int32_T k;
  int32_T lidx;
  int32_T nsubs;
  int32_T nw;
  int32_T nx;
  int32_T x_size_idx_1;
  int32_T *gpu_nrefine;
  uint32_T xSize[2];
  uint32_T N;
  char_T unusedExpr[23];
  char_T cpu_wav[5];
  char_T cpu_wname[5];
  char_T (*gpu_wav)[5];
  char_T (*gpu_wname)[5];
  int8_T n_idx_0;
  boolean_T b_b[2];
  boolean_T G_needsGpuEnsureCapacity;
  boolean_T Nodd;
  boolean_T a_data_outdatedOnGpu;
  boolean_T b_fx_data_outdatedOnCpu;
  boolean_T b_y_needsGpuEnsureCapacity;
  boolean_T c_omega_tmp1_needsGpuEnsureCapa;
  boolean_T c_y_needsGpuEnsureCapacity;
  boolean_T d_y_needsGpuEnsureCapacity;
  boolean_T daughter_needsGpuEnsureCapacity;
  boolean_T daughter_outdatedOnGpu;
  boolean_T doDownsample;
  boolean_T e_y_needsGpuEnsureCapacity;
  boolean_T exitg2;
  boolean_T f_y_needsGpuEnsureCapacity;
  boolean_T first_iteration;
  boolean_T fx_data_outdatedOnCpu;
  boolean_T g_y_needsGpuEnsureCapacity;
  boolean_T guard1;
  boolean_T h_needsGpuEnsureCapacity;
  boolean_T h_outdatedOnGpu;
  boolean_T h_y_needsGpuEnsureCapacity;
  boolean_T i_y_needsGpuEnsureCapacity;
  boolean_T interval_outdatedOnGpu;
  boolean_T j_y_needsGpuEnsureCapacity;
  boolean_T p;
  boolean_T validLaunchParams;
  boolean_T wav_outdatedOnCpu;
  boolean_T x_data_outdatedOnGpu;
  boolean_T x_needsGpuEnsureCapacity;
  boolean_T x_outdatedOnGpu;
  boolean_T y_needsGpuEnsureCapacity;
  if (!gpuConstsCopied_ec_cwt) {
    gpuConstsCopied_ec_cwt = true;
    checkCudaError(cudaMemcpy(*global_gpu_cv, cpu_cv, sizeof(char_T [128]),
      cudaMemcpyHostToDevice), __FILE__, __LINE__);
    checkCudaError(cudaMemcpy(*global_gpu_table100, cpu_table100, sizeof(real_T
      [100]), cudaMemcpyHostToDevice), __FILE__, __LINE__);
  }

  checkCudaError(mwCudaMalloc(&gpu_lshift, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_csz, 8UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&cb_gpu_w);
  gpuEmxReset_real_T(&ad_gpu_y);
  gpuEmxReset_real_T(&bb_gpu_w);
  gpuEmxReset_real_T(&i_gpu_w);
  gpuEmxReset_real_T(&r_gpu_w);
  gpuEmxReset_real_T(&y_gpu_w);
  gpuEmxReset_real_T(&h_gpu_y);
  gpuEmxReset_real_T(&v_gpu_y);
  gpuEmxReset_real_T(&hb_gpu_y);
  gpuEmxReset_real_T(&vb_gpu_y);
  gpuEmxReset_real_T(&c_gpu_w);
  gpuEmxReset_real_T(&l_gpu_w);
  gpuEmxReset_real_T(&lc_gpu_y);
  gpuEmxReset_real_T(&f_gpu_w);
  gpuEmxReset_real_T(&o_gpu_w);
  gpuEmxReset_real_T(&v_gpu_w);
  gpuEmxReset_real_T(&h_gpu_w);
  gpuEmxReset_real_T(&q_gpu_w);
  gpuEmxReset_real_T(&x_gpu_w);
  gpuEmxReset_real_T(&b_gpu_w);
  gpuEmxReset_real_T(&k_gpu_w);
  gpuEmxReset_real_T(&e_gpu_w);
  gpuEmxReset_real_T(&n_gpu_w);
  gpuEmxReset_real_T(&u_gpu_w);
  gpuEmxReset_real_T(&gpu_b0);
  gpuEmxReset_int32_T(&rb_gpu_rows);
  gpuEmxReset_int32_T(&sb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv94);
  gpuEmxReset_int32_T(&m_gpu_rows);
  gpuEmxReset_int32_T(&bb_gpu_rows);
  gpuEmxReset_int32_T(&lb_gpu_rows);
  gpuEmxReset_int32_T(&pb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv93);
  gpuEmxReset_int32_T(&n_gpu_rows);
  gpuEmxReset_int32_T(&cb_gpu_rows);
  gpuEmxReset_int32_T(&gb_gpu_rows);
  gpuEmxReset_int32_T(&mb_gpu_rows);
  gpuEmxReset_int32_T(&qb_gpu_rows);
  gpuEmxReset_int32_T(&g_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv89);
  gpuEmxReset_int32_T(&u_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv87);
  gpuEmxReset_int32_T(&gpu_iv86);
  gpuEmxReset_int32_T(&gpu_iv85);
  gpuEmxReset_int32_T(&h_gpu_rows);
  gpuEmxReset_int32_T(&k_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv84);
  gpuEmxReset_int32_T(&v_gpu_rows);
  gpuEmxReset_int32_T(&y_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv83);
  gpuEmxReset_int32_T(&jb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv81);
  gpuEmxReset_int32_T(&f_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv80);
  gpuEmxReset_int32_T(&b_gpu_rows);
  gpuEmxReset_int32_T(&l_gpu_rows);
  gpuEmxReset_int32_T(&p_gpu_rows);
  gpuEmxReset_int32_T(&ab_gpu_rows);
  gpuEmxReset_int32_T(&kb_gpu_rows);
  gpuEmxReset_int32_T(&id_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv79);
  gpuEmxReset_int32_T(&gpu_iv78);
  gpuEmxReset_int32_T(&ob_gpu_rows);
  gpuEmxReset_int32_T(&jd_gpu_y);
  gpuEmxReset_int32_T(&e_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv77);
  gpuEmxReset_int32_T(&gpu_iv76);
  gpuEmxReset_int32_T(&s_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv75);
  gpuEmxReset_int32_T(&gpu_iv74);
  gpuEmxReset_int32_T(&fb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv73);
  gpuEmxReset_real_T(&xb_gpu_expanded);
  gpuEmxReset_real_T(&yb_gpu_expanded);
  gpuEmxReset_int32_T(&f_gpu_rows);
  gpuEmxReset_int32_T(&b_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv71);
  gpuEmxReset_int32_T(&t_gpu_rows);
  gpuEmxReset_int32_T(&d_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv69);
  gpuEmxReset_int32_T(&e_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv68);
  gpuEmxReset_int32_T(&eb_gpu_y);
  gpuEmxReset_int32_T(&ec_gpu_y);
  gpuEmxReset_int32_T(&wc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv67);
  gpuEmxReset_int32_T(&gd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv66);
  gpuEmxReset_int32_T(&j_gpu_rows);
  gpuEmxReset_int32_T(&fb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv65);
  gpuEmxReset_int32_T(&x_gpu_rows);
  gpuEmxReset_int32_T(&fc_gpu_y);
  gpuEmxReset_int32_T(&ib_gpu_rows);
  gpuEmxReset_int32_T(&xc_gpu_y);
  gpuEmxReset_int32_T(&hd_gpu_y);
  gpuEmxReset_int32_T(&gpu_rows);
  gpuEmxReset_int32_T(&gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv64);
  gpuEmxReset_real_T(&o_gpu_expanded);
  gpuEmxReset_real_T(&p_gpu_expanded);
  gpuEmxReset_int32_T(&o_gpu_rows);
  gpuEmxReset_int32_T(&c_gpu_cols);
  gpuEmxReset_int32_T(&gpu_iv63);
  gpuEmxReset_real_T(&fb_gpu_expanded);
  gpuEmxReset_real_T(&gb_gpu_expanded);
  gpuEmxReset_real_T(&qb_gpu_expanded);
  gpuEmxReset_real_T(&rb_gpu_expanded);
  gpuEmxReset_real_T(&vb_gpu_expanded);
  gpuEmxReset_real_T(&wb_gpu_expanded);
  gpuEmxReset_int32_T(&s_gpu_y);
  gpuEmxReset_int32_T(&sb_gpu_y);
  gpuEmxReset_int32_T(&nb_gpu_rows);
  gpuEmxReset_int32_T(&d_gpu_rows);
  gpuEmxReset_int32_T(&t_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv62);
  gpuEmxReset_int32_T(&cb_gpu_y);
  gpuEmxReset_int32_T(&r_gpu_rows);
  gpuEmxReset_int32_T(&tb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv61);
  gpuEmxReset_int32_T(&cc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv60);
  gpuEmxReset_int32_T(&gpu_iv59);
  gpuEmxReset_int32_T(&uc_gpu_y);
  gpuEmxReset_real_T(&h_gpu_expanded);
  gpuEmxReset_real_T(&i_gpu_expanded);
  gpuEmxReset_int32_T(&db_gpu_y);
  gpuEmxReset_real_T(&x_gpu_expanded);
  gpuEmxReset_real_T(&y_gpu_expanded);
  gpuEmxReset_int32_T(&dc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv58);
  gpuEmxReset_int32_T(&vc_gpu_y);
  gpuEmxReset_real_T(&bd_gpu_y);
  gpuEmxReset_real_T(&m_gpu_expanded);
  gpuEmxReset_real_T(&n_gpu_expanded);
  gpuEmxReset_real_T(&db_gpu_expanded);
  gpuEmxReset_real_T(&eb_gpu_expanded);
  gpuEmxReset_real_T(&ob_gpu_expanded);
  gpuEmxReset_real_T(&pb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv57);
  gpuEmxReset_int32_T(&q_gpu_y);
  gpuEmxReset_int32_T(&i_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv56);
  gpuEmxReset_int32_T(&qb_gpu_y);
  gpuEmxReset_int32_T(&w_gpu_rows);
  gpuEmxReset_int32_T(&hb_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv54);
  gpuEmxReset_int32_T(&r_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv53);
  gpuEmxReset_int32_T(&rb_gpu_y);
  gpuEmxReset_real_T(&kc_gpu_y);
  gpuEmxReset_int32_T(&fd_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv52);
  gpuEmxReset_real_T(&f_gpu_expanded);
  gpuEmxReset_real_T(&g_gpu_expanded);
  gpuEmxReset_real_T(&w_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv51);
  gpuEmxReset_real_T(&v_gpu_expanded);
  gpuEmxReset_real_T(&w_gpu_expanded);
  gpuEmxReset_real_T(&wb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv50);
  gpuEmxReset_int32_T(&c_gpu_rows);
  gpuEmxReset_int32_T(&q_gpu_rows);
  gpuEmxReset_int32_T(&gpu_iv49);
  gpuEmxReset_int32_T(&oc_gpu_y);
  gpuEmxReset_real_T(&nc_gpu_y);
  gpuEmxReset_real_T(&g_gpu_y);
  gpuEmxReset_int32_T(&bb_gpu_y);
  gpuEmxReset_real_T(&gb_gpu_y);
  gpuEmxReset_int32_T(&bc_gpu_y);
  gpuEmxReset_int32_T(&pc_gpu_y);
  gpuEmxReset_int32_T(&tc_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv46);
  gpuEmxReset_int32_T(&gpu_iv45);
  gpuEmxReset_int32_T(&gpu_iv44);
  gpuEmxReset_real_T(&jb_gpu_expanded);
  gpuEmxReset_real_T(&kb_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv43);
  gpuEmxReset_real_T(&yc_gpu_y);
  gpuEmxReset_real_T(&j_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv42);
  gpuEmxReset_real_T(&jb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv41);
  gpuEmxReset_int32_T(&gpu_iv40);
  gpuEmxReset_real_T(&f_gpu_result);
  gpuEmxReset_int32_T(&k_gpu_y);
  gpuEmxReset_int32_T(&p_gpu_y);
  gpuEmxReset_int32_T(&kb_gpu_y);
  gpuEmxReset_int32_T(&pb_gpu_y);
  gpuEmxReset_int32_T(&l_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv39);
  gpuEmxReset_int32_T(&gpu_iv38);
  gpuEmxReset_int32_T(&lb_gpu_y);
  gpuEmxReset_int32_T(&gpu_iv37);
  gpuEmxReset_int32_T(&gpu_iv36);
  gpuEmxReset_int32_T(&gpu_iv35);
  gpuEmxReset_int32_T(&dd_gpu_y);
  gpuEmxReset_real_T(&gpu_expanded);
  gpuEmxReset_real_T(&b_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv34);
  gpuEmxReset_real_T(&u_gpu_y);
  gpuEmxReset_real_T(&q_gpu_expanded);
  gpuEmxReset_real_T(&r_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv33);
  gpuEmxReset_real_T(&ub_gpu_y);
  gpuEmxReset_real_T(&mc_gpu_y);
  gpuEmxReset_int32_T(&ed_gpu_y);
  gpuEmxReset_real_T(&b_gpu_result);
  gpuEmxReset_real_T(&d_gpu_result);
  gpuEmxReset_real_T(&m_gpu_c);
  gpuEmxReset_real_T(&e_gpu_result);
  gpuEmxReset_int32_T(&cd_gpu_y);
  gpuEmxReset_real_T(&tb_gpu_expanded);
  gpuEmxReset_real_T(&ub_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv32);
  gpuEmxReset_int32_T(&gpu_iv31);
  gpuEmxReset_real_T(&i_gpu_y);
  gpuEmxReset_int32_T(&y_gpu_y);
  gpuEmxReset_real_T(&ib_gpu_y);
  gpuEmxReset_int32_T(&yb_gpu_y);
  gpuEmxReset_int32_T(&rc_gpu_y);
  gpuEmxReset_real_T(&sb_gpu_expanded);
  gpuEmxReset_real_T(&gpu_result);
  gpuEmxReset_int32_T(&ab_gpu_y);
  gpuEmxReset_real_T(&c_gpu_result);
  gpuEmxReset_int32_T(&ac_gpu_y);
  gpuEmxReset_int32_T(&sc_gpu_y);
  gpuEmxReset_real_T(&b_gpu_c);
  gpuEmxReset_int32_T(&x_gpu_y);
  gpuEmxReset_real_T(&k_gpu_expanded);
  gpuEmxReset_real_T(&l_gpu_expanded);
  gpuEmxReset_real_T(&h_gpu_c);
  gpuEmxReset_int32_T(&xb_gpu_y);
  gpuEmxReset_real_T(&bb_gpu_expanded);
  gpuEmxReset_real_T(&cb_gpu_expanded);
  gpuEmxReset_int32_T(&qc_gpu_y);
  gpuEmxReset_real_T(&mb_gpu_expanded);
  gpuEmxReset_real_T(&nb_gpu_expanded);
  gpuEmxReset_int32_T(&n_gpu_y);
  gpuEmxReset_int32_T(&nb_gpu_y);
  gpuEmxReset_int32_T(&db_gpu_rows);
  gpuEmxReset_int32_T(&eb_gpu_rows);
  gpuEmxReset_real_T(&q_gpu_c);
  gpuEmxReset_int32_T(&o_gpu_y);
  gpuEmxReset_real_T(&j_gpu_expanded);
  gpuEmxReset_int32_T(&ob_gpu_y);
  gpuEmxReset_real_T(&ab_gpu_expanded);
  gpuEmxReset_real_T(&lb_gpu_expanded);
  gpuEmxReset_int32_T(&m_gpu_y);
  gpuEmxReset_real_T(&d_gpu_expanded);
  gpuEmxReset_real_T(&e_gpu_expanded);
  gpuEmxReset_int32_T(&mb_gpu_y);
  gpuEmxReset_real_T(&t_gpu_expanded);
  gpuEmxReset_real_T(&u_gpu_expanded);
  gpuEmxReset_int32_T(&gpu_iv30);
  gpuEmxReset_int32_T(&gpu_iv29);
  gpuEmxReset_real_T(&c_gpu_expanded);
  gpuEmxReset_real_T(&f_gpu_c);
  gpuEmxReset_real_T(&s_gpu_expanded);
  gpuEmxReset_real_T(&l_gpu_c);
  gpuEmxReset_real_T(&o_gpu_c);
  gpuEmxReset_real_T(&d_gpu_c);
  gpuEmxReset_real_T(&j_gpu_c);
  gpuEmxReset_real_T(&hc_gpu_y);
  gpuEmxReset_real_T(&b_gpu_a);
  gpuEmxReset_real_T(&e_gpu_a);
  gpuEmxReset_int32_T(&ic_gpu_y);
  gpuEmxReset_int32_T(&jc_gpu_y);
  gpuEmxReset_real_T(&gpu_c);
  gpuEmxReset_real_T(&g_gpu_c);
  gpuEmxReset_real_T(&i_gpu_a);
  gpuEmxReset_real_T(&hb_gpu_expanded);
  gpuEmxReset_real_T(&ib_gpu_expanded);
  gpuEmxReset_real_T(&p_gpu_c);
  gpuEmxReset_real_T(&gc_gpu_y);
  gpuEmxReset_real_T(&d_gpu_a);
  gpuEmxReset_real_T(&g_gpu_a);
  gpuEmxReset_real_T(&h_gpu_a);
  gpuEmxReset_real_T(&e_gpu_c);
  gpuEmxReset_real_T(&k_gpu_c);
  gpuEmxReset_real_T(&t_gpu_w);
  gpuEmxReset_real_T(&n_gpu_c);
  gpuEmxReset_real_T(&c_gpu_a);
  gpuEmxReset_real_T(&f_gpu_a);
  gpuEmxReset_real_T(&c_gpu_c);
  gpuEmxReset_real_T(&i_gpu_c);
  gpuEmxReset_real_T(&j_gpu_x);
  gpuEmxReset_real_T(&gpu_w);
  gpuEmxReset_real_T(&j_gpu_w);
  gpuEmxReset_real_T(&ab_gpu_w);
  gpuEmxReset_real_T(&d_gpu_x);
  gpuEmxReset_real_T(&g_gpu_x);
  gpuEmxReset_real_T(&s_gpu_w);
  gpuEmxReset_real_T(&l_gpu_x);
  gpuEmxReset_real_T(&g_gpu_w);
  gpuEmxReset_real_T(&p_gpu_w);
  gpuEmxReset_real_T(&w_gpu_w);
  gpuEmxReset_real_T(&h_gpu_yCol);
  gpuEmxReset_real_T(&d_gpu_w);
  gpuEmxReset_real_T(&f_gpu_x);
  gpuEmxReset_real_T(&m_gpu_w);
  gpuEmxReset_real_T(&i_gpu_x);
  gpuEmxReset_real_T(&k_gpu_x);
  gpuEmxReset_real_T(&gpu_yCol);
  gpuEmxReset_real_T(&d_gpu_yCol);
  gpuEmxReset_real_T(&e_gpu_x);
  gpuEmxReset_real_T(&h_gpu_x);
  gpuEmxReset_real_T(&j_gpu_yCol);
  gpuEmxReset_real_T(&e_gpu_y);
  gpuEmxReset_real_T(&c_gpu_yCol);
  gpuEmxReset_real_T(&f_gpu_yCol);
  gpuEmxReset_real_T(&i_gpu_yCol);
  gpuEmxReset_real_T(&b_gpu_yCol);
  gpuEmxReset_real_T(&e_gpu_yCol);
  gpuEmxReset_real_T(&g_gpu_yCol);
  gpuEmxReset_int32_T(&gpu_IPIV);
  gpuEmxReset_real_T(&d_gpu_y);
  gpuEmxReset_real_T(&gpu_tau);
  gpuEmxReset_real_T(&gpu_xCol);
  gpuEmxReset_real_T(&gpu_dv21);
  gpuEmxReset_int32_T(&gpu_jpvt);
  gpuEmxReset_real_T(&m_gpu_x);
  gpuEmxReset_real_T(&gpu_dv20);
  gpuEmxReset_real_T(&gpu_a);
  gpuEmxReset_real_T(&gpu_y1);
  gpuEmxReset_real_T(&gpu_b);
  gpuEmxReset_int32_T(&gpu_iv6);
  gpuEmxReset_real_T(&gpu_sinc4A);
  gpuEmxReset_uint32_T(&f_gpu_y);
  gpuEmxReset_real_T(&gpu_sinc3A);
  gpuEmxReset_real_T(&b_gpu_h);
  gpuEmxReset_real_T(&gpu_sinc2A);
  gpuEmxReset_real_T(&gpu_sinc1A);
  gpuEmxReset_real_T(&gpu_G);
  gpuEmxReset_real_T(&gpu_k);
  gpuEmxReset_real_T(&gpu_m);
  gpuEmxReset_real_T(&gpu_h);
  gpuEmxReset_real_T(&gpu_h1);
  gpuEmxReset_real_T(&gpu_dv18);
  gpuEmxReset_real_T(&gpu_opts_x);
  gpuEmxReset_real_T(&gpu_opts_filter);
  gpuEmxReset_real_T(&gpu_xCh);
  gpuEmxReset_real_T(&c_gpu_y);
  gpuEmxReset_creal_T(&gpu_cfsposdft);
  gpuEmxReset_real_T(&c_gpu_x);
  gpuEmxReset_creal_T(&gpu_xposdft);
  gpuEmxReset_real_T(&gpu_xv);
  gpuEmxReset_creal_T(&gpu_cfspos);
  checkCudaError(mwCudaMalloc(&gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv13_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv16_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&kd_gpu_y);
  gpuEmxReset_real_T(&gpu_x);
  checkCudaError(mwCudaMalloc(&gpu_a_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_powscales);
  checkCudaError(mwCudaMalloc(&b_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_expnt);
  gpuEmxReset_real_T(&gpu_absomega);
  gpuEmxReset_real_T(&db_gpu_w);
  gpuEmxReset_real_T(&gpu_somega);
  gpuEmxReset_real_T(&b_gpu_somega);
  gpuEmxReset_real_T(&gpu_f);
  gpuEmxReset_real_T(&gpu_daughter);
  checkCudaError(mwCudaMalloc(&c_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv4_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dv10_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&md_gpu_y);
  checkCudaError(mwCudaMalloc(&b_gpu_a_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&ld_gpu_y);
  checkCudaError(mwCudaMalloc(&d_gpu_fx_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&b_gpu_y);
  checkCudaError(mwCudaMalloc(&gpu_y_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_y);
  checkCudaError(mwCudaMalloc(&gpu_xt_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_x_data, 77880UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_fb_Scales);
  checkCudaError(mwCudaMalloc(&gpu_x_data, 77880UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_subs, 10384UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_fb_Omega);
  checkCudaError(mwCudaMalloc(&gpu_interval, 5200UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&b_gpu_r, 8UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_omega_tmp2);
  checkCudaError(mwCudaMalloc(&gpu_wname, 5UL), __FILE__, __LINE__);
  gpuEmxReset_int32_T(&gpu_omega_tmp1);
  checkCudaError(mwCudaMalloc(&gpu_wav, 5UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_r, 8UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_nrefine, 4UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dc1, 16UL), __FILE__, __LINE__);
  checkCudaError(mwCudaMalloc(&gpu_dc6, 16UL), __FILE__, __LINE__);
  gpuEmxReset_real_T(&gpu_freqs);
  gpuEmxReset_real_T(&b_gpu_x);
  h_outdatedOnGpu = false;
  b_fx_data_outdatedOnCpu = false;
  fx_data_outdatedOnCpu = false;
  x_outdatedOnGpu = true;
  j_y_needsGpuEnsureCapacity = true;
  i_y_needsGpuEnsureCapacity = true;
  h_y_needsGpuEnsureCapacity = true;
  g_y_needsGpuEnsureCapacity = true;
  f_y_needsGpuEnsureCapacity = true;
  e_y_needsGpuEnsureCapacity = true;
  d_y_needsGpuEnsureCapacity = true;
  c_y_needsGpuEnsureCapacity = true;
  G_needsGpuEnsureCapacity = true;
  h_needsGpuEnsureCapacity = true;
  b_y_needsGpuEnsureCapacity = true;
  y_needsGpuEnsureCapacity = true;
  c_omega_tmp1_needsGpuEnsureCapa = true;
  x_needsGpuEnsureCapacity = true;
  checkCudaError(cudaMemcpy(gpu_dc1, &cpu_dc1, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  checkCudaError(cudaMemcpy(gpu_dc6, &cpu_dc6, 16UL, cudaMemcpyHostToDevice),
                 __FILE__, __LINE__);
  ec_cwt_kernel1<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_dc1, gpu_dc6);
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);

  //  Continuous wavelet transform - CUDA binary wrapper (double-precision, FP64)
  //  CWT uses morse wavelets, as they account for unequal variance-covariance across freqs.
  //  L1-norm is applied to mitigate 1/f decay of neuronal field potentials.
  //  Log-transform & robust z-scoring converts absolute valued CWT outputs into normal distribution.
  //
  //  Kevin Tan, 2022 (kevmtan.github.io)
  //  Input validation
  // 'ec_cwt:11' x (:,:){mustBeFloat}
  //  Input data
  // 'ec_cwt:12' fs (1,1){mustBeFloat} = 1000
  //  Sampling rate
  // 'ec_cwt:13' fLims (1,2){mustBeFloat} = [1 300]
  //  Frequency limits
  // 'ec_cwt:14' fOctave (1,1){mustBeFloat} = 10
  //  Voices per octave
  // 'ec_cwt:15' ds (1,2){mustBeFloat} = [1 1]
  //  Frequency limits
  // 'ec_cwt:17' coder.gpu.kernelfun;
  // 'ec_cwt:18' nFrames = height(x);
  // 'ec_cwt:19' nChs = width(x);
  // 'ec_cwt:20' doDownsample = ds(2)>ds(1);
  doDownsample = (ds[1] > ds[0]);

  //  Prep CWT
  // 'ec_cwt:23' fb = cwtfilterbank(Wavelet="Morse",SignalLength=nFrames,...
  // 'ec_cwt:24'     SamplingFrequency=fs,FrequencyLimits=fLims,VoicesPerOctave=fOctave);
  fb_CutOff = 50;
  for (itime = 0; itime < 2; itime++) {
    fb_FrequencyLimits[itime] = fLims[itime];
  }

  first_iteration = false;
  cpu_nrefine = 0;
  do {
    exitg1 = 0;
    if (cpu_nrefine + 1 < 11) {
      if (cpu_cv[static_cast<int32_T>(b[cpu_nrefine])] != cpu_cv[static_cast<
          int32_T>(cv1[cpu_nrefine])]) {
        exitg1 = 1;
      } else {
        cpu_nrefine++;
      }
    } else {
      first_iteration = true;
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  if (first_iteration) {
    if (cpu_x->size[0] <= 100000) {
      fb_SignalPad = static_cast<int32_T>(std::floor(static_cast<real_T>
        (cpu_x->size[0]) / 2.0));
    } else {
      cpu_r = std::frexp(static_cast<real_T>(cpu_x->size[0]), &ix);
      if (cpu_r == 0.5) {
        cpu_r = static_cast<real_T>(ix) - 1.0;
      } else {
        cpu_r = std::log(cpu_r) / 0.69314718055994529 + static_cast<real_T>(ix);
      }

      cpu_r = std::ceil(cpu_r);
      fb_SignalPad = static_cast<int32_T>(cpu_r);
    }
  } else {
    fb_SignalPad = 0;
  }

  for (itime = 0; itime < 2; itime++) {
    b_b[itime] = std::isnan(fLims[itime]);
  }

  first_iteration = true;
  k = 0;
  exitg2 = false;
  while ((!exitg2) && (k < 2)) {
    if (!b_b[k]) {
      first_iteration = false;
      exitg2 = true;
    } else {
      k++;
    }
  }

  if (!first_iteration) {
    real_T freqrange[2];
    for (itime = 0; itime < 2; itime++) {
      freqrange[itime] = fLims[itime];
    }

    NyquistRange[1] = fs / 2.0;
    emxInit_char_T(&tmpStr, 2, &u_emlrtRTEI, true);
    if ((fLims[1] <= 0.0) || (fLims[0] >= NyquistRange[1])) {
      b_tmpStr = nullptr;
      y = nullptr;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m, &u[0]);
      emlrtAssign(&y, m);
      b_y = nullptr;
      m1 = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 2, m1, &formatSpec[0]);
      emlrtAssign(&b_y, m1);
      c_y = nullptr;
      m2 = emlrtCreateDoubleScalar(NyquistRange[1]);
      emlrtAssign(&c_y, m2);
      emlrtAssign(&b_tmpStr, feval(y, b_y, c_y, &emlrtMCI));
      emlrt_marshallIn(length(emlrtAlias(b_tmpStr), &b_emlrtMCI),
                       "<output of length>");
      emlrt_marshallIn(emlrtAlias(b_tmpStr), "tmpStr", tmpStr);
      emlrtDestroyArray(&b_tmpStr);
    }

    emxFree_char_T(&tmpStr);
    omegac = 3.1415926535897931;
    ec_cwt_kernel2<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv,
      *gpu_wname, *gpu_wav, c_b[0], c_b[1], c_b[2], c_b[3], c_b[4]);
    wav_outdatedOnCpu = true;
    checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 5UL, cudaMemcpyDeviceToHost),
                   __FILE__, __LINE__);
    if (cpu_wname[0] == 'm') {
      cf = 1.8820720577620569;
      r = 0.0057083835261;
      cpu_r = 0.0057083835261;
      b_cpu_r = 0.0057083835261;
      for (lidx = 0; lidx < 6; lidx++) {
        fc = c[lidx];
        r = r * 0.005353955978584176 + fc;
        cpu_r = cpu_r * 0.005353955978584176 + fc;
        b_cpu_r = b_cpu_r * 0.005353955978584176 + fc;
      }

      r /= 13.666666666666666;
      cpu_r /= 13.666666666666666;
      b_cpu_r /= 13.666666666666666;
      cpu_r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((r
        + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) + std::
                         exp((cpu_table100[14] + 2.5377749931802178) - (((cpu_r
        + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) -
                        std::exp((cpu_table100[13] + 5.8211893391859881) -
        (((b_cpu_r + 0.91893853320467278) - 1.307479889018099) +
         22.071116966494703)));
      if (std::isinf(cpu_r) || std::isnan(cpu_r)) {
        ec_cwt_kernel3<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_cwt_kernel4<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        intDsq = 0.0;
        ix = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        nw = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (nw > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            lidx = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            b_cpu_r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (itime = 0; itime < lidx; itime++) {
              cpu_interval[n_idx_0 - itime] = cpu_interval[0] +
                static_cast<real_T>(n_idx_0 - itime) * b_cpu_r;
            }
          }

          ix = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        lidx = 0;
        for (cpu_nrefine = 0; cpu_nrefine < ix; cpu_nrefine++) {
          if (std::abs(cpu_interval[cpu_nrefine + 1] - cpu_interval[lidx]) > 0.0)
          {
            lidx++;
            cpu_interval[lidx] = cpu_interval[cpu_nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_cwt_kernel5<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (nw <= 0) {
          intDsq = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel629<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          q_ok = 0.0;
          err_ok = 0.0;
          first_iteration = true;
          do {
            exitg1 = 0;
            x_data_outdatedOnGpu = false;
            dim = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              fc = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              b_cpu_r = cpu_subs[(k << 1) + 1];
              cpu_r = (fc + b_cpu_r) / 2.0;
              halfh = (b_cpu_r - fc) / 2.0;
              for (itime = 0; itime < 15; itime++) {
                SD->f0.cpu_x_data[(ix + itime) + 1] = NODES[itime] * halfh +
                  cpu_r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            xt_size[0] = 1;
            xt_size[1] = dim;
            mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
              2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel630<<<grid, block>>>(*gpu_x_data, dim - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              cpu_r = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= dim - 2)) {
                s = cpu_r;
                cpu_r = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, cpu_r)) {
                  Nodd = true;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>(dim)
                  - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel631<<<grid, block>>>(static_cast<int16_T>(dim) -
                    1, *d_gpu_fx_data);
                }

                exitg1 = 1;
              } else {
                guard1 = true;
              }
            } else {
              guard1 = true;
            }

            if (guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel632<<<grid, block>>>(*b_gpu_x_data, dim - 1,
                  *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel633<<<grid, block>>>(*b_gpu_x_data, dim - 1,
                  *gpu_x_data);
              }

              a_size[1] = dim;
              mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel634<<<grid, block>>>(*gpu_x_data, *gpu_y_data, dim
                  - 1, *b_gpu_a_data);
              }

              dv4_size[0] = 1;
              dv4_size[1] = a_size[1];
              mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel635<<<grid, block>>>(*b_gpu_a_data, a_size[1] - 1, *
                  gpu_dv4_data);
              }

              mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel636<<<grid, block>>>(*b_gpu_x_data, dim - 1,
                  *gpu_y_data);
              }

              dv7_size[0] = 1;
              dv7_size[1] = dim;
              mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel637<<<grid, block>>>(*gpu_y_data, dim - 1,
                  *gpu_x_data);
              }

              if (a_size[1] == dim) {
                fx_size[0] = 1;
                fx_size[1] = a_size[1];
                mwGetLaunchParameters1D(computeNumIters(a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel638<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv4_data, a_size[1] - 1, *d_gpu_fx_data);
                }

                fx_data_outdatedOnCpu = true;
              } else {
                if (fx_data_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *d_gpu_fx_data,
                    77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                checkCudaError(cudaMemcpy(SD->f0.cpu_dv4_data, *gpu_dv4_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                binary_expand_op_5(SD->f0.cpu_fx_data, fx_size,
                                   SD->f0.cpu_dv4_data, dv4_size,
                                   SD->f0.cpu_x_data, dv7_size,
                                   SD->f0.cpu_xt_data, xt_size);
                fx_data_outdatedOnCpu = false;
              }

              cpu_r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                fc = 0.0;
                b_cpu_r = 0.0;
                for (itime = 0; itime < 15; itime++) {
                  if (fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *d_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  fc += dv5[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                  fx_data_outdatedOnCpu = false;
                  b_cpu_r += dv6[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                fc *= halfh;
                qsub[k] = fc;
                cpu_r += fc;
                errsub[k] = b_cpu_r * halfh;
              }

              intDsq = cpu_r + q_ok;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(intDsq));
              tau = 2.0 * tol;
              cpu_r = 0.0;
              cpu_nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                fc = errsub[k];
                b_cpu_r = std::abs(fc);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (b_cpu_r <= tau * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1])
                                      / 2.0)) {
                  err_ok += fc;
                  q_ok += qsub[k];
                } else {
                  cpu_r += b_cpu_r;
                  cpu_nrefine++;
                  cpu_subs[(cpu_nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((cpu_nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              cpu_r += std::abs(err_ok);
              if ((!std::isinf(intDsq)) && (!std::isnan(intDsq)) && ((!std::
                    isinf(cpu_r)) && (!std::isnan(cpu_r))) && (cpu_nrefine != 0)
                  && (!(cpu_r <= tol))) {
                nsubs = cpu_nrefine << 1;
                if (nsubs > 650) {
                  exitg1 = 1;
                } else {
                  for (k = 0; k < cpu_nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((cpu_nrefine - k) << 1) - 1) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((cpu_nrefine - k) - 1) << 1] + cpu_subs[(((cpu_nrefine -
                      k) - 1) << 1) + 1]) / 2.0;
                    cpu_subs[((((cpu_nrefine - k) << 1) - 2) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((cpu_nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg1 = 1;
              }
            }
          } while (exitg1 == 0);
        }

        ec_cwt_kernel6<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_cwt_kernel7<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        intFsq = 0.0;
        ix = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        nw = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (nw > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            cpu_nrefine = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            b_cpu_r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (itime = 0; itime < cpu_nrefine; itime++) {
              cpu_interval[n_idx_0 - itime] = cpu_interval[0] +
                static_cast<real_T>(n_idx_0 - itime) * b_cpu_r;
            }
          }

          ix = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        lidx = 0;
        for (cpu_nrefine = 0; cpu_nrefine < ix; cpu_nrefine++) {
          if (std::abs(cpu_interval[cpu_nrefine + 1] - cpu_interval[lidx]) > 0.0)
          {
            lidx++;
            cpu_interval[lidx] = cpu_interval[cpu_nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_cwt_kernel8<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (nw <= 0) {
          intFsq = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel622<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          q_ok = 0.0;
          err_ok = 0.0;
          first_iteration = true;
          do {
            exitg1 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              fc = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              b_cpu_r = cpu_subs[(k << 1) + 1];
              cpu_r = (fc + b_cpu_r) / 2.0;
              halfh = (b_cpu_r - fc) / 2.0;
              for (itime = 0; itime < 15; itime++) {
                SD->f0.cpu_x_data[(ix + itime) + 1] = NODES[itime] * halfh +
                  cpu_r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel623<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              cpu_r = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= x_size_idx_1 - 2)) {
                s = cpu_r;
                cpu_r = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, cpu_r)) {
                  Nodd = true;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>
                  (x_size_idx_1) - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel624<<<grid, block>>>(static_cast<int16_T>
                    (x_size_idx_1) - 1, *c_gpu_fx_data);
                }

                exitg1 = 1;
              } else {
                guard1 = true;
              }
            } else {
              guard1 = true;
            }

            if (guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel625<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_dv10_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel626<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel627<<<grid, block>>>(*gpu_y_data, x_size_idx_1 - 1,
                  *gpu_x_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel628<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                  *gpu_dv10_data, x_size_idx_1 - 1, *c_gpu_fx_data);
              }

              fx_data_outdatedOnCpu = true;
              cpu_r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                fc = 0.0;
                b_cpu_r = 0.0;
                for (itime = 0; itime < 15; itime++) {
                  if (fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *c_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  fc += dv5[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                  fx_data_outdatedOnCpu = false;
                  b_cpu_r += dv6[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                fc *= halfh;
                qsub[k] = fc;
                cpu_r += fc;
                errsub[k] = b_cpu_r * halfh;
              }

              intFsq = cpu_r + q_ok;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(intFsq));
              tau = 2.0 * tol;
              cpu_r = 0.0;
              cpu_nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                fc = errsub[k];
                b_cpu_r = std::abs(fc);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (b_cpu_r <= tau * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1])
                                      / 2.0)) {
                  err_ok += fc;
                  q_ok += qsub[k];
                } else {
                  cpu_r += b_cpu_r;
                  cpu_nrefine++;
                  cpu_subs[(cpu_nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((cpu_nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              cpu_r += std::abs(err_ok);
              if ((!std::isinf(intFsq)) && (!std::isnan(intFsq)) && ((!std::
                    isinf(cpu_r)) && (!std::isnan(cpu_r))) && (cpu_nrefine != 0)
                  && (!(cpu_r <= tol))) {
                nsubs = cpu_nrefine << 1;
                if (nsubs > 650) {
                  exitg1 = 1;
                } else {
                  for (k = 0; k < cpu_nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((cpu_nrefine - k) << 1) - 1) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((cpu_nrefine - k) - 1) << 1] + cpu_subs[(((cpu_nrefine -
                      k) - 1) << 1) + 1]) / 2.0;
                    cpu_subs[((((cpu_nrefine - k) << 1) - 2) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((cpu_nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg1 = 1;
              }
            }
          } while (exitg1 == 0);
        }

        cpu_r = std::sqrt(3.5421952306087032 * (intDsq / intFsq));
      }
    } else if (cpu_wname[0] == 'a') {
      cf = 6.0;
      cpu_r = 1.4142135623730951;
    } else {
      cf = 5.0;
      cpu_r = 5.847705;
    }

    b_cpu_r = static_cast<real_T>(cpu_x->size[0]) / (cpu_r * 2.0);
    first_iteration = false;
    cpu_nrefine = 0;
    do {
      exitg1 = 0;
      if (cpu_nrefine + 1 < 6) {
        if (wav_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 5UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        wav_outdatedOnCpu = false;
        if (cv3[cpu_nrefine] != cpu_wav[cpu_nrefine]) {
          exitg1 = 1;
        } else {
          cpu_nrefine++;
        }
      } else {
        first_iteration = true;
        exitg1 = 1;
      }
    } while (exitg1 == 0);

    if (first_iteration) {
      itime = 0;
    } else {
      itime = -1;
    }

    if (itime == 0) {
      if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
          (-rt_powd_snf(cf, 3.0)) >= 0.0) {
        if (1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
            (-rt_powd_snf(cf, 3.0)) == 1.0) {
          omegac = 9.0856029641606977;
        } else {
          omegac = cf;
        }
      } else {
        a = cf;
        omegac = 9.0856029641606977;
        cpu_r = 1.0 - 0.0050536085896138528 * rt_powd_snf(cf, 20.0) * std::exp
          (-rt_powd_snf(cf, 3.0));
        halfh = 1.0;
        if (cpu_r == 0.0) {
          omegac = cf;
        } else {
          fc = 1.0;
          tol = 9.0856029641606977;
          tau = 0.0;
          d = 0.0;
          exitg2 = false;
          while ((!exitg2) && ((halfh != 0.0) && (a != omegac))) {
            if ((halfh > 0.0) == (fc > 0.0)) {
              tol = a;
              fc = cpu_r;
              d = omegac - a;
              tau = d;
            }

            if (std::abs(fc) < std::abs(halfh)) {
              a = omegac;
              omegac = tol;
              tol = a;
              cpu_r = halfh;
              halfh = fc;
              fc = cpu_r;
            }

            intFsq = 0.5 * (tol - omegac);
            intDsq = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(intFsq) <= intDsq) || (halfh == 0.0)) {
              exitg2 = true;
            } else {
              if ((std::abs(tau) < intDsq) || (std::abs(cpu_r) <= std::abs(halfh)))
              {
                d = intFsq;
                tau = intFsq;
              } else {
                s = halfh / cpu_r;
                if (a == tol) {
                  cpu_r = 2.0 * intFsq * s;
                  err_ok = 1.0 - s;
                } else {
                  err_ok = cpu_r / fc;
                  r = halfh / fc;
                  cpu_r = s * (2.0 * intFsq * err_ok * (err_ok - r) - (omegac -
                    a) * (r - 1.0));
                  err_ok = (err_ok - 1.0) * (r - 1.0) * (s - 1.0);
                }

                if (cpu_r > 0.0) {
                  err_ok = -err_ok;
                } else {
                  cpu_r = -cpu_r;
                }

                if ((2.0 * cpu_r < 3.0 * intFsq * err_ok - std::abs(intDsq *
                      err_ok)) && (cpu_r < std::abs(0.5 * tau * err_ok))) {
                  tau = d;
                  d = cpu_r / err_ok;
                } else {
                  d = intFsq;
                  tau = intFsq;
                }
              }

              a = omegac;
              cpu_r = halfh;
              if (std::abs(d) > intDsq) {
                omegac += d;
              } else if (omegac > tol) {
                omegac -= intDsq;
              } else {
                omegac += intDsq;
              }

              halfh = 1.0 - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0) *
                std::exp(-rt_powd_snf(omegac, 3.0));
            }
          }
        }
      }
    }

    cpu_r = omegac / 3.1415926535897931;
    if (b_cpu_r < cpu_r * rt_powd_snf(2.0, 1.0 / fOctave)) {
      b_cpu_r = cpu_r * rt_powd_snf(2.0, 1.0 / fOctave);
    }

    cpu_r = 1.0 / (b_cpu_r * (6.2831853071795862 / cf)) * fs;
    if (fLims[0] < cpu_r) {
      fb_FrequencyLimits[0] = cpu_r;
      freqrange[0] = cpu_r;
    }

    if (fLims[1] > fs / 2.0) {
      fb_FrequencyLimits[1] = fs / 2.0;
      freqrange[1] = fb_FrequencyLimits[1];
    }

    if (freqrange[1] == 0.0) {
      b_cpu_r = rtMinusInf;
    } else if (freqrange[1] < 0.0) {
      b_cpu_r = rtNaN;
    } else if ((!std::isinf(freqrange[1])) && (!std::isnan(freqrange[1]))) {
      cpu_r = std::frexp(freqrange[1], &b_nx);
      if (cpu_r == 0.5) {
        b_cpu_r = static_cast<real_T>(b_nx) - 1.0;
      } else if ((b_nx == 1) && (cpu_r < 0.75)) {
        b_cpu_r = std::log(2.0 * cpu_r) / 0.69314718055994529;
      } else {
        b_cpu_r = std::log(cpu_r) / 0.69314718055994529 + static_cast<real_T>
          (b_nx);
      }
    } else {
      b_cpu_r = freqrange[1];
    }

    if (freqrange[0] == 0.0) {
      cpu_r = rtMinusInf;
    } else if (freqrange[0] < 0.0) {
      cpu_r = rtNaN;
    } else if ((!std::isinf(freqrange[0])) && (!std::isnan(freqrange[0]))) {
      cpu_r = std::frexp(freqrange[0], &eint);
      if (cpu_r == 0.5) {
        cpu_r = static_cast<real_T>(eint) - 1.0;
      } else if ((eint == 1) && (cpu_r < 0.75)) {
        cpu_r = std::log(2.0 * cpu_r) / 0.69314718055994529;
      } else {
        cpu_r = std::log(cpu_r) / 0.69314718055994529 + static_cast<real_T>(eint);
      }
    } else {
      cpu_r = freqrange[0];
    }

    if (!(b_cpu_r - cpu_r >= 1.0 / fOctave)) {
      c_tmpStr = nullptr;
      d_y = nullptr;
      m3 = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m3, &u[0]);
      emlrtAssign(&d_y, m3);
      e_y = nullptr;
      m4 = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 5, m4, &b_formatSpec[0]);
      emlrtAssign(&e_y, m4);
      f_y = nullptr;
      m5 = emlrtCreateDoubleScalar(1.0 / fOctave);
      emlrtAssign(&f_y, m5);
      emlrtAssign(&c_tmpStr, feval(d_y, e_y, f_y, &emlrtMCI));
      emlrt_marshallIn(length(emlrtAlias(c_tmpStr), &b_emlrtMCI),
                       "<output of length>");
      emxInit_char_T(&d_tmpStr, 2, &u_emlrtRTEI, true);
      emlrt_marshallIn(emlrtAlias(c_tmpStr), "tmpStr", d_tmpStr);
      emxFree_char_T(&d_tmpStr);
      emlrtDestroyArray(&c_tmpStr);
    }
  }

  first_iteration = false;
  cpu_nrefine = 0;
  do {
    exitg1 = 0;
    if (cpu_nrefine + 1 < 6) {
      if (cpu_cv[static_cast<int32_T>(c_b[cpu_nrefine])] != cpu_cv
          [static_cast<int32_T>(cv2[cpu_nrefine])]) {
        exitg1 = 1;
      } else {
        cpu_nrefine++;
      }
    } else {
      first_iteration = true;
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  if (!first_iteration) {
    fb_CutOff = 10;
  }

  N = static_cast<uint32_T>(cpu_x->size[0]) + static_cast<uint32_T>(fb_SignalPad
    << 1);
  cpu_nrefine = static_cast<int32_T>(std::trunc(static_cast<real_T>(N) / 2.0));
  emxInit_int32_T(&cpu_omega_tmp1, 2, &emlrtRTEI, true);
  if (cpu_nrefine < 1) {
    cpu_omega_tmp1->size[0] = 1;
    cpu_omega_tmp1->size[1] = 0;
  } else {
    eint = cpu_omega_tmp1->size[0] * cpu_omega_tmp1->size[1];
    cpu_omega_tmp1->size[0] = 1;
    cpu_omega_tmp1->size[1] = cpu_nrefine;
    emxEnsureCapacity_int32_T(cpu_omega_tmp1, eint, &emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel621<<<grid, block>>>(cpu_nrefine - 1, gpu_omega_tmp1);
    }
  }

  emxInit_real_T(&cpu_omega_tmp2, 2, &b_emlrtRTEI, true);
  eint = cpu_omega_tmp2->size[0] * cpu_omega_tmp2->size[1];
  cpu_omega_tmp2->size[0] = 1;
  cpu_omega_tmp2->size[1] = cpu_omega_tmp1->size[1];
  emxEnsureCapacity_real_T(cpu_omega_tmp2, eint, &b_emlrtRTEI);
  b_nx = cpu_omega_tmp1->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
  if (c_omega_tmp1_needsGpuEnsureCapa) {
    gpuEmxEnsureCapacity_int32_T(cpu_omega_tmp1, &gpu_omega_tmp1, true);
  }

  gpuEmxEnsureCapacity_real_T(cpu_omega_tmp2, &gpu_omega_tmp2, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_cwt_kernel9<<<grid, block>>>(6.2831853071795862 / static_cast<real_T>(N),
      gpu_omega_tmp1, b_nx, gpu_omega_tmp2);
  }

  emxFree_int32_T(&cpu_omega_tmp1);
  cpu_nrefine = static_cast<int32_T>(std::trunc((static_cast<real_T>(N) - 1.0) /
    2.0));
  if (cpu_nrefine < 1) {
    lidx = 0;
    cpu_nrefine = 1;
    nw = -1;
  } else {
    lidx = cpu_nrefine - 1;
    cpu_nrefine = -1;
    nw = 0;
  }

  emxInit_real_T(&cpu_fb_Omega, 2, &f_emlrtRTEI, true);
  eint = cpu_fb_Omega->size[0] * cpu_fb_Omega->size[1];
  cpu_fb_Omega->size[0] = 1;
  cpu_fb_Omega->size[1] = (cpu_omega_tmp2->size[1] + div_s32(nw - lidx,
    cpu_nrefine)) + 2;
  emxEnsureCapacity_real_T(cpu_fb_Omega, eint, &c_emlrtRTEI);
  gpuEmxEnsureCapacity_real_T(cpu_fb_Omega, &gpu_fb_Omega, true);
  ec_cwt_kernel10<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_fb_Omega);
  dim = cpu_omega_tmp2->size[1];
  mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_cwt_kernel11<<<grid, block>>>(gpu_omega_tmp2, dim - 1, gpu_fb_Omega);
  }

  dim = div_s32(nw - lidx, cpu_nrefine);
  mwGetLaunchParameters1D(computeNumIters(dim), &grid, &block, 2147483647U);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_cwt_kernel12<<<grid, block>>>(cpu_nrefine, lidx, gpu_omega_tmp2, dim,
      gpu_fb_Omega, cpu_omega_tmp2->size[1U]);
  }

  wav_outdatedOnCpu = true;
  emxFree_real_T(&cpu_omega_tmp2);
  for (itime = 0; itime < 2; itime++) {
    b_b[itime] = std::isnan(fb_FrequencyLimits[itime]);
  }

  first_iteration = true;
  k = 0;
  exitg2 = false;
  while ((!exitg2) && (k < 2)) {
    if (!b_b[k]) {
      first_iteration = false;
      exitg2 = true;
    } else {
      k++;
    }
  }

  emxInit_real_T(&cpu_fb_Scales, 2, &f_emlrtRTEI, true);
  if (!first_iteration) {
    for (itime = 0; itime < 2; itime++) {
      NyquistRange[itime] = fb_FrequencyLimits[itime] / fs * 2.0 *
        3.1415926535897931;
    }

    for (k = 0; k < 5; k++) {
      cpu_wname[k] = cpu_cv[static_cast<int32_T>(c_b[k])];
    }

    if (cpu_wname[0] == 'm') {
      cpu_r = 1.8820720577620569;
    } else {
      itime = 1;
      if (cpu_wname[0] == 'a') {
        itime = 2;
      }

      if (itime > 1) {
        cpu_r = 6.0;
      } else {
        cpu_r = 5.0;
      }
    }

    halfh = cpu_r / NyquistRange[1];
    cpu_r = cpu_r / NyquistRange[0] / halfh;
    if (cpu_r == 0.0) {
      cpu_r = rtMinusInf;
    } else if (cpu_r < 0.0) {
      cpu_r = rtNaN;
    } else if ((!std::isinf(cpu_r)) && (!std::isnan(cpu_r))) {
      cpu_r = std::frexp(cpu_r, &nx);
      if (cpu_r == 0.5) {
        cpu_r = static_cast<real_T>(nx) - 1.0;
      } else if ((nx == 1) && (cpu_r < 0.75)) {
        cpu_r = std::log(2.0 * cpu_r) / 0.69314718055994529;
      } else {
        cpu_r = std::log(cpu_r) / 0.69314718055994529 + static_cast<real_T>(nx);
      }
    }

    emxInit_real_T(&cpu_y, 2, &fd_emlrtRTEI, true);
    q_ok = fOctave * cpu_r;
    if (std::isnan(q_ok)) {
      eint = cpu_y->size[0] * cpu_y->size[1];
      cpu_y->size[0] = 1;
      cpu_y->size[1] = 1;
      emxEnsureCapacity_real_T(cpu_y, eint, &d_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
      y_needsGpuEnsureCapacity = false;
      ec_cwt_kernel13<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_y);
    } else if (q_ok < 0.0) {
      cpu_y->size[0] = 1;
      cpu_y->size[1] = 0;
    } else {
      eint = cpu_y->size[0] * cpu_y->size[1];
      cpu_y->size[0] = 1;
      cpu_y->size[1] = static_cast<int32_T>(q_ok) + 1;
      emxEnsureCapacity_real_T(cpu_y, eint, &d_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(q_ok)), &grid,
        &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
      y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel592<<<grid, block>>>(static_cast<int32_T>(q_ok), gpu_y);
      }
    }

    emxInit_real_T(&b_cpu_y, 2, &gd_emlrtRTEI, true);
    eint = b_cpu_y->size[0] * b_cpu_y->size[1];
    b_cpu_y->size[0] = 1;
    b_cpu_y->size[1] = cpu_y->size[1];
    emxEnsureCapacity_real_T(b_cpu_y, eint, &e_emlrtRTEI);
    ix = cpu_y->size[1];
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    if (y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_y, &gpu_y, true);
    }

    gpuEmxEnsureCapacity_real_T(b_cpu_y, &b_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel14<<<grid, block>>>(gpu_y, rt_powd_snf(2.0, 1.0 / fOctave),
        ix - 1, b_gpu_y);
    }

    emxFree_real_T(&cpu_y);
    eint = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
    cpu_fb_Scales->size[0] = 1;
    cpu_fb_Scales->size[1] = b_cpu_y->size[1];
    emxEnsureCapacity_real_T(cpu_fb_Scales, eint, &f_emlrtRTEI);
    itime = b_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel15<<<grid, block>>>(b_gpu_y, halfh, itime, gpu_fb_Scales);
    }

    x_data_outdatedOnGpu = true;
    emxFree_real_T(&b_cpu_y);
  } else {
    omegac = 3.1415926535897931;
    ec_cwt_kernel593<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*global_gpu_cv,
      *gpu_wav, *gpu_wname, c_b[0], c_b[1], c_b[2], c_b[3], c_b[4]);
    fx_data_outdatedOnCpu = true;
    checkCudaError(cudaMemcpy(cpu_wav, *gpu_wav, 5UL, cudaMemcpyDeviceToHost),
                   __FILE__, __LINE__);
    if (cpu_wav[0] == 'm') {
      a = 1.8820720577620569;
      r = 0.0057083835261;
      cpu_r = 0.0057083835261;
      b_cpu_r = 0.0057083835261;
      for (lidx = 0; lidx < 6; lidx++) {
        fc = c[lidx];
        r = r * 0.005353955978584176 + fc;
        cpu_r = cpu_r * 0.005353955978584176 + fc;
        b_cpu_r = b_cpu_r * 0.005353955978584176 + fc;
      }

      r /= 13.666666666666666;
      cpu_r /= 13.666666666666666;
      b_cpu_r /= 13.666666666666666;
      cpu_r = std::sqrt((std::exp((cpu_table100[12] + 7.7183093240718676) - (((r
        + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703)) + std::
                         exp((cpu_table100[14] + 2.5377749931802178) - (((cpu_r
        + 0.91893853320467278) - 1.307479889018099) + 22.071116966494703))) -
                        std::exp((cpu_table100[13] + 5.8211893391859881) -
        (((b_cpu_r + 0.91893853320467278) - 1.307479889018099) +
         22.071116966494703)));
      if (std::isinf(cpu_r) || std::isnan(cpu_r)) {
        ec_cwt_kernel594<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_cwt_kernel595<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        intDsq = 0.0;
        ix = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        nw = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (nw > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            cpu_nrefine = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            b_cpu_r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (itime = 0; itime < cpu_nrefine; itime++) {
              cpu_interval[n_idx_0 - itime] = cpu_interval[0] +
                static_cast<real_T>(n_idx_0 - itime) * b_cpu_r;
            }
          }

          ix = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        lidx = 0;
        for (cpu_nrefine = 0; cpu_nrefine < ix; cpu_nrefine++) {
          if (std::abs(cpu_interval[cpu_nrefine + 1] - cpu_interval[lidx]) > 0.0)
          {
            lidx++;
            cpu_interval[lidx] = cpu_interval[cpu_nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_cwt_kernel596<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (nw <= 0) {
          intDsq = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel611<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          q_ok = 0.0;
          err_ok = 0.0;
          do {
            exitg1 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              fc = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              b_cpu_r = cpu_subs[(k << 1) + 1];
              cpu_r = (fc + b_cpu_r) / 2.0;
              halfh = (b_cpu_r - fc) / 2.0;
              for (itime = 0; itime < 15; itime++) {
                SD->f0.cpu_x_data[(ix + itime) + 1] = NODES[itime] * halfh +
                  cpu_r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            b_xt_size[0] = 1;
            b_xt_size[1] = x_size_idx_1;
            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel612<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              cpu_r = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= x_size_idx_1 - 2)) {
                s = cpu_r;
                cpu_r = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, cpu_r)) {
                  Nodd = true;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>
                  (x_size_idx_1) - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel613<<<grid, block>>>(static_cast<int16_T>
                    (x_size_idx_1) - 1, *b_gpu_fx_data);
                }

                exitg1 = 1;
              } else {
                guard1 = true;
              }
            } else {
              guard1 = true;
            }

            if (guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel614<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel615<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_x_data);
              }

              b_a_size[1] = x_size_idx_1;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel616<<<grid, block>>>(*gpu_x_data, *gpu_y_data,
                  x_size_idx_1 - 1, *gpu_a_data);
              }

              dv13_size[0] = 1;
              dv13_size[1] = b_a_size[1];
              mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel617<<<grid, block>>>(*gpu_a_data, b_a_size[1] - 1, *
                  gpu_dv13_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel618<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_y_data);
              }

              dv14_size[0] = 1;
              dv14_size[1] = x_size_idx_1;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel619<<<grid, block>>>(*gpu_y_data, x_size_idx_1 - 1,
                  *gpu_x_data);
              }

              if (b_a_size[1] == x_size_idx_1) {
                fx_size[0] = 1;
                fx_size[1] = b_a_size[1];
                mwGetLaunchParameters1D(computeNumIters(b_a_size[1] - 1), &grid,
                  &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel620<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                    *gpu_dv13_data, b_a_size[1] - 1, *b_gpu_fx_data);
                }

                b_fx_data_outdatedOnCpu = true;
              } else {
                if (b_fx_data_outdatedOnCpu) {
                  checkCudaError(cudaMemcpy(cpu_fx_data, *b_gpu_fx_data, 77880UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                checkCudaError(cudaMemcpy(cpu_dv13_data, *gpu_dv13_data, 77880UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *gpu_x_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                checkCudaError(cudaMemcpy(SD->f0.cpu_xt_data, *gpu_xt_data,
                  77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                binary_expand_op_5(cpu_fx_data, fx_size, cpu_dv13_data,
                                   dv13_size, SD->f0.cpu_x_data, dv14_size,
                                   SD->f0.cpu_xt_data, b_xt_size);
                b_fx_data_outdatedOnCpu = false;
              }

              cpu_r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                fc = 0.0;
                b_cpu_r = 0.0;
                for (itime = 0; itime < 15; itime++) {
                  if (b_fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(cpu_fx_data, *b_gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  fc += dv5[itime] * cpu_fx_data[(ix + itime) + 1];
                  b_fx_data_outdatedOnCpu = false;
                  b_cpu_r += dv6[itime] * cpu_fx_data[(ix + itime) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                fc *= halfh;
                qsub[k] = fc;
                cpu_r += fc;
                errsub[k] = b_cpu_r * halfh;
              }

              intDsq = cpu_r + q_ok;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(intDsq));
              tau = 2.0 * tol;
              cpu_r = 0.0;
              cpu_nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                fc = errsub[k];
                b_cpu_r = std::abs(fc);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (b_cpu_r <= tau * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1])
                                      / 2.0)) {
                  err_ok += fc;
                  q_ok += qsub[k];
                } else {
                  cpu_r += b_cpu_r;
                  cpu_nrefine++;
                  cpu_subs[(cpu_nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((cpu_nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              cpu_r += std::abs(err_ok);
              if ((!std::isinf(intDsq)) && (!std::isnan(intDsq)) && ((!std::
                    isinf(cpu_r)) && (!std::isnan(cpu_r))) && (cpu_nrefine != 0)
                  && (!(cpu_r <= tol))) {
                nsubs = cpu_nrefine << 1;
                if (nsubs > 650) {
                  exitg1 = 1;
                } else {
                  for (k = 0; k < cpu_nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((cpu_nrefine - k) << 1) - 1) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((cpu_nrefine - k) - 1) << 1] + cpu_subs[(((cpu_nrefine -
                      k) - 1) << 1) + 1]) / 2.0;
                    cpu_subs[((((cpu_nrefine - k) << 1) - 2) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((cpu_nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg1 = 1;
              }
            }
          } while (exitg1 == 0);
        }

        ec_cwt_kernel597<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(*gpu_interval);
        ec_cwt_kernel598<<<dim3(6U, 1U, 1U), dim3(128U, 1U, 1U)>>>(*gpu_interval);
        interval_outdatedOnGpu = false;
        intFsq = 0.0;
        ix = 1;
        checkCudaError(cudaMemcpy(cpu_interval, *gpu_interval, 5200UL,
          cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        nw = static_cast<int32_T>(cpu_interval[1]) - static_cast<int32_T>
          (cpu_interval[0]);
        if (nw > 0) {
          n_idx_0 = static_cast<int8_T>(static_cast<int32_T>(std::abs
            (cpu_interval[1] - cpu_interval[0])) * 10 - 1);
          nsubs = n_idx_0 + 1;
          if (n_idx_0 + 2 > 2) {
            cpu_nrefine = n_idx_0;
            cpu_interval[n_idx_0 + 1] = cpu_interval[1];
            interval_outdatedOnGpu = true;
            b_cpu_r = (cpu_interval[1] - cpu_interval[0]) / (static_cast<real_T>
              (n_idx_0) + 1.0);
            for (itime = 0; itime < cpu_nrefine; itime++) {
              cpu_interval[n_idx_0 - itime] = cpu_interval[0] +
                static_cast<real_T>(n_idx_0 - itime) * b_cpu_r;
            }
          }

          ix = n_idx_0 + 1;
        } else {
          nsubs = 1;
        }

        lidx = 0;
        for (cpu_nrefine = 0; cpu_nrefine < ix; cpu_nrefine++) {
          if (std::abs(cpu_interval[cpu_nrefine + 1] - cpu_interval[lidx]) > 0.0)
          {
            lidx++;
            cpu_interval[lidx] = cpu_interval[cpu_nrefine + 1];
            interval_outdatedOnGpu = true;
          } else {
            nsubs--;
          }
        }

        if (nsubs + 1 < 2) {
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_cwt_kernel599<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ix,
            *gpu_interval);
          interval_outdatedOnGpu = false;
          nsubs = 1;
        }

        if (nw <= 0) {
          intFsq = rtNaN;
        } else {
          mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            checkCudaError(cudaMemcpy(*gpu_interval, cpu_interval, 5200UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel604<<<grid, block>>>(*gpu_interval, nsubs - 1,
              *gpu_subs);
          }

          interval_outdatedOnGpu = true;
          q_ok = 0.0;
          err_ok = 0.0;
          first_iteration = true;
          do {
            exitg1 = 0;
            x_data_outdatedOnGpu = false;
            x_size_idx_1 = 15 * nsubs;
            ix = -1;
            for (k = 0; k < nsubs; k++) {
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              fc = cpu_subs[k << 1];
              interval_outdatedOnGpu = false;
              b_cpu_r = cpu_subs[(k << 1) + 1];
              cpu_r = (fc + b_cpu_r) / 2.0;
              halfh = (b_cpu_r - fc) / 2.0;
              for (itime = 0; itime < 15; itime++) {
                SD->f0.cpu_x_data[(ix + itime) + 1] = NODES[itime] * halfh +
                  cpu_r;
                x_data_outdatedOnGpu = true;
              }

              ix += 15;
            }

            mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
              &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_x_data, SD->f0.cpu_x_data, 77880UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel605<<<grid, block>>>(*gpu_x_data, x_size_idx_1 - 1,
                *gpu_xt_data, *b_gpu_x_data);
            }

            guard1 = false;
            if (!first_iteration) {
              checkCudaError(cudaMemcpy(SD->f0.cpu_x_data, *b_gpu_x_data,
                77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              cpu_r = std::abs(SD->f0.cpu_x_data[0]);
              Nodd = false;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= x_size_idx_1 - 2)) {
                s = cpu_r;
                cpu_r = std::abs(SD->f0.cpu_x_data[k + 1]);
                if (std::abs(SD->f0.cpu_x_data[k + 1] - SD->f0.cpu_x_data[k]) <=
                    2.2204460492503131E-14 * std::fmax(s, cpu_r)) {
                  Nodd = true;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (Nodd) {
                mwGetLaunchParameters1D(computeNumIters(static_cast<int16_T>
                  (x_size_idx_1) - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel606<<<grid, block>>>(static_cast<int16_T>
                    (x_size_idx_1) - 1, *gpu_fx_data);
                }

                exitg1 = 1;
              } else {
                guard1 = true;
              }
            } else {
              guard1 = true;
            }

            if (guard1) {
              first_iteration = false;
              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel607<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_dv16_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel608<<<grid, block>>>(*b_gpu_x_data, x_size_idx_1 -
                  1, *gpu_y_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel609<<<grid, block>>>(*gpu_y_data, x_size_idx_1 - 1,
                  *gpu_x_data);
              }

              mwGetLaunchParameters1D(computeNumIters(x_size_idx_1 - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel610<<<grid, block>>>(*gpu_xt_data, *gpu_x_data,
                  *gpu_dv16_data, x_size_idx_1 - 1, *gpu_fx_data);
              }

              b_fx_data_outdatedOnCpu = true;
              cpu_r = 0.0;
              ix = -1;
              for (k = 0; k < nsubs; k++) {
                fc = 0.0;
                b_cpu_r = 0.0;
                for (itime = 0; itime < 15; itime++) {
                  if (b_fx_data_outdatedOnCpu) {
                    checkCudaError(cudaMemcpy(SD->f0.cpu_fx_data, *gpu_fx_data,
                      77880UL, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                  }

                  fc += dv5[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                  b_fx_data_outdatedOnCpu = false;
                  b_cpu_r += dv6[itime] * SD->f0.cpu_fx_data[(ix + itime) + 1];
                }

                ix += 15;
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                halfh = (cpu_subs[(k << 1) + 1] - cpu_subs[k << 1]) / 2.0;
                fc *= halfh;
                qsub[k] = fc;
                cpu_r += fc;
                errsub[k] = b_cpu_r * halfh;
              }

              intFsq = cpu_r + q_ok;
              tol = std::fmax(1.0E-10, 1.0E-6 * std::abs(intFsq));
              tau = 2.0 * tol;
              cpu_r = 0.0;
              cpu_nrefine = 0;
              for (k = 0; k < nsubs; k++) {
                fc = errsub[k];
                b_cpu_r = std::abs(fc);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                    cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                }

                interval_outdatedOnGpu = false;
                if (b_cpu_r <= tau * ((cpu_subs[(k << 1) + 1] - cpu_subs[k << 1])
                                      / 2.0)) {
                  err_ok += fc;
                  q_ok += qsub[k];
                } else {
                  cpu_r += b_cpu_r;
                  cpu_nrefine++;
                  cpu_subs[(cpu_nrefine - 1) << 1] = cpu_subs[k << 1];
                  cpu_subs[((cpu_nrefine - 1) << 1) + 1] = cpu_subs[(k << 1) + 1];
                }
              }

              cpu_r += std::abs(err_ok);
              if ((!std::isinf(intFsq)) && (!std::isnan(intFsq)) && ((!std::
                    isinf(cpu_r)) && (!std::isnan(cpu_r))) && (cpu_nrefine != 0)
                  && (!(cpu_r <= tol))) {
                nsubs = cpu_nrefine << 1;
                if (nsubs > 650) {
                  exitg1 = 1;
                } else {
                  for (k = 0; k < cpu_nrefine; k++) {
                    if (interval_outdatedOnGpu) {
                      checkCudaError(cudaMemcpy(cpu_subs, *gpu_subs, 10384UL,
                        cudaMemcpyDeviceToHost), __FILE__, __LINE__);
                    }

                    cpu_subs[((((cpu_nrefine - k) << 1) - 1) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) - 1) << 1) + 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1] = (cpu_subs
                      [((cpu_nrefine - k) - 1) << 1] + cpu_subs[(((cpu_nrefine -
                      k) - 1) << 1) + 1]) / 2.0;
                    cpu_subs[((((cpu_nrefine - k) << 1) - 2) << 1) + 1] =
                      cpu_subs[(((cpu_nrefine - k) << 1) - 1) << 1];
                    cpu_subs[(((cpu_nrefine - k) << 1) - 2) << 1] = cpu_subs
                      [((cpu_nrefine - k) - 1) << 1];
                    interval_outdatedOnGpu = false;
                  }
                }
              } else {
                exitg1 = 1;
              }
            }
          } while (exitg1 == 0);
        }

        cpu_r = std::sqrt(3.5421952306087032 * (intDsq / intFsq));
      }
    } else if (cpu_wav[0] == 'a') {
      a = 6.0;
      cpu_r = 1.4142135623730951;
    } else {
      a = 5.0;
      cpu_r = 5.847705;
    }

    q_ok = static_cast<real_T>(cpu_x->size[0]) / (cpu_r * 2.0);
    first_iteration = false;
    cpu_nrefine = 0;
    do {
      exitg1 = 0;
      if (cpu_nrefine + 1 < 6) {
        if (fx_data_outdatedOnCpu) {
          checkCudaError(cudaMemcpy(cpu_wname, *gpu_wname, 5UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
        }

        fx_data_outdatedOnCpu = false;
        if (cv3[cpu_nrefine] != cpu_wname[cpu_nrefine]) {
          exitg1 = 1;
        } else {
          cpu_nrefine++;
        }
      } else {
        first_iteration = true;
        exitg1 = 1;
      }
    } while (exitg1 == 0);

    if (first_iteration) {
      itime = 0;
    } else {
      itime = -1;
    }

    if (itime == 0) {
      b_cpu_r = 2.0 * (static_cast<real_T>(fb_CutOff) / 100.0);
      if (b_cpu_r - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::exp
          (-rt_powd_snf(a, 3.0)) >= 0.0) {
        if (b_cpu_r == b_cpu_r - 0.0050536085896138528 * rt_powd_snf(a, 20.0) *
            std::exp(-rt_powd_snf(a, 3.0))) {
          omegac = 9.0856029641606977;
        } else {
          omegac = a;
        }
      } else {
        omegac = 9.0856029641606977;
        cpu_r = b_cpu_r - 0.0050536085896138528 * rt_powd_snf(a, 20.0) * std::
          exp(-rt_powd_snf(a, 3.0));
        halfh = b_cpu_r;
        if (cpu_r == 0.0) {
          omegac = a;
        } else {
          fc = b_cpu_r;
          tol = 9.0856029641606977;
          tau = 0.0;
          d = 0.0;
          exitg2 = false;
          while ((!exitg2) && ((halfh != 0.0) && (a != omegac))) {
            if ((halfh > 0.0) == (fc > 0.0)) {
              tol = a;
              fc = cpu_r;
              d = omegac - a;
              tau = d;
            }

            if (std::abs(fc) < std::abs(halfh)) {
              a = omegac;
              omegac = tol;
              tol = a;
              cpu_r = halfh;
              halfh = fc;
              fc = cpu_r;
            }

            intFsq = 0.5 * (tol - omegac);
            intDsq = 4.4408920985006262E-16 * std::fmax(std::abs(omegac), 1.0);
            if ((std::abs(intFsq) <= intDsq) || (halfh == 0.0)) {
              exitg2 = true;
            } else {
              if ((std::abs(tau) < intDsq) || (std::abs(cpu_r) <= std::abs(halfh)))
              {
                d = intFsq;
                tau = intFsq;
              } else {
                s = halfh / cpu_r;
                if (a == tol) {
                  cpu_r = 2.0 * intFsq * s;
                  err_ok = 1.0 - s;
                } else {
                  err_ok = cpu_r / fc;
                  r = halfh / fc;
                  cpu_r = s * (2.0 * intFsq * err_ok * (err_ok - r) - (omegac -
                    a) * (r - 1.0));
                  err_ok = (err_ok - 1.0) * (r - 1.0) * (s - 1.0);
                }

                if (cpu_r > 0.0) {
                  err_ok = -err_ok;
                } else {
                  cpu_r = -cpu_r;
                }

                if ((2.0 * cpu_r < 3.0 * intFsq * err_ok - std::abs(intDsq *
                      err_ok)) && (cpu_r < std::abs(0.5 * tau * err_ok))) {
                  tau = d;
                  d = cpu_r / err_ok;
                } else {
                  d = intFsq;
                  tau = intFsq;
                }
              }

              a = omegac;
              cpu_r = halfh;
              if (std::abs(d) > intDsq) {
                omegac += d;
              } else if (omegac > tol) {
                omegac -= intDsq;
              } else {
                omegac += intDsq;
              }

              halfh = b_cpu_r - 0.0050536085896138528 * rt_powd_snf(omegac, 20.0)
                * std::exp(-rt_powd_snf(omegac, 3.0));
            }
          }
        }
      }
    }

    halfh = omegac / 3.1415926535897931;
    if (q_ok < halfh * rt_powd_snf(2.0, 1.0 / fOctave)) {
      q_ok = halfh * rt_powd_snf(2.0, 1.0 / fOctave);
    }

    s = q_ok / halfh;
    if (s == 0.0) {
      s = rtMinusInf;
    } else if (s < 0.0) {
      s = rtNaN;
    } else if ((!std::isinf(s)) && (!std::isnan(s))) {
      s = std::frexp(s, &nx);
      if (s == 0.5) {
        s = static_cast<real_T>(nx) - 1.0;
      } else if ((nx == 1) && (s < 0.75)) {
        s = std::log(2.0 * s) / 0.69314718055994529;
      } else {
        s = std::log(s) / 0.69314718055994529 + static_cast<real_T>(nx);
      }
    }

    emxInit_real_T(&c_cpu_y, 2, &md_emlrtRTEI, true);
    q_ok = std::fmax(s, 1.0 / fOctave) * fOctave;
    if (std::isnan(q_ok)) {
      eint = c_cpu_y->size[0] * c_cpu_y->size[1];
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = 1;
      emxEnsureCapacity_real_T(c_cpu_y, eint, &d_emlrtRTEI);
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &ld_gpu_y, true);
      b_y_needsGpuEnsureCapacity = false;
      ec_cwt_kernel600<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ld_gpu_y);
    } else if (q_ok < 0.0) {
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = 0;
    } else {
      eint = c_cpu_y->size[0] * c_cpu_y->size[1];
      c_cpu_y->size[0] = 1;
      c_cpu_y->size[1] = static_cast<int32_T>(q_ok) + 1;
      emxEnsureCapacity_real_T(c_cpu_y, eint, &d_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(q_ok)), &grid,
        &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &ld_gpu_y, true);
      b_y_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel603<<<grid, block>>>(static_cast<int32_T>(q_ok), ld_gpu_y);
      }
    }

    emxInit_real_T(&d_cpu_y, 2, &nd_emlrtRTEI, true);
    eint = d_cpu_y->size[0] * d_cpu_y->size[1];
    d_cpu_y->size[0] = 1;
    d_cpu_y->size[1] = c_cpu_y->size[1];
    emxEnsureCapacity_real_T(d_cpu_y, eint, &e_emlrtRTEI);
    ix = c_cpu_y->size[1];
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    if (b_y_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(c_cpu_y, &ld_gpu_y, true);
    }

    gpuEmxEnsureCapacity_real_T(d_cpu_y, &md_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel601<<<grid, block>>>(ld_gpu_y, rt_powd_snf(2.0, 1.0 / fOctave),
        ix - 1, md_gpu_y);
    }

    emxFree_real_T(&c_cpu_y);
    eint = cpu_fb_Scales->size[0] * cpu_fb_Scales->size[1];
    cpu_fb_Scales->size[0] = 1;
    cpu_fb_Scales->size[1] = d_cpu_y->size[1];
    emxEnsureCapacity_real_T(cpu_fb_Scales, eint, &f_emlrtRTEI);
    itime = d_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    c_omega_tmp1_needsGpuEnsureCapa = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel602<<<grid, block>>>(md_gpu_y, halfh, itime, gpu_fb_Scales);
    }

    x_data_outdatedOnGpu = true;
    emxFree_real_T(&d_cpu_y);
  }

  first_iteration = false;
  cpu_nrefine = 0;
  do {
    exitg1 = 0;
    if (cpu_nrefine + 1 < 6) {
      if (cpu_cv[static_cast<int32_T>(c_b[cpu_nrefine])] != cpu_cv
          [static_cast<int32_T>(cv2[cpu_nrefine])]) {
        exitg1 = 1;
      } else {
        cpu_nrefine++;
      }
    } else {
      first_iteration = true;
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  emxInit_real_T(&cpu_daughter, 2, &p_emlrtRTEI, true);
  emxInit_real_T(&cpu_f, 2, &od_emlrtRTEI, true);
  if (first_iteration) {
    emxInit_real_T(&b_cpu_somega, 2, &id_emlrtRTEI, true);
    if (cpu_fb_Scales->size[1] == 1) {
      a_data_outdatedOnGpu = false;
      fx_data_outdatedOnCpu = false;
      eint = b_cpu_somega->size[0] * b_cpu_somega->size[1];
      b_cpu_somega->size[0] = 1;
      if (cpu_fb_Omega->size[1] == 1) {
        b_cpu_somega->size[1] = 1;
      } else {
        b_cpu_somega->size[1] = cpu_fb_Omega->size[1];
      }

      emxEnsureCapacity_real_T(b_cpu_somega, eint, &h_emlrtRTEI);
      interval_outdatedOnGpu = true;
      lidx = (cpu_fb_Omega->size[1] != 1);
      cpu_nrefine = b_cpu_somega->size[1] - 1;
      for (k = 0; k <= cpu_nrefine; k++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Scales, &gpu_fb_Scales);
        }

        x_data_outdatedOnGpu = false;
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Omega, &gpu_fb_Omega);
        }

        wav_outdatedOnCpu = false;
        b_cpu_somega->data[k] = cpu_fb_Scales->data[0] * cpu_fb_Omega->data[lidx
          * k];
        fx_data_outdatedOnCpu = true;
        c_omega_tmp1_needsGpuEnsureCapa = true;
      }
    } else {
      eint = b_cpu_somega->size[0] * b_cpu_somega->size[1];
      b_cpu_somega->size[0] = cpu_fb_Scales->size[1];
      b_cpu_somega->size[1] = cpu_fb_Omega->size[1];
      emxEnsureCapacity_real_T(b_cpu_somega, eint, &i_emlrtRTEI);
      dim = cpu_fb_Omega->size[1];
      b_nx = cpu_fb_Scales->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(dim - 1, b_nx), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_somega, &gpu_somega, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel583<<<grid, block>>>(gpu_fb_Omega, gpu_fb_Scales, b_nx, dim
          - 1, gpu_somega, b_cpu_somega->size[0U]);
      }

      fx_data_outdatedOnCpu = false;
      a_data_outdatedOnGpu = true;
    }

    ix = b_cpu_somega->size[0] * b_cpu_somega->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(b_cpu_somega->size[itime]);
    }

    emxInit_real_T(&cpu_absomega, 2, &kd_emlrtRTEI, true);
    eint = cpu_absomega->size[0] * cpu_absomega->size[1];
    cpu_absomega->size[0] = static_cast<int32_T>(xSize[0]);
    cpu_absomega->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real_T(cpu_absomega, eint, &k_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_real_T(b_cpu_somega, &gpu_somega,
        !fx_data_outdatedOnCpu);
    }

    gpuEmxEnsureCapacity_real_T(cpu_absomega, &gpu_absomega, true);
    if (fx_data_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_somega, b_cpu_somega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel16<<<grid, block>>>(gpu_somega, ix - 1, gpu_absomega);
    }

    emxInit_real_T(&cpu_powscales, 2, &m_emlrtRTEI, true);
    eint = cpu_powscales->size[0] * cpu_powscales->size[1];
    cpu_powscales->size[0] = cpu_absomega->size[0];
    cpu_powscales->size[1] = cpu_absomega->size[1];
    emxEnsureCapacity_real_T(cpu_powscales, eint, &m_emlrtRTEI);
    b_nx = cpu_absomega->size[0] * cpu_absomega->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_powscales, &gpu_powscales, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel17<<<grid, block>>>(gpu_absomega, b_nx, gpu_powscales);
    }

    ix = cpu_absomega->size[0] * cpu_absomega->size[1];
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel18<<<grid, block>>>(ix - 1, gpu_absomega);
    }

    emxInit_real_T(&b_cpu_x, 2, &n_emlrtRTEI, true);
    if ((cpu_absomega->size[0] == cpu_powscales->size[0]) && (cpu_absomega->
         size[1] == cpu_powscales->size[1])) {
      eint = b_cpu_x->size[0] * b_cpu_x->size[1];
      b_cpu_x->size[0] = cpu_absomega->size[0];
      b_cpu_x->size[1] = cpu_absomega->size[1];
      emxEnsureCapacity_real_T(b_cpu_x, eint, &n_emlrtRTEI);
      b_nx = cpu_absomega->size[0] * cpu_absomega->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_x, &gpu_x, true);
      x_data_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel19<<<grid, block>>>(gpu_powscales, gpu_absomega, b_nx,
          gpu_x);
      }

      fx_data_outdatedOnCpu = false;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(cpu_absomega, &gpu_absomega);
      gpuEmxMemcpyGpuToCpu_real_T(cpu_powscales, &gpu_powscales);
      binary_expand_op_3(b_cpu_x, cpu_absomega, cpu_powscales);
      fx_data_outdatedOnCpu = true;
      x_data_outdatedOnGpu = true;
    }

    emxFree_real_T(&cpu_powscales);
    emxFree_real_T(&cpu_absomega);
    ix = b_cpu_x->size[0] * b_cpu_x->size[1];
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    if (x_data_outdatedOnGpu) {
      gpuEmxEnsureCapacity_real_T(b_cpu_x, &gpu_x, !fx_data_outdatedOnCpu);
    }

    if (fx_data_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_x, b_cpu_x);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel20<<<grid, block>>>(ix - 1, gpu_x);
    }

    if ((b_cpu_x->size[0] == b_cpu_somega->size[0]) && (b_cpu_x->size[1] ==
         b_cpu_somega->size[1])) {
      eint = cpu_daughter->size[0] * cpu_daughter->size[1];
      cpu_daughter->size[0] = b_cpu_x->size[0];
      cpu_daughter->size[1] = b_cpu_x->size[1];
      emxEnsureCapacity_real_T(cpu_daughter, eint, &o_emlrtRTEI);
      b_nx = b_cpu_x->size[0] * b_cpu_x->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
      daughter_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel21<<<grid, block>>>(gpu_somega, gpu_x, b_nx, gpu_daughter);
      }

      daughter_outdatedOnGpu = false;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(b_cpu_x, &gpu_x);
      if (a_data_outdatedOnGpu) {
        gpuEmxMemcpyGpuToCpu_real_T(b_cpu_somega, &gpu_somega);
      }

      binary_expand_op_2(cpu_daughter, b_cpu_x, b_cpu_somega);
      daughter_outdatedOnGpu = true;
      daughter_needsGpuEnsureCapacity = true;
    }

    emxFree_real_T(&b_cpu_x);
    emxFree_real_T(&b_cpu_somega);
    eint = cpu_f->size[0] * cpu_f->size[1];
    cpu_f->size[0] = 1;
    cpu_f->size[1] = cpu_fb_Scales->size[1];
    emxEnsureCapacity_real_T(cpu_f, eint, &q_emlrtRTEI);
    b_nx = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    if (c_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    }

    gpuEmxEnsureCapacity_real_T(cpu_f, &gpu_f, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel22<<<grid, block>>>(gpu_fb_Scales, b_nx, gpu_f);
    }
  } else {
    emxInit_real_T(&cpu_somega, 2, &hd_emlrtRTEI, true);
    if (cpu_fb_Scales->size[1] == 1) {
      fx_data_outdatedOnCpu = false;
      eint = cpu_somega->size[0] * cpu_somega->size[1];
      cpu_somega->size[0] = 1;
      if (cpu_fb_Omega->size[1] == 1) {
        cpu_somega->size[1] = 1;
      } else {
        cpu_somega->size[1] = cpu_fb_Omega->size[1];
      }

      emxEnsureCapacity_real_T(cpu_somega, eint, &h_emlrtRTEI);
      interval_outdatedOnGpu = true;
      lidx = (cpu_fb_Omega->size[1] != 1);
      cpu_nrefine = cpu_somega->size[1] - 1;
      for (k = 0; k <= cpu_nrefine; k++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Scales, &gpu_fb_Scales);
        }

        x_data_outdatedOnGpu = false;
        if (wav_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_fb_Omega, &gpu_fb_Omega);
        }

        wav_outdatedOnCpu = false;
        cpu_somega->data[k] = cpu_fb_Scales->data[0] * cpu_fb_Omega->data[lidx *
          k];
        fx_data_outdatedOnCpu = true;
        c_omega_tmp1_needsGpuEnsureCapa = true;
      }
    } else {
      eint = cpu_somega->size[0] * cpu_somega->size[1];
      cpu_somega->size[0] = cpu_fb_Scales->size[1];
      cpu_somega->size[1] = cpu_fb_Omega->size[1];
      emxEnsureCapacity_real_T(cpu_somega, eint, &g_emlrtRTEI);
      dim = cpu_fb_Omega->size[1];
      b_nx = cpu_fb_Scales->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(dim - 1, b_nx), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_somega, &b_gpu_somega, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel591<<<grid, block>>>(gpu_fb_Omega, gpu_fb_Scales, b_nx, dim
          - 1, b_gpu_somega, cpu_somega->size[0U]);
      }

      fx_data_outdatedOnCpu = false;
    }

    emxInit_real_T(&cpu_w, 2, &j_emlrtRTEI, true);
    eint = cpu_w->size[0] * cpu_w->size[1];
    cpu_w->size[0] = cpu_somega->size[0];
    cpu_w->size[1] = cpu_somega->size[1];
    emxEnsureCapacity_real_T(cpu_w, eint, &j_emlrtRTEI);
    b_nx = cpu_somega->size[0] * cpu_somega->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_real_T(cpu_somega, &b_gpu_somega,
        !fx_data_outdatedOnCpu);
    }

    gpuEmxEnsureCapacity_real_T(cpu_w, &db_gpu_w, true);
    if (fx_data_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_somega, cpu_somega);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel584<<<grid, block>>>(b_gpu_somega, b_nx, db_gpu_w);
    }

    emxFree_real_T(&cpu_somega);
    emxInit_real_T(&cpu_expnt, 2, &jd_emlrtRTEI, true);
    eint = cpu_expnt->size[0] * cpu_expnt->size[1];
    cpu_expnt->size[0] = cpu_w->size[0];
    cpu_expnt->size[1] = cpu_w->size[1];
    emxEnsureCapacity_real_T(cpu_expnt, eint, &l_emlrtRTEI);
    b_nx = cpu_w->size[0] * cpu_w->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_expnt, &gpu_expnt, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel585<<<grid, block>>>(db_gpu_w, b_nx, gpu_expnt);
    }

    ix = cpu_expnt->size[0] * cpu_expnt->size[1];
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel586<<<grid, block>>>(ix - 1, gpu_expnt);
    }

    ix = cpu_w->size[0] * cpu_w->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_w->size[itime]);
    }

    emxInit_real_T(&e_cpu_y, 2, &ld_emlrtRTEI, true);
    eint = e_cpu_y->size[0] * e_cpu_y->size[1];
    e_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    e_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real_T(e_cpu_y, eint, &k_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    gpuEmxEnsureCapacity_real_T(e_cpu_y, &kd_gpu_y, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel587<<<grid, block>>>(db_gpu_w, ix - 1, kd_gpu_y);
    }

    emxFree_real_T(&cpu_w);
    if ((cpu_expnt->size[0] == e_cpu_y->size[0]) && (cpu_expnt->size[1] ==
         e_cpu_y->size[1])) {
      eint = cpu_daughter->size[0] * cpu_daughter->size[1];
      cpu_daughter->size[0] = cpu_expnt->size[0];
      cpu_daughter->size[1] = cpu_expnt->size[1];
      emxEnsureCapacity_real_T(cpu_daughter, eint, &p_emlrtRTEI);
      b_nx = cpu_expnt->size[0] * cpu_expnt->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter, true);
      daughter_needsGpuEnsureCapacity = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel588<<<grid, block>>>(kd_gpu_y, gpu_expnt, b_nx,
          gpu_daughter);
      }

      daughter_outdatedOnGpu = false;
    } else {
      gpuEmxMemcpyGpuToCpu_real_T(cpu_expnt, &gpu_expnt);
      gpuEmxMemcpyGpuToCpu_real_T(e_cpu_y, &kd_gpu_y);
      binary_expand_op_4(cpu_daughter, cpu_expnt, e_cpu_y);
      daughter_outdatedOnGpu = true;
      daughter_needsGpuEnsureCapacity = true;
    }

    emxFree_real_T(&e_cpu_y);
    emxFree_real_T(&cpu_expnt);
    cpu_nrefine = cpu_daughter->size[0] * cpu_daughter->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(cpu_nrefine), &grid, &block,
      2147483647U);
    if (daughter_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter,
        !daughter_outdatedOnGpu);
    }

    daughter_needsGpuEnsureCapacity = false;
    if (daughter_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&gpu_daughter, cpu_daughter);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel589<<<grid, block>>>(cpu_nrefine, gpu_daughter);
    }

    daughter_outdatedOnGpu = false;
    eint = cpu_f->size[0] * cpu_f->size[1];
    cpu_f->size[0] = 1;
    cpu_f->size[1] = cpu_fb_Scales->size[1];
    emxEnsureCapacity_real_T(cpu_f, eint, &s_emlrtRTEI);
    b_nx = cpu_fb_Scales->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    if (c_omega_tmp1_needsGpuEnsureCapa) {
      gpuEmxEnsureCapacity_real_T(cpu_fb_Scales, &gpu_fb_Scales, true);
    }

    gpuEmxEnsureCapacity_real_T(cpu_f, &gpu_f, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel590<<<grid, block>>>(gpu_fb_Scales, b_nx, gpu_f);
    }
  }

  emxFree_real_T(&cpu_fb_Omega);
  emxFree_real_T(&cpu_fb_Scales);
  eint = cpu_f->size[0] * cpu_f->size[1];
  cpu_f->size[0] = 1;
  emxEnsureCapacity_real_T(cpu_f, eint, &r_emlrtRTEI);
  eint = cpu_f->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(eint), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real_T(cpu_f, &gpu_f, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_cwt_kernel23<<<grid, block>>>(fs, eint, gpu_f);
  }

  // 'ec_cwt:25' freqs = centerFrequencies(fb);
  eint = cpu_freqs->size[0];
  cpu_freqs->size[0] = cpu_f->size[1];
  emxEnsureCapacity_real_T(cpu_freqs, eint, &t_emlrtRTEI);
  b_nx = cpu_f->size[1] - 1;
  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
  gpuEmxEnsureCapacity_real_T(cpu_freqs, &gpu_freqs, true);
  validLaunchParams = mwValidateLaunchParameters(grid, block);
  if (validLaunchParams) {
    ec_cwt_kernel24<<<grid, block>>>(gpu_f, b_nx, gpu_freqs);
  }

  emxFree_real_T(&cpu_f);

  //  nFreqs = uint32(numel(freqs));
  //  nFrames = uint32(numel(1:ds:nFrames));
  //  Preallocate
  // 'ec_cwt:30' tmp = cell(1,nChs);
  eint = y_size[0] * y_size[1];
  y_size[0] = 1;
  y_size[1] = cpu_x->size[1];
  emxEnsureCapacity_cell_wrap_0(y_data, y_size, eint, &u_emlrtRTEI);

  // 'ec_cwt:31' y = coder.nullcopy(tmp);
  //  y = coder.nullcopy(zeros([nFrames nChs nFreqs],like=x)); % Preallocate output
  //  Channel loop
  // 'ec_cwt:35' for ch = 1:nChs
  x_size_idx_1 = cpu_x->size[1];
  emxInit_creal_T(&cpu_cfspos, 2, &bb_emlrtRTEI, true);
  if (cpu_x->size[1] - 1 >= 0) {
    csz_idx_0 = cpu_daughter->size[0];
  }

  emxInit_real_T(&cpu_xv, 2, &v_emlrtRTEI, true);
  emxInit_creal_T(&cpu_xposdft, 2, &w_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_x, 2, &y_emlrtRTEI, true);
  emxInit_creal_T(&cpu_cfsposdft, 2, &pd_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_y, 2, &qd_emlrtRTEI, true);
  emxInit_real_T(&cpu_xCh, 2, &db_emlrtRTEI, true);
  emxInit_real_T(&cpu_opts_filter, 1, &fb_emlrtRTEI, true);
  emxInit_real_T(&cpu_opts_x, 2, &fb_emlrtRTEI, true);
  emxInit_real_T(&cpu_dv18, 1, &rd_emlrtRTEI, true);
  emxInit_real_T(&cpu_h1, 1, &kb_emlrtRTEI, true);
  emxInit_real_T(&cpu_h, 2, &u_emlrtRTEI, true);
  emxInit_real_T(&cpu_m, 2, &jb_emlrtRTEI, true);
  emxInit_real_T(&cpu_k, 1, &lb_emlrtRTEI, true);
  emxInit_real_T(&cpu_G, 2, &sd_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc1A, 2, &td_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc2A, 2, &ud_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_h, 1, &qb_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc3A, 2, &vd_emlrtRTEI, true);
  emxInit_uint32_T(&g_cpu_y, 2, &wd_emlrtRTEI, true);
  emxInit_real_T(&cpu_sinc4A, 2, &xd_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv6, 2, &yd_emlrtRTEI, true);
  emxInit_real_T(&cpu_b, 1, &sb_emlrtRTEI, true);
  emxInit_real_T(&cpu_y1, 2, &ae_emlrtRTEI, true);
  emxInit_real_T(&cpu_a, 1, &u_emlrtRTEI, true);
  emxInit_real_T(&cpu_dv20, 1, &be_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_x, 1, &ce_emlrtRTEI, true);
  emxInit_int32_T(&cpu_jpvt, 2, &u_emlrtRTEI, true);
  emxInit_real_T(&cpu_dv21, 1, &be_emlrtRTEI, true);
  emxInit_real_T(&cpu_xCol, 2, &ic_emlrtRTEI, true);
  emxInit_real_T(&cpu_tau, 1, &u_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_y, 1, &de_emlrtRTEI, true);
  emxInit_ptrdiff_t(&jpvt_t, 1, &mc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_IPIV, 1, &ee_emlrtRTEI, true);
  emxInit_real_T(&cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_y, 1, &ge_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_yCol, 1, &fe_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_w, 1, &rc_emlrtRTEI, true);
  emxInit_real_T(&k_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&l_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_x, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&k_cpu_w, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_y, 1, &rc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_c, 1, &he_emlrtRTEI, true);
  emxInit_int32_T(&k_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&l_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_a, 1, &tc_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_y, 2, &ie_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&k_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&l_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv29, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv30, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&n_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&g_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&h_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&o_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&i_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&j_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&p_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&k_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&q_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&n_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_int32_T(&cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&r_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&s_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&l_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&t_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&n_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&o_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&u_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&o_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&p_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&q_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&v_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&p_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_int32_T(&w_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&x_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_int32_T(&y_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&b_cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_real_T(&r_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ab_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&bb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&cb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&db_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&eb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv31, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv32, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&s_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&t_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&fb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&c_cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_real_T(&q_cpu_c, 1, &je_emlrtRTEI, true);
  emxInit_real_T(&d_cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_real_T(&e_cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_int32_T(&gb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&hb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&ib_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv33, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&u_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&v_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&jb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv34, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&w_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&x_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&kb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv35, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv36, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv37, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&lb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv38, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv39, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&mb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&nb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ob_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&pb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&qb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&f_cpu_result, 1, &rc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv40, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv41, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&rb_cpu_y, 2, &ie_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv42, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&sb_cpu_y, 2, &ie_emlrtRTEI, true);
  emxInit_real_T(&tb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv43, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&y_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&ab_cpu_expanded, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv44, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv45, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv46, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ub_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&vb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&wb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&xb_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&yb_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&ac_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_real_T(&bc_cpu_y, 2, &ie_emlrtRTEI, true);
  emxInit_int32_T(&cc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv49, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&d_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv50, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&dc_cpu_y, 2, &ke_emlrtRTEI, true);
  emxInit_real_T(&bb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&cb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv51, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&ec_cpu_y, 2, &ke_emlrtRTEI, true);
  emxInit_real_T(&db_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&eb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv52, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&fc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&gc_cpu_y, 2, &rc_emlrtRTEI, true);
  emxInit_int32_T(&hc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv53, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ic_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv54, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&e_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&f_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&jc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv56, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&g_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&kc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv57, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&fb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&gb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&hb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&ib_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&jb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&kb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&lc_cpu_y, 2, &ke_emlrtRTEI, true);
  emxInit_int32_T(&mc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv58, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&nc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&lb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&mb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&oc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&nb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&ob_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&pc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv59, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv60, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&qc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv61, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&rc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&h_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&sc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv62, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&tc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&i_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&j_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&uc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&vc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&pb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&qb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&rb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&sb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&tb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&ub_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv63, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&k_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&vb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&wb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv64, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&b_cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&l_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&wc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&xc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&m_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&yc_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&n_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv65, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ad_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&o_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv66, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&bd_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv67, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cd_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&dd_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ed_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv68, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&c_cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv69, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&d_cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&p_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv71, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&e_cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&q_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&xb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_real_T(&yb_cpu_expanded, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv73, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&r_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv74, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv75, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&s_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv76, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv77, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&t_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&fd_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&u_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv78, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv79, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&gd_cpu_y, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&v_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&w_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&x_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&y_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ab_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv80, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&f_cpu_cols, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv81, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&bb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv83, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&db_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv84, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&eb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&fb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv85, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv86, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv87, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&gb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv89, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&hb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ib_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&jb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&kb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&lb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&mb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv93, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&nb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&ob_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&pb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&qb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&cpu_iv94, 1, &xc_emlrtRTEI, true);
  emxInit_int32_T(&rb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_int32_T(&sb_cpu_rows, 2, &xc_emlrtRTEI, true);
  emxInit_real_T(&cpu_b0, 1, &vb_emlrtRTEI, true);
  emxInit_real_T(&l_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&m_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&n_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&o_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&p_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&q_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&r_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&s_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&t_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&u_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&v_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&hd_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&w_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&x_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&id_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&jd_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&kd_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&ld_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&y_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&ab_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&bb_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&cb_cpu_w, 2, &bd_emlrtRTEI, true);
  emxInit_real_T(&md_cpu_y, 2, &cd_emlrtRTEI, true);
  emxInit_real_T(&db_cpu_w, 2, &bd_emlrtRTEI, true);
  for (int32_T y_size_idx_1{0}; y_size_idx_1 < x_size_idx_1; y_size_idx_1++) {
    //  CWT
    // 'ec_cwt:37' xCh = abs(wt(fb,x(:,ch)))';
    eint = cpu_xv->size[0] * cpu_xv->size[1];
    cpu_xv->size[0] = 1;
    cpu_xv->size[1] = cpu_x->size[0];
    emxEnsureCapacity_real_T(cpu_xv, eint, &v_emlrtRTEI);
    b_nx = cpu_x->size[0] - 1;
    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
    if (x_needsGpuEnsureCapacity) {
      gpuEmxEnsureCapacity_real_T(cpu_x, &b_gpu_x, !x_outdatedOnGpu);
    }

    x_needsGpuEnsureCapacity = false;
    gpuEmxEnsureCapacity_real_T(cpu_xv, &gpu_xv, true);
    interval_outdatedOnGpu = false;
    if (x_outdatedOnGpu) {
      gpuEmxMemcpyCpuToGpu_real_T(&b_gpu_x, cpu_x);
    }

    x_outdatedOnGpu = false;
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel25<<<grid, block>>>(y_size_idx_1, b_gpu_x, b_nx, gpu_xv,
        cpu_x->size[0U]);
    }

    fx_data_outdatedOnCpu = false;
    if (fb_SignalPad > 0) {
      nw = cpu_x->size[0] - fb_SignalPad;
      if (nw + 1 > cpu_x->size[0]) {
        lidx = 0;
        ix = 1;
        nw = -1;
      } else {
        lidx = cpu_x->size[0] - 1;
        ix = -1;
      }

      eint = c_cpu_x->size[0] * c_cpu_x->size[1];
      c_cpu_x->size[0] = 1;
      c_cpu_x->size[1] = fb_SignalPad;
      emxEnsureCapacity_real_T(c_cpu_x, eint, &y_emlrtRTEI);
      mwGetLaunchParameters1D(computeNumIters(fb_SignalPad - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(c_cpu_x, &c_gpu_x, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel26<<<grid, block>>>(y_size_idx_1, b_gpu_x, fb_SignalPad - 1,
          c_gpu_x, cpu_x->size[0U]);
      }

      cpu_nrefine = fb_SignalPad >> 1;
      mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel27<<<grid, block>>>(fb_SignalPad, cpu_nrefine - 1, c_gpu_x);
      }

      eint = cpu_xv->size[0] * cpu_xv->size[1];
      cpu_xv->size[0] = 1;
      cpu_xv->size[1] = ((cpu_x->size[0] + c_cpu_x->size[1]) + div_s32(nw - lidx,
        ix)) + 1;
      emxEnsureCapacity_real_T(cpu_xv, eint, &ab_emlrtRTEI);
      dim = c_cpu_x->size[1];
      mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
        2147483647U);
      gpuEmxEnsureCapacity_real_T(cpu_xv, &gpu_xv, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel28<<<grid, block>>>(c_gpu_x, dim - 1, gpu_xv);
      }

      x_data_outdatedOnGpu = true;
      dim = cpu_x->size[0];
      for (eint = 0; eint < dim; eint++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_xv, &gpu_xv);
        }

        cpu_xv->data[eint + c_cpu_x->size[1]] = cpu_x->data[eint + cpu_x->size[0]
          * y_size_idx_1];
        x_data_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = true;
        x_needsGpuEnsureCapacity = true;
        interval_outdatedOnGpu = true;
      }

      dim = div_s32(nw - lidx, ix);
      for (eint = 0; eint <= dim; eint++) {
        if (x_data_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_xv, &gpu_xv);
        }

        cpu_xv->data[(eint + cpu_x->size[0]) + c_cpu_x->size[1]] = cpu_x->data
          [(lidx + ix * eint) + cpu_x->size[0] * y_size_idx_1];
        x_data_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = true;
        x_needsGpuEnsureCapacity = true;
        interval_outdatedOnGpu = true;
      }
    }

    if (cpu_xv->size[1] - (static_cast<int32_T>(static_cast<uint32_T>
          (cpu_xv->size[1]) >> 1) << 1) == 1) {
      cufftHandle fftPlanHandle;
      eint = cpu_xposdft->size[0] * cpu_xposdft->size[1];
      cpu_xposdft->size[0] = 1;
      cpu_xposdft->size[1] = cpu_xv->size[1];
      emxEnsureCapacity_creal_T(cpu_xposdft, eint, &w_emlrtRTEI);
      b_nx = cpu_xv->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_xv, &gpu_xv, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_creal_T(cpu_xposdft, &gpu_xposdft, true);
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_xv, cpu_xv);
      }

      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel29<<<grid, block>>>(gpu_xv, b_nx, gpu_xposdft);
      }

      cpu_nrefine = cpu_xposdft->size[1];
      fftPlanHandle = acquireCUFFTPlan(1, &cpu_nrefine, &cpu_nrefine, 1, 1,
        CUFFT_Z2Z, 1);
      cufftExecZ2Z(fftPlanHandle, (cufftDoubleComplex *)&gpu_xposdft.data[0],
                   (cufftDoubleComplex *)&gpu_xposdft.data[0], CUFFT_FORWARD);
    } else {
      cufftHandle b_fftPlanHandle;
      cpu_nrefine = cpu_xv->size[1];
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_xv->size[itime]);
      }

      eint = cpu_xposdft->size[0] * cpu_xposdft->size[1];
      cpu_xposdft->size[0] = 1;
      cpu_xposdft->size[1] = static_cast<int32_T>(xSize[1]);
      emxEnsureCapacity_creal_T(cpu_xposdft, eint, &x_emlrtRTEI);
      b_fftPlanHandle = acquireCUFFTPlan(1, &cpu_nrefine, &cpu_nrefine, 1, 1,
        CUFFT_D2Z, 1);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_xv, &gpu_xv, !fx_data_outdatedOnCpu);
      }

      gpuEmxEnsureCapacity_creal_T(cpu_xposdft, &gpu_xposdft, true);
      if (fx_data_outdatedOnCpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_xv, cpu_xv);
      }

      cufftExecD2Z(b_fftPlanHandle, (cufftDoubleReal *)&gpu_xv.data[0],
                   (cufftDoubleComplex *)&gpu_xposdft.data[0]);
      cpu_nrefine = static_cast<int32_T>(static_cast<real_T>(static_cast<int32_T>
        (xSize[1]) + 1) / 2.0);
      mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 2), &grid, &block,
        2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel582<<<grid, block>>>(cpu_nrefine - 2, gpu_xposdft, xSize[1]);
      }
    }

    ix = cpu_daughter->size[1];
    nw = cpu_xposdft->size[1];
    if (ix <= nw) {
      nw = ix;
    }

    if (cpu_daughter->size[1] == 1) {
      eint = cpu_xposdft->size[1];
    } else if (cpu_xposdft->size[1] == cpu_daughter->size[1]) {
      eint = cpu_xposdft->size[1];
    } else {
      eint = nw;
    }

    nsubs = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1];
    cpu_cfsposdft->size[0] = csz_idx_0;
    ix = cpu_daughter->size[1];
    nw = cpu_xposdft->size[1];
    if (ix <= nw) {
      nw = ix;
    }

    if (cpu_daughter->size[1] == 1) {
      cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
    } else if (cpu_xposdft->size[1] == cpu_daughter->size[1]) {
      cpu_cfsposdft->size[1] = cpu_xposdft->size[1];
    } else {
      cpu_cfsposdft->size[1] = nw;
    }

    emxEnsureCapacity_creal_T(cpu_cfsposdft, nsubs, &h_emlrtRTEI);
    interval_outdatedOnGpu = true;
    if ((csz_idx_0 != 0) && (eint != 0)) {
      lidx = (cpu_daughter->size[1] != 1);
      itime = cpu_cfsposdft->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(eint - 1, itime), &grid, &block,
        2147483647U);
      if (daughter_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(cpu_daughter, &gpu_daughter,
          !daughter_outdatedOnGpu);
      }

      daughter_needsGpuEnsureCapacity = false;
      gpuEmxEnsureCapacity_creal_T(cpu_cfsposdft, &gpu_cfsposdft, true);
      interval_outdatedOnGpu = false;
      if (daughter_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_daughter, cpu_daughter);
      }

      daughter_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel30<<<grid, block>>>(gpu_xposdft, gpu_daughter, lidx, itime,
          eint - 1, gpu_cfsposdft, cpu_daughter->size[0U], cpu_cfsposdft->size
          [0U]);
      }
    }

    if ((cpu_cfsposdft->size[0] == 0) || (cpu_cfsposdft->size[1] == 0)) {
      for (itime = 0; itime < 2; itime++) {
        xSize[itime] = static_cast<uint32_T>(cpu_cfsposdft->size[itime]);
      }

      xSize[1] = static_cast<uint32_T>(cpu_cfsposdft->size[1]);
      eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[0] = static_cast<int32_T>(xSize[0]);
      cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal_T(cpu_cfspos, eint, &bb_emlrtRTEI);
      b_nx = static_cast<int32_T>(xSize[0]) * static_cast<int32_T>(xSize[1]) - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal_T(cpu_cfspos, &gpu_cfspos, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel31<<<grid, block>>>(b_nx, gpu_cfspos);
      }

      fx_data_outdatedOnCpu = false;
      x_data_outdatedOnGpu = true;
    } else {
      cufftHandle c_fftPlanHandle;
      cpu_nrefine = cpu_cfsposdft->size[1];
      c_fftPlanHandle = acquireCUFFTPlan(1, &cpu_nrefine, &cpu_nrefine,
        cpu_cfsposdft->size[0], 1, CUFFT_Z2Z, cpu_cfsposdft->size[0]);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_creal_T(cpu_cfsposdft, &gpu_cfsposdft, true);
      }

      cufftExecZ2Z(c_fftPlanHandle, (cufftDoubleComplex *)&gpu_cfsposdft.data[0],
                   (cufftDoubleComplex *)&gpu_cfsposdft.data[0], CUFFT_INVERSE);
      eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[0] = cpu_cfsposdft->size[0];
      cpu_cfspos->size[1] = cpu_cfsposdft->size[1];
      emxEnsureCapacity_creal_T(cpu_cfspos, eint, &bb_emlrtRTEI);
      b_nx = cpu_cfsposdft->size[1];
      itime = cpu_cfsposdft->size[0] * cpu_cfsposdft->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_creal_T(cpu_cfspos, &gpu_cfspos, true);
      interval_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel581<<<grid, block>>>(static_cast<real_T>(b_nx),
          gpu_cfsposdft, itime, gpu_cfspos);
      }

      fx_data_outdatedOnCpu = false;
      x_data_outdatedOnGpu = true;
    }

    if (fb_SignalPad > 0) {
      N = static_cast<uint32_T>(fb_SignalPad) + static_cast<uint32_T>
        (cpu_x->size[0]);
      if (static_cast<uint32_T>(fb_SignalPad + 1) > N) {
        cpu_nrefine = 0;
        nw = 0;
      } else {
        cpu_nrefine = fb_SignalPad;
        nw = static_cast<int32_T>(N);
      }

      lidx = cpu_cfspos->size[0];
      dim = nw - cpu_nrefine;
      for (eint = 0; eint < dim; eint++) {
        for (nsubs = 0; nsubs < lidx; nsubs++) {
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyGpuToCpu_creal_T(cpu_cfspos, &gpu_cfspos);
          }

          cpu_cfspos->data[nsubs + lidx * eint] = cpu_cfspos->data[nsubs +
            cpu_cfspos->size[0] * (cpu_nrefine + eint)];
          x_data_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = true;
        }
      }

      eint = cpu_cfspos->size[0] * cpu_cfspos->size[1];
      cpu_cfspos->size[1] = nw - cpu_nrefine;
      emxEnsureCapacity_creal_T(cpu_cfspos, eint, &cb_emlrtRTEI);
      interval_outdatedOnGpu = true;
    }

    ix = cpu_cfspos->size[0] * cpu_cfspos->size[1];
    for (itime = 0; itime < 2; itime++) {
      xSize[itime] = static_cast<uint32_T>(cpu_cfspos->size[itime]);
    }

    eint = f_cpu_y->size[0] * f_cpu_y->size[1];
    f_cpu_y->size[0] = static_cast<int32_T>(xSize[0]);
    f_cpu_y->size[1] = static_cast<int32_T>(xSize[1]);
    emxEnsureCapacity_real_T(f_cpu_y, eint, &k_emlrtRTEI);
    mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block, 2147483647U);
    if (interval_outdatedOnGpu) {
      gpuEmxEnsureCapacity_creal_T(cpu_cfspos, &gpu_cfspos,
        !fx_data_outdatedOnCpu);
    }

    gpuEmxEnsureCapacity_real_T(f_cpu_y, &c_gpu_y, true);
    if (fx_data_outdatedOnCpu) {
      gpuEmxMemcpyCpuToGpu_creal_T(&gpu_cfspos, cpu_cfspos);
    }

    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel32<<<grid, block>>>(gpu_cfspos, ix - 1, c_gpu_y);
    }

    eint = cpu_xCh->size[0] * cpu_xCh->size[1];
    cpu_xCh->size[0] = f_cpu_y->size[1];
    cpu_xCh->size[1] = f_cpu_y->size[0];
    emxEnsureCapacity_real_T(cpu_xCh, eint, &db_emlrtRTEI);
    itime = f_cpu_y->size[0] - 1;
    b_nx = f_cpu_y->size[1] - 1;
    mwGetLaunchParameters1D(computeNumIters(itime, b_nx), &grid, &block,
      2147483647U);
    gpuEmxEnsureCapacity_real_T(cpu_xCh, &gpu_xCh, true);
    validLaunchParams = mwValidateLaunchParameters(grid, block);
    if (validLaunchParams) {
      ec_cwt_kernel33<<<grid, block>>>(c_gpu_y, b_nx, itime, gpu_xCh,
        cpu_xCh->size[0U], f_cpu_y->size[0U]);
    }

    interval_outdatedOnGpu = true;

    //  CWT
    //  Downsample
    // 'ec_cwt:40' if doDownsample
    if (doDownsample) {
      int64_T e;
      real_T varargin_2[4];
      int32_T omega_tmp2[1];
      boolean_T opts_isRowVectorInput;
      boolean_T opts_x_needsGpuEnsureCapacity;
      boolean_T opts_x_outdatedOnCpu;

      // 'ec_cwt:41' y{ch} = resample(xCh,ds(1),ds(2));
      if ((cpu_xCh->size[0] == 1) || (cpu_xCh->size[1] == 1)) {
        nx = 1;
      } else {
        nx = 2;
        if (cpu_xCh->size[0] != 1) {
          nx = 1;
        }
      }

      opts_isRowVectorInput = (cpu_xCh->size[0] == 1);
      if (nx == 1) {
        if ((cpu_xCh->size[0] == 1) || (cpu_xCh->size[1] == 1)) {
          if ((cpu_xCh->size[0] == 0) || (cpu_xCh->size[1] == 0)) {
            nw = 0;
          } else {
            ix = cpu_xCh->size[0];
            nw = cpu_xCh->size[1];
            if (ix >= nw) {
              nw = ix;
            }
          }

          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = nw;
          cpu_opts_x->size[1] = 1;
          emxEnsureCapacity_real_T(cpu_opts_x, eint, &fb_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(nw - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
          opts_x_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel34<<<grid, block>>>(gpu_xCh, nw - 1, gpu_opts_x);
          }

          opts_x_outdatedOnCpu = true;
        } else {
          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = cpu_xCh->size[0];
          cpu_opts_x->size[1] = cpu_xCh->size[1];
          emxEnsureCapacity_real_T(cpu_opts_x, eint, &fb_emlrtRTEI);
          b_nx = cpu_xCh->size[0] * cpu_xCh->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
          opts_x_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel579<<<grid, block>>>(gpu_xCh, b_nx, gpu_opts_x);
          }

          opts_x_outdatedOnCpu = true;
        }
      } else {
        eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
        cpu_opts_x->size[0] = cpu_xCh->size[1];
        cpu_opts_x->size[1] = cpu_xCh->size[0];
        emxEnsureCapacity_real_T(cpu_opts_x, eint, &fb_emlrtRTEI);
        b_nx = cpu_xCh->size[0] - 1;
        itime = cpu_xCh->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(b_nx, itime), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
        opts_x_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel580<<<grid, block>>>(gpu_xCh, itime, b_nx, gpu_opts_x,
            cpu_opts_x->size[0U], cpu_xCh->size[0U]);
        }

        opts_x_outdatedOnCpu = true;
      }

      s = ds[0] / ds[1];
      q_ok = s;
      b_cpu_r = std::abs(s);
      if (std::isinf(b_cpu_r) || std::isnan(b_cpu_r)) {
        r = rtNaN;
      } else if (b_cpu_r < 4.4501477170144028E-308) {
        r = 4.94065645841247E-324;
      } else {
        std::frexp(b_cpu_r, &exponent);
        r = std::ldexp(1.0, exponent - 53);
      }

      tau = std::fmax(1.0E-12, r);
      if (std::isinf(s) || std::isnan(s)) {
        if (!std::isnan(s)) {
          if (s < 0.0) {
            cf = -1.0;
          } else {
            cf = 1.0;
          }
        } else {
          cf = 0.0;
        }

        intFsq = 0.0;
      } else {
        cpu_r = 1.0;
        d = 0.0;
        b_cpu_r = 0.0;
        halfh = 1.0;
        do {
          exitg1 = 0;
          tol = std::round(s);
          if (!std::isinf(s)) {
            s -= tol;
            err_ok = b_cpu_r;
            b_cpu_r = cpu_r;
            cpu_r = cpu_r * tol + err_ok;
            err_ok = halfh;
            halfh = d;
            d = d * tol + err_ok;
          } else {
            b_cpu_r = cpu_r;
            halfh = d;
            cpu_r = s;
            d = 0.0;
          }

          if ((s == 0.0) || (std::abs(cpu_r / d - q_ok) <= tau)) {
            exitg1 = 1;
          } else {
            s = 1.0 / s;
          }
        } while (exitg1 == 0);

        if (std::isnan(d)) {
          omegac = rtNaN;
        } else if (d < 0.0) {
          omegac = -1.0;
        } else {
          omegac = (d > 0.0);
        }

        cf = cpu_r / omegac;
        intFsq = std::abs(d);
      }

      b_cpu_r = std::fmax(cf, intFsq);
      fc = 0.5 / b_cpu_r;
      tau = 20.0 * b_cpu_r + 1.0;
      varargin_2[0] = 0.0;
      varargin_2[1] = 2.0 * fc;
      varargin_2[2] = 2.0 * fc;
      varargin_2[3] = 1.0;
      b_cpu_r = 0.0;
      cpu_r = 0.0;
      Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] > 0.0));
      if (Nodd) {
        b_cpu_r = varargin_2[1];
      }

      Nodd = ((!std::isnan(varargin_2[1])) && (varargin_2[1] < 0.0));
      if (Nodd) {
        cpu_r = varargin_2[1];
      }

      Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(b_cpu_r) || (b_cpu_r <
                varargin_2[2])));
      if (Nodd) {
        b_cpu_r = varargin_2[2];
      }

      Nodd = ((!std::isnan(varargin_2[2])) && (std::isnan(cpu_r) || (cpu_r >
                varargin_2[2])));
      if (Nodd) {
        cpu_r = varargin_2[2];
      }

      Nodd = (std::isnan(b_cpu_r) || (b_cpu_r < 1.0));
      if (Nodd) {
        b_cpu_r = 1.0;
      }

      Nodd = (std::isnan(cpu_r) || (cpu_r > 1.0));
      if (Nodd) {
        cpu_r = 1.0;
      }

      if ((!(b_cpu_r > 1.0)) && (!(cpu_r < 0.0))) {
        real_T F[4];
        boolean_T G_outdatedOnCpu;
        for (itime = 0; itime < 4; itime++) {
          F[itime] = varargin_2[itime] / 2.0;
        }

        halfh = (((tau - 1.0) + 1.0) - 1.0) / 2.0;
        Nodd = (rt_remd_snf((tau - 1.0) + 1.0, 2.0) == 1.0);
        intDsq = 0.0;
        if (!Nodd) {
          eint = cpu_m->size[0] * cpu_m->size[1];
          cpu_m->size[0] = 1;
          cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
          emxEnsureCapacity_real_T(cpu_m, eint, &jb_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel35<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
          }
        } else {
          eint = cpu_m->size[0] * cpu_m->size[1];
          cpu_m->size[0] = 1;
          cpu_m->size[1] = static_cast<int32_T>(halfh) + 1;
          emxEnsureCapacity_real_T(cpu_m, eint, &ib_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh)),
            &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_m, &gpu_m, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel578<<<grid, block>>>(static_cast<int32_T>(halfh), gpu_m);
          }
        }

        eint = cpu_k->size[0];
        cpu_k->size[0] = cpu_m->size[1];
        emxEnsureCapacity_real_T(cpu_k, eint, &lb_emlrtRTEI);
        b_nx = cpu_m->size[1] - 1;
        mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel36<<<grid, block>>>(gpu_m, b_nx, gpu_k);
        }

        x_data_outdatedOnGpu = false;
        a_data_outdatedOnGpu = true;
        first_iteration = (F[2] - F[1] != 0.0);
        lidx = cpu_k->size[0];
        if (first_iteration) {
          eint = cpu_G->size[0] * cpu_G->size[1];
          cpu_G->size[0] = cpu_k->size[0];
          cpu_G->size[1] = cpu_k->size[0];
          emxEnsureCapacity_real_T(cpu_G, eint, &mb_emlrtRTEI);
          k = cpu_k->size[0] * cpu_k->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
          G_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel37<<<grid, block>>>(k, gpu_G);
          }

          G_outdatedOnCpu = true;
          s = 2.0 * static_cast<real_T>(cpu_k->size[0]) - 1.0;
        } else {
          G_outdatedOnCpu = false;
          cpu_G->size[0] = 0;
          cpu_G->size[1] = 0;
          s = 0.0;
        }

        eint = cpu_sinc1A->size[0] * cpu_sinc1A->size[1];
        cpu_sinc1A->size[0] = 1;
        cpu_sinc1A->size[1] = static_cast<int32_T>(s);
        emxEnsureCapacity_real_T(cpu_sinc1A, eint, &nb_emlrtRTEI);
        fx_data_outdatedOnCpu = true;
        eint = cpu_sinc2A->size[0] * cpu_sinc2A->size[1];
        cpu_sinc2A->size[0] = 1;
        cpu_sinc2A->size[1] = static_cast<int32_T>(s);
        emxEnsureCapacity_real_T(cpu_sinc2A, eint, &ob_emlrtRTEI);
        c_omega_tmp1_needsGpuEnsureCapa = true;
        eint = cpu_sinc3A->size[0] * cpu_sinc3A->size[1];
        cpu_sinc3A->size[0] = 1;
        cpu_sinc3A->size[1] = static_cast<int32_T>(s);
        emxEnsureCapacity_real_T(cpu_sinc3A, eint, &pb_emlrtRTEI);
        wav_outdatedOnCpu = true;
        eint = cpu_sinc4A->size[0] * cpu_sinc4A->size[1];
        cpu_sinc4A->size[0] = 1;
        cpu_sinc4A->size[1] = static_cast<int32_T>(s);
        emxEnsureCapacity_real_T(cpu_sinc4A, eint, &rb_emlrtRTEI);
        y_needsGpuEnsureCapacity = true;
        if (Nodd) {
          nsubs = -1;
          if (cpu_k->size[0] < 2) {
            cpu_nrefine = 0;
            nw = 0;
          } else {
            cpu_nrefine = 1;
            nw = cpu_k->size[0];
          }

          dim = nw - cpu_nrefine;
          for (eint = 0; eint < dim; eint++) {
            if (a_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
            }

            cpu_k->data[eint] = cpu_k->data[cpu_nrefine + eint];
            a_data_outdatedOnGpu = false;
            x_data_outdatedOnGpu = true;
          }

          eint = cpu_k->size[0];
          cpu_k->size[0] = nw - cpu_nrefine;
          emxEnsureCapacity_real_T(cpu_k, eint, &ub_emlrtRTEI);
          interval_outdatedOnGpu = true;
        } else {
          nsubs = 0;
        }

        eint = cpu_b->size[0];
        cpu_b->size[0] = cpu_k->size[0];
        emxEnsureCapacity_real_T(cpu_b, eint, &sb_emlrtRTEI);
        k = cpu_k->size[0] - 1;
        mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
        b_y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel38<<<grid, block>>>(k, gpu_b);
        }

        h_needsGpuEnsureCapacity = false;
        b_fx_data_outdatedOnCpu = true;
        for (fb_CutOff = 0; fb_CutOff < 2; fb_CutOff++) {
          nw = fb_CutOff << 1;
          n_idx_0 = A[nw];
          tol = F[nw + 1];
          fc = F[nw];
          cpu_r = static_cast<real_T>(A[nw + 1] - n_idx_0) / (tol - fc);
          b_cpu_r = static_cast<real_T>(n_idx_0) - cpu_r * fc;
          if (Nodd) {
            intDsq += b_cpu_r * (tol - fc) + cpu_r / 2.0 * (tol * tol - fc * fc);
          }

          eint = cpu_dv20->size[0];
          cpu_dv20->size[0] = cpu_k->size[0];
          emxEnsureCapacity_real_T(cpu_dv20, eint, &yb_emlrtRTEI);
          k = cpu_k->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, !x_data_outdatedOnGpu);
          }

          gpuEmxEnsureCapacity_real_T(cpu_dv20, &gpu_dv20, true);
          if (x_data_outdatedOnGpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_k, cpu_k);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel39<<<grid, block>>>(tol, gpu_k, k, gpu_dv20);
          }

          ix = cpu_dv20->size[0];
          eint = cpu_dv21->size[0];
          cpu_dv21->size[0] = cpu_k->size[0];
          emxEnsureCapacity_real_T(cpu_dv21, eint, &yb_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_dv21, &gpu_dv21, true);
          x_data_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel40<<<grid, block>>>(F[nw], gpu_k, ix - 1, gpu_dv21,
              gpu_dv20);
          }

          ix = cpu_dv21->size[0];
          mwGetLaunchParameters1D(computeNumIters(ix - 1), &grid, &block,
            2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel41<<<grid, block>>>(ix - 1, gpu_dv21);
          }

          a = cpu_r / 39.478417604357432;
          if (cpu_dv20->size[0] == 1) {
            itime = cpu_k->size[0];
          } else {
            itime = cpu_dv20->size[0];
          }

          if ((cpu_dv20->size[0] == cpu_k->size[0]) && (cpu_b->size[0] == itime))
          {
            b_nx = cpu_b->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            interval_outdatedOnGpu = false;
            if (b_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
                !h_needsGpuEnsureCapacity);
            }

            b_y_needsGpuEnsureCapacity = false;
            if (h_needsGpuEnsureCapacity) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel42<<<grid, block>>>(gpu_k, gpu_dv21, gpu_dv20, a,
                b_nx, gpu_b);
            }

            h_needsGpuEnsureCapacity = false;
            b_fx_data_outdatedOnCpu = true;
          } else {
            if (b_fx_data_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
            }

            gpuEmxMemcpyGpuToCpu_real_T(cpu_dv20, &gpu_dv20);
            gpuEmxMemcpyGpuToCpu_real_T(cpu_dv21, &gpu_dv21);
            if (a_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_k, &gpu_k);
            }

            a_data_outdatedOnGpu = false;
            binary_expand_op_1(cpu_b, a, cpu_dv20, cpu_dv21, cpu_k);
            b_fx_data_outdatedOnCpu = false;
            h_needsGpuEnsureCapacity = true;
            interval_outdatedOnGpu = true;
            b_y_needsGpuEnsureCapacity = true;
          }

          eint = h_cpu_y->size[0];
          h_cpu_y->size[0] = cpu_k->size[0];
          emxEnsureCapacity_real_T(h_cpu_y, eint, &yb_emlrtRTEI);
          k = cpu_k->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(k), &grid, &block, 2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_k, &gpu_k, true);
          }

          gpuEmxEnsureCapacity_real_T(h_cpu_y, &d_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel43<<<grid, block>>>(F[nw + 1], gpu_k, k, d_gpu_y);
          }

          cpu_nrefine = h_cpu_y->size[0];
          fc = F[nw + 1];
          a = fc * (cpu_r * fc + b_cpu_r);
          eint = i_cpu_y->size[0];
          i_cpu_y->size[0] = cpu_k->size[0];
          emxEnsureCapacity_real_T(i_cpu_y, eint, &yb_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
            &block, 2147483647U);
          interval_outdatedOnGpu = false;
          gpuEmxEnsureCapacity_real_T(i_cpu_y, &e_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel44<<<grid, block>>>(F[nw], gpu_k, cpu_nrefine - 1,
              e_gpu_y, d_gpu_y);
          }

          cpu_nrefine = i_cpu_y->size[0];
          mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
            &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel45<<<grid, block>>>(cpu_nrefine - 1, e_gpu_y);
          }

          fc = F[nw];
          cpu_r = fc * (cpu_r * fc + b_cpu_r);
          if (cpu_b->size[0] == h_cpu_y->size[0]) {
            b_nx = cpu_b->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            if (b_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
                !h_needsGpuEnsureCapacity);
            }

            b_y_needsGpuEnsureCapacity = false;
            if (h_needsGpuEnsureCapacity) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel46<<<grid, block>>>(e_gpu_y, cpu_r, d_gpu_y, a, b_nx,
                gpu_b);
            }

            h_needsGpuEnsureCapacity = false;
            b_fx_data_outdatedOnCpu = true;
          } else {
            if (b_fx_data_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_b, &gpu_b);
            }

            gpuEmxMemcpyGpuToCpu_real_T(h_cpu_y, &d_gpu_y);
            gpuEmxMemcpyGpuToCpu_real_T(i_cpu_y, &e_gpu_y);
            binary_expand_op(cpu_b, a, h_cpu_y, cpu_r, i_cpu_y);
            b_fx_data_outdatedOnCpu = false;
            h_needsGpuEnsureCapacity = true;
            b_y_needsGpuEnsureCapacity = true;
          }

          if (first_iteration) {
            cpu_r = 2.0 * F[nw + 1];
            b_cpu_r = 2.0 * F[nw];
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(s) - 1),
              &grid, &block, 2147483647U);
            if (y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_sinc4A, &gpu_sinc4A, true);
            }

            if (wav_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real_T(cpu_sinc3A, &gpu_sinc3A, true);
            }

            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxEnsureCapacity_real_T(cpu_sinc2A, &gpu_sinc2A, true);
            }

            if (fx_data_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real_T(cpu_sinc1A, &gpu_sinc1A, true);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel47<<<grid, block>>>(b_cpu_r, cpu_r, lidx, nsubs,
                static_cast<int32_T>(s) - 1, gpu_sinc4A, gpu_sinc3A, gpu_sinc2A,
                gpu_sinc1A);
            }

            mwGetLaunchParameters1D(computeNumIters(lidx - 1, lidx - 1), &grid,
              &block, 2147483647U);
            y_needsGpuEnsureCapacity = false;
            c_omega_tmp1_needsGpuEnsureCapa = false;
            wav_outdatedOnCpu = false;
            fx_data_outdatedOnCpu = false;
            if (G_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
            }

            G_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel48<<<grid, block>>>(gpu_sinc4A, gpu_sinc2A, b_cpu_r,
                gpu_sinc3A, gpu_sinc1A, cpu_r, lidx, lidx - 1, lidx - 1, gpu_G,
                cpu_G->size[0U]);
            }

            G_outdatedOnCpu = true;
          }
        }

        if (Nodd) {
          eint = cpu_b0->size[0];
          cpu_b0->size[0] = cpu_b->size[0] + 1;
          emxEnsureCapacity_real_T(cpu_b0, eint, &vb_emlrtRTEI);
          gpuEmxEnsureCapacity_real_T(cpu_b0, &gpu_b0, true);
          ec_cwt_kernel49<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(intDsq,
            gpu_b0);
          dim = cpu_b->size[0];
          mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
            2147483647U);
          if (b_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, !h_needsGpuEnsureCapacity);
          }

          if (h_needsGpuEnsureCapacity) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel50<<<grid, block>>>(gpu_b, dim - 1, gpu_b0);
          }

          eint = cpu_b->size[0];
          cpu_b->size[0] = cpu_b0->size[0];
          emxEnsureCapacity_real_T(cpu_b, eint, &cc_emlrtRTEI);
          b_nx = cpu_b0->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
          b_y_needsGpuEnsureCapacity = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel51<<<grid, block>>>(gpu_b0, b_nx, gpu_b);
          }

          h_needsGpuEnsureCapacity = false;
        }

        if (first_iteration) {
          if ((cpu_G->size[0] == 0) || (cpu_G->size[1] == 0) || (cpu_b->size[0] ==
               0)) {
            eint = cpu_a->size[0];
            cpu_a->size[0] = cpu_G->size[1];
            emxEnsureCapacity_real_T(cpu_a, eint, &xb_emlrtRTEI);
            b_nx = cpu_G->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, true);
            x_data_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel52<<<grid, block>>>(b_nx, gpu_a);
            }

            interval_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
          } else if (cpu_G->size[0] == cpu_G->size[1]) {
            eint = cpu_a->size[0];
            cpu_a->size[0] = cpu_b->size[0];
            emxEnsureCapacity_real_T(cpu_a, eint, &xb_emlrtRTEI);
            b_nx = cpu_b->size[0] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            if (b_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
                !h_needsGpuEnsureCapacity);
            }

            gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, true);
            if (h_needsGpuEnsureCapacity) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel566<<<grid, block>>>(gpu_b, b_nx, gpu_a);
            }

            ix = cpu_G->size[0];
            nw = cpu_G->size[1];
            if (ix <= nw) {
              nw = ix;
            }

            ix = cpu_a->size[0];
            if (ix <= nw) {
              nw = ix;
            }

            eint = cpu_IPIV->size[0];
            cpu_IPIV->size[0] = nw;
            emxEnsureCapacity_int32_T(cpu_IPIV, eint, &gc_emlrtRTEI);
            if (G_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, true);
            }

            cusolverCheck(cusolverDnDgetrf_bufferSize(getCuSolverGlobalHandle(),
              nw, nw, (double *)&gpu_G.data[0], cpu_G->size[0],
              getCuSolverWorkspaceReq()), __FILE__, __LINE__);
            setCuSolverWorkspaceTypeSize(8);
            cusolverInitWorkspace();
            G_needsGpuEnsureCapacity = false;
            gpuEmxEnsureCapacity_int32_T(cpu_IPIV, &gpu_IPIV, true);
            cusolverCheck(cusolverDnDgetrf(getCuSolverGlobalHandle(), nw, nw,
              (double *)&gpu_G.data[0], cpu_G->size[0], static_cast<real_T *>
              (getCuSolverWorkspaceBuff()), &gpu_IPIV.data[0], gpu_nrefine),
                          __FILE__, __LINE__);
            checkCudaError(cudaMemcpy(&cpu_nrefine, gpu_nrefine, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            if (cpu_nrefine < 0) {
              omega_tmp2[0] = cpu_a->size[0];
              eint = cpu_a->size[0];
              cpu_a->size[0] = omega_tmp2[0];
              emxEnsureCapacity_real_T(cpu_a, eint, &oc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, true);
              x_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel567<<<grid, block>>>(omega_tmp2[0] - 1, gpu_a);
              }

              interval_outdatedOnGpu = false;
              c_omega_tmp1_needsGpuEnsureCapa = true;
            } else {
              x_data_outdatedOnGpu = false;
              cusolverCheck(cusolverDnDgetrs(getCuSolverGlobalHandle(),
                CUBLAS_OP_N, nw, 1, (double *)&gpu_G.data[0], cpu_G->size[0],
                &gpu_IPIV.data[0], (double *)&gpu_a.data[0], cpu_a->size[0],
                gpu_nrefine), __FILE__, __LINE__);
              interval_outdatedOnGpu = false;
              c_omega_tmp1_needsGpuEnsureCapa = true;
            }
          } else {
            ptrdiff_t info_t;
            nw = cpu_G->size[0];
            nsubs = cpu_G->size[1] - 1;
            eint = cpu_jpvt->size[0] * cpu_jpvt->size[1];
            cpu_jpvt->size[0] = 1;
            cpu_jpvt->size[1] = cpu_G->size[1];
            emxEnsureCapacity_int32_T(cpu_jpvt, eint, &fc_emlrtRTEI);
            b_nx = cpu_G->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &gpu_jpvt, true);
            interval_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel568<<<grid, block>>>(b_nx, gpu_jpvt);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            wav_outdatedOnCpu = true;
            ix = cpu_G->size[0];
            cpu_nrefine = cpu_G->size[1];
            if (ix <= cpu_nrefine) {
              cpu_nrefine = ix;
            }

            eint = cpu_tau->size[0];
            cpu_tau->size[0] = cpu_nrefine;
            emxEnsureCapacity_real_T(cpu_tau, eint, &kc_emlrtRTEI);
            eint = jpvt_t->size[0];
            jpvt_t->size[0] = cpu_G->size[1];
            emxEnsureCapacity_ptrdiff_t(jpvt_t, eint, &mc_emlrtRTEI);
            for (eint = 0; eint < cpu_G->size[1]; eint++) {
              jpvt_t->data[eint] = (ptrdiff_t)0;
            }

            if (G_outdatedOnCpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
            }

            info_t = LAPACKE_dgeqp3(102, (ptrdiff_t)cpu_G->size[0], (ptrdiff_t)
              cpu_G->size[1], &cpu_G->data[0], (ptrdiff_t)cpu_G->size[0],
              &jpvt_t->data[0], &cpu_tau->data[0]);
            x_data_outdatedOnGpu = true;
            G_outdatedOnCpu = false;
            a_data_outdatedOnGpu = true;
            fx_data_outdatedOnCpu = true;
            G_needsGpuEnsureCapacity = true;
            if ((int32_T)info_t != 0) {
              mwGetLaunchParameters1D(computeNumIters(nsubs, nw - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, false);
              G_needsGpuEnsureCapacity = false;
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel569<<<grid, block>>>(nw - 1, nsubs, gpu_G,
                  cpu_G->size[0U]);
              }

              a_data_outdatedOnGpu = false;
              G_outdatedOnCpu = true;
              ix = cpu_G->size[0];
              lidx = cpu_G->size[1];
              if (ix <= lidx) {
                lidx = ix;
              }

              mwGetLaunchParameters1D(computeNumIters(lidx - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(cpu_tau, &gpu_tau, false);
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, cpu_tau);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel570<<<grid, block>>>(lidx - 1, gpu_tau);
              }

              e = computeEndIdx(static_cast<int64_T>(lidx + 1),
                                static_cast<int64_T>(cpu_nrefine), 1L);
              mwGetLaunchParameters1D(computeNumIters(e), &grid, &block,
                2147483647U);
              fx_data_outdatedOnCpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel571<<<grid, block>>>(lidx + 1, e, gpu_tau);
              }

              x_data_outdatedOnGpu = false;
              mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
                2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel572<<<grid, block>>>(nsubs, gpu_jpvt);
              }
            } else {
              for (k = 0; k <= nsubs; k++) {
                if (wav_outdatedOnCpu) {
                  gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &gpu_jpvt);
                }

                cpu_jpvt->data[k] = (int32_T)jpvt_t->data[k];
                wav_outdatedOnCpu = false;
                c_omega_tmp1_needsGpuEnsureCapa = true;
                interval_outdatedOnGpu = true;
              }
            }

            nsubs = -1;
            if (cpu_G->size[0] < cpu_G->size[1]) {
              lidx = cpu_G->size[0];
              cpu_nrefine = cpu_G->size[1];
            } else {
              lidx = cpu_G->size[1];
              cpu_nrefine = cpu_G->size[0];
            }

            exitg2 = false;
            while ((!exitg2) && (nsubs + 1 < lidx)) {
              if (G_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
              }

              G_outdatedOnCpu = false;
              if (!(std::abs(cpu_G->data[(nsubs + cpu_G->size[0] * (nsubs + 1))
                             + 1]) <= std::fmin(1.4901161193847656E-8,
                    2.2204460492503131E-15 * static_cast<real_T>(cpu_nrefine)) *
                    std::abs(cpu_G->data[0]))) {
                G_needsGpuEnsureCapacity = true;
                nsubs++;
              } else {
                G_needsGpuEnsureCapacity = true;
                exitg2 = true;
              }
            }

            eint = cpu_a->size[0];
            cpu_a->size[0] = cpu_G->size[1];
            emxEnsureCapacity_real_T(cpu_a, eint, &xb_emlrtRTEI);
            b_nx = cpu_G->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel573<<<grid, block>>>(b_nx, gpu_a);
            }

            cpu_nrefine = 0;
            ix = cpu_G->size[0];
            nw = cpu_G->size[1];
            if (ix <= nw) {
              nw = ix;
            }

            if (G_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_G, &gpu_G, !a_data_outdatedOnGpu);
            }

            if (fx_data_outdatedOnCpu) {
              gpuEmxEnsureCapacity_real_T(cpu_tau, &gpu_tau,
                !x_data_outdatedOnGpu);
            }

            if (b_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b,
                !h_needsGpuEnsureCapacity);
            }

            if (a_data_outdatedOnGpu) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_G, cpu_G);
            }

            if (x_data_outdatedOnGpu) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_tau, cpu_tau);
            }

            if (h_needsGpuEnsureCapacity) {
              gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
            }

            cusolverCheck(cusolverDnDormqr_bufferSize(getCuSolverGlobalHandle(),
              CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, nw, (double *)
              &gpu_G.data[0], cpu_G->size[0], (double *)&gpu_tau.data[0],
              (double *)&gpu_b.data[0], cpu_b->size[0], getCuSolverWorkspaceReq()),
                          __FILE__, __LINE__);
            setCuSolverWorkspaceTypeSize(8);
            cusolverInitWorkspace();
            G_needsGpuEnsureCapacity = false;
            checkCudaError(cudaMemcpy(gpu_nrefine, &cpu_nrefine, 4UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
            cusolverCheck(cusolverDnDormqr(getCuSolverGlobalHandle(),
              CUBLAS_SIDE_LEFT, CUBLAS_OP_T, cpu_b->size[0], 1, nw, (double *)
              &gpu_G.data[0], cpu_G->size[0], (double *)&gpu_tau.data[0],
              (double *)&gpu_b.data[0], cpu_b->size[0], static_cast<real_T *>
              (getCuSolverWorkspaceBuff()), *getCuSolverWorkspaceReq(),
              gpu_nrefine), __FILE__, __LINE__);
            checkCudaError(cudaMemcpy(&cpu_nrefine, gpu_nrefine, 4UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            if (cpu_nrefine < 0) {
              omega_tmp2[0] = cpu_b->size[0];
              eint = cpu_b->size[0];
              cpu_b->size[0] = omega_tmp2[0];
              emxEnsureCapacity_real_T(cpu_b, eint, &sc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel574<<<grid, block>>>(omega_tmp2[0] - 1, gpu_b);
              }
            }

            mwGetLaunchParameters1D(computeNumIters(nsubs), &grid, &block,
              2147483647U);
            if (interval_outdatedOnGpu) {
              gpuEmxEnsureCapacity_int32_T(cpu_jpvt, &gpu_jpvt,
                !c_omega_tmp1_needsGpuEnsureCapa);
            }

            x_data_outdatedOnGpu = false;
            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxMemcpyCpuToGpu_int32_T(&gpu_jpvt, cpu_jpvt);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel575<<<grid, block>>>(gpu_b, gpu_jpvt, nsubs, gpu_a);
            }

            interval_outdatedOnGpu = false;
            c_omega_tmp1_needsGpuEnsureCapa = true;
            for (itime = 0; itime <= nsubs; itime++) {
              if (c_omega_tmp1_needsGpuEnsureCapa) {
                gpuEmxMemcpyGpuToCpu_real_T(cpu_a, &gpu_a);
              }

              if (wav_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_int32_T(cpu_jpvt, &gpu_jpvt);
              }

              wav_outdatedOnCpu = false;
              if (G_outdatedOnCpu) {
                gpuEmxMemcpyGpuToCpu_real_T(cpu_G, &gpu_G);
              }

              G_outdatedOnCpu = false;
              cpu_a->data[cpu_jpvt->data[nsubs - itime] - 1] /= cpu_G->data
                [(nsubs - itime) + cpu_G->size[0] * (nsubs - itime)];
              c_omega_tmp1_needsGpuEnsureCapa = false;
              interval_outdatedOnGpu = true;
              G_needsGpuEnsureCapacity = true;
              x_data_outdatedOnGpu = true;
              cpu_nrefine = nsubs - itime;
              for (lidx = 0; lidx < cpu_nrefine; lidx++) {
                cpu_a->data[cpu_jpvt->data[lidx] - 1] -= cpu_a->data
                  [cpu_jpvt->data[nsubs - itime] - 1] * cpu_G->data[lidx +
                  cpu_G->size[0] * (nsubs - itime)];
              }
            }
          }
        } else {
          eint = cpu_a->size[0];
          cpu_a->size[0] = cpu_b->size[0];
          emxEnsureCapacity_real_T(cpu_a, eint, &wb_emlrtRTEI);
          b_nx = cpu_b->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          if (b_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(cpu_b, &gpu_b, !h_needsGpuEnsureCapacity);
          }

          gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, true);
          x_data_outdatedOnGpu = false;
          if (h_needsGpuEnsureCapacity) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_b, cpu_b);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel576<<<grid, block>>>(gpu_b, b_nx, gpu_a);
          }

          interval_outdatedOnGpu = false;
          c_omega_tmp1_needsGpuEnsureCapa = true;
          if (Nodd) {
            ec_cwt_kernel577<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_a);
          }
        }

        if (Nodd) {
          if (halfh + 1.0 < 2.0) {
            cpu_nrefine = 0;
            lidx = 1;
            nw = -1;
            ix = 0;
            nsubs = 0;
          } else {
            cpu_nrefine = static_cast<int32_T>(halfh + 1.0) - 1;
            lidx = -1;
            nw = 1;
            ix = 1;
            nsubs = static_cast<int32_T>(halfh + 1.0);
          }

          eint = cpu_h->size[0] * cpu_h->size[1];
          cpu_h->size[0] = 1;
          cpu_h->size[1] = ((div_s32(nw - cpu_nrefine, lidx) + nsubs) - ix) + 2;
          emxEnsureCapacity_real_T(cpu_h, eint, &pc_emlrtRTEI);
          dim = div_s32(nw - cpu_nrefine, lidx);
          mwGetLaunchParameters1D(computeNumIters(dim), &grid, &block,
            2147483647U);
          if (x_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, !interval_outdatedOnGpu);
          }

          gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
          if (interval_outdatedOnGpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_a, cpu_a);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel53<<<grid, block>>>(gpu_a, lidx, cpu_nrefine, dim,
              gpu_h);
          }

          h_needsGpuEnsureCapacity = false;
          ec_cwt_kernel54<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_a, lidx,
            cpu_nrefine, nw, gpu_h);
          a_data_outdatedOnGpu = true;
          dim = nsubs - ix;
          for (eint = 0; eint < dim; eint++) {
            if (a_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_h, &gpu_h);
            }

            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_a, &gpu_a);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            cpu_h->data[(eint + div_s32(nw - cpu_nrefine, lidx)) + 2] =
              cpu_a->data[ix + eint] / 2.0;
            a_data_outdatedOnGpu = false;
            h_outdatedOnGpu = true;
            h_needsGpuEnsureCapacity = true;
          }
        } else {
          eint = d_cpu_x->size[0];
          d_cpu_x->size[0] = cpu_a->size[0];
          emxEnsureCapacity_real_T(d_cpu_x, eint, &jc_emlrtRTEI);
          b_nx = cpu_a->size[0] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          if (x_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_a, &gpu_a, !interval_outdatedOnGpu);
          }

          gpuEmxEnsureCapacity_real_T(d_cpu_x, &m_gpu_x, true);
          x_data_outdatedOnGpu = false;
          if (interval_outdatedOnGpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&gpu_a, cpu_a);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel564<<<grid, block>>>(gpu_a, b_nx, m_gpu_x);
          }

          fx_data_outdatedOnCpu = false;
          interval_outdatedOnGpu = true;
          nw = cpu_a->size[0] - 1;
          cpu_nrefine = cpu_a->size[0] >> 1;
          for (lidx = 0; lidx < cpu_nrefine; lidx++) {
            if (interval_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real_T(d_cpu_x, &m_gpu_x);
            }

            b_cpu_r = d_cpu_x->data[lidx];
            d_cpu_x->data[lidx] = d_cpu_x->data[nw - lidx];
            d_cpu_x->data[nw - lidx] = b_cpu_r;
            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = true;
            x_data_outdatedOnGpu = true;
          }

          eint = cpu_h->size[0] * cpu_h->size[1];
          cpu_h->size[0] = 1;
          cpu_h->size[1] = d_cpu_x->size[0] + cpu_a->size[0];
          emxEnsureCapacity_real_T(cpu_h, eint, &qc_emlrtRTEI);
          dim = d_cpu_x->size[0];
          mwGetLaunchParameters1D(computeNumIters(dim - 1), &grid, &block,
            2147483647U);
          if (x_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(d_cpu_x, &m_gpu_x,
              !fx_data_outdatedOnCpu);
          }

          gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, true);
          h_needsGpuEnsureCapacity = false;
          if (fx_data_outdatedOnCpu) {
            gpuEmxMemcpyCpuToGpu_real_T(&m_gpu_x, d_cpu_x);
          }

          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel565<<<grid, block>>>(m_gpu_x, dim - 1, gpu_h);
          }

          a_data_outdatedOnGpu = true;
          dim = cpu_a->size[0];
          for (eint = 0; eint < dim; eint++) {
            if (a_data_outdatedOnGpu) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_h, &gpu_h);
            }

            if (c_omega_tmp1_needsGpuEnsureCapa) {
              gpuEmxMemcpyGpuToCpu_real_T(cpu_a, &gpu_a);
            }

            c_omega_tmp1_needsGpuEnsureCapa = false;
            cpu_h->data[eint + d_cpu_x->size[0]] = 0.5 * cpu_a->data[eint];
            a_data_outdatedOnGpu = false;
            h_outdatedOnGpu = true;
            h_needsGpuEnsureCapacity = true;
          }
        }
      }

      if (tau == std::floor(tau)) {
        nw = static_cast<int32_T>(tau);
      } else {
        nw = static_cast<int32_T>(std::round(tau));
        coder::internal::warning();
      }

      eint = cpu_dv18->size[0];
      cpu_dv18->size[0] = nw;
      emxEnsureCapacity_real_T(cpu_dv18, eint, &gb_emlrtRTEI);
      if (nw <= 1) {
        eint = cpu_dv18->size[0];
        cpu_dv18->size[0] = nw;
        emxEnsureCapacity_real_T(cpu_dv18, eint, &hb_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(nw - 1), &grid, &block,
          2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_dv18, &gpu_dv18, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel55<<<grid, block>>>(nw - 1, gpu_dv18);
        }

        x_data_outdatedOnGpu = false;
      } else {
        lidx = nw >> 1;
        e = computeEndIdx(static_cast<int64_T>(lidx + 1), static_cast<int64_T>
                          (nw), 1L);
        mwGetLaunchParameters1D(computeNumIters(e), &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_real_T(cpu_dv18, &gpu_dv18, true);
        interval_outdatedOnGpu = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel563<<<grid, block>>>(gpu_dc6, *global_gpu_table100, dc7,
            gpu_dc1, nw, lidx, 1 - (nw & 1), lidx + 1, e, gpu_dv18, q1[0], q1[1],
            q1[2], q1[3], q1[4], q1[5], q1[6], q1[7], p1[0], p1[1], p1[2], p1[3],
            p1[4], p1[5], p1[6], p1[7], q2[0], q2[1], q2[2], q2[3], q2[4], q2[5],
            q2[6], q2[7], p2[0], p2[1], p2[2], p2[3], p2[4], p2[5], p2[6], p2[7],
            q4[0], q4[1], q4[2], q4[3], q4[4], q4[5], q4[6], q4[7], p4[0], p4[1],
            p4[2], p4[3], p4[4], p4[5], p4[6], p4[7], c[0], c[1], c[2], c[3], c
            [4], c[5], c[6]);
        }

        x_data_outdatedOnGpu = false;
        fx_data_outdatedOnCpu = true;
        for (k = 0; k < lidx; k++) {
          if (fx_data_outdatedOnCpu) {
            gpuEmxMemcpyGpuToCpu_real_T(cpu_dv18, &gpu_dv18);
          }

          cpu_dv18->data[k] = cpu_dv18->data[(nw - k) - 1];
          fx_data_outdatedOnCpu = false;
          x_data_outdatedOnGpu = true;
          interval_outdatedOnGpu = true;
        }
      }

      eint = cpu_h1->size[0];
      cpu_h1->size[0] = cpu_h->size[1];
      emxEnsureCapacity_real_T(cpu_h1, eint, &kb_emlrtRTEI);
      b_nx = cpu_h->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_dv18, &gpu_dv18, !x_data_outdatedOnGpu);
      }

      if (h_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_real_T(cpu_h, &gpu_h, !h_outdatedOnGpu);
      }

      h_needsGpuEnsureCapacity = false;
      gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
      interval_outdatedOnGpu = false;
      if (x_data_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_dv18, cpu_dv18);
      }

      if (h_outdatedOnGpu) {
        gpuEmxMemcpyCpuToGpu_real_T(&gpu_h, cpu_h);
      }

      h_outdatedOnGpu = false;
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel56<<<grid, block>>>(gpu_dv18, gpu_h, b_nx, gpu_h1);
      }

      cpu_nrefine = cpu_h1->size[0];
      if (cpu_h1->size[0] == 0) {
        cpu_r = 0.0;
      } else {
        gpuEmxMemcpyGpuToCpu_real_T(cpu_h1, &gpu_h1);
        cpu_r = cpu_h1->data[0];
        interval_outdatedOnGpu = true;
        for (k = 0; k <= cpu_nrefine - 2; k++) {
          cpu_r += cpu_h1->data[k + 1];
        }
      }

      eint = cpu_opts_filter->size[0];
      cpu_opts_filter->size[0] = cpu_h1->size[0];
      emxEnsureCapacity_real_T(cpu_opts_filter, eint, &fb_emlrtRTEI);
      b_nx = cpu_h1->size[0] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      if (interval_outdatedOnGpu) {
        gpuEmxEnsureCapacity_real_T(cpu_h1, &gpu_h1, true);
      }

      gpuEmxEnsureCapacity_real_T(cpu_opts_filter, &gpu_opts_filter, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel57<<<grid, block>>>(cpu_r, gpu_h1, cf, b_nx,
          gpu_opts_filter);
      }

      b_cpu_r = (static_cast<real_T>(cpu_opts_filter->size[0]) - 1.0) / 2.0;
      r = b_cpu_r;
      if (intFsq == 0.0) {
        if (b_cpu_r == 0.0) {
          r = 0.0;
        }
      } else if (std::isnan(intFsq)) {
        r = rtNaN;
      } else if (b_cpu_r == 0.0) {
        r = 0.0;
      } else if (std::isinf(intFsq)) {
        if (b_cpu_r < 0.0) {
          r = intFsq;
        }
      } else {
        r = std::fmod(b_cpu_r, intFsq);
        if (r == 0.0) {
          r = intFsq * 0.0;
        } else if (b_cpu_r < 0.0) {
          r += intFsq;
        }
      }

      halfh = std::floor(intFsq - r);
      tol = std::floor(std::ceil(b_cpu_r + halfh) / intFsq);
      cpu_r = static_cast<real_T>(cpu_opts_filter->size[0]) + halfh;
      b_cpu_r = 0.0;
      cpu_nrefine = cpu_opts_x->size[0];
      while (std::ceil((((static_cast<real_T>(cpu_nrefine) - 1.0) * cf + cpu_r)
                        + b_cpu_r) / intFsq) - tol < std::ceil
             (static_cast<real_T>(cpu_nrefine) * cf / intFsq)) {
        b_cpu_r++;
      }

      eint = b_cpu_h->size[0];
      b_cpu_h->size[0] = static_cast<int32_T>((halfh + static_cast<real_T>
        (cpu_opts_filter->size[0])) + b_cpu_r);
      emxEnsureCapacity_real_T(b_cpu_h, eint, &qb_emlrtRTEI);
      b_nx = static_cast<int32_T>((halfh + static_cast<real_T>
        (cpu_opts_filter->size[0])) + b_cpu_r) - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      gpuEmxEnsureCapacity_real_T(b_cpu_h, &b_gpu_h, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel58<<<grid, block>>>(b_nx, b_gpu_h);
      }

      if (cpu_opts_filter->size[0] < 1) {
        g_cpu_y->size[0] = 1;
        g_cpu_y->size[1] = 0;
      } else {
        N = static_cast<uint32_T>(cpu_opts_filter->size[0]);
        eint = g_cpu_y->size[0] * g_cpu_y->size[1];
        g_cpu_y->size[0] = 1;
        g_cpu_y->size[1] = cpu_opts_filter->size[0];
        emxEnsureCapacity_uint32_T(g_cpu_y, eint, &d_emlrtRTEI);
        mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(N) - 1),
          &grid, &block, 2147483647U);
        gpuEmxEnsureCapacity_uint32_T(g_cpu_y, &f_gpu_y, true);
        c_y_needsGpuEnsureCapacity = false;
        validLaunchParams = mwValidateLaunchParameters(grid, block);
        if (validLaunchParams) {
          ec_cwt_kernel562<<<grid, block>>>(static_cast<int32_T>(N) - 1, f_gpu_y);
        }
      }

      eint = cpu_iv6->size[0] * cpu_iv6->size[1];
      cpu_iv6->size[0] = 1;
      cpu_iv6->size[1] = g_cpu_y->size[1];
      emxEnsureCapacity_int32_T(cpu_iv6, eint, &tb_emlrtRTEI);
      itime = g_cpu_y->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block, 2147483647U);
      if (c_y_needsGpuEnsureCapacity) {
        gpuEmxEnsureCapacity_uint32_T(g_cpu_y, &f_gpu_y, true);
      }

      c_y_needsGpuEnsureCapacity = false;
      gpuEmxEnsureCapacity_int32_T(cpu_iv6, &gpu_iv6, true);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel59<<<grid, block>>>(f_gpu_y, halfh, itime, gpu_iv6);
      }

      b_nx = cpu_iv6->size[1] - 1;
      mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block, 2147483647U);
      validLaunchParams = mwValidateLaunchParameters(grid, block);
      if (validLaunchParams) {
        ec_cwt_kernel60<<<grid, block>>>(gpu_opts_filter, gpu_iv6, b_nx, b_gpu_h);
      }

      if (nx == 1) {
        if (opts_isRowVectorInput) {
          if ((cf == 1.0) && (intFsq == 1.0)) {
            eint = cpu_y1->size[0] * cpu_y1->size[1];
            cpu_y1->size[0] = cpu_opts_x->size[0];
            cpu_y1->size[1] = cpu_opts_x->size[1];
            emxEnsureCapacity_real_T(cpu_y1, eint, &bc_emlrtRTEI);
            b_nx = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel61<<<grid, block>>>(gpu_opts_x, b_nx, gpu_y1);
            }
          } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
            if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              nw = 0;
            } else {
              ix = cpu_opts_x->size[0];
              nw = cpu_opts_x->size[1];
              if (ix >= nw) {
                nw = ix;
              }
            }

            err_ok = std::ceil(static_cast<real_T>(nw) * cf / intFsq);
            if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
              int32_T cpu_csz[2];
              int32_T cpu_lshift[2];
              if (!(cf - 1.0 >= 0.0)) {
                n_y = nullptr;
                m19 = emlrtCreateCharArray(2, &iv16[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m19, &rfmt[0]);
                emlrtAssign(&n_y, m19);
                w_y = nullptr;
                m25 = emlrtCreateDoubleScalar(cf - 1.0);
                emlrtAssign(&w_y, m25);
                emlrt_marshallIn(b_sprintf(n_y, w_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              eint = i_cpu_yCol->size[0];
              i_cpu_yCol->size[0] = static_cast<int32_T>(cf);
              emxEnsureCapacity_real_T(i_cpu_yCol, eint, &lc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(cf) -
                1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(i_cpu_yCol, &gpu_yCol, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel63<<<grid, block>>>(static_cast<int32_T>(cf) - 1,
                  gpu_yCol);
              }

              if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf)
                     > 0) && (static_cast<int32_T>(cf) < 1)) ||
                   ((static_cast<int32_T>(cf) < 0) && (static_cast<int32_T>(cf) >
                     1)))) {
                nw = 1;
                cpu_nrefine = 0;
              } else {
                nw = static_cast<int32_T>(cf);
                cpu_nrefine = static_cast<int32_T>(cf);
              }

              mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1,
                nw)), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel64<<<grid, block>>>(gpu_opts_x, nw, div_s32
                  (cpu_nrefine - 1, nw), gpu_yCol);
              }

              ec_cwt_kernel65<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cf,
                *gpu_csz);
              eint = l_cpu_x->size[0] * l_cpu_x->size[1];
              l_cpu_x->size[0] = static_cast<int32_T>(cf);
              l_cpu_x->size[1] = 1;
              emxEnsureCapacity_real_T(l_cpu_x, eint, &rc_emlrtRTEI);
              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(l_cpu_x, &d_gpu_x, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel66<<<grid, block>>>(gpu_yCol, cpu_csz[0] - 1,
                  d_gpu_x);
              }

              if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                eint = i_cpu_a->size[0];
                i_cpu_a->size[0] = 1;
                emxEnsureCapacity_real_T(i_cpu_a, eint, &tc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(i_cpu_a, &b_gpu_a, true);
                ec_cwt_kernel67<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                  gpu_yCol, gpu_r, b_gpu_a);
                eint = h_cpu_c->size[0];
                h_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(h_cpu_c, eint, &wc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(h_cpu_c, &gpu_c, true);
                ec_cwt_kernel68<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_r,
                  b_gpu_a, gpu_c);
                eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = 1;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel69<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_c,
                  gpu_w);
              } else if (b_cpu_h->size[0] > cpu_csz[0]) {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
                }

                eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = nsubs;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel81<<<grid, block>>>(nsubs - 1, gpu_w);
                }

                if (cpu_csz[0] == 0) {
                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = nsubs;
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel82<<<grid, block>>>(nsubs - 1, gpu_w);
                  }
                } else if ((b_cpu_h->size[0] == 1) && (cpu_csz[0] == 1)) {
                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = 1;
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel83<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (gpu_yCol, b_gpu_h, gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                           real_T>(cpu_csz[0])) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                    floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                  if (fc >= -2.147483648E+9) {
                    dim = static_cast<int32_T>(fc);
                  } else {
                    dim = MIN_int32_T;
                  }

                  if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff))
                  {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                              - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + cpu_csz[0];
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = x_cpu_expanded->size[0] * x_cpu_expanded->size[1];
                  x_cpu_expanded->size[0] = ix;
                  x_cpu_expanded->size[1] = 1;
                  emxEnsureCapacity_real_T(x_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = (fb_CutOff + cpu_csz[0]) - 2;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(x_cpu_expanded, &gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel84<<<grid, block>>>(b_nx, gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = qb_cpu_y->size[0] * qb_cpu_y->size[1];
                  qb_cpu_y->size[0] = 1;
                  qb_cpu_y->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(qb_cpu_y, eint, &ad_emlrtRTEI);
                  qb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    qb_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv52->size[0];
                  cpu_iv52->size[0] = qb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv52, eint, &xc_emlrtRTEI);
                  itime = qb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(qb_cpu_y, &k_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv52, &gpu_iv52, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&k_gpu_y, qb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel85<<<grid, block>>>(dim, k_gpu_y, itime,
                      gpu_iv52);
                  }

                  omega_tmp2[0] = cpu_iv52->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel86<<<grid, block>>>(b_gpu_h, gpu_iv52,
                      omega_tmp2[0] - 1, gpu_expanded);
                  }

                  if (cpu_csz[0] < -2147483647) {
                    ix = MIN_int32_T;
                  } else {
                    ix = cpu_csz[0] - 1;
                  }

                  if (ix < 0) {
                    b_nx = 0;
                  } else {
                    b_nx = ix + 1;
                  }

                  interval_outdatedOnGpu = false;
                  eint = l_cpu_rows->size[0] * l_cpu_rows->size[1];
                  l_cpu_rows->size[0] = 1;
                  l_cpu_rows->size[1] = b_nx;
                  emxEnsureCapacity_int32_T(l_cpu_rows, eint, &ad_emlrtRTEI);
                  if (b_nx > 0) {
                    l_cpu_rows->data[0] = 0;
                    interval_outdatedOnGpu = true;
                    nsubs = 0;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      l_cpu_rows->data[k + 1] = nsubs;
                    }
                  }

                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = fb_CutOff;
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (fb_CutOff != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    eint = threadDims[0];
                    if (threadDims[0] < 0) {
                      eint = 0;
                    }

                    mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                      dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(l_cpu_rows, &gpu_rows,
                      !interval_outdatedOnGpu);
                    gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    if (interval_outdatedOnGpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&gpu_rows, l_cpu_rows);
                    }

                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel87<<<grid, block>>>(gpu_yCol, gpu_expanded,
                        gpu_rows, *gpu_csz, fb_CutOff - 1, gpu_w);
                    }
                  }
                }
              } else {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
                }

                eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                j_cpu_w->size[0] = nsubs;
                j_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel88<<<grid, block>>>(nsubs - 1, gpu_w);
                }

                if (cpu_csz[0] == 0) {
                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = nsubs;
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel89<<<grid, block>>>(nsubs - 1, gpu_w);
                  }
                } else if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                  eint = p_cpu_c->size[0];
                  p_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(p_cpu_c, eint, &vc_emlrtRTEI);
                  cpu_r = 1.0;
                  b_cpu_r = 0.0;
                  gpuEmxEnsureCapacity_real_T(p_cpu_c, &b_gpu_c, true);
                  cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                    CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                    &d_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                    &b_cpu_r, (double *)&b_gpu_c.data[0], 1), __FILE__, __LINE__);
                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = nsubs;
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel90<<<grid, block>>>(b_gpu_c, nsubs - 1, gpu_w);
                  }
                } else {
                  real_T blockDims[3];
                  N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                       (b_cpu_h->size[0])) - 1U;
                  lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                    (N)));
                  blockDims[0] = std::floor((static_cast<real_T>(N) + (
                    static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                  if (N > 2147483647U) {
                    N = 2147483647U;
                  }

                  fb_CutOff = static_cast<int32_T>(N);
                  dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                    (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                  if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                       MAX_int32_T - static_cast<int32_T>(N))) {
                    ix = MAX_int32_T;
                  } else {
                    ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                  }

                  eint = w_cpu_expanded->size[0] * w_cpu_expanded->size[1];
                  w_cpu_expanded->size[0] = ix - 1;
                  w_cpu_expanded->size[1] = 1;
                  emxEnsureCapacity_real_T(w_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(w_cpu_expanded, &b_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel91<<<grid, block>>>(b_nx, b_gpu_expanded);
                  }

                  b_nx = cpu_csz[0];
                  eint = mb_cpu_y->size[0] * mb_cpu_y->size[1];
                  mb_cpu_y->size[0] = 1;
                  mb_cpu_y->size[1] = cpu_csz[0];
                  emxEnsureCapacity_int32_T(mb_cpu_y, eint, &ad_emlrtRTEI);
                  mb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    mb_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv54->size[0];
                  cpu_iv54->size[0] = mb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv54, eint, &xc_emlrtRTEI);
                  itime = mb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(mb_cpu_y, &l_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv54, &gpu_iv54, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&l_gpu_y, mb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel92<<<grid, block>>>(dim, l_gpu_y, itime,
                      gpu_iv54);
                  }

                  xt_size[0] = cpu_iv54->size[0];
                  mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel93<<<grid, block>>>(gpu_yCol, gpu_iv54,
                      xt_size[0] - 1, b_gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = ab_cpu_rows->size[0] * ab_cpu_rows->size[1];
                  ab_cpu_rows->size[0] = 1;
                  ab_cpu_rows->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(ab_cpu_rows, eint, &ad_emlrtRTEI);
                  ab_cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    ab_cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = j_cpu_w->size[0] * j_cpu_w->size[1];
                  j_cpu_w->size[0] = static_cast<int32_T>(N);
                  j_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(j_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (static_cast<int32_T>(N) != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                      dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(lidx), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(ab_cpu_rows, &b_gpu_rows, false);
                    gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_rows, ab_cpu_rows);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel94<<<grid, block>>>(b_gpu_expanded,
                        b_gpu_rows, b_gpu_h, fb_CutOff - 1, gpu_w, b_cpu_h->
                        size[0U]);
                    }
                  }
                }
              }

              if (!(intFsq - 1.0 >= 0.0)) {
                lb_y = nullptr;
                m42 = emlrtCreateCharArray(2, &iv27[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m42, &rfmt[0]);
                emlrtAssign(&lb_y, m42);
                sb_y = nullptr;
                m46 = emlrtCreateDoubleScalar(intFsq - 1.0);
                emlrtAssign(&sb_y, m46);
                emlrt_marshallIn(b_sprintf(lb_y, sb_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              dim = 2;
              if (j_cpu_w->size[0] != 1) {
                dim = 1;
              }

              interval_outdatedOnGpu = false;
              fx_data_outdatedOnCpu = false;
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = j_cpu_w->size[itime];
                fx_data_outdatedOnCpu = true;
                cpu_lshift[itime] = j_cpu_w->size[itime];
                interval_outdatedOnGpu = true;
              }

              if (1 - dim >= 0) {
                cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                  static_cast<real_T>(dim))) / 2.0);
                mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                  &block, 2147483647U);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel70<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                    *gpu_lshift);
                }

                checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              cpu_nrefine = cpu_lshift[0];
              cpu_lshift[0] = cpu_lshift[1];
              cpu_lshift[1] = cpu_nrefine;
              if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
                lidx = 1;
                nw = -1;
              } else {
                lidx = static_cast<int32_T>(intFsq);
                nw = cpu_lshift[0] - 1;
              }

              if (fx_data_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              ec_cwt_kernel71<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
                dim, *gpu_csz);
              eint = p_cpu_w->size[0] * p_cpu_w->size[1];
              p_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              p_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(p_cpu_w, eint, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
                &grid, &block, 2147483647U);
              if (x_data_outdatedOnGpu) {
                gpuEmxEnsureCapacity_real_T(j_cpu_w, &gpu_w, true);
              }

              gpuEmxEnsureCapacity_real_T(p_cpu_w, &b_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel72<<<grid, block>>>(gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_nrefine - 1, b_gpu_w, p_cpu_w->size[0U]);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              eint = ac_cpu_y->size[0] * ac_cpu_y->size[1];
              ac_cpu_y->size[0] = cpu_csz[0];
              ac_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(ac_cpu_y, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(ac_cpu_y, &g_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel73<<<grid, block>>>(b_gpu_w, b_nx, g_gpu_y);
              }

              b_cpu_r = std::ceil((0.0 * cf + static_cast<real_T>(b_cpu_h->size
                [0])) / intFsq);
              if (!(cpu_csz[0] < b_cpu_r)) {
                if (b_cpu_r < 1.0) {
                  cpu_nrefine = 0;
                } else {
                  cpu_nrefine = static_cast<int32_T>(b_cpu_r);
                }

                nsubs = x_cpu_w->size[0] * x_cpu_w->size[1];
                x_cpu_w->size[0] = div_s32(nw, lidx) + 1;
                x_cpu_w->size[1] = cpu_lshift[1];
                emxEnsureCapacity_real_T(x_cpu_w, nsubs, &bd_emlrtRTEI);
                itime = nw / lidx;
                mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                  &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(x_cpu_w, &c_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel74<<<grid, block>>>(gpu_w, cpu_lshift[0], lidx,
                    itime, cpu_lshift[1] - 1, c_gpu_w, x_cpu_w->size[0U]);
                }

                nsubs = ac_cpu_y->size[0] * ac_cpu_y->size[1];
                ac_cpu_y->size[0] = cpu_nrefine;
                ac_cpu_y->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(ac_cpu_y, nsubs, &uc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                  cpu_nrefine - 1), &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(ac_cpu_y, &g_gpu_y, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel75<<<grid, block>>>(c_gpu_w, cpu_csz[0],
                    cpu_nrefine - 1, cpu_csz[1] - 1, g_gpu_y, ac_cpu_y->size[0U]);
                }
              }

              if (ac_cpu_y->size[0] * ac_cpu_y->size[1] == 0) {
                b_nx = 0;
              } else {
                b_nx = ac_cpu_y->size[0] * ac_cpu_y->size[1];
              }

              omega_tmp2[0] = ac_cpu_y->size[0] * ac_cpu_y->size[1];
              eint = ld_cpu_y->size[0] * ld_cpu_y->size[1];
              ld_cpu_y->size[0] = 1;
              ld_cpu_y->size[1] = omega_tmp2[0];
              emxEnsureCapacity_real_T(ld_cpu_y, eint, &cd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(ld_cpu_y, &h_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel76<<<grid, block>>>(g_gpu_y, omega_tmp2[0] - 1,
                  h_gpu_y);
              }

              eint = eb_cpu_y->size[0] * eb_cpu_y->size[1];
              eb_cpu_y->size[0] = b_nx;
              eb_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(eb_cpu_y, eint, &dd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_nx - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(eb_cpu_y, &i_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel77<<<grid, block>>>(h_gpu_y, b_nx - 1, i_gpu_y);
              }
            } else {
              int32_T cpu_csz[2];
              int32_T cpu_lshift[2];
              if (!(cf - 1.0 >= 0.0)) {
                m_y = nullptr;
                m9 = emlrtCreateCharArray(2, &iv10[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m9, &rfmt[0]);
                emlrtAssign(&m_y, m9);
                v_y = nullptr;
                m17 = emlrtCreateDoubleScalar(cf - 1.0);
                emlrtAssign(&v_y, m17);
                emlrt_marshallIn(b_sprintf(m_y, v_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              ix = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = cpu_opts_x->size[itime];
              }

              cpu_nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              eint = c_cpu_yCol->size[0];
              c_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
              emxEnsureCapacity_real_T(c_cpu_yCol, eint, &lc_emlrtRTEI);
              itime = ix * static_cast<int32_T>(cf) - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(c_cpu_yCol, &b_gpu_yCol, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel95<<<grid, block>>>(itime, b_gpu_yCol);
              }

              if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf)
                     > 0) && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                     static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                     static_cast<int32_T>(cf) > 1)))) {
                nw = 1;
                cpu_nrefine = 0;
              } else {
                nw = static_cast<int32_T>(cf);
                cpu_nrefine = ix * static_cast<int32_T>(cf);
              }

              mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1,
                nw)), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel96<<<grid, block>>>(gpu_opts_x, nw, div_s32
                  (cpu_nrefine - 1, nw), b_gpu_yCol);
              }

              cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(cf);
              eint = f_cpu_x->size[0] * f_cpu_x->size[1];
              f_cpu_x->size[0] = cpu_csz[0];
              f_cpu_x->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_real_T(f_cpu_x, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(f_cpu_x, &e_gpu_x, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel97<<<grid, block>>>(b_gpu_yCol, b_nx, e_gpu_x);
              }

              if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                if (cpu_opts_x->size[1] < 1) {
                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = 1;
                  c_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel98<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (d_gpu_w);
                } else {
                  eint = cpu_opts_x->size[1];
                  nsubs = c_cpu_a->size[0];
                  c_cpu_a->size[0] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(c_cpu_a, nsubs, &tc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(c_cpu_a, &c_gpu_a, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel105<<<grid, block>>>(b_gpu_yCol, eint - 1,
                      c_gpu_a);
                  }

                  gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
                  q_ok = b_cpu_h->data[0];
                  eint = b_cpu_c->size[0];
                  b_cpu_c->size[0] = c_cpu_a->size[0];
                  emxEnsureCapacity_real_T(b_cpu_c, eint, &wc_emlrtRTEI);
                  b_nx = c_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_c, &c_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel106<<<grid, block>>>(b_nx, c_gpu_c);
                  }

                  if (c_cpu_a->size[0] == 1) {
                    cpu_r = b_cpu_h->data[0];
                    eint = b_cpu_c->size[0];
                    b_cpu_c->size[0] = 1;
                    emxEnsureCapacity_real_T(b_cpu_c, eint, &wc_emlrtRTEI);
                    gpuEmxEnsureCapacity_real_T(b_cpu_c, &c_gpu_c, true);
                    ec_cwt_kernel107<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cpu_r, c_gpu_a, c_gpu_c);
                  } else {
                    int32_T threadDims[3];
                    lidx = static_cast<int32_T>(std::fmin(32.0,
                      (static_cast<real_T>(c_cpu_a->size[0]) + 1.0) - 1.0));
                    threadDims[0] = static_cast<int32_T>(std::floor(static_cast<
                      real_T>((static_cast<uint32_T>(c_cpu_a->size[0]) +
                               static_cast<uint32_T>(lidx)) - 1U) /
                      static_cast<real_T>(lidx)));
                    fb_CutOff = c_cpu_a->size[0];
                    if (c_cpu_a->size[0] > 2147483646) {
                      ix = MAX_int32_T;
                    } else {
                      ix = c_cpu_a->size[0] + 1;
                    }

                    eint = d_cpu_expanded->size[0];
                    d_cpu_expanded->size[0] = ix - 1;
                    emxEnsureCapacity_real_T(d_cpu_expanded, eint, &xc_emlrtRTEI);
                    b_nx = c_cpu_a->size[0] - 1;
                    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                      2147483647U);
                    gpuEmxEnsureCapacity_real_T(d_cpu_expanded, &c_gpu_expanded,
                      true);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel109<<<grid, block>>>(b_nx, c_gpu_expanded);
                    }

                    b_nx = c_cpu_a->size[0];
                    eint = o_cpu_y->size[0] * o_cpu_y->size[1];
                    o_cpu_y->size[0] = 1;
                    o_cpu_y->size[1] = c_cpu_a->size[0];
                    emxEnsureCapacity_int32_T(o_cpu_y, eint, &ad_emlrtRTEI);
                    o_cpu_y->data[0] = 1;
                    nsubs = 1;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      o_cpu_y->data[k + 1] = nsubs;
                    }

                    eint = cpu_iv32->size[0];
                    cpu_iv32->size[0] = o_cpu_y->size[1];
                    emxEnsureCapacity_int32_T(cpu_iv32, eint, &xc_emlrtRTEI);
                    itime = o_cpu_y->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(itime), &grid,
                      &block, 2147483647U);
                    gpuEmxEnsureCapacity_int32_T(o_cpu_y, &m_gpu_y, false);
                    gpuEmxEnsureCapacity_int32_T(cpu_iv32, &gpu_iv32, true);
                    gpuEmxMemcpyCpuToGpu_int32_T(&m_gpu_y, o_cpu_y);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel110<<<grid, block>>>(m_gpu_y, itime, gpu_iv32);
                    }

                    omega_tmp2[0] = cpu_iv32->size[0];
                    mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                      &grid, &block, 2147483647U);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel111<<<grid, block>>>(c_gpu_a, gpu_iv32,
                        omega_tmp2[0] - 1, c_gpu_expanded);
                    }

                    eint = b_cpu_c->size[0];
                    b_cpu_c->size[0] = c_cpu_a->size[0];
                    emxEnsureCapacity_real_T(b_cpu_c, eint, &xc_emlrtRTEI);
                    mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3
                      (static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                      static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_real_T(b_cpu_c, &c_gpu_c, true);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel112<<<grid, block>>>(q_ok, c_gpu_expanded,
                        fb_CutOff - 1, c_gpu_c);
                    }
                  }

                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = 1;
                  c_cpu_w->size[1] = b_cpu_c->size[0];
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  b_nx = b_cpu_c->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel108<<<grid, block>>>(c_gpu_c, b_nx, d_gpu_w,
                      c_cpu_w->size[0U]);
                  }
                }
              } else if (b_cpu_h->size[0] > cpu_csz[0]) {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
                }

                if (cpu_opts_x->size[1] == 0) {
                  cpu_nrefine = 1;
                } else {
                  cpu_nrefine = cpu_opts_x->size[1];
                }

                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = nsubs;
                c_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel113<<<grid, block>>>(itime, d_gpu_w);
                }

                if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = nsubs;
                  c_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel114<<<grid, block>>>(itime, d_gpu_w);
                  }
                } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                            (cpu_opts_x->size[1] == 1))) {
                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = 1;
                  c_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel115<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (b_gpu_yCol, b_gpu_h, d_gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                           real_T>(cpu_csz[0])) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (
                    static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  blockDims[1] = std::floor(static_cast<real_T>((static_cast<
                    uint32_T>(cpu_opts_x->size[1]) + static_cast<uint32_T>
                    (cpu_nrefine)) - 1U) / static_cast<real_T>(cpu_nrefine));
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  threadDims[1] = cpu_nrefine;
                  nw = cpu_opts_x->size[1];
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                    floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                  if (fc >= -2.147483648E+9) {
                    dim = static_cast<int32_T>(fc);
                  } else {
                    dim = MIN_int32_T;
                  }

                  if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff))
                  {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                              - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + cpu_csz[0];
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = h_cpu_expanded->size[0] * h_cpu_expanded->size[1];
                  h_cpu_expanded->size[0] = ix;
                  emxEnsureCapacity_real_T(h_cpu_expanded, eint, &xc_emlrtRTEI);
                  if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                    ix = MAX_int32_T;
                  } else {
                    ix = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                  }

                  eint = h_cpu_expanded->size[0] * h_cpu_expanded->size[1];
                  h_cpu_expanded->size[1] = ix - 1;
                  emxEnsureCapacity_real_T(h_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_opts_x->size[1]
                    + cpu_opts_x->size[1]) - 1) - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(h_cpu_expanded, &d_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel116<<<grid, block>>>(b_nx, d_gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = s_cpu_y->size[0] * s_cpu_y->size[1];
                  s_cpu_y->size[0] = 1;
                  s_cpu_y->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(s_cpu_y, eint, &ad_emlrtRTEI);
                  s_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    s_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv34->size[0];
                  cpu_iv34->size[0] = s_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv34, eint, &xc_emlrtRTEI);
                  itime = s_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(s_cpu_y, &n_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv34, &gpu_iv34, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&n_gpu_y, s_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel117<<<grid, block>>>(dim, n_gpu_y, itime,
                      gpu_iv34);
                  }

                  cpu_nrefine = static_cast<int32_T>(std::floor
                    (static_cast<real_T>(cpu_opts_x->size[1]) / 2.0)) +
                    static_cast<int32_T>(std::floor((static_cast<real_T>
                    (cpu_opts_x->size[1]) - 1.0) / 2.0));
                  omega_tmp2[0] = cpu_iv34->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel118<<<grid, block>>>(b_gpu_h, cpu_nrefine,
                      gpu_iv34, omega_tmp2[0] - 1, d_gpu_expanded,
                      h_cpu_expanded->size[0U]);
                  }

                  if (cpu_csz[0] < -2147483647) {
                    ix = MIN_int32_T;
                  } else {
                    ix = cpu_csz[0] - 1;
                  }

                  if (ix < 0) {
                    b_nx = 0;
                  } else {
                    b_nx = ix + 1;
                  }

                  interval_outdatedOnGpu = false;
                  eint = d_cpu_rows->size[0] * d_cpu_rows->size[1];
                  d_cpu_rows->size[0] = 1;
                  d_cpu_rows->size[1] = b_nx;
                  emxEnsureCapacity_int32_T(d_cpu_rows, eint, &ad_emlrtRTEI);
                  if (b_nx > 0) {
                    d_cpu_rows->data[0] = 0;
                    interval_outdatedOnGpu = true;
                    nsubs = 0;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      d_cpu_rows->data[k + 1] = nsubs;
                    }
                  }

                  b_nx = cpu_opts_x->size[1];
                  eint = b_cpu_cols->size[0] * b_cpu_cols->size[1];
                  b_cpu_cols->size[0] = 1;
                  b_cpu_cols->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_int32_T(b_cpu_cols, eint, &ad_emlrtRTEI);
                  b_cpu_cols->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    b_cpu_cols->data[k + 1] = nsubs;
                  }

                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = fb_CutOff;
                  c_cpu_w->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (fb_CutOff != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    eint = threadDims[0];
                    if (threadDims[0] < 0) {
                      eint = 0;
                    }

                    mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff -
                      1), dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3
                      (static_cast<uint32_T>(eint), static_cast<uint32_T>
                       (threadDims[1]), 1U), &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(b_cpu_cols, &gpu_cols, false);
                    gpuEmxEnsureCapacity_int32_T(d_cpu_rows, &c_gpu_rows,
                      !interval_outdatedOnGpu);
                    gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&gpu_cols, b_cpu_cols);
                    if (interval_outdatedOnGpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_rows, d_cpu_rows);
                    }

                    checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                      cudaMemcpyHostToDevice), __FILE__, __LINE__);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel119<<<grid, block>>>(b_gpu_yCol,
                        d_gpu_expanded, gpu_cols, c_gpu_rows, *gpu_csz,
                        fb_CutOff - 1, nw - 1, d_gpu_w, h_cpu_expanded->size[0U],
                        c_cpu_w->size[0U]);
                    }
                  }
                }
              } else {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
                }

                if (cpu_opts_x->size[1] == 0) {
                  cpu_nrefine = 1;
                } else {
                  cpu_nrefine = cpu_opts_x->size[1];
                }

                eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                c_cpu_w->size[0] = nsubs;
                c_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel120<<<grid, block>>>(itime, d_gpu_w);
                }

                if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = nsubs;
                  c_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel121<<<grid, block>>>(itime, d_gpu_w);
                  }
                } else if ((cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                           (b_cpu_h->size[0] == 1)) {
                  eint = j_cpu_c->size[0];
                  j_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(j_cpu_c, eint, &vc_emlrtRTEI);
                  cpu_r = 1.0;
                  b_cpu_r = 0.0;
                  gpuEmxEnsureCapacity_real_T(j_cpu_c, &d_gpu_c, true);
                  cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                    CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                    &e_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                    &b_cpu_r, (double *)&d_gpu_c.data[0], 1), __FILE__, __LINE__);
                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = nsubs;
                  c_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel122<<<grid, block>>>(d_gpu_c, itime, d_gpu_w);
                  }
                } else {
                  real_T blockDims[3];
                  N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                       (b_cpu_h->size[0])) - 1U;
                  lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                    (N)));
                  cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (
                    static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                  blockDims[0] = std::floor((static_cast<real_T>(N) + (
                    static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                  blockDims[1] = std::floor(static_cast<real_T>
                    ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                      static_cast<uint32_T>(cpu_nrefine)) - 1U) /
                    static_cast<real_T>(cpu_nrefine));
                  nw = cpu_opts_x->size[1];
                  if (N > 2147483647U) {
                    N = 2147483647U;
                  }

                  fb_CutOff = static_cast<int32_T>(N);
                  dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                    (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                  if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                       MAX_int32_T - static_cast<int32_T>(N))) {
                    ix = MAX_int32_T;
                  } else {
                    ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                  }

                  eint = g_cpu_expanded->size[0] * g_cpu_expanded->size[1];
                  g_cpu_expanded->size[0] = ix - 1;
                  emxEnsureCapacity_real_T(g_cpu_expanded, eint, &xc_emlrtRTEI);
                  if (cpu_opts_x->size[1] > 2147483646) {
                    ix = MAX_int32_T;
                  } else {
                    ix = cpu_opts_x->size[1] + 1;
                  }

                  eint = g_cpu_expanded->size[0] * g_cpu_expanded->size[1];
                  g_cpu_expanded->size[1] = ix - 1;
                  emxEnsureCapacity_real_T(g_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                    cpu_opts_x->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(g_cpu_expanded, &e_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel123<<<grid, block>>>(b_nx, e_gpu_expanded);
                  }

                  b_nx = cpu_csz[0];
                  eint = q_cpu_y->size[0] * q_cpu_y->size[1];
                  q_cpu_y->size[0] = 1;
                  q_cpu_y->size[1] = cpu_csz[0];
                  emxEnsureCapacity_int32_T(q_cpu_y, eint, &ad_emlrtRTEI);
                  q_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    q_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv39->size[0];
                  cpu_iv39->size[0] = q_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv39, eint, &xc_emlrtRTEI);
                  itime = q_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(q_cpu_y, &o_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv39, &gpu_iv39, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&o_gpu_y, q_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel124<<<grid, block>>>(dim, o_gpu_y, itime,
                      gpu_iv39);
                  }

                  b_nx = cpu_opts_x->size[1];
                  eint = pb_cpu_y->size[0] * pb_cpu_y->size[1];
                  pb_cpu_y->size[0] = 1;
                  pb_cpu_y->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_int32_T(pb_cpu_y, eint, &ad_emlrtRTEI);
                  pb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    pb_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv57->size[0];
                  cpu_iv57->size[0] = pb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv57, eint, &xc_emlrtRTEI);
                  itime = pb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(pb_cpu_y, &p_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv57, &gpu_iv57, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&p_gpu_y, pb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel125<<<grid, block>>>(p_gpu_y, itime, gpu_iv57);
                  }

                  xt_size[0] = cpu_iv39->size[0];
                  xt_size[1] = cpu_iv57->size[0];
                  mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1,
                    xt_size[0] - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel126<<<grid, block>>>(b_gpu_yCol, xt_size[0],
                      gpu_iv57, gpu_iv39, xt_size[0] - 1, xt_size[1] - 1,
                      e_gpu_expanded, g_cpu_expanded->size[0U]);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = i_cpu_rows->size[0] * i_cpu_rows->size[1];
                  i_cpu_rows->size[0] = 1;
                  i_cpu_rows->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(i_cpu_rows, eint, &ad_emlrtRTEI);
                  i_cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    i_cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = c_cpu_w->size[0] * c_cpu_w->size[1];
                  c_cpu_w->size[0] = static_cast<int32_T>(N);
                  c_cpu_w->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(c_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (static_cast<int32_T>(N) != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff -
                      1), dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3
                      (static_cast<uint32_T>(lidx), static_cast<uint32_T>(
                      static_cast<int8_T>(cpu_nrefine)), 1U), &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(i_cpu_rows, &d_gpu_rows, false);
                    gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_rows, i_cpu_rows);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel127<<<grid, block>>>(e_gpu_expanded,
                        d_gpu_rows, b_gpu_h, fb_CutOff - 1, nw - 1, d_gpu_w,
                        b_cpu_h->size[0U], g_cpu_expanded->size[0U],
                        c_cpu_w->size[0U]);
                    }
                  }
                }
              }

              if (!(intFsq - 1.0 >= 0.0)) {
                jb_y = nullptr;
                m29 = emlrtCreateCharArray(2, &iv20[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m29, &rfmt[0]);
                emlrtAssign(&jb_y, m29);
                qb_y = nullptr;
                m35 = emlrtCreateDoubleScalar(intFsq - 1.0);
                emlrtAssign(&qb_y, m35);
                emlrt_marshallIn(b_sprintf(jb_y, qb_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              dim = 2;
              if (c_cpu_w->size[0] != 1) {
                dim = 1;
              }

              interval_outdatedOnGpu = false;
              fx_data_outdatedOnCpu = false;
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = c_cpu_w->size[itime];
                fx_data_outdatedOnCpu = true;
                cpu_lshift[itime] = c_cpu_w->size[itime];
                interval_outdatedOnGpu = true;
              }

              if (1 - dim >= 0) {
                cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                  static_cast<real_T>(dim))) / 2.0);
                mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                  &block, 2147483647U);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel99<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                    *gpu_lshift);
                }

                checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              cpu_nrefine = cpu_lshift[0];
              cpu_lshift[0] = cpu_lshift[1];
              cpu_lshift[1] = cpu_nrefine;
              if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
                lidx = 1;
                nw = -1;
              } else {
                lidx = static_cast<int32_T>(intFsq);
                nw = cpu_lshift[0] - 1;
              }

              if (fx_data_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              ec_cwt_kernel100<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
                dim, *gpu_csz);
              eint = n_cpu_w->size[0] * n_cpu_w->size[1];
              n_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              n_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(n_cpu_w, eint, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
                &grid, &block, 2147483647U);
              if (x_data_outdatedOnGpu) {
                gpuEmxEnsureCapacity_real_T(c_cpu_w, &d_gpu_w, true);
              }

              gpuEmxEnsureCapacity_real_T(n_cpu_w, &e_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel101<<<grid, block>>>(d_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_nrefine - 1, e_gpu_w, n_cpu_w->size[0U]);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              eint = eb_cpu_y->size[0] * eb_cpu_y->size[1];
              eb_cpu_y->size[0] = cpu_csz[0];
              eb_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(eb_cpu_y, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(eb_cpu_y, &i_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel102<<<grid, block>>>(e_gpu_w, b_nx, i_gpu_y);
              }

              b_cpu_r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) -
                                    1.0) * cf + static_cast<real_T>
                                   (b_cpu_h->size[0])) / intFsq);
              if (!(cpu_csz[0] < b_cpu_r)) {
                if (b_cpu_r < 1.0) {
                  cpu_nrefine = 0;
                } else {
                  cpu_nrefine = static_cast<int32_T>(b_cpu_r);
                }

                nsubs = v_cpu_w->size[0] * v_cpu_w->size[1];
                v_cpu_w->size[0] = div_s32(nw, lidx) + 1;
                v_cpu_w->size[1] = cpu_lshift[1];
                emxEnsureCapacity_real_T(v_cpu_w, nsubs, &bd_emlrtRTEI);
                itime = nw / lidx;
                mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                  &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(v_cpu_w, &f_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel103<<<grid, block>>>(d_gpu_w, cpu_lshift[0], lidx,
                    itime, cpu_lshift[1] - 1, f_gpu_w, v_cpu_w->size[0U]);
                }

                nsubs = eb_cpu_y->size[0] * eb_cpu_y->size[1];
                eb_cpu_y->size[0] = cpu_nrefine;
                eb_cpu_y->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(eb_cpu_y, nsubs, &uc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                  cpu_nrefine - 1), &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(eb_cpu_y, &i_gpu_y, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel104<<<grid, block>>>(f_gpu_w, cpu_csz[0],
                    cpu_nrefine - 1, cpu_csz[1] - 1, i_gpu_y, eb_cpu_y->size[0U]);
                }
              }
            }

            if (std::isnan(err_ok)) {
              eint = sb_cpu_y->size[0] * sb_cpu_y->size[1];
              sb_cpu_y->size[0] = 1;
              sb_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(sb_cpu_y, eint, &d_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(sb_cpu_y, &j_gpu_y, true);
              f_y_needsGpuEnsureCapacity = false;
              ec_cwt_kernel78<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(j_gpu_y);
            } else if (err_ok < 1.0) {
              sb_cpu_y->size[0] = 1;
              sb_cpu_y->size[1] = 0;
            } else {
              eint = sb_cpu_y->size[0] * sb_cpu_y->size[1];
              sb_cpu_y->size[0] = 1;
              sb_cpu_y->size[1] = static_cast<int32_T>(err_ok - 1.0) + 1;
              emxEnsureCapacity_real_T(sb_cpu_y, eint, &d_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>
                (err_ok - 1.0)), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(sb_cpu_y, &j_gpu_y, true);
              f_y_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel80<<<grid, block>>>(static_cast<int32_T>(err_ok -
                  1.0), j_gpu_y);
              }
            }

            eint = cpu_y1->size[0] * cpu_y1->size[1];
            cpu_y1->size[0] = static_cast<int32_T>(err_ok);
            cpu_y1->size[1] = 1;
            emxEnsureCapacity_real_T(cpu_y1, eint, &bc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(err_ok)
              - 1), &grid, &block, 2147483647U);
            if (f_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(sb_cpu_y, &j_gpu_y, true);
            }

            f_y_needsGpuEnsureCapacity = false;
            gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel79<<<grid, block>>>(i_gpu_y, j_gpu_y, tol,
                static_cast<int32_T>(err_ok) - 1, gpu_y1);
            }
          } else {
            int32_T cpu_csz[2];
            int32_T cpu_lshift[2];
            q_ok = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * cf /
                             intFsq);
            first_iteration = (cpu_opts_x->size[0] == 1);
            if (first_iteration) {
              eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              cpu_opts_x->size[0] *= cpu_opts_x->size[1];
              cpu_opts_x->size[1] = 1;
              emxEnsureCapacity_real_T(cpu_opts_x, eint, &ic_emlrtRTEI);
              opts_x_needsGpuEnsureCapacity = true;
            }

            if (!(cf - 1.0 >= 0.0)) {
              h_y = nullptr;
              m8 = emlrtCreateCharArray(2, &iv9[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m8, &rfmt[0]);
              emlrtAssign(&h_y, m8);
              p_y = nullptr;
              m16 = emlrtCreateDoubleScalar(cf - 1.0);
              emlrtAssign(&p_y, m16);
              emlrt_marshallIn(b_sprintf(h_y, p_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            ix = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
              dim = 0;
            } else {
              dim = 1;
              if (cpu_opts_x->size[0] != 1) {
                dim = 0;
              }
            }

            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = cpu_opts_x->size[itime];
            }

            cpu_nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            eint = f_cpu_yCol->size[0];
            f_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
            emxEnsureCapacity_real_T(f_cpu_yCol, eint, &lc_emlrtRTEI);
            itime = ix * static_cast<int32_T>(cf) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(f_cpu_yCol, &c_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel156<<<grid, block>>>(itime, c_gpu_yCol);
            }

            if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf) >
                   0) && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                   static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                   static_cast<int32_T>(cf) > 1)))) {
              nw = 1;
              cpu_nrefine = 0;
            } else {
              nw = static_cast<int32_T>(cf);
              cpu_nrefine = ix * static_cast<int32_T>(cf);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1, nw)),
              &grid, &block, 2147483647U);
            if (opts_x_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel157<<<grid, block>>>(gpu_opts_x, nw, div_s32
                (cpu_nrefine - 1, nw), c_gpu_yCol);
            }

            cpu_csz[dim] = cpu_opts_x->size[dim] * static_cast<int32_T>(cf);
            eint = i_cpu_x->size[0] * i_cpu_x->size[1];
            i_cpu_x->size[0] = cpu_csz[0];
            i_cpu_x->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(i_cpu_x, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(i_cpu_x, &f_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel158<<<grid, block>>>(c_gpu_yCol, b_nx, f_gpu_x);
            }

            if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (cpu_csz[1] < 1) {
                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = 1;
                f_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel159<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_w);
              } else {
                nsubs = f_cpu_a->size[0];
                f_cpu_a->size[0] = cpu_csz[1];
                emxEnsureCapacity_real_T(f_cpu_a, nsubs, &tc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(f_cpu_a, &d_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel171<<<grid, block>>>(c_gpu_yCol, cpu_csz[1] - 1,
                    d_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
                b_cpu_r = b_cpu_h->data[0];
                eint = e_cpu_c->size[0];
                e_cpu_c->size[0] = f_cpu_a->size[0];
                emxEnsureCapacity_real_T(e_cpu_c, eint, &wc_emlrtRTEI);
                b_nx = f_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_c, &e_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel172<<<grid, block>>>(b_nx, e_gpu_c);
                }

                if (f_cpu_a->size[0] == 1) {
                  cpu_r = b_cpu_h->data[0];
                  eint = e_cpu_c->size[0];
                  e_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(e_cpu_c, eint, &wc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(e_cpu_c, &e_gpu_c, true);
                  ec_cwt_kernel173<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_r, d_gpu_a, e_gpu_c);
                } else {
                  int32_T threadDims[3];
                  lidx = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(f_cpu_a->size[0]) + 1.0) - 1.0));
                  threadDims[0] = static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(static_cast<uint32_T>(f_cpu_a->size[0])
                    + static_cast<uint32_T>(lidx)) - 1.0) / static_cast<real_T>
                     (lidx)));
                  fb_CutOff = f_cpu_a->size[0];
                  if (f_cpu_a->size[0] > 2147483646) {
                    ix = MAX_int32_T;
                  } else {
                    ix = f_cpu_a->size[0] + 1;
                  }

                  eint = k_cpu_expanded->size[0];
                  k_cpu_expanded->size[0] = ix - 1;
                  emxEnsureCapacity_real_T(k_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = f_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(k_cpu_expanded, &j_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel175<<<grid, block>>>(b_nx, j_gpu_expanded);
                  }

                  b_nx = f_cpu_a->size[0];
                  eint = v_cpu_y->size[0] * v_cpu_y->size[1];
                  v_cpu_y->size[0] = 1;
                  v_cpu_y->size[1] = f_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(v_cpu_y, eint, &ad_emlrtRTEI);
                  v_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    v_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv38->size[0];
                  cpu_iv38->size[0] = v_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv38, eint, &xc_emlrtRTEI);
                  itime = v_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(v_cpu_y, &x_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv38, &gpu_iv38, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_y, v_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel176<<<grid, block>>>(x_gpu_y, itime, gpu_iv38);
                  }

                  omega_tmp2[0] = cpu_iv38->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel177<<<grid, block>>>(d_gpu_a, gpu_iv38,
                      omega_tmp2[0] - 1, j_gpu_expanded);
                  }

                  eint = e_cpu_c->size[0];
                  e_cpu_c->size[0] = f_cpu_a->size[0];
                  emxEnsureCapacity_real_T(e_cpu_c, eint, &xc_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(
                    static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_real_T(e_cpu_c, &e_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel178<<<grid, block>>>(b_cpu_r, j_gpu_expanded,
                      fb_CutOff - 1, e_gpu_c);
                  }
                }

                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = 1;
                f_cpu_w->size[1] = e_cpu_c->size[0];
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                b_nx = e_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel174<<<grid, block>>>(e_gpu_c, b_nx, g_gpu_w,
                    f_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > cpu_csz[0]) {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
              }

              if (cpu_csz[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_csz[1];
              }

              eint = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = nsubs;
              f_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel179<<<grid, block>>>(itime, g_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = nsubs;
                f_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel180<<<grid, block>>>(itime, g_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                          (cpu_csz[1] == 1))) {
                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = 1;
                f_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel181<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (c_gpu_yCol, b_gpu_h, g_gpu_w);
              } else {
                real_T blockDims[3];
                int32_T threadDims[3];
                cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                         real_T>(cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, cpu_r);
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_csz[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) +
                  1.0) - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                  static_cast<real_T>(cpu_nrefine));
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                threadDims[0] = eint;
                threadDims[1] = cpu_nrefine;
                nw = cpu_csz[1];
                if (cpu_r < 2.147483648E+9) {
                  if (cpu_r >= -2.147483648E+9) {
                    fb_CutOff = static_cast<int32_T>(cpu_r);
                  } else {
                    fb_CutOff = MIN_int32_T;
                  }
                } else {
                  fb_CutOff = MAX_int32_T;
                }

                fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  dim = static_cast<int32_T>(fc);
                } else {
                  dim = MIN_int32_T;
                }

                if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff)) {
                  ix = MIN_int32_T;
                } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                            - fb_CutOff)) {
                  ix = MAX_int32_T;
                } else {
                  ix = fb_CutOff + cpu_csz[0];
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = q_cpu_expanded->size[0] * q_cpu_expanded->size[1];
                q_cpu_expanded->size[0] = ix;
                emxEnsureCapacity_real_T(q_cpu_expanded, eint, &xc_emlrtRTEI);
                if ((cpu_csz[1] < 0) && (cpu_csz[1] < MIN_int32_T - cpu_csz[1]))
                {
                  ix = MIN_int32_T;
                } else if ((cpu_csz[1] > 0) && (cpu_csz[1] > MAX_int32_T
                            - cpu_csz[1])) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_csz[1] + cpu_csz[1];
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = q_cpu_expanded->size[0] * q_cpu_expanded->size[1];
                q_cpu_expanded->size[1] = ix;
                emxEnsureCapacity_real_T(q_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_csz[1] + cpu_csz[1])
                  - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(q_cpu_expanded, &k_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel182<<<grid, block>>>(b_nx, k_gpu_expanded);
                }

                b_nx = b_cpu_h->size[0];
                eint = db_cpu_y->size[0] * db_cpu_y->size[1];
                db_cpu_y->size[0] = 1;
                db_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(db_cpu_y, eint, &ad_emlrtRTEI);
                db_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  db_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv42->size[0];
                cpu_iv42->size[0] = db_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv42, eint, &xc_emlrtRTEI);
                itime = db_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(db_cpu_y, &y_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv42, &gpu_iv42, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&y_gpu_y, db_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel183<<<grid, block>>>(dim, y_gpu_y, itime,
                    gpu_iv42);
                }

                fc = std::floor(static_cast<real_T>(cpu_csz[1]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_csz[1]) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  cpu_nrefine = static_cast<int32_T>(fc);
                } else {
                  cpu_nrefine = MIN_int32_T;
                }

                omega_tmp2[0] = cpu_iv42->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel184<<<grid, block>>>(b_gpu_h, cpu_nrefine,
                    gpu_iv42, omega_tmp2[0] - 1, k_gpu_expanded,
                    q_cpu_expanded->size[0U]);
                }

                if (cpu_csz[0] < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = cpu_csz[0] - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                interval_outdatedOnGpu = false;
                eint = g_cpu_rows->size[0] * g_cpu_rows->size[1];
                g_cpu_rows->size[0] = 1;
                g_cpu_rows->size[1] = b_nx;
                emxEnsureCapacity_int32_T(g_cpu_rows, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  g_cpu_rows->data[0] = 0;
                  interval_outdatedOnGpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    g_cpu_rows->data[k + 1] = nsubs;
                  }
                }

                if (cpu_csz[1] < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = cpu_csz[1] - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                fx_data_outdatedOnCpu = false;
                eint = e_cpu_cols->size[0] * e_cpu_cols->size[1];
                e_cpu_cols->size[0] = 1;
                e_cpu_cols->size[1] = b_nx;
                emxEnsureCapacity_int32_T(e_cpu_cols, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  e_cpu_cols->data[0] = 0;
                  fx_data_outdatedOnCpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    e_cpu_cols->data[k + 1] = nsubs;
                  }
                }

                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = fb_CutOff;
                f_cpu_w->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(f_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if ((fb_CutOff != 0) && (cpu_csz[1] != 0)) {
                  uint32_T b_u;
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  if (blockDims[1] < 4.294967296E+9) {
                    if (blockDims[1] >= 0.0) {
                      b_u = static_cast<uint32_T>(blockDims[1]);
                    } else {
                      b_u = 0U;
                    }
                  } else if (blockDims[1] >= 4.294967296E+9) {
                    b_u = MAX_uint32_T;
                  } else {
                    b_u = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  nsubs = threadDims[1];
                  if (threadDims[1] < 0) {
                    nsubs = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                    static_cast<uint32_T>(nsubs), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(e_cpu_cols, &b_gpu_cols,
                    !fx_data_outdatedOnCpu);
                  gpuEmxEnsureCapacity_int32_T(g_cpu_rows, &i_gpu_rows,
                    !interval_outdatedOnGpu);
                  gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  if (fx_data_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&b_gpu_cols, e_cpu_cols);
                  }

                  if (interval_outdatedOnGpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&i_gpu_rows, g_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel185<<<grid, block>>>(c_gpu_yCol, k_gpu_expanded,
                      b_gpu_cols, i_gpu_rows, *gpu_csz, fb_CutOff - 1, nw - 1,
                      g_gpu_w, q_cpu_expanded->size[0U], f_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
              }

              if (cpu_csz[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_csz[1];
              }

              eint = f_cpu_w->size[0] * f_cpu_w->size[1];
              f_cpu_w->size[0] = nsubs;
              f_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel186<<<grid, block>>>(itime, g_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = nsubs;
                f_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel187<<<grid, block>>>(itime, g_gpu_w);
                }
              } else if ((cpu_csz[0] == 1) && (cpu_csz[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                eint = m_cpu_c->size[0];
                m_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(m_cpu_c, eint, &vc_emlrtRTEI);
                cpu_r = 1.0;
                b_cpu_r = 0.0;
                gpuEmxEnsureCapacity_real_T(m_cpu_c, &f_gpu_c, true);
                cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                  &f_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                  &b_cpu_r, (double *)&f_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = nsubs;
                f_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(f_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel188<<<grid, block>>>(f_gpu_c, itime, g_gpu_w);
                }
              } else {
                real_T blockDims[3];
                N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                     (b_cpu_h->size[0])) - 1U;
                lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_csz[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) +
                  1.0) - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                  static_cast<real_T>(cpu_nrefine));
                nw = cpu_csz[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                fb_CutOff = static_cast<int32_T>(N);
                dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  ix = MAX_int32_T;
                } else {
                  ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = p_cpu_expanded->size[0] * p_cpu_expanded->size[1];
                p_cpu_expanded->size[0] = ix - 1;
                emxEnsureCapacity_real_T(p_cpu_expanded, eint, &xc_emlrtRTEI);
                if (cpu_csz[1] > 2147483646) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_csz[1] + 1;
                }

                eint = p_cpu_expanded->size[0] * p_cpu_expanded->size[1];
                p_cpu_expanded->size[1] = ix - 1;
                emxEnsureCapacity_real_T(p_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                  cpu_csz[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(p_cpu_expanded, &l_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel189<<<grid, block>>>(b_nx, l_gpu_expanded);
                }

                b_nx = cpu_csz[0];
                eint = y_cpu_y->size[0] * y_cpu_y->size[1];
                y_cpu_y->size[0] = 1;
                y_cpu_y->size[1] = cpu_csz[0];
                emxEnsureCapacity_int32_T(y_cpu_y, eint, &ad_emlrtRTEI);
                y_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  y_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv45->size[0];
                cpu_iv45->size[0] = y_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv45, eint, &xc_emlrtRTEI);
                itime = y_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(y_cpu_y, &ab_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv45, &gpu_iv45, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ab_gpu_y, y_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel190<<<grid, block>>>(dim, ab_gpu_y, itime,
                    gpu_iv45);
                }

                if (cpu_csz[1] < 1) {
                  b_nx = 0;
                } else {
                  b_nx = cpu_csz[1];
                }

                interval_outdatedOnGpu = false;
                eint = yb_cpu_y->size[0] * yb_cpu_y->size[1];
                yb_cpu_y->size[0] = 1;
                yb_cpu_y->size[1] = b_nx;
                emxEnsureCapacity_int32_T(yb_cpu_y, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  yb_cpu_y->data[0] = 1;
                  interval_outdatedOnGpu = true;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    yb_cpu_y->data[k + 1] = nsubs;
                  }
                }

                eint = cpu_iv62->size[0];
                cpu_iv62->size[0] = yb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv62, eint, &xc_emlrtRTEI);
                itime = yb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(yb_cpu_y, &bb_gpu_y,
                  !interval_outdatedOnGpu);
                gpuEmxEnsureCapacity_int32_T(cpu_iv62, &gpu_iv62, true);
                if (interval_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&bb_gpu_y, yb_cpu_y);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel191<<<grid, block>>>(bb_gpu_y, itime, gpu_iv62);
                }

                xt_size[0] = cpu_iv45->size[0];
                xt_size[1] = cpu_iv62->size[0];
                mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel192<<<grid, block>>>(c_gpu_yCol, xt_size[0],
                    gpu_iv62, gpu_iv45, xt_size[0] - 1, xt_size[1] - 1,
                    l_gpu_expanded, p_cpu_expanded->size[0U]);
                }

                b_nx = b_cpu_h->size[0];
                eint = o_cpu_rows->size[0] * o_cpu_rows->size[1];
                o_cpu_rows->size[0] = 1;
                o_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(o_cpu_rows, eint, &ad_emlrtRTEI);
                o_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  o_cpu_rows->data[k + 1] = nsubs;
                }

                eint = f_cpu_w->size[0] * f_cpu_w->size[1];
                f_cpu_w->size[0] = static_cast<int32_T>(N);
                f_cpu_w->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(f_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if ((static_cast<int32_T>(N) != 0) && (cpu_csz[1] != 0)) {
                  uint32_T b_u;
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  if (blockDims[1] < 4.294967296E+9) {
                    if (blockDims[1] >= 0.0) {
                      b_u = static_cast<uint32_T>(blockDims[1]);
                    } else {
                      b_u = 0U;
                    }
                  } else if (blockDims[1] >= 4.294967296E+9) {
                    b_u = MAX_uint32_T;
                  } else {
                    b_u = 0U;
                  }

                  eint = cpu_nrefine;
                  if (cpu_nrefine < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(lidx),
                    static_cast<uint32_T>(eint), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(o_cpu_rows, &j_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&j_gpu_rows, o_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel193<<<grid, block>>>(l_gpu_expanded, j_gpu_rows,
                      b_gpu_h, fb_CutOff - 1, nw - 1, g_gpu_w, b_cpu_h->size[0U],
                      p_cpu_expanded->size[0U], f_cpu_w->size[0U]);
                  }
                }
              }
            }

            if (!(intFsq - 1.0 >= 0.0)) {
              ib_y = nullptr;
              m33 = emlrtCreateCharArray(2, &iv24[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m33, &rfmt[0]);
              emlrtAssign(&ib_y, m33);
              pb_y = nullptr;
              m40 = emlrtCreateDoubleScalar(intFsq - 1.0);
              emlrtAssign(&pb_y, m40);
              emlrt_marshallIn(b_sprintf(ib_y, pb_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            dim = 2;
            if (f_cpu_w->size[0] != 1) {
              dim = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = f_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_lshift[itime] = f_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - dim >= 0) {
              cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                static_cast<real_T>(dim))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel160<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_nrefine = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_nrefine;
            if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
              lidx = 1;
              nw = -1;
            } else {
              lidx = static_cast<int32_T>(intFsq);
              nw = cpu_lshift[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_cwt_kernel161<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
              dim, *gpu_csz);
            eint = s_cpu_w->size[0] * s_cpu_w->size[1];
            s_cpu_w->size[0] = div_s32(nw, lidx) + 1;
            s_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(s_cpu_w, eint, &bd_emlrtRTEI);
            itime = nw / lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real_T(f_cpu_w, &g_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real_T(s_cpu_w, &h_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel162<<<grid, block>>>(g_gpu_w, cpu_lshift[0], lidx,
                itime, cpu_nrefine - 1, h_gpu_w, s_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = jb_cpu_y->size[0] * jb_cpu_y->size[1];
            jb_cpu_y->size[0] = cpu_csz[0];
            jb_cpu_y->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(jb_cpu_y, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(jb_cpu_y, &u_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel163<<<grid, block>>>(h_gpu_w, b_nx, u_gpu_y);
            }

            b_cpu_r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0)
                                 * cf + static_cast<real_T>(b_cpu_h->size[0])) /
                                intFsq);
            if (!(cpu_csz[0] < b_cpu_r)) {
              if (b_cpu_r < 1.0) {
                cpu_nrefine = 0;
              } else {
                cpu_nrefine = static_cast<int32_T>(b_cpu_r);
              }

              nsubs = bb_cpu_w->size[0] * bb_cpu_w->size[1];
              bb_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              bb_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real_T(bb_cpu_w, nsubs, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(bb_cpu_w, &i_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel164<<<grid, block>>>(g_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_lshift[1] - 1, i_gpu_w, bb_cpu_w->size[0U]);
              }

              nsubs = jb_cpu_y->size[0] * jb_cpu_y->size[1];
              jb_cpu_y->size[0] = cpu_nrefine;
              jb_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(jb_cpu_y, nsubs, &uc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                cpu_nrefine - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(jb_cpu_y, &u_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel165<<<grid, block>>>(i_gpu_w, cpu_csz[0],
                  cpu_nrefine - 1, cpu_csz[1] - 1, u_gpu_y, jb_cpu_y->size[0U]);
              }
            }

            if (first_iteration) {
              omega_tmp2[0] = jb_cpu_y->size[0] * jb_cpu_y->size[1];
              eint = kd_cpu_y->size[0] * kd_cpu_y->size[1];
              kd_cpu_y->size[0] = 1;
              kd_cpu_y->size[1] = omega_tmp2[0];
              emxEnsureCapacity_real_T(kd_cpu_y, eint, &cd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(kd_cpu_y, &v_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel166<<<grid, block>>>(u_gpu_y, omega_tmp2[0] - 1,
                  v_gpu_y, kd_cpu_y->size[0U]);
              }

              eint = jb_cpu_y->size[0] * jb_cpu_y->size[1];
              jb_cpu_y->size[0] = 1;
              jb_cpu_y->size[1] = kd_cpu_y->size[1];
              emxEnsureCapacity_real_T(jb_cpu_y, eint, &ed_emlrtRTEI);
              itime = kd_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(jb_cpu_y, &u_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel167<<<grid, block>>>(v_gpu_y, itime, u_gpu_y);
              }
            }

            if (std::isnan(q_ok)) {
              eint = ec_cpu_y->size[0] * ec_cpu_y->size[1];
              ec_cpu_y->size[0] = 1;
              ec_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(ec_cpu_y, eint, &d_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(ec_cpu_y, &w_gpu_y, true);
              i_y_needsGpuEnsureCapacity = false;
              ec_cwt_kernel168<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(w_gpu_y);
            } else if (q_ok < 1.0) {
              ec_cpu_y->size[0] = 1;
              ec_cpu_y->size[1] = 0;
            } else {
              eint = ec_cpu_y->size[0] * ec_cpu_y->size[1];
              ec_cpu_y->size[0] = 1;
              ec_cpu_y->size[1] = static_cast<int32_T>(q_ok - 1.0) + 1;
              emxEnsureCapacity_real_T(ec_cpu_y, eint, &d_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(q_ok
                - 1.0)), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(ec_cpu_y, &w_gpu_y, true);
              i_y_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel170<<<grid, block>>>(static_cast<int32_T>(q_ok -
                  1.0), w_gpu_y);
              }
            }

            cpu_nrefine = jb_cpu_y->size[1];
            eint = cpu_y1->size[0] * cpu_y1->size[1];
            cpu_y1->size[0] = ec_cpu_y->size[1];
            cpu_y1->size[1] = jb_cpu_y->size[1];
            emxEnsureCapacity_real_T(cpu_y1, eint, &bc_emlrtRTEI);
            itime = ec_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (i_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(ec_cpu_y, &w_gpu_y, true);
            }

            i_y_needsGpuEnsureCapacity = false;
            gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel169<<<grid, block>>>(u_gpu_y, w_gpu_y, tol, itime,
                cpu_nrefine - 1, gpu_y1, cpu_y1->size[0U], jb_cpu_y->size[0U]);
            }
          }

          if ((cpu_y1->size[0] == 0) || (cpu_y1->size[1] == 0)) {
            nw = 0;
          } else {
            ix = cpu_y1->size[0];
            nw = cpu_y1->size[1];
            if (ix >= nw) {
              nw = ix;
            }
          }

          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = 1;
          cpu_opts_x->size[1] = nw;
          emxEnsureCapacity_real_T(cpu_opts_x, eint, &nc_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(nw - 1), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel62<<<grid, block>>>(gpu_y1, nw - 1, gpu_opts_x);
          }
        } else if ((!(cf == 1.0)) || (!(intFsq == 1.0))) {
          if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
            if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
              nw = 0;
            } else {
              ix = cpu_opts_x->size[0];
              nw = cpu_opts_x->size[1];
              if (ix >= nw) {
                nw = ix;
              }
            }

            err_ok = std::ceil(static_cast<real_T>(nw) * cf / intFsq);
            if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
              int32_T cpu_csz[2];
              int32_T cpu_lshift[2];
              if (!(cf - 1.0 >= 0.0)) {
                l_y = nullptr;
                m18 = emlrtCreateCharArray(2, &iv15[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m18, &rfmt[0]);
                emlrtAssign(&l_y, m18);
                u_y = nullptr;
                m24 = emlrtCreateDoubleScalar(cf - 1.0);
                emlrtAssign(&u_y, m24);
                emlrt_marshallIn(b_sprintf(l_y, u_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              eint = h_cpu_yCol->size[0];
              h_cpu_yCol->size[0] = static_cast<int32_T>(cf);
              emxEnsureCapacity_real_T(h_cpu_yCol, eint, &lc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(cf) -
                1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(h_cpu_yCol, &d_gpu_yCol, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel222<<<grid, block>>>(static_cast<int32_T>(cf) - 1,
                  d_gpu_yCol);
              }

              if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf)
                     > 0) && (static_cast<int32_T>(cf) < 1)) ||
                   ((static_cast<int32_T>(cf) < 0) && (static_cast<int32_T>(cf) >
                     1)))) {
                nw = 1;
                cpu_nrefine = 0;
              } else {
                nw = static_cast<int32_T>(cf);
                cpu_nrefine = static_cast<int32_T>(cf);
              }

              mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1,
                nw)), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel223<<<grid, block>>>(gpu_opts_x, nw, div_s32
                  (cpu_nrefine - 1, nw), d_gpu_yCol);
              }

              ec_cwt_kernel224<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cf,
                *gpu_csz);
              eint = k_cpu_x->size[0] * k_cpu_x->size[1];
              k_cpu_x->size[0] = static_cast<int32_T>(cf);
              k_cpu_x->size[1] = 1;
              emxEnsureCapacity_real_T(k_cpu_x, eint, &rc_emlrtRTEI);
              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(k_cpu_x, &g_gpu_x, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel225<<<grid, block>>>(d_gpu_yCol, cpu_csz[0] - 1,
                  g_gpu_x);
              }

              if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                eint = h_cpu_a->size[0];
                h_cpu_a->size[0] = 1;
                emxEnsureCapacity_real_T(h_cpu_a, eint, &tc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(h_cpu_a, &e_gpu_a, true);
                ec_cwt_kernel226<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (b_gpu_h, d_gpu_yCol, gpu_r, e_gpu_a);
                eint = g_cpu_c->size[0];
                g_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(g_cpu_c, eint, &wc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(g_cpu_c, &g_gpu_c, true);
                ec_cwt_kernel227<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(gpu_r,
                  e_gpu_a, g_gpu_c);
                eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = 1;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel228<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (g_gpu_c, j_gpu_w);
              } else if (b_cpu_h->size[0] > cpu_csz[0]) {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
                }

                eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = nsubs;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel240<<<grid, block>>>(nsubs - 1, j_gpu_w);
                }

                if (cpu_csz[0] == 0) {
                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = nsubs;
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel241<<<grid, block>>>(nsubs - 1, j_gpu_w);
                  }
                } else if ((b_cpu_h->size[0] == 1) && (cpu_csz[0] == 1)) {
                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = 1;
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel242<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (d_gpu_yCol, b_gpu_h, j_gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                           real_T>(cpu_csz[0])) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                    floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                  if (fc >= -2.147483648E+9) {
                    dim = static_cast<int32_T>(fc);
                  } else {
                    dim = MIN_int32_T;
                  }

                  if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff))
                  {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                              - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + cpu_csz[0];
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = v_cpu_expanded->size[0] * v_cpu_expanded->size[1];
                  v_cpu_expanded->size[0] = ix;
                  v_cpu_expanded->size[1] = 1;
                  emxEnsureCapacity_real_T(v_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = (fb_CutOff + cpu_csz[0]) - 2;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(v_cpu_expanded, &q_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel243<<<grid, block>>>(b_nx, q_gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = ob_cpu_y->size[0] * ob_cpu_y->size[1];
                  ob_cpu_y->size[0] = 1;
                  ob_cpu_y->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(ob_cpu_y, eint, &ad_emlrtRTEI);
                  ob_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    ob_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv51->size[0];
                  cpu_iv51->size[0] = ob_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv51, eint, &xc_emlrtRTEI);
                  itime = ob_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(ob_cpu_y, &kb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv51, &gpu_iv51, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&kb_gpu_y, ob_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel244<<<grid, block>>>(dim, kb_gpu_y, itime,
                      gpu_iv51);
                  }

                  omega_tmp2[0] = cpu_iv51->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel245<<<grid, block>>>(b_gpu_h, gpu_iv51,
                      omega_tmp2[0] - 1, q_gpu_expanded);
                  }

                  if (cpu_csz[0] < -2147483647) {
                    ix = MIN_int32_T;
                  } else {
                    ix = cpu_csz[0] - 1;
                  }

                  if (ix < 0) {
                    b_nx = 0;
                  } else {
                    b_nx = ix + 1;
                  }

                  interval_outdatedOnGpu = false;
                  eint = k_cpu_rows->size[0] * k_cpu_rows->size[1];
                  k_cpu_rows->size[0] = 1;
                  k_cpu_rows->size[1] = b_nx;
                  emxEnsureCapacity_int32_T(k_cpu_rows, eint, &ad_emlrtRTEI);
                  if (b_nx > 0) {
                    k_cpu_rows->data[0] = 0;
                    interval_outdatedOnGpu = true;
                    nsubs = 0;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      k_cpu_rows->data[k + 1] = nsubs;
                    }
                  }

                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = fb_CutOff;
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (fb_CutOff != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    eint = threadDims[0];
                    if (threadDims[0] < 0) {
                      eint = 0;
                    }

                    mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                      dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(k_cpu_rows, &o_gpu_rows,
                      !interval_outdatedOnGpu);
                    gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    if (interval_outdatedOnGpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&o_gpu_rows, k_cpu_rows);
                    }

                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel246<<<grid, block>>>(d_gpu_yCol,
                        q_gpu_expanded, o_gpu_rows, *gpu_csz, fb_CutOff - 1,
                        j_gpu_w);
                    }
                  }
                }
              } else {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
                }

                eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                i_cpu_w->size[0] = nsubs;
                i_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel247<<<grid, block>>>(nsubs - 1, j_gpu_w);
                }

                if (cpu_csz[0] == 0) {
                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = nsubs;
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel248<<<grid, block>>>(nsubs - 1, j_gpu_w);
                  }
                } else if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                  eint = o_cpu_c->size[0];
                  o_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(o_cpu_c, eint, &vc_emlrtRTEI);
                  cpu_r = 1.0;
                  b_cpu_r = 0.0;
                  gpuEmxEnsureCapacity_real_T(o_cpu_c, &h_gpu_c, true);
                  cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                    CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                    &g_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                    &b_cpu_r, (double *)&h_gpu_c.data[0], 1), __FILE__, __LINE__);
                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = nsubs;
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &rc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel249<<<grid, block>>>(h_gpu_c, nsubs - 1,
                      j_gpu_w);
                  }
                } else {
                  real_T blockDims[3];
                  N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                       (b_cpu_h->size[0])) - 1U;
                  lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                    (N)));
                  blockDims[0] = std::floor((static_cast<real_T>(N) + (
                    static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                  if (N > 2147483647U) {
                    N = 2147483647U;
                  }

                  fb_CutOff = static_cast<int32_T>(N);
                  dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                    (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                  if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                       MAX_int32_T - static_cast<int32_T>(N))) {
                    ix = MAX_int32_T;
                  } else {
                    ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                  }

                  eint = u_cpu_expanded->size[0] * u_cpu_expanded->size[1];
                  u_cpu_expanded->size[0] = ix - 1;
                  u_cpu_expanded->size[1] = 1;
                  emxEnsureCapacity_real_T(u_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(u_cpu_expanded, &r_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel250<<<grid, block>>>(b_nx, r_gpu_expanded);
                  }

                  b_nx = cpu_csz[0];
                  eint = lb_cpu_y->size[0] * lb_cpu_y->size[1];
                  lb_cpu_y->size[0] = 1;
                  lb_cpu_y->size[1] = cpu_csz[0];
                  emxEnsureCapacity_int32_T(lb_cpu_y, eint, &ad_emlrtRTEI);
                  lb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    lb_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv53->size[0];
                  cpu_iv53->size[0] = lb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv53, eint, &xc_emlrtRTEI);
                  itime = lb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(lb_cpu_y, &lb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv53, &gpu_iv53, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&lb_gpu_y, lb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel251<<<grid, block>>>(dim, lb_gpu_y, itime,
                      gpu_iv53);
                  }

                  xt_size[0] = cpu_iv53->size[0];
                  mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel252<<<grid, block>>>(d_gpu_yCol, gpu_iv53,
                      xt_size[0] - 1, r_gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = x_cpu_rows->size[0] * x_cpu_rows->size[1];
                  x_cpu_rows->size[0] = 1;
                  x_cpu_rows->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(x_cpu_rows, eint, &ad_emlrtRTEI);
                  x_cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    x_cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = i_cpu_w->size[0] * i_cpu_w->size[1];
                  i_cpu_w->size[0] = static_cast<int32_T>(N);
                  i_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(i_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (static_cast<int32_T>(N) != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                      dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(lidx), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(x_cpu_rows, &p_gpu_rows, false);
                    gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&p_gpu_rows, x_cpu_rows);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel253<<<grid, block>>>(r_gpu_expanded,
                        p_gpu_rows, b_gpu_h, fb_CutOff - 1, j_gpu_w,
                        b_cpu_h->size[0U]);
                    }
                  }
                }
              }

              if (!(intFsq - 1.0 >= 0.0)) {
                kb_y = nullptr;
                m41 = emlrtCreateCharArray(2, &iv26[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m41, &rfmt[0]);
                emlrtAssign(&kb_y, m41);
                rb_y = nullptr;
                m45 = emlrtCreateDoubleScalar(intFsq - 1.0);
                emlrtAssign(&rb_y, m45);
                emlrt_marshallIn(b_sprintf(kb_y, rb_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              dim = 2;
              if (i_cpu_w->size[0] != 1) {
                dim = 1;
              }

              interval_outdatedOnGpu = false;
              fx_data_outdatedOnCpu = false;
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = i_cpu_w->size[itime];
                fx_data_outdatedOnCpu = true;
                cpu_lshift[itime] = i_cpu_w->size[itime];
                interval_outdatedOnGpu = true;
              }

              if (1 - dim >= 0) {
                cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                  static_cast<real_T>(dim))) / 2.0);
                mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                  &block, 2147483647U);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel229<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                    *gpu_lshift);
                }

                checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              cpu_nrefine = cpu_lshift[0];
              cpu_lshift[0] = cpu_lshift[1];
              cpu_lshift[1] = cpu_nrefine;
              if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
                lidx = 1;
                nw = -1;
              } else {
                lidx = static_cast<int32_T>(intFsq);
                nw = cpu_lshift[0] - 1;
              }

              if (fx_data_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              ec_cwt_kernel230<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
                dim, *gpu_csz);
              eint = o_cpu_w->size[0] * o_cpu_w->size[1];
              o_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              o_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(o_cpu_w, eint, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
                &grid, &block, 2147483647U);
              if (x_data_outdatedOnGpu) {
                gpuEmxEnsureCapacity_real_T(i_cpu_w, &j_gpu_w, true);
              }

              gpuEmxEnsureCapacity_real_T(o_cpu_w, &k_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel231<<<grid, block>>>(j_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_nrefine - 1, k_gpu_w, o_cpu_w->size[0U]);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              eint = xb_cpu_y->size[0] * xb_cpu_y->size[1];
              xb_cpu_y->size[0] = cpu_csz[0];
              xb_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(xb_cpu_y, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(xb_cpu_y, &gb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel232<<<grid, block>>>(k_gpu_w, b_nx, gb_gpu_y);
              }

              b_cpu_r = std::ceil((0.0 * cf + static_cast<real_T>(b_cpu_h->size
                [0])) / intFsq);
              if (!(cpu_csz[0] < b_cpu_r)) {
                if (b_cpu_r < 1.0) {
                  cpu_nrefine = 0;
                } else {
                  cpu_nrefine = static_cast<int32_T>(b_cpu_r);
                }

                nsubs = w_cpu_w->size[0] * w_cpu_w->size[1];
                w_cpu_w->size[0] = div_s32(nw, lidx) + 1;
                w_cpu_w->size[1] = cpu_lshift[1];
                emxEnsureCapacity_real_T(w_cpu_w, nsubs, &bd_emlrtRTEI);
                itime = nw / lidx;
                mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                  &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(w_cpu_w, &l_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel233<<<grid, block>>>(j_gpu_w, cpu_lshift[0], lidx,
                    itime, cpu_lshift[1] - 1, l_gpu_w, w_cpu_w->size[0U]);
                }

                nsubs = xb_cpu_y->size[0] * xb_cpu_y->size[1];
                xb_cpu_y->size[0] = cpu_nrefine;
                xb_cpu_y->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(xb_cpu_y, nsubs, &uc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                  cpu_nrefine - 1), &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(xb_cpu_y, &gb_gpu_y, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel234<<<grid, block>>>(l_gpu_w, cpu_csz[0],
                    cpu_nrefine - 1, cpu_csz[1] - 1, gb_gpu_y, xb_cpu_y->size[0U]);
                }
              }

              if (xb_cpu_y->size[0] * xb_cpu_y->size[1] == 0) {
                b_nx = 0;
              } else {
                b_nx = xb_cpu_y->size[0] * xb_cpu_y->size[1];
              }

              omega_tmp2[0] = xb_cpu_y->size[0] * xb_cpu_y->size[1];
              eint = jd_cpu_y->size[0] * jd_cpu_y->size[1];
              jd_cpu_y->size[0] = 1;
              jd_cpu_y->size[1] = omega_tmp2[0];
              emxEnsureCapacity_real_T(jd_cpu_y, eint, &cd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(jd_cpu_y, &hb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel235<<<grid, block>>>(gb_gpu_y, omega_tmp2[0] - 1,
                  hb_gpu_y);
              }

              eint = cb_cpu_y->size[0] * cb_cpu_y->size[1];
              cb_cpu_y->size[0] = b_nx;
              cb_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(cb_cpu_y, eint, &dd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(b_nx - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(cb_cpu_y, &ib_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel236<<<grid, block>>>(hb_gpu_y, b_nx - 1, ib_gpu_y);
              }
            } else {
              int32_T cpu_csz[2];
              int32_T cpu_lshift[2];
              if (!(cf - 1.0 >= 0.0)) {
                k_y = nullptr;
                m7 = emlrtCreateCharArray(2, &iv8[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m7, &rfmt[0]);
                emlrtAssign(&k_y, m7);
                t_y = nullptr;
                m15 = emlrtCreateDoubleScalar(cf - 1.0);
                emlrtAssign(&t_y, m15);
                emlrt_marshallIn(b_sprintf(k_y, t_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              ix = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = cpu_opts_x->size[itime];
              }

              cpu_nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              eint = b_cpu_yCol->size[0];
              b_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
              emxEnsureCapacity_real_T(b_cpu_yCol, eint, &lc_emlrtRTEI);
              itime = ix * static_cast<int32_T>(cf) - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(b_cpu_yCol, &e_gpu_yCol, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel254<<<grid, block>>>(itime, e_gpu_yCol);
              }

              if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf)
                     > 0) && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                     static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                     static_cast<int32_T>(cf) > 1)))) {
                nw = 1;
                cpu_nrefine = 0;
              } else {
                nw = static_cast<int32_T>(cf);
                cpu_nrefine = ix * static_cast<int32_T>(cf);
              }

              mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1,
                nw)), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel255<<<grid, block>>>(gpu_opts_x, nw, div_s32
                  (cpu_nrefine - 1, nw), e_gpu_yCol);
              }

              cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(cf);
              eint = e_cpu_x->size[0] * e_cpu_x->size[1];
              e_cpu_x->size[0] = cpu_csz[0];
              e_cpu_x->size[1] = cpu_opts_x->size[1];
              emxEnsureCapacity_real_T(e_cpu_x, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_opts_x->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(e_cpu_x, &h_gpu_x, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel256<<<grid, block>>>(e_gpu_yCol, b_nx, h_gpu_x);
              }

              if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
                if (cpu_opts_x->size[1] < 1) {
                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = 1;
                  b_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel257<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (m_gpu_w);
                } else {
                  eint = cpu_opts_x->size[1];
                  nsubs = b_cpu_a->size[0];
                  b_cpu_a->size[0] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(b_cpu_a, nsubs, &tc_emlrtRTEI);
                  mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid,
                    &block, 2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_a, &f_gpu_a, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel264<<<grid, block>>>(e_gpu_yCol, eint - 1,
                      f_gpu_a);
                  }

                  gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
                  q_ok = b_cpu_h->data[0];
                  eint = cpu_c->size[0];
                  cpu_c->size[0] = b_cpu_a->size[0];
                  emxEnsureCapacity_real_T(cpu_c, eint, &wc_emlrtRTEI);
                  b_nx = b_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(cpu_c, &i_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel265<<<grid, block>>>(b_nx, i_gpu_c);
                  }

                  if (b_cpu_a->size[0] == 1) {
                    cpu_r = b_cpu_h->data[0];
                    eint = cpu_c->size[0];
                    cpu_c->size[0] = 1;
                    emxEnsureCapacity_real_T(cpu_c, eint, &wc_emlrtRTEI);
                    gpuEmxEnsureCapacity_real_T(cpu_c, &i_gpu_c, true);
                    ec_cwt_kernel266<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                      (cpu_r, f_gpu_a, i_gpu_c);
                  } else {
                    int32_T threadDims[3];
                    lidx = static_cast<int32_T>(std::fmin(32.0,
                      (static_cast<real_T>(b_cpu_a->size[0]) + 1.0) - 1.0));
                    threadDims[0] = static_cast<int32_T>(std::floor(static_cast<
                      real_T>((static_cast<uint32_T>(b_cpu_a->size[0]) +
                               static_cast<uint32_T>(lidx)) - 1U) /
                      static_cast<real_T>(lidx)));
                    fb_CutOff = b_cpu_a->size[0];
                    if (b_cpu_a->size[0] > 2147483646) {
                      ix = MAX_int32_T;
                    } else {
                      ix = b_cpu_a->size[0] + 1;
                    }

                    eint = c_cpu_expanded->size[0];
                    c_cpu_expanded->size[0] = ix - 1;
                    emxEnsureCapacity_real_T(c_cpu_expanded, eint, &xc_emlrtRTEI);
                    b_nx = b_cpu_a->size[0] - 1;
                    mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                      2147483647U);
                    gpuEmxEnsureCapacity_real_T(c_cpu_expanded, &s_gpu_expanded,
                      true);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel268<<<grid, block>>>(b_nx, s_gpu_expanded);
                    }

                    b_nx = b_cpu_a->size[0];
                    eint = n_cpu_y->size[0] * n_cpu_y->size[1];
                    n_cpu_y->size[0] = 1;
                    n_cpu_y->size[1] = b_cpu_a->size[0];
                    emxEnsureCapacity_int32_T(n_cpu_y, eint, &ad_emlrtRTEI);
                    n_cpu_y->data[0] = 1;
                    nsubs = 1;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      n_cpu_y->data[k + 1] = nsubs;
                    }

                    eint = cpu_iv31->size[0];
                    cpu_iv31->size[0] = n_cpu_y->size[1];
                    emxEnsureCapacity_int32_T(cpu_iv31, eint, &xc_emlrtRTEI);
                    itime = n_cpu_y->size[1] - 1;
                    mwGetLaunchParameters1D(computeNumIters(itime), &grid,
                      &block, 2147483647U);
                    gpuEmxEnsureCapacity_int32_T(n_cpu_y, &mb_gpu_y, false);
                    gpuEmxEnsureCapacity_int32_T(cpu_iv31, &gpu_iv31, true);
                    gpuEmxMemcpyCpuToGpu_int32_T(&mb_gpu_y, n_cpu_y);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel269<<<grid, block>>>(mb_gpu_y, itime,
                        gpu_iv31);
                    }

                    omega_tmp2[0] = cpu_iv31->size[0];
                    mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                      &grid, &block, 2147483647U);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel270<<<grid, block>>>(f_gpu_a, gpu_iv31,
                        omega_tmp2[0] - 1, s_gpu_expanded);
                    }

                    eint = cpu_c->size[0];
                    cpu_c->size[0] = b_cpu_a->size[0];
                    emxEnsureCapacity_real_T(cpu_c, eint, &xc_emlrtRTEI);
                    mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3
                      (static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                      static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                      &grid, &block);
                    gpuEmxEnsureCapacity_real_T(cpu_c, &i_gpu_c, true);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel271<<<grid, block>>>(q_ok, s_gpu_expanded,
                        fb_CutOff - 1, i_gpu_c);
                    }
                  }

                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = 1;
                  b_cpu_w->size[1] = cpu_c->size[0];
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  b_nx = cpu_c->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel267<<<grid, block>>>(i_gpu_c, b_nx, m_gpu_w,
                      b_cpu_w->size[0U]);
                  }
                }
              } else if (b_cpu_h->size[0] > cpu_csz[0]) {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
                }

                if (cpu_opts_x->size[1] == 0) {
                  cpu_nrefine = 1;
                } else {
                  cpu_nrefine = cpu_opts_x->size[1];
                }

                eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = nsubs;
                b_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel272<<<grid, block>>>(itime, m_gpu_w);
                }

                if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = nsubs;
                  b_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel273<<<grid, block>>>(itime, m_gpu_w);
                  }
                } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                            (cpu_opts_x->size[1] == 1))) {
                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = 1;
                  b_cpu_w->size[1] = 1;
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  ec_cwt_kernel274<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (e_gpu_yCol, b_gpu_h, m_gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                           real_T>(cpu_csz[0])) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (
                    static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  blockDims[1] = std::floor(static_cast<real_T>((static_cast<
                    uint32_T>(cpu_opts_x->size[1]) + static_cast<uint32_T>
                    (cpu_nrefine)) - 1U) / static_cast<real_T>(cpu_nrefine));
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  threadDims[1] = cpu_nrefine;
                  nw = cpu_opts_x->size[1];
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                    floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                  if (fc >= -2.147483648E+9) {
                    dim = static_cast<int32_T>(fc);
                  } else {
                    dim = MIN_int32_T;
                  }

                  if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff))
                  {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                              - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + cpu_csz[0];
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = f_cpu_expanded->size[0] * f_cpu_expanded->size[1];
                  f_cpu_expanded->size[0] = ix;
                  emxEnsureCapacity_real_T(f_cpu_expanded, eint, &xc_emlrtRTEI);
                  if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                    ix = MAX_int32_T;
                  } else {
                    ix = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                  }

                  eint = f_cpu_expanded->size[0] * f_cpu_expanded->size[1];
                  f_cpu_expanded->size[1] = ix - 1;
                  emxEnsureCapacity_real_T(f_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_opts_x->size[1]
                    + cpu_opts_x->size[1]) - 1) - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(f_cpu_expanded, &t_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel275<<<grid, block>>>(b_nx, t_gpu_expanded);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = r_cpu_y->size[0] * r_cpu_y->size[1];
                  r_cpu_y->size[0] = 1;
                  r_cpu_y->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(r_cpu_y, eint, &ad_emlrtRTEI);
                  r_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    r_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv33->size[0];
                  cpu_iv33->size[0] = r_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv33, eint, &xc_emlrtRTEI);
                  itime = r_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(r_cpu_y, &nb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv33, &gpu_iv33, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&nb_gpu_y, r_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel276<<<grid, block>>>(dim, nb_gpu_y, itime,
                      gpu_iv33);
                  }

                  cpu_nrefine = static_cast<int32_T>(std::floor(static_cast<
                    real_T>(cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>
                    (std::floor((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0)
                                / 2.0));
                  omega_tmp2[0] = cpu_iv33->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel277<<<grid, block>>>(b_gpu_h, cpu_nrefine,
                      gpu_iv33, omega_tmp2[0] - 1, t_gpu_expanded,
                      f_cpu_expanded->size[0U]);
                  }

                  if (cpu_csz[0] < -2147483647) {
                    ix = MIN_int32_T;
                  } else {
                    ix = cpu_csz[0] - 1;
                  }

                  if (ix < 0) {
                    b_nx = 0;
                  } else {
                    b_nx = ix + 1;
                  }

                  interval_outdatedOnGpu = false;
                  eint = c_cpu_rows->size[0] * c_cpu_rows->size[1];
                  c_cpu_rows->size[0] = 1;
                  c_cpu_rows->size[1] = b_nx;
                  emxEnsureCapacity_int32_T(c_cpu_rows, eint, &ad_emlrtRTEI);
                  if (b_nx > 0) {
                    c_cpu_rows->data[0] = 0;
                    interval_outdatedOnGpu = true;
                    nsubs = 0;
                    for (k = 0; k <= b_nx - 2; k++) {
                      nsubs++;
                      c_cpu_rows->data[k + 1] = nsubs;
                    }
                  }

                  b_nx = cpu_opts_x->size[1];
                  eint = cpu_cols->size[0] * cpu_cols->size[1];
                  cpu_cols->size[0] = 1;
                  cpu_cols->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_int32_T(cpu_cols, eint, &ad_emlrtRTEI);
                  cpu_cols->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    cpu_cols->data[k + 1] = nsubs;
                  }

                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = fb_CutOff;
                  b_cpu_w->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (fb_CutOff != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    eint = threadDims[0];
                    if (threadDims[0] < 0) {
                      eint = 0;
                    }

                    mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff -
                      1), dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3
                      (static_cast<uint32_T>(eint), static_cast<uint32_T>
                       (threadDims[1]), 1U), &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(cpu_cols, &c_gpu_cols, false);
                    gpuEmxEnsureCapacity_int32_T(c_cpu_rows, &q_gpu_rows,
                      !interval_outdatedOnGpu);
                    gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&c_gpu_cols, cpu_cols);
                    if (interval_outdatedOnGpu) {
                      gpuEmxMemcpyCpuToGpu_int32_T(&q_gpu_rows, c_cpu_rows);
                    }

                    checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                      cudaMemcpyHostToDevice), __FILE__, __LINE__);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel278<<<grid, block>>>(e_gpu_yCol,
                        t_gpu_expanded, c_gpu_cols, q_gpu_rows, *gpu_csz,
                        fb_CutOff - 1, nw - 1, m_gpu_w, f_cpu_expanded->size[0U],
                        b_cpu_w->size[0U]);
                    }
                  }
                }
              } else {
                if (cpu_csz[0] == 0) {
                  nsubs = b_cpu_h->size[0];
                } else {
                  nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
                }

                if (cpu_opts_x->size[1] == 0) {
                  cpu_nrefine = 1;
                } else {
                  cpu_nrefine = cpu_opts_x->size[1];
                }

                eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                b_cpu_w->size[0] = nsubs;
                b_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel279<<<grid, block>>>(itime, m_gpu_w);
                }

                if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = nsubs;
                  b_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel280<<<grid, block>>>(itime, m_gpu_w);
                  }
                } else if ((cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                           (b_cpu_h->size[0] == 1)) {
                  eint = i_cpu_c->size[0];
                  i_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(i_cpu_c, eint, &vc_emlrtRTEI);
                  cpu_r = 1.0;
                  b_cpu_r = 0.0;
                  gpuEmxEnsureCapacity_real_T(i_cpu_c, &j_gpu_c, true);
                  cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                    CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                    &h_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                    &b_cpu_r, (double *)&j_gpu_c.data[0], 1), __FILE__, __LINE__);
                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = nsubs;
                  b_cpu_w->size[1] = cpu_nrefine;
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &rc_emlrtRTEI);
                  itime = nsubs * cpu_nrefine - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel281<<<grid, block>>>(j_gpu_c, itime, m_gpu_w);
                  }
                } else {
                  real_T blockDims[3];
                  N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                       (b_cpu_h->size[0])) - 1U;
                  lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                    (N)));
                  cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (
                    static_cast<real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                  blockDims[0] = std::floor((static_cast<real_T>(N) + (
                    static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                  blockDims[1] = std::floor(static_cast<real_T>
                    ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                      static_cast<uint32_T>(cpu_nrefine)) - 1U) /
                    static_cast<real_T>(cpu_nrefine));
                  nw = cpu_opts_x->size[1];
                  if (N > 2147483647U) {
                    N = 2147483647U;
                  }

                  fb_CutOff = static_cast<int32_T>(N);
                  dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                    (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                  if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                       MAX_int32_T - static_cast<int32_T>(N))) {
                    ix = MAX_int32_T;
                  } else {
                    ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                  }

                  eint = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
                  e_cpu_expanded->size[0] = ix - 1;
                  emxEnsureCapacity_real_T(e_cpu_expanded, eint, &xc_emlrtRTEI);
                  if (cpu_opts_x->size[1] > 2147483646) {
                    ix = MAX_int32_T;
                  } else {
                    ix = cpu_opts_x->size[1] + 1;
                  }

                  eint = e_cpu_expanded->size[0] * e_cpu_expanded->size[1];
                  e_cpu_expanded->size[1] = ix - 1;
                  emxEnsureCapacity_real_T(e_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                    cpu_opts_x->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(e_cpu_expanded, &u_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel282<<<grid, block>>>(b_nx, u_gpu_expanded);
                  }

                  b_nx = cpu_csz[0];
                  eint = p_cpu_y->size[0] * p_cpu_y->size[1];
                  p_cpu_y->size[0] = 1;
                  p_cpu_y->size[1] = cpu_csz[0];
                  emxEnsureCapacity_int32_T(p_cpu_y, eint, &ad_emlrtRTEI);
                  p_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    p_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv37->size[0];
                  cpu_iv37->size[0] = p_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv37, eint, &xc_emlrtRTEI);
                  itime = p_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(p_cpu_y, &ob_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv37, &gpu_iv37, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&ob_gpu_y, p_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel283<<<grid, block>>>(dim, ob_gpu_y, itime,
                      gpu_iv37);
                  }

                  b_nx = cpu_opts_x->size[1];
                  eint = nb_cpu_y->size[0] * nb_cpu_y->size[1];
                  nb_cpu_y->size[0] = 1;
                  nb_cpu_y->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_int32_T(nb_cpu_y, eint, &ad_emlrtRTEI);
                  nb_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    nb_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv56->size[0];
                  cpu_iv56->size[0] = nb_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv56, eint, &xc_emlrtRTEI);
                  itime = nb_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(nb_cpu_y, &pb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv56, &gpu_iv56, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&pb_gpu_y, nb_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel284<<<grid, block>>>(pb_gpu_y, itime, gpu_iv56);
                  }

                  xt_size[0] = cpu_iv37->size[0];
                  xt_size[1] = cpu_iv56->size[0];
                  mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1,
                    xt_size[0] - 1), &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel285<<<grid, block>>>(e_gpu_yCol, xt_size[0],
                      gpu_iv56, gpu_iv37, xt_size[0] - 1, xt_size[1] - 1,
                      u_gpu_expanded, e_cpu_expanded->size[0U]);
                  }

                  b_nx = b_cpu_h->size[0];
                  eint = h_cpu_rows->size[0] * h_cpu_rows->size[1];
                  h_cpu_rows->size[0] = 1;
                  h_cpu_rows->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(h_cpu_rows, eint, &ad_emlrtRTEI);
                  h_cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    h_cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = b_cpu_w->size[0] * b_cpu_w->size[1];
                  b_cpu_w->size[0] = static_cast<int32_T>(N);
                  b_cpu_w->size[1] = cpu_opts_x->size[1];
                  emxEnsureCapacity_real_T(b_cpu_w, eint, &xc_emlrtRTEI);
                  x_data_outdatedOnGpu = true;
                  if (static_cast<int32_T>(N) != 0) {
                    if (blockDims[0] < 4.294967296E+9) {
                      if (blockDims[0] >= 0.0) {
                        N = static_cast<uint32_T>(blockDims[0]);
                      } else {
                        N = 0U;
                      }
                    } else if (blockDims[0] >= 4.294967296E+9) {
                      N = MAX_uint32_T;
                    } else {
                      N = 0U;
                    }

                    mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff -
                      1), dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3
                      (static_cast<uint32_T>(lidx), static_cast<uint32_T>(
                      static_cast<int8_T>(cpu_nrefine)), 1U), &grid, &block);
                    gpuEmxEnsureCapacity_int32_T(h_cpu_rows, &r_gpu_rows, false);
                    gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
                    x_data_outdatedOnGpu = false;
                    gpuEmxMemcpyCpuToGpu_int32_T(&r_gpu_rows, h_cpu_rows);
                    validLaunchParams = mwValidateLaunchParameters(grid, block);
                    if (validLaunchParams) {
                      ec_cwt_kernel286<<<grid, block>>>(u_gpu_expanded,
                        r_gpu_rows, b_gpu_h, fb_CutOff - 1, nw - 1, m_gpu_w,
                        b_cpu_h->size[0U], e_cpu_expanded->size[0U],
                        b_cpu_w->size[0U]);
                    }
                  }
                }
              }

              if (!(intFsq - 1.0 >= 0.0)) {
                hb_y = nullptr;
                m28 = emlrtCreateCharArray(2, &iv19[0]);
                emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m28, &rfmt[0]);
                emlrtAssign(&hb_y, m28);
                ob_y = nullptr;
                m34 = emlrtCreateDoubleScalar(intFsq - 1.0);
                emlrtAssign(&ob_y, m34);
                emlrt_marshallIn(b_sprintf(hb_y, ob_y, &e_emlrtMCI),
                                 "<output of sprintf>", unusedExpr);
              }

              dim = 2;
              if (b_cpu_w->size[0] != 1) {
                dim = 1;
              }

              interval_outdatedOnGpu = false;
              fx_data_outdatedOnCpu = false;
              for (itime = 0; itime < 2; itime++) {
                cpu_csz[itime] = b_cpu_w->size[itime];
                fx_data_outdatedOnCpu = true;
                cpu_lshift[itime] = b_cpu_w->size[itime];
                interval_outdatedOnGpu = true;
              }

              if (1 - dim >= 0) {
                cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                  static_cast<real_T>(dim))) / 2.0);
                mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                  &block, 2147483647U);
                if (interval_outdatedOnGpu) {
                  checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel258<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                    *gpu_lshift);
                }

                checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                  cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              }

              cpu_nrefine = cpu_lshift[0];
              cpu_lshift[0] = cpu_lshift[1];
              cpu_lshift[1] = cpu_nrefine;
              if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
                lidx = 1;
                nw = -1;
              } else {
                lidx = static_cast<int32_T>(intFsq);
                nw = cpu_lshift[0] - 1;
              }

              if (fx_data_outdatedOnCpu) {
                checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              ec_cwt_kernel259<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
                dim, *gpu_csz);
              eint = m_cpu_w->size[0] * m_cpu_w->size[1];
              m_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              m_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(m_cpu_w, eint, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
                &grid, &block, 2147483647U);
              if (x_data_outdatedOnGpu) {
                gpuEmxEnsureCapacity_real_T(b_cpu_w, &m_gpu_w, true);
              }

              gpuEmxEnsureCapacity_real_T(m_cpu_w, &n_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel260<<<grid, block>>>(m_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_nrefine - 1, n_gpu_w, m_cpu_w->size[0U]);
              }

              checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
              eint = cb_cpu_y->size[0] * cb_cpu_y->size[1];
              cb_cpu_y->size[0] = cpu_csz[0];
              cb_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(cb_cpu_y, eint, &rc_emlrtRTEI);
              b_nx = cpu_csz[0] * cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(cb_cpu_y, &ib_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel261<<<grid, block>>>(n_gpu_w, b_nx, ib_gpu_y);
              }

              b_cpu_r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) -
                                    1.0) * cf + static_cast<real_T>
                                   (b_cpu_h->size[0])) / intFsq);
              if (!(cpu_csz[0] < b_cpu_r)) {
                if (b_cpu_r < 1.0) {
                  cpu_nrefine = 0;
                } else {
                  cpu_nrefine = static_cast<int32_T>(b_cpu_r);
                }

                nsubs = u_cpu_w->size[0] * u_cpu_w->size[1];
                u_cpu_w->size[0] = div_s32(nw, lidx) + 1;
                u_cpu_w->size[1] = cpu_lshift[1];
                emxEnsureCapacity_real_T(u_cpu_w, nsubs, &bd_emlrtRTEI);
                itime = nw / lidx;
                mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                  &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(u_cpu_w, &o_gpu_w, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel262<<<grid, block>>>(m_gpu_w, cpu_lshift[0], lidx,
                    itime, cpu_lshift[1] - 1, o_gpu_w, u_cpu_w->size[0U]);
                }

                nsubs = cb_cpu_y->size[0] * cb_cpu_y->size[1];
                cb_cpu_y->size[0] = cpu_nrefine;
                cb_cpu_y->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(cb_cpu_y, nsubs, &uc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                  cpu_nrefine - 1), &grid, &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(cb_cpu_y, &ib_gpu_y, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel263<<<grid, block>>>(o_gpu_w, cpu_csz[0],
                    cpu_nrefine - 1, cpu_csz[1] - 1, ib_gpu_y, cb_cpu_y->size[0U]);
                }
              }
            }

            if (std::isnan(err_ok)) {
              eint = rb_cpu_y->size[0] * rb_cpu_y->size[1];
              rb_cpu_y->size[0] = 1;
              rb_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(rb_cpu_y, eint, &d_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(rb_cpu_y, &jb_gpu_y, true);
              e_y_needsGpuEnsureCapacity = false;
              ec_cwt_kernel237<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(jb_gpu_y);
            } else if (err_ok < 1.0) {
              rb_cpu_y->size[0] = 1;
              rb_cpu_y->size[1] = 0;
            } else {
              eint = rb_cpu_y->size[0] * rb_cpu_y->size[1];
              rb_cpu_y->size[0] = 1;
              rb_cpu_y->size[1] = static_cast<int32_T>(err_ok - 1.0) + 1;
              emxEnsureCapacity_real_T(rb_cpu_y, eint, &d_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>
                (err_ok - 1.0)), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(rb_cpu_y, &jb_gpu_y, true);
              e_y_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel239<<<grid, block>>>(static_cast<int32_T>(err_ok -
                  1.0), jb_gpu_y);
              }
            }

            eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_opts_x->size[0] = static_cast<int32_T>(err_ok);
            cpu_opts_x->size[1] = 1;
            emxEnsureCapacity_real_T(cpu_opts_x, eint, &nc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(err_ok)
              - 1), &grid, &block, 2147483647U);
            if (e_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(rb_cpu_y, &jb_gpu_y, true);
            }

            e_y_needsGpuEnsureCapacity = false;
            gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel238<<<grid, block>>>(ib_gpu_y, jb_gpu_y, tol,
                static_cast<int32_T>(err_ok) - 1, gpu_opts_x);
            }
          } else {
            int32_T cpu_csz[2];
            int32_T cpu_lshift[2];
            q_ok = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * cf /
                             intFsq);
            first_iteration = (cpu_opts_x->size[0] == 1);
            if (first_iteration) {
              eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
              cpu_opts_x->size[0] *= cpu_opts_x->size[1];
              cpu_opts_x->size[1] = 1;
              emxEnsureCapacity_real_T(cpu_opts_x, eint, &ic_emlrtRTEI);
              opts_x_needsGpuEnsureCapacity = true;
            }

            if (!(cf - 1.0 >= 0.0)) {
              g_y = nullptr;
              m6 = emlrtCreateCharArray(2, &iv7[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m6, &rfmt[0]);
              emlrtAssign(&g_y, m6);
              o_y = nullptr;
              m14 = emlrtCreateDoubleScalar(cf - 1.0);
              emlrtAssign(&o_y, m14);
              emlrt_marshallIn(b_sprintf(g_y, o_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            ix = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
              dim = 0;
            } else {
              dim = 1;
              if (cpu_opts_x->size[0] != 1) {
                dim = 0;
              }
            }

            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = cpu_opts_x->size[itime];
            }

            cpu_nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            eint = e_cpu_yCol->size[0];
            e_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
            emxEnsureCapacity_real_T(e_cpu_yCol, eint, &lc_emlrtRTEI);
            itime = ix * static_cast<int32_T>(cf) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(e_cpu_yCol, &f_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel315<<<grid, block>>>(itime, f_gpu_yCol);
            }

            if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf) >
                   0) && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                   static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                   static_cast<int32_T>(cf) > 1)))) {
              nw = 1;
              cpu_nrefine = 0;
            } else {
              nw = static_cast<int32_T>(cf);
              cpu_nrefine = ix * static_cast<int32_T>(cf);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1, nw)),
              &grid, &block, 2147483647U);
            if (opts_x_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel316<<<grid, block>>>(gpu_opts_x, nw, div_s32
                (cpu_nrefine - 1, nw), f_gpu_yCol);
            }

            cpu_csz[dim] = cpu_opts_x->size[dim] * static_cast<int32_T>(cf);
            eint = h_cpu_x->size[0] * h_cpu_x->size[1];
            h_cpu_x->size[0] = cpu_csz[0];
            h_cpu_x->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(h_cpu_x, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(h_cpu_x, &i_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel317<<<grid, block>>>(f_gpu_yCol, b_nx, i_gpu_x);
            }

            if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (cpu_csz[1] < 1) {
                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = 1;
                e_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel318<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (p_gpu_w);
              } else {
                nsubs = e_cpu_a->size[0];
                e_cpu_a->size[0] = cpu_csz[1];
                emxEnsureCapacity_real_T(e_cpu_a, nsubs, &tc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_a, &g_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel330<<<grid, block>>>(f_gpu_yCol, cpu_csz[1] - 1,
                    g_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
                b_cpu_r = b_cpu_h->data[0];
                eint = d_cpu_c->size[0];
                d_cpu_c->size[0] = e_cpu_a->size[0];
                emxEnsureCapacity_real_T(d_cpu_c, eint, &wc_emlrtRTEI);
                b_nx = e_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_c, &k_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel331<<<grid, block>>>(b_nx, k_gpu_c);
                }

                if (e_cpu_a->size[0] == 1) {
                  cpu_r = b_cpu_h->data[0];
                  eint = d_cpu_c->size[0];
                  d_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(d_cpu_c, eint, &wc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(d_cpu_c, &k_gpu_c, true);
                  ec_cwt_kernel332<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_r, g_gpu_a, k_gpu_c);
                } else {
                  int32_T threadDims[3];
                  lidx = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(e_cpu_a->size[0]) + 1.0) - 1.0));
                  threadDims[0] = static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(static_cast<uint32_T>(e_cpu_a->size[0])
                    + static_cast<uint32_T>(lidx)) - 1.0) / static_cast<real_T>
                     (lidx)));
                  fb_CutOff = e_cpu_a->size[0];
                  if (e_cpu_a->size[0] > 2147483646) {
                    ix = MAX_int32_T;
                  } else {
                    ix = e_cpu_a->size[0] + 1;
                  }

                  eint = j_cpu_expanded->size[0];
                  j_cpu_expanded->size[0] = ix - 1;
                  emxEnsureCapacity_real_T(j_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = e_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(j_cpu_expanded, &ab_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel334<<<grid, block>>>(b_nx, ab_gpu_expanded);
                  }

                  b_nx = e_cpu_a->size[0];
                  eint = u_cpu_y->size[0] * u_cpu_y->size[1];
                  u_cpu_y->size[0] = 1;
                  u_cpu_y->size[1] = e_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(u_cpu_y, eint, &ad_emlrtRTEI);
                  u_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    u_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv36->size[0];
                  cpu_iv36->size[0] = u_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv36, eint, &xc_emlrtRTEI);
                  itime = u_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(u_cpu_y, &xb_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv36, &gpu_iv36, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&xb_gpu_y, u_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel335<<<grid, block>>>(xb_gpu_y, itime, gpu_iv36);
                  }

                  omega_tmp2[0] = cpu_iv36->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel336<<<grid, block>>>(g_gpu_a, gpu_iv36,
                      omega_tmp2[0] - 1, ab_gpu_expanded);
                  }

                  eint = d_cpu_c->size[0];
                  d_cpu_c->size[0] = e_cpu_a->size[0];
                  emxEnsureCapacity_real_T(d_cpu_c, eint, &xc_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(
                    static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_real_T(d_cpu_c, &k_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel337<<<grid, block>>>(b_cpu_r, ab_gpu_expanded,
                      fb_CutOff - 1, k_gpu_c);
                  }
                }

                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = 1;
                e_cpu_w->size[1] = d_cpu_c->size[0];
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                b_nx = d_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel333<<<grid, block>>>(k_gpu_c, b_nx, p_gpu_w,
                    e_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > cpu_csz[0]) {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
              }

              if (cpu_csz[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_csz[1];
              }

              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = nsubs;
              e_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel338<<<grid, block>>>(itime, p_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = nsubs;
                e_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel339<<<grid, block>>>(itime, p_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                          (cpu_csz[1] == 1))) {
                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = 1;
                e_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel340<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (f_gpu_yCol, b_gpu_h, p_gpu_w);
              } else {
                real_T blockDims[3];
                int32_T threadDims[3];
                cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                         real_T>(cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, cpu_r);
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_csz[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) +
                  1.0) - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                  static_cast<real_T>(cpu_nrefine));
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                threadDims[0] = eint;
                threadDims[1] = cpu_nrefine;
                nw = cpu_csz[1];
                if (cpu_r < 2.147483648E+9) {
                  if (cpu_r >= -2.147483648E+9) {
                    fb_CutOff = static_cast<int32_T>(cpu_r);
                  } else {
                    fb_CutOff = MIN_int32_T;
                  }
                } else {
                  fb_CutOff = MAX_int32_T;
                }

                fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  dim = static_cast<int32_T>(fc);
                } else {
                  dim = MIN_int32_T;
                }

                if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff)) {
                  ix = MIN_int32_T;
                } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                            - fb_CutOff)) {
                  ix = MAX_int32_T;
                } else {
                  ix = fb_CutOff + cpu_csz[0];
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = o_cpu_expanded->size[0] * o_cpu_expanded->size[1];
                o_cpu_expanded->size[0] = ix;
                emxEnsureCapacity_real_T(o_cpu_expanded, eint, &xc_emlrtRTEI);
                if ((cpu_csz[1] < 0) && (cpu_csz[1] < MIN_int32_T - cpu_csz[1]))
                {
                  ix = MIN_int32_T;
                } else if ((cpu_csz[1] > 0) && (cpu_csz[1] > MAX_int32_T
                            - cpu_csz[1])) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_csz[1] + cpu_csz[1];
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = o_cpu_expanded->size[0] * o_cpu_expanded->size[1];
                o_cpu_expanded->size[1] = ix;
                emxEnsureCapacity_real_T(o_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_csz[1] + cpu_csz[1])
                  - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(o_cpu_expanded, &bb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel341<<<grid, block>>>(b_nx, bb_gpu_expanded);
                }

                b_nx = b_cpu_h->size[0];
                eint = bb_cpu_y->size[0] * bb_cpu_y->size[1];
                bb_cpu_y->size[0] = 1;
                bb_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(bb_cpu_y, eint, &ad_emlrtRTEI);
                bb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  bb_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv41->size[0];
                cpu_iv41->size[0] = bb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv41, eint, &xc_emlrtRTEI);
                itime = bb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(bb_cpu_y, &yb_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv41, &gpu_iv41, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&yb_gpu_y, bb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel342<<<grid, block>>>(dim, yb_gpu_y, itime,
                    gpu_iv41);
                }

                fc = std::floor(static_cast<real_T>(cpu_csz[1]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_csz[1]) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  cpu_nrefine = static_cast<int32_T>(fc);
                } else {
                  cpu_nrefine = MIN_int32_T;
                }

                omega_tmp2[0] = cpu_iv41->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel343<<<grid, block>>>(b_gpu_h, cpu_nrefine,
                    gpu_iv41, omega_tmp2[0] - 1, bb_gpu_expanded,
                    o_cpu_expanded->size[0U]);
                }

                if (cpu_csz[0] < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = cpu_csz[0] - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                interval_outdatedOnGpu = false;
                eint = f_cpu_rows->size[0] * f_cpu_rows->size[1];
                f_cpu_rows->size[0] = 1;
                f_cpu_rows->size[1] = b_nx;
                emxEnsureCapacity_int32_T(f_cpu_rows, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  f_cpu_rows->data[0] = 0;
                  interval_outdatedOnGpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    f_cpu_rows->data[k + 1] = nsubs;
                  }
                }

                if (cpu_csz[1] < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = cpu_csz[1] - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                fx_data_outdatedOnCpu = false;
                eint = d_cpu_cols->size[0] * d_cpu_cols->size[1];
                d_cpu_cols->size[0] = 1;
                d_cpu_cols->size[1] = b_nx;
                emxEnsureCapacity_int32_T(d_cpu_cols, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  d_cpu_cols->data[0] = 0;
                  fx_data_outdatedOnCpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    d_cpu_cols->data[k + 1] = nsubs;
                  }
                }

                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = fb_CutOff;
                e_cpu_w->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(e_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if ((fb_CutOff != 0) && (cpu_csz[1] != 0)) {
                  uint32_T b_u;
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  if (blockDims[1] < 4.294967296E+9) {
                    if (blockDims[1] >= 0.0) {
                      b_u = static_cast<uint32_T>(blockDims[1]);
                    } else {
                      b_u = 0U;
                    }
                  } else if (blockDims[1] >= 4.294967296E+9) {
                    b_u = MAX_uint32_T;
                  } else {
                    b_u = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  nsubs = threadDims[1];
                  if (threadDims[1] < 0) {
                    nsubs = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                    static_cast<uint32_T>(nsubs), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(d_cpu_cols, &d_gpu_cols,
                    !fx_data_outdatedOnCpu);
                  gpuEmxEnsureCapacity_int32_T(f_cpu_rows, &w_gpu_rows,
                    !interval_outdatedOnGpu);
                  gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  if (fx_data_outdatedOnCpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&d_gpu_cols, d_cpu_cols);
                  }

                  if (interval_outdatedOnGpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&w_gpu_rows, f_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel344<<<grid, block>>>(f_gpu_yCol,
                      bb_gpu_expanded, d_gpu_cols, w_gpu_rows, *gpu_csz,
                      fb_CutOff - 1, nw - 1, p_gpu_w, o_cpu_expanded->size[0U],
                      e_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
              }

              if (cpu_csz[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_csz[1];
              }

              eint = e_cpu_w->size[0] * e_cpu_w->size[1];
              e_cpu_w->size[0] = nsubs;
              e_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel345<<<grid, block>>>(itime, p_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = nsubs;
                e_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel346<<<grid, block>>>(itime, p_gpu_w);
                }
              } else if ((cpu_csz[0] == 1) && (cpu_csz[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                eint = l_cpu_c->size[0];
                l_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(l_cpu_c, eint, &vc_emlrtRTEI);
                cpu_r = 1.0;
                b_cpu_r = 0.0;
                gpuEmxEnsureCapacity_real_T(l_cpu_c, &l_gpu_c, true);
                cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                  &i_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                  &b_cpu_r, (double *)&l_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = nsubs;
                e_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(e_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel347<<<grid, block>>>(l_gpu_c, itime, p_gpu_w);
                }
              } else {
                real_T blockDims[3];
                N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                     (b_cpu_h->size[0])) - 1U;
                lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_csz[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) +
                  1.0) - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                  static_cast<real_T>(cpu_nrefine));
                nw = cpu_csz[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                fb_CutOff = static_cast<int32_T>(N);
                dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  ix = MAX_int32_T;
                } else {
                  ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[0] = ix - 1;
                emxEnsureCapacity_real_T(n_cpu_expanded, eint, &xc_emlrtRTEI);
                if (cpu_csz[1] > 2147483646) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_csz[1] + 1;
                }

                eint = n_cpu_expanded->size[0] * n_cpu_expanded->size[1];
                n_cpu_expanded->size[1] = ix - 1;
                emxEnsureCapacity_real_T(n_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                  cpu_csz[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(n_cpu_expanded, &cb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel348<<<grid, block>>>(b_nx, cb_gpu_expanded);
                }

                b_nx = cpu_csz[0];
                eint = x_cpu_y->size[0] * x_cpu_y->size[1];
                x_cpu_y->size[0] = 1;
                x_cpu_y->size[1] = cpu_csz[0];
                emxEnsureCapacity_int32_T(x_cpu_y, eint, &ad_emlrtRTEI);
                x_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  x_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv44->size[0];
                cpu_iv44->size[0] = x_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv44, eint, &xc_emlrtRTEI);
                itime = x_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(x_cpu_y, &ac_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv44, &gpu_iv44, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&ac_gpu_y, x_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel349<<<grid, block>>>(dim, ac_gpu_y, itime,
                    gpu_iv44);
                }

                if (cpu_csz[1] < 1) {
                  b_nx = 0;
                } else {
                  b_nx = cpu_csz[1];
                }

                interval_outdatedOnGpu = false;
                eint = wb_cpu_y->size[0] * wb_cpu_y->size[1];
                wb_cpu_y->size[0] = 1;
                wb_cpu_y->size[1] = b_nx;
                emxEnsureCapacity_int32_T(wb_cpu_y, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  wb_cpu_y->data[0] = 1;
                  interval_outdatedOnGpu = true;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    wb_cpu_y->data[k + 1] = nsubs;
                  }
                }

                eint = cpu_iv61->size[0];
                cpu_iv61->size[0] = wb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv61, eint, &xc_emlrtRTEI);
                itime = wb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(wb_cpu_y, &bc_gpu_y,
                  !interval_outdatedOnGpu);
                gpuEmxEnsureCapacity_int32_T(cpu_iv61, &gpu_iv61, true);
                if (interval_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&bc_gpu_y, wb_cpu_y);
                }

                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel350<<<grid, block>>>(bc_gpu_y, itime, gpu_iv61);
                }

                xt_size[0] = cpu_iv44->size[0];
                xt_size[1] = cpu_iv61->size[0];
                mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel351<<<grid, block>>>(f_gpu_yCol, xt_size[0],
                    gpu_iv61, gpu_iv44, xt_size[0] - 1, xt_size[1] - 1,
                    cb_gpu_expanded, n_cpu_expanded->size[0U]);
                }

                b_nx = b_cpu_h->size[0];
                eint = n_cpu_rows->size[0] * n_cpu_rows->size[1];
                n_cpu_rows->size[0] = 1;
                n_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(n_cpu_rows, eint, &ad_emlrtRTEI);
                n_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  n_cpu_rows->data[k + 1] = nsubs;
                }

                eint = e_cpu_w->size[0] * e_cpu_w->size[1];
                e_cpu_w->size[0] = static_cast<int32_T>(N);
                e_cpu_w->size[1] = cpu_csz[1];
                emxEnsureCapacity_real_T(e_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if ((static_cast<int32_T>(N) != 0) && (cpu_csz[1] != 0)) {
                  uint32_T b_u;
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  if (blockDims[1] < 4.294967296E+9) {
                    if (blockDims[1] >= 0.0) {
                      b_u = static_cast<uint32_T>(blockDims[1]);
                    } else {
                      b_u = 0U;
                    }
                  } else if (blockDims[1] >= 4.294967296E+9) {
                    b_u = MAX_uint32_T;
                  } else {
                    b_u = 0U;
                  }

                  eint = cpu_nrefine;
                  if (cpu_nrefine < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(lidx),
                    static_cast<uint32_T>(eint), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(n_cpu_rows, &x_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&x_gpu_rows, n_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel352<<<grid, block>>>(cb_gpu_expanded,
                      x_gpu_rows, b_gpu_h, fb_CutOff - 1, nw - 1, p_gpu_w,
                      b_cpu_h->size[0U], n_cpu_expanded->size[0U], e_cpu_w->
                      size[0U]);
                  }
                }
              }
            }

            if (!(intFsq - 1.0 >= 0.0)) {
              gb_y = nullptr;
              m32 = emlrtCreateCharArray(2, &iv23[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m32, &rfmt[0]);
              emlrtAssign(&gb_y, m32);
              nb_y = nullptr;
              m39 = emlrtCreateDoubleScalar(intFsq - 1.0);
              emlrtAssign(&nb_y, m39);
              emlrt_marshallIn(b_sprintf(gb_y, nb_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            dim = 2;
            if (e_cpu_w->size[0] != 1) {
              dim = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = e_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_lshift[itime] = e_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - dim >= 0) {
              cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                static_cast<real_T>(dim))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel319<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_nrefine = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_nrefine;
            if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
              lidx = 1;
              nw = -1;
            } else {
              lidx = static_cast<int32_T>(intFsq);
              nw = cpu_lshift[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_cwt_kernel320<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
              dim, *gpu_csz);
            eint = r_cpu_w->size[0] * r_cpu_w->size[1];
            r_cpu_w->size[0] = div_s32(nw, lidx) + 1;
            r_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(r_cpu_w, eint, &bd_emlrtRTEI);
            itime = nw / lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real_T(e_cpu_w, &p_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real_T(r_cpu_w, &q_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel321<<<grid, block>>>(p_gpu_w, cpu_lshift[0], lidx,
                itime, cpu_nrefine - 1, q_gpu_w, r_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = ib_cpu_y->size[0] * ib_cpu_y->size[1];
            ib_cpu_y->size[0] = cpu_csz[0];
            ib_cpu_y->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(ib_cpu_y, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(ib_cpu_y, &ub_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel322<<<grid, block>>>(q_gpu_w, b_nx, ub_gpu_y);
            }

            b_cpu_r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0)
                                 * cf + static_cast<real_T>(b_cpu_h->size[0])) /
                                intFsq);
            if (!(cpu_csz[0] < b_cpu_r)) {
              if (b_cpu_r < 1.0) {
                cpu_nrefine = 0;
              } else {
                cpu_nrefine = static_cast<int32_T>(b_cpu_r);
              }

              nsubs = ab_cpu_w->size[0] * ab_cpu_w->size[1];
              ab_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              ab_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real_T(ab_cpu_w, nsubs, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(ab_cpu_w, &r_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel323<<<grid, block>>>(p_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_lshift[1] - 1, r_gpu_w, ab_cpu_w->size[0U]);
              }

              nsubs = ib_cpu_y->size[0] * ib_cpu_y->size[1];
              ib_cpu_y->size[0] = cpu_nrefine;
              ib_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(ib_cpu_y, nsubs, &uc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                cpu_nrefine - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(ib_cpu_y, &ub_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel324<<<grid, block>>>(r_gpu_w, cpu_csz[0],
                  cpu_nrefine - 1, cpu_csz[1] - 1, ub_gpu_y, ib_cpu_y->size[0U]);
              }
            }

            if (first_iteration) {
              omega_tmp2[0] = ib_cpu_y->size[0] * ib_cpu_y->size[1];
              eint = id_cpu_y->size[0] * id_cpu_y->size[1];
              id_cpu_y->size[0] = 1;
              id_cpu_y->size[1] = omega_tmp2[0];
              emxEnsureCapacity_real_T(id_cpu_y, eint, &cd_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(id_cpu_y, &vb_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel325<<<grid, block>>>(ub_gpu_y, omega_tmp2[0] - 1,
                  vb_gpu_y, id_cpu_y->size[0U]);
              }

              eint = ib_cpu_y->size[0] * ib_cpu_y->size[1];
              ib_cpu_y->size[0] = 1;
              ib_cpu_y->size[1] = id_cpu_y->size[1];
              emxEnsureCapacity_real_T(ib_cpu_y, eint, &ed_emlrtRTEI);
              itime = id_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(ib_cpu_y, &ub_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel326<<<grid, block>>>(vb_gpu_y, itime, ub_gpu_y);
              }
            }

            if (std::isnan(q_ok)) {
              eint = dc_cpu_y->size[0] * dc_cpu_y->size[1];
              dc_cpu_y->size[0] = 1;
              dc_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(dc_cpu_y, eint, &d_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(dc_cpu_y, &wb_gpu_y, true);
              h_y_needsGpuEnsureCapacity = false;
              ec_cwt_kernel327<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(wb_gpu_y);
            } else if (q_ok < 1.0) {
              dc_cpu_y->size[0] = 1;
              dc_cpu_y->size[1] = 0;
            } else {
              eint = dc_cpu_y->size[0] * dc_cpu_y->size[1];
              dc_cpu_y->size[0] = 1;
              dc_cpu_y->size[1] = static_cast<int32_T>(q_ok - 1.0) + 1;
              emxEnsureCapacity_real_T(dc_cpu_y, eint, &d_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(q_ok
                - 1.0)), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(dc_cpu_y, &wb_gpu_y, true);
              h_y_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel329<<<grid, block>>>(static_cast<int32_T>(q_ok -
                  1.0), wb_gpu_y);
              }
            }

            cpu_nrefine = ib_cpu_y->size[1];
            eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_opts_x->size[0] = dc_cpu_y->size[1];
            cpu_opts_x->size[1] = ib_cpu_y->size[1];
            emxEnsureCapacity_real_T(cpu_opts_x, eint, &nc_emlrtRTEI);
            itime = dc_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (h_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(dc_cpu_y, &wb_gpu_y, true);
            }

            h_y_needsGpuEnsureCapacity = false;
            gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel328<<<grid, block>>>(ub_gpu_y, wb_gpu_y, tol, itime,
                cpu_nrefine - 1, gpu_opts_x, cpu_opts_x->size[0U],
                ib_cpu_y->size[0U]);
            }
          }
        }
      } else {
        if (cpu_opts_x->size[0] == 1) {
          halfh = std::ceil(cf / intFsq);
          eint = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = static_cast<int32_T>(halfh);
          cpu_y1->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_real_T(cpu_y1, eint, &dc_emlrtRTEI);
          interval_outdatedOnGpu = true;
          lidx = cpu_opts_x->size[1];
          if (cpu_opts_x->size[1] - 1 >= 0) {
            if ((static_cast<int32_T>(cf) == 0) || ((static_cast<int32_T>(cf) >
                  0) && (static_cast<int32_T>(cf) < 1))) {
              i36 = 1;
              i39 = 0;
            } else {
              i36 = static_cast<int32_T>(cf);
              i39 = static_cast<int32_T>(cf);
            }

            p = (static_cast<int32_T>(cf) == 1);
            Ly = std::ceil((0.0 * cf + static_cast<real_T>(b_cpu_h->size[0])) /
                           intFsq);
          }

          for (nx = 0; nx < lidx; nx++) {
            if (!(cf - 1.0 >= 0.0)) {
              q_y = nullptr;
              m12 = emlrtCreateCharArray(2, &iv13[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m12, &rfmt[0]);
              emlrtAssign(&q_y, m12);
              y_y = nullptr;
              m21 = emlrtCreateDoubleScalar(cf - 1.0);
              emlrtAssign(&y_y, m21);
              emlrt_marshallIn(b_sprintf(q_y, y_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            eint = cpu_yCol->size[0];
            cpu_yCol->size[0] = static_cast<int32_T>(cf);
            emxEnsureCapacity_real_T(cpu_yCol, eint, &lc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(cf) - 1),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_yCol, &g_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel381<<<grid, block>>>(static_cast<int32_T>(cf) - 1,
                g_gpu_yCol);
            }

            cpu_nrefine = div_s32(i39 - 1, i36) + 1;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
              &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel382<<<grid, block>>>(gpu_opts_x, nx, i36, cpu_nrefine
                - 1, g_gpu_yCol);
            }

            if (p && (b_cpu_h->size[0] == 1)) {
              eint = g_cpu_w->size[0];
              g_cpu_w->size[0] = 1;
              emxEnsureCapacity_real_T(g_cpu_w, eint, &rc_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
              ec_cwt_kernel383<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                g_gpu_yCol, s_gpu_w);
            } else if (b_cpu_h->size[0] > static_cast<int32_T>(cf)) {
              if (static_cast<int32_T>(cf) == 0) {
                nsubs = b_cpu_h->size[0] + static_cast<int32_T>(cf);
              } else {
                nsubs = (b_cpu_h->size[0] + static_cast<int32_T>(cf)) - 1;
              }

              eint = g_cpu_w->size[0];
              g_cpu_w->size[0] = nsubs;
              emxEnsureCapacity_real_T(g_cpu_w, eint, &rc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel388<<<grid, block>>>(nsubs - 1, s_gpu_w);
              }

              if (static_cast<int32_T>(cf) != 0) {
                if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(cf) == 1))
                {
                  ec_cwt_kernel389<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (g_gpu_yCol, b_gpu_r);
                  eint = g_cpu_w->size[0];
                  g_cpu_w->size[0] = 1;
                  emxEnsureCapacity_real_T(g_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
                  ec_cwt_kernel390<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (b_gpu_r, b_gpu_h, s_gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) +
                           static_cast<real_T>(static_cast<int32_T>(cf))) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  fc = std::floor(static_cast<real_T>(static_cast<int32_T>(cf)) /
                                  2.0) + std::floor((static_cast<real_T>(
                    static_cast<int32_T>(cf)) - 1.0) / 2.0);
                  if (fc >= -2.147483648E+9) {
                    dim = static_cast<int32_T>(fc);
                  } else {
                    dim = MIN_int32_T;
                  }

                  if ((fb_CutOff < 0) && (static_cast<int32_T>(cf) < MIN_int32_T
                       - fb_CutOff)) {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (static_cast<int32_T>(cf) >
                              MAX_int32_T - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + static_cast<int32_T>(cf);
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = b_cpu_expanded->size[0];
                  b_cpu_expanded->size[0] = ix;
                  emxEnsureCapacity_real_T(b_cpu_expanded, eint, &xc_emlrtRTEI);
                  itime = (fb_CutOff + static_cast<int32_T>(cf)) - 2;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(b_cpu_expanded, &hb_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel391<<<grid, block>>>(itime, hb_gpu_expanded);
                  }

                  eint = b_cpu_h->size[0];
                  nsubs = l_cpu_y->size[0] * l_cpu_y->size[1];
                  l_cpu_y->size[0] = 1;
                  l_cpu_y->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(l_cpu_y, nsubs, &ad_emlrtRTEI);
                  l_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= eint - 2; k++) {
                    nsubs++;
                    l_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv30->size[0];
                  cpu_iv30->size[0] = l_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv30, eint, &xc_emlrtRTEI);
                  itime = l_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(l_cpu_y, &ic_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv30, &gpu_iv30, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&ic_gpu_y, l_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel392<<<grid, block>>>(dim, ic_gpu_y, itime,
                      gpu_iv30);
                  }

                  omega_tmp2[0] = cpu_iv30->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel393<<<grid, block>>>(b_gpu_h, gpu_iv30,
                      omega_tmp2[0] - 1, hb_gpu_expanded);
                  }

                  if (static_cast<int32_T>(cf) < -2147483647) {
                    ix = MIN_int32_T;
                    cpu_nrefine = MIN_int32_T;
                  } else {
                    ix = static_cast<int32_T>(cf) - 1;
                    cpu_nrefine = static_cast<int32_T>(cf) - 1;
                  }

                  eint = b_cpu_rows->size[0] * b_cpu_rows->size[1];
                  b_cpu_rows->size[0] = 1;
                  b_cpu_rows->size[1] = cpu_nrefine + 1;
                  emxEnsureCapacity_int32_T(b_cpu_rows, eint, &ad_emlrtRTEI);
                  b_cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k < ix; k++) {
                    nsubs++;
                    b_cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = g_cpu_w->size[0];
                  g_cpu_w->size[0] = fb_CutOff;
                  emxEnsureCapacity_real_T(g_cpu_w, eint, &xc_emlrtRTEI);
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(N,
                    1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U), &grid,
                    &block);
                  gpuEmxEnsureCapacity_int32_T(b_cpu_rows, &db_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&db_gpu_rows, b_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel394<<<grid, block>>>(g_gpu_yCol,
                      hb_gpu_expanded, db_gpu_rows, cf, fb_CutOff - 1, s_gpu_w);
                  }
                }
              }
            } else {
              if (static_cast<int32_T>(cf) == 0) {
                nsubs = static_cast<int32_T>(cf) + b_cpu_h->size[0];
              } else {
                nsubs = (static_cast<int32_T>(cf) + b_cpu_h->size[0]) - 1;
              }

              eint = g_cpu_w->size[0];
              g_cpu_w->size[0] = nsubs;
              emxEnsureCapacity_real_T(g_cpu_w, eint, &rc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel395<<<grid, block>>>(nsubs - 1, s_gpu_w);
              }

              if (static_cast<int32_T>(cf) != 0) {
                if ((static_cast<int32_T>(cf) == 1) && (b_cpu_h->size[0] == 1))
                {
                  eint = g_cpu_w->size[0];
                  g_cpu_w->size[0] = 1;
                  emxEnsureCapacity_real_T(g_cpu_w, eint, &rc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
                  ec_cwt_kernel396<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (b_gpu_h, g_gpu_yCol, s_gpu_w);
                } else {
                  real_T blockDims[3];
                  int32_T threadDims[3];
                  cpu_r = (static_cast<real_T>(static_cast<int32_T>(cf)) +
                           static_cast<real_T>(b_cpu_h->size[0])) - 1.0;
                  s = std::fmin(32.0, cpu_r);
                  blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                  if (s >= -2.147483648E+9) {
                    eint = static_cast<int32_T>(s);
                  } else {
                    eint = MIN_int32_T;
                  }

                  threadDims[0] = eint;
                  if (cpu_r < 2.147483648E+9) {
                    if (cpu_r >= -2.147483648E+9) {
                      fb_CutOff = static_cast<int32_T>(cpu_r);
                    } else {
                      fb_CutOff = MIN_int32_T;
                    }
                  } else {
                    fb_CutOff = MAX_int32_T;
                  }

                  dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                    (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor
                    ((static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                  if ((fb_CutOff < 0) && (b_cpu_h->size[0] < MIN_int32_T
                                          - fb_CutOff)) {
                    ix = MIN_int32_T;
                  } else if ((fb_CutOff > 0) && (b_cpu_h->size[0] > MAX_int32_T
                              - fb_CutOff)) {
                    ix = MAX_int32_T;
                  } else {
                    ix = fb_CutOff + b_cpu_h->size[0];
                  }

                  if (ix >= -2147483647) {
                    ix--;
                  }

                  eint = cpu_expanded->size[0];
                  cpu_expanded->size[0] = ix;
                  emxEnsureCapacity_real_T(cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = (fb_CutOff + b_cpu_h->size[0]) - 2;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(cpu_expanded, &ib_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel397<<<grid, block>>>(b_nx, ib_gpu_expanded);
                  }

                  b_nx = static_cast<int32_T>(cf);
                  eint = k_cpu_y->size[0] * k_cpu_y->size[1];
                  k_cpu_y->size[0] = 1;
                  k_cpu_y->size[1] = static_cast<int32_T>(cf);
                  emxEnsureCapacity_int32_T(k_cpu_y, eint, &ad_emlrtRTEI);
                  k_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    k_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv29->size[0];
                  cpu_iv29->size[0] = k_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv29, eint, &xc_emlrtRTEI);
                  itime = k_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(k_cpu_y, &jc_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv29, &gpu_iv29, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&jc_gpu_y, k_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel398<<<grid, block>>>(dim, jc_gpu_y, itime,
                      gpu_iv29);
                  }

                  omega_tmp2[0] = cpu_iv29->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel399<<<grid, block>>>(g_gpu_yCol, gpu_iv29,
                      omega_tmp2[0] - 1, ib_gpu_expanded);
                  }

                  eint = b_cpu_h->size[0];
                  nsubs = cpu_rows->size[0] * cpu_rows->size[1];
                  cpu_rows->size[0] = 1;
                  cpu_rows->size[1] = b_cpu_h->size[0];
                  emxEnsureCapacity_int32_T(cpu_rows, nsubs, &ad_emlrtRTEI);
                  cpu_rows->data[0] = 0;
                  nsubs = 0;
                  for (k = 0; k <= eint - 2; k++) {
                    nsubs++;
                    cpu_rows->data[k + 1] = nsubs;
                  }

                  eint = g_cpu_w->size[0];
                  g_cpu_w->size[0] = fb_CutOff;
                  emxEnsureCapacity_real_T(g_cpu_w, eint, &xc_emlrtRTEI);
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(N,
                    1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U), &grid,
                    &block);
                  gpuEmxEnsureCapacity_int32_T(cpu_rows, &eb_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(g_cpu_w, &s_gpu_w, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&eb_gpu_rows, cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel400<<<grid, block>>>(ib_gpu_expanded,
                      eb_gpu_rows, b_gpu_h, fb_CutOff - 1, s_gpu_w,
                      b_cpu_h->size[0U]);
                  }
                }
              }
            }

            if (!(intFsq - 1.0 >= 0.0)) {
              bb_y = nullptr;
              m30 = emlrtCreateCharArray(2, &iv21[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m30, &rfmt[0]);
              emlrtAssign(&bb_y, m30);
              cb_y = nullptr;
              m36 = emlrtCreateDoubleScalar(intFsq - 1.0);
              emlrtAssign(&cb_y, m36);
              emlrt_marshallIn(b_sprintf(bb_y, cb_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            if (intFsq == 0.0) {
              cpu_nrefine = 1;
              nw = -1;
            } else {
              cpu_nrefine = static_cast<int32_T>(intFsq);
              nw = g_cpu_w->size[0] - 1;
            }

            eint = j_cpu_y->size[0];
            j_cpu_y->size[0] = div_s32(nw, cpu_nrefine) + 1;
            emxEnsureCapacity_real_T(j_cpu_y, eint, &rc_emlrtRTEI);
            itime = nw / cpu_nrefine;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(j_cpu_y, &gc_gpu_y, true);
            b_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel384<<<grid, block>>>(s_gpu_w, cpu_nrefine, itime,
                gc_gpu_y);
            }

            if (!(div_s32(nw, cpu_nrefine) + 1 < Ly)) {
              eint = j_cpu_y->size[0];
              if (Ly < 1.0) {
                j_cpu_y->size[0] = 0;
              } else {
                j_cpu_y->size[0] = static_cast<int32_T>(Ly);
              }

              emxEnsureCapacity_real_T(j_cpu_y, eint, &uc_emlrtRTEI);
              b_y_needsGpuEnsureCapacity = true;
            }

            if (std::isnan(halfh)) {
              eint = m_cpu_y->size[0] * m_cpu_y->size[1];
              m_cpu_y->size[0] = 1;
              m_cpu_y->size[1] = 1;
              emxEnsureCapacity_real_T(m_cpu_y, eint, &d_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(m_cpu_y, &hc_gpu_y, true);
              d_y_needsGpuEnsureCapacity = false;
              ec_cwt_kernel385<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(hc_gpu_y);
            } else if (halfh < 1.0) {
              m_cpu_y->size[0] = 1;
              m_cpu_y->size[1] = 0;
            } else {
              eint = m_cpu_y->size[0] * m_cpu_y->size[1];
              m_cpu_y->size[0] = 1;
              m_cpu_y->size[1] = static_cast<int32_T>(halfh - 1.0) + 1;
              emxEnsureCapacity_real_T(m_cpu_y, eint, &d_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(halfh
                - 1.0)), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(m_cpu_y, &hc_gpu_y, true);
              d_y_needsGpuEnsureCapacity = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel387<<<grid, block>>>(static_cast<int32_T>(halfh -
                  1.0), hc_gpu_y);
              }
            }

            cpu_nrefine = cpu_y1->size[0];
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
              &block, 2147483647U);
            if (b_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(j_cpu_y, &gc_gpu_y, true);
            }

            if (d_y_needsGpuEnsureCapacity) {
              gpuEmxEnsureCapacity_real_T(m_cpu_y, &hc_gpu_y, true);
            }

            d_y_needsGpuEnsureCapacity = false;
            if (interval_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
            }

            interval_outdatedOnGpu = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel386<<<grid, block>>>(gc_gpu_y, hc_gpu_y, tol, nx,
                cpu_nrefine - 1, gpu_y1, cpu_y1->size[0U]);
            }
          }
        } else if ((cf == 1.0) && (intFsq == 1.0)) {
          eint = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = cpu_opts_x->size[0];
          cpu_y1->size[1] = cpu_opts_x->size[1];
          emxEnsureCapacity_real_T(cpu_y1, eint, &ac_emlrtRTEI);
          b_nx = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel403<<<grid, block>>>(gpu_opts_x, b_nx, gpu_y1);
          }
        } else if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
          if ((cpu_opts_x->size[0] == 0) || (cpu_opts_x->size[1] == 0)) {
            nw = 0;
          } else {
            ix = cpu_opts_x->size[0];
            nw = cpu_opts_x->size[1];
            if (ix >= nw) {
              nw = ix;
            }
          }

          err_ok = std::ceil(static_cast<real_T>(nw) * cf / intFsq);
          if ((cpu_opts_x->size[0] == 1) && (cpu_opts_x->size[1] == 1)) {
            int32_T cpu_csz[2];
            int32_T cpu_lshift[2];
            if (!(cf - 1.0 >= 0.0)) {
              j_y = nullptr;
              m23 = emlrtCreateCharArray(2, &iv17[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m23, &rfmt[0]);
              emlrtAssign(&j_y, m23);
              s_y = nullptr;
              m27 = emlrtCreateDoubleScalar(cf - 1.0);
              emlrtAssign(&s_y, m27);
              emlrt_marshallIn(b_sprintf(j_y, s_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            eint = j_cpu_yCol->size[0];
            j_cpu_yCol->size[0] = static_cast<int32_T>(cf);
            emxEnsureCapacity_real_T(j_cpu_yCol, eint, &lc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(cf) - 1),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(j_cpu_yCol, &h_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel404<<<grid, block>>>(static_cast<int32_T>(cf) - 1,
                h_gpu_yCol);
            }

            if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf) >
                   0) && (static_cast<int32_T>(cf) < 1)) ||
                 ((static_cast<int32_T>(cf) < 0) && (static_cast<int32_T>(cf) >
                   1)))) {
              nw = 1;
              cpu_nrefine = 0;
            } else {
              nw = static_cast<int32_T>(cf);
              cpu_nrefine = static_cast<int32_T>(cf);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1, nw)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel405<<<grid, block>>>(gpu_opts_x, nw, div_s32
                (cpu_nrefine - 1, nw), h_gpu_yCol);
            }

            eint = m_cpu_x->size[0] * m_cpu_x->size[1];
            m_cpu_x->size[0] = static_cast<int32_T>(cf);
            m_cpu_x->size[1] = 1;
            emxEnsureCapacity_real_T(m_cpu_x, eint, &rc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(cf) - 1),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(m_cpu_x, &j_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel406<<<grid, block>>>(h_gpu_yCol, static_cast<int32_T>
                (cf) - 1, j_gpu_x);
            }

            if ((static_cast<int32_T>(cf) == 1) && (b_cpu_h->size[0] == 1)) {
              eint = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = 1;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
              x_data_outdatedOnGpu = false;
              ec_cwt_kernel407<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(b_gpu_h,
                h_gpu_yCol, t_gpu_w);
            } else if (b_cpu_h->size[0] > static_cast<int32_T>(cf)) {
              if (static_cast<int32_T>(cf) == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + static_cast<int32_T>(cf)) - 1;
              }

              eint = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = nsubs;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel419<<<grid, block>>>(nsubs - 1, t_gpu_w);
              }

              if (static_cast<int32_T>(cf) == 0) {
                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = nsubs;
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel420<<<grid, block>>>(nsubs - 1, t_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && (static_cast<int32_T>(cf) ==
                          1)) {
                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = 1;
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel421<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (h_gpu_yCol, b_gpu_h, t_gpu_w);
              } else {
                real_T blockDims[3];
                int32_T threadDims[3];
                cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) +
                         static_cast<real_T>(static_cast<int32_T>(cf))) - 1.0;
                s = std::fmin(32.0, cpu_r);
                blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                threadDims[0] = eint;
                if (cpu_r < 2.147483648E+9) {
                  if (cpu_r >= -2.147483648E+9) {
                    fb_CutOff = static_cast<int32_T>(cpu_r);
                  } else {
                    fb_CutOff = MIN_int32_T;
                  }
                } else {
                  fb_CutOff = MAX_int32_T;
                }

                fc = std::floor(static_cast<real_T>(static_cast<int32_T>(cf)) /
                                2.0) + std::floor((static_cast<real_T>(
                  static_cast<int32_T>(cf)) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  dim = static_cast<int32_T>(fc);
                } else {
                  dim = MIN_int32_T;
                }

                if ((fb_CutOff < 0) && (static_cast<int32_T>(cf) < MIN_int32_T -
                     fb_CutOff)) {
                  ix = MIN_int32_T;
                } else if ((fb_CutOff > 0) && (static_cast<int32_T>(cf) >
                            MAX_int32_T - fb_CutOff)) {
                  ix = MAX_int32_T;
                } else {
                  ix = fb_CutOff + static_cast<int32_T>(cf);
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = ab_cpu_expanded->size[0] * ab_cpu_expanded->size[1];
                ab_cpu_expanded->size[0] = ix;
                ab_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real_T(ab_cpu_expanded, eint, &xc_emlrtRTEI);
                itime = (fb_CutOff + static_cast<int32_T>(cf)) - 2;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(ab_cpu_expanded, &jb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel422<<<grid, block>>>(itime, jb_gpu_expanded);
                }

                b_nx = b_cpu_h->size[0];
                eint = cc_cpu_y->size[0] * cc_cpu_y->size[1];
                cc_cpu_y->size[0] = 1;
                cc_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(cc_cpu_y, eint, &ad_emlrtRTEI);
                cc_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  cc_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv58->size[0];
                cpu_iv58->size[0] = cc_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv58, eint, &xc_emlrtRTEI);
                itime = cc_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(cc_cpu_y, &oc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv58, &gpu_iv58, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&oc_gpu_y, cc_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel423<<<grid, block>>>(dim, oc_gpu_y, itime,
                    gpu_iv58);
                }

                omega_tmp2[0] = cpu_iv58->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel424<<<grid, block>>>(b_gpu_h, gpu_iv58,
                    omega_tmp2[0] - 1, jb_gpu_expanded);
                }

                if (static_cast<int32_T>(cf) < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = static_cast<int32_T>(cf) - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                interval_outdatedOnGpu = false;
                eint = r_cpu_rows->size[0] * r_cpu_rows->size[1];
                r_cpu_rows->size[0] = 1;
                r_cpu_rows->size[1] = b_nx;
                emxEnsureCapacity_int32_T(r_cpu_rows, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  r_cpu_rows->data[0] = 0;
                  interval_outdatedOnGpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    r_cpu_rows->data[k + 1] = nsubs;
                  }
                }

                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = fb_CutOff;
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if (fb_CutOff != 0) {
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                    dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(eint), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(r_cpu_rows, &fb_gpu_rows,
                    !interval_outdatedOnGpu);
                  gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  if (interval_outdatedOnGpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&fb_gpu_rows, r_cpu_rows);
                  }

                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel425<<<grid, block>>>(h_gpu_yCol,
                      jb_gpu_expanded, fb_gpu_rows, cf, fb_CutOff - 1, t_gpu_w);
                  }
                }
              }
            } else {
              if (static_cast<int32_T>(cf) == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (static_cast<int32_T>(cf) + b_cpu_h->size[0]) - 1;
              }

              eint = k_cpu_w->size[0] * k_cpu_w->size[1];
              k_cpu_w->size[0] = nsubs;
              k_cpu_w->size[1] = 1;
              emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel426<<<grid, block>>>(nsubs - 1, t_gpu_w);
              }

              if (static_cast<int32_T>(cf) == 0) {
                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = nsubs;
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel427<<<grid, block>>>(nsubs - 1, t_gpu_w);
                }
              } else if ((static_cast<int32_T>(cf) == 1) && (b_cpu_h->size[0] ==
                          1)) {
                eint = q_cpu_c->size[0];
                q_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(q_cpu_c, eint, &vc_emlrtRTEI);
                cpu_r = 1.0;
                b_cpu_r = 0.0;
                gpuEmxEnsureCapacity_real_T(q_cpu_c, &m_gpu_c, true);
                cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                  &j_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                  &b_cpu_r, (double *)&m_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = nsubs;
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &rc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(nsubs - 1), &grid,
                  &block, 2147483647U);
                gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel428<<<grid, block>>>(m_gpu_c, nsubs - 1, t_gpu_w);
                }
              } else {
                real_T blockDims[3];
                N = (static_cast<uint32_T>(static_cast<int32_T>(cf)) +
                     static_cast<uint32_T>(b_cpu_h->size[0])) - 1U;
                lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                fb_CutOff = static_cast<int32_T>(N);
                dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  ix = MAX_int32_T;
                } else {
                  ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = y_cpu_expanded->size[0] * y_cpu_expanded->size[1];
                y_cpu_expanded->size[0] = ix - 1;
                y_cpu_expanded->size[1] = 1;
                emxEnsureCapacity_real_T(y_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = (static_cast<int32_T>(N) + b_cpu_h->size[0]) - 2;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(y_cpu_expanded, &kb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel429<<<grid, block>>>(b_nx, kb_gpu_expanded);
                }

                b_nx = static_cast<int32_T>(cf);
                eint = vb_cpu_y->size[0] * vb_cpu_y->size[1];
                vb_cpu_y->size[0] = 1;
                vb_cpu_y->size[1] = static_cast<int32_T>(cf);
                emxEnsureCapacity_int32_T(vb_cpu_y, eint, &ad_emlrtRTEI);
                vb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  vb_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv60->size[0];
                cpu_iv60->size[0] = vb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv60, eint, &xc_emlrtRTEI);
                itime = vb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(vb_cpu_y, &pc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv60, &gpu_iv60, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&pc_gpu_y, vb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel430<<<grid, block>>>(dim, pc_gpu_y, itime,
                    gpu_iv60);
                }

                xt_size[0] = cpu_iv60->size[0];
                mwGetLaunchParameters1D(computeNumIters(0, xt_size[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel431<<<grid, block>>>(h_gpu_yCol, gpu_iv60,
                    xt_size[0] - 1, kb_gpu_expanded);
                }

                b_nx = b_cpu_h->size[0];
                eint = kb_cpu_rows->size[0] * kb_cpu_rows->size[1];
                kb_cpu_rows->size[0] = 1;
                kb_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(kb_cpu_rows, eint, &ad_emlrtRTEI);
                kb_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  kb_cpu_rows->data[k + 1] = nsubs;
                }

                eint = k_cpu_w->size[0] * k_cpu_w->size[1];
                k_cpu_w->size[0] = static_cast<int32_T>(N);
                k_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(k_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(0, fb_CutOff - 1),
                    dim3(N, 1U, 1U), dim3(static_cast<uint32_T>(lidx), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(kb_cpu_rows, &gb_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&gb_gpu_rows, kb_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel432<<<grid, block>>>(kb_gpu_expanded,
                      gb_gpu_rows, b_gpu_h, fb_CutOff - 1, t_gpu_w,
                      b_cpu_h->size[0U]);
                  }
                }
              }
            }

            if (!(intFsq - 1.0 >= 0.0)) {
              db_y = nullptr;
              m44 = emlrtCreateCharArray(2, &iv28[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m44, &rfmt[0]);
              emlrtAssign(&db_y, m44);
              eb_y = nullptr;
              m47 = emlrtCreateDoubleScalar(intFsq - 1.0);
              emlrtAssign(&eb_y, m47);
              emlrt_marshallIn(b_sprintf(db_y, eb_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            dim = 2;
            if (k_cpu_w->size[0] != 1) {
              dim = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = k_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_lshift[itime] = k_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - dim >= 0) {
              cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                static_cast<real_T>(dim))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel408<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_nrefine = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_nrefine;
            if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
              lidx = 1;
              nw = -1;
            } else {
              lidx = static_cast<int32_T>(intFsq);
              nw = cpu_lshift[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_cwt_kernel409<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
              dim, *gpu_csz);
            eint = l_cpu_w->size[0] * l_cpu_w->size[1];
            l_cpu_w->size[0] = div_s32(nw, lidx) + 1;
            l_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(l_cpu_w, eint, &bd_emlrtRTEI);
            itime = nw / lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real_T(k_cpu_w, &t_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real_T(l_cpu_w, &u_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel410<<<grid, block>>>(t_gpu_w, cpu_lshift[0], lidx,
                itime, cpu_nrefine - 1, u_gpu_w, l_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = gc_cpu_y->size[0] * gc_cpu_y->size[1];
            gc_cpu_y->size[0] = cpu_csz[0];
            gc_cpu_y->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(gc_cpu_y, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(gc_cpu_y, &kc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel411<<<grid, block>>>(u_gpu_w, b_nx, kc_gpu_y);
            }

            b_cpu_r = std::ceil((0.0 * cf + static_cast<real_T>(b_cpu_h->size[0]))
                                / intFsq);
            if (!(cpu_csz[0] < b_cpu_r)) {
              if (b_cpu_r < 1.0) {
                cpu_nrefine = 0;
              } else {
                cpu_nrefine = static_cast<int32_T>(b_cpu_r);
              }

              nsubs = t_cpu_w->size[0] * t_cpu_w->size[1];
              t_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              t_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real_T(t_cpu_w, nsubs, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(t_cpu_w, &v_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel412<<<grid, block>>>(t_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_lshift[1] - 1, v_gpu_w, t_cpu_w->size[0U]);
              }

              nsubs = gc_cpu_y->size[0] * gc_cpu_y->size[1];
              gc_cpu_y->size[0] = cpu_nrefine;
              gc_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(gc_cpu_y, nsubs, &uc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                cpu_nrefine - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(gc_cpu_y, &kc_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel413<<<grid, block>>>(v_gpu_w, cpu_csz[0],
                  cpu_nrefine - 1, cpu_csz[1] - 1, kc_gpu_y, gc_cpu_y->size[0U]);
              }
            }

            if (gc_cpu_y->size[0] * gc_cpu_y->size[1] == 0) {
              b_nx = 0;
            } else {
              b_nx = gc_cpu_y->size[0] * gc_cpu_y->size[1];
            }

            omega_tmp2[0] = gc_cpu_y->size[0] * gc_cpu_y->size[1];
            eint = hd_cpu_y->size[0] * hd_cpu_y->size[1];
            hd_cpu_y->size[0] = 1;
            hd_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real_T(hd_cpu_y, eint, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(hd_cpu_y, &lc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel414<<<grid, block>>>(kc_gpu_y, omega_tmp2[0] - 1,
                lc_gpu_y);
            }

            eint = hb_cpu_y->size[0] * hb_cpu_y->size[1];
            hb_cpu_y->size[0] = b_nx;
            hb_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(hb_cpu_y, eint, &dd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(b_nx - 1), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(hb_cpu_y, &mc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel415<<<grid, block>>>(lc_gpu_y, b_nx - 1, mc_gpu_y);
            }
          } else {
            int32_T cpu_csz[2];
            int32_T cpu_lshift[2];
            if (!(cf - 1.0 >= 0.0)) {
              i_y = nullptr;
              m11 = emlrtCreateCharArray(2, &iv12[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m11, &rfmt[0]);
              emlrtAssign(&i_y, m11);
              r_y = nullptr;
              m20 = emlrtCreateDoubleScalar(cf - 1.0);
              emlrtAssign(&r_y, m20);
              emlrt_marshallIn(b_sprintf(i_y, r_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            ix = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = cpu_opts_x->size[itime];
            }

            cpu_nrefine = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            eint = d_cpu_yCol->size[0];
            d_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
            emxEnsureCapacity_real_T(d_cpu_yCol, eint, &lc_emlrtRTEI);
            itime = ix * static_cast<int32_T>(cf) - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(d_cpu_yCol, &i_gpu_yCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel433<<<grid, block>>>(itime, i_gpu_yCol);
            }

            if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf) >
                   0) && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                   static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                   static_cast<int32_T>(cf) > 1)))) {
              nw = 1;
              cpu_nrefine = 0;
            } else {
              nw = static_cast<int32_T>(cf);
              cpu_nrefine = ix * static_cast<int32_T>(cf);
            }

            mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1, nw)),
              &grid, &block, 2147483647U);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel434<<<grid, block>>>(gpu_opts_x, nw, div_s32
                (cpu_nrefine - 1, nw), i_gpu_yCol);
            }

            cpu_csz[0] = cpu_opts_x->size[0] * static_cast<int32_T>(cf);
            eint = g_cpu_x->size[0] * g_cpu_x->size[1];
            g_cpu_x->size[0] = cpu_csz[0];
            g_cpu_x->size[1] = cpu_opts_x->size[1];
            emxEnsureCapacity_real_T(g_cpu_x, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(g_cpu_x, &k_gpu_x, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel435<<<grid, block>>>(i_gpu_yCol, b_nx, k_gpu_x);
            }

            if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
              if (cpu_opts_x->size[1] < 1) {
                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = 1;
                d_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel436<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (w_gpu_w);
              } else {
                eint = cpu_opts_x->size[1];
                nsubs = d_cpu_a->size[0];
                d_cpu_a->size[0] = cpu_opts_x->size[1];
                emxEnsureCapacity_real_T(d_cpu_a, nsubs, &tc_emlrtRTEI);
                mwGetLaunchParameters1D(computeNumIters(eint - 1), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_a, &h_gpu_a, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel443<<<grid, block>>>(i_gpu_yCol, eint - 1,
                    h_gpu_a);
                }

                gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
                q_ok = b_cpu_h->data[0];
                eint = c_cpu_c->size[0];
                c_cpu_c->size[0] = d_cpu_a->size[0];
                emxEnsureCapacity_real_T(c_cpu_c, eint, &wc_emlrtRTEI);
                b_nx = d_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(c_cpu_c, &n_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel444<<<grid, block>>>(b_nx, n_gpu_c);
                }

                if (d_cpu_a->size[0] == 1) {
                  cpu_r = b_cpu_h->data[0];
                  eint = c_cpu_c->size[0];
                  c_cpu_c->size[0] = 1;
                  emxEnsureCapacity_real_T(c_cpu_c, eint, &wc_emlrtRTEI);
                  gpuEmxEnsureCapacity_real_T(c_cpu_c, &n_gpu_c, true);
                  ec_cwt_kernel445<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                    (cpu_r, h_gpu_a, n_gpu_c);
                } else {
                  int32_T threadDims[3];
                  lidx = static_cast<int32_T>(std::fmin(32.0,
                    (static_cast<real_T>(d_cpu_a->size[0]) + 1.0) - 1.0));
                  threadDims[0] = static_cast<int32_T>(std::floor(static_cast<
                    real_T>((static_cast<uint32_T>(d_cpu_a->size[0]) +
                             static_cast<uint32_T>(lidx)) - 1U) /
                    static_cast<real_T>(lidx)));
                  fb_CutOff = d_cpu_a->size[0];
                  if (d_cpu_a->size[0] > 2147483646) {
                    ix = MAX_int32_T;
                  } else {
                    ix = d_cpu_a->size[0] + 1;
                  }

                  eint = i_cpu_expanded->size[0];
                  i_cpu_expanded->size[0] = ix - 1;
                  emxEnsureCapacity_real_T(i_cpu_expanded, eint, &xc_emlrtRTEI);
                  b_nx = d_cpu_a->size[0] - 1;
                  mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_real_T(i_cpu_expanded, &lb_gpu_expanded,
                    true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel447<<<grid, block>>>(b_nx, lb_gpu_expanded);
                  }

                  b_nx = d_cpu_a->size[0];
                  eint = t_cpu_y->size[0] * t_cpu_y->size[1];
                  t_cpu_y->size[0] = 1;
                  t_cpu_y->size[1] = d_cpu_a->size[0];
                  emxEnsureCapacity_int32_T(t_cpu_y, eint, &ad_emlrtRTEI);
                  t_cpu_y->data[0] = 1;
                  nsubs = 1;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    t_cpu_y->data[k + 1] = nsubs;
                  }

                  eint = cpu_iv35->size[0];
                  cpu_iv35->size[0] = t_cpu_y->size[1];
                  emxEnsureCapacity_int32_T(cpu_iv35, eint, &xc_emlrtRTEI);
                  itime = t_cpu_y->size[1] - 1;
                  mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                    2147483647U);
                  gpuEmxEnsureCapacity_int32_T(t_cpu_y, &qc_gpu_y, false);
                  gpuEmxEnsureCapacity_int32_T(cpu_iv35, &gpu_iv35, true);
                  gpuEmxMemcpyCpuToGpu_int32_T(&qc_gpu_y, t_cpu_y);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel448<<<grid, block>>>(qc_gpu_y, itime, gpu_iv35);
                  }

                  omega_tmp2[0] = cpu_iv35->size[0];
                  mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                    &grid, &block, 2147483647U);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel449<<<grid, block>>>(h_gpu_a, gpu_iv35,
                      omega_tmp2[0] - 1, lb_gpu_expanded);
                  }

                  eint = c_cpu_c->size[0];
                  c_cpu_c->size[0] = d_cpu_a->size[0];
                  emxEnsureCapacity_real_T(c_cpu_c, eint, &xc_emlrtRTEI);
                  mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(
                    static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                    static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                    &grid, &block);
                  gpuEmxEnsureCapacity_real_T(c_cpu_c, &n_gpu_c, true);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel450<<<grid, block>>>(q_ok, lb_gpu_expanded,
                      fb_CutOff - 1, n_gpu_c);
                  }
                }

                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = 1;
                d_cpu_w->size[1] = c_cpu_c->size[0];
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                b_nx = c_cpu_c->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel446<<<grid, block>>>(n_gpu_c, b_nx, w_gpu_w,
                    d_cpu_w->size[0U]);
                }
              }
            } else if (b_cpu_h->size[0] > cpu_csz[0]) {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_opts_x->size[1];
              }

              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = nsubs;
              d_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel451<<<grid, block>>>(itime, w_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = nsubs;
                d_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel452<<<grid, block>>>(itime, w_gpu_w);
                }
              } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                          (cpu_opts_x->size[1] == 1))) {
                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = 1;
                d_cpu_w->size[1] = 1;
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                ec_cwt_kernel453<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                  (i_gpu_yCol, b_gpu_h, w_gpu_w);
              } else {
                real_T blockDims[3];
                int32_T threadDims[3];
                cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) + static_cast<
                         real_T>(cpu_csz[0])) - 1.0;
                s = std::fmin(32.0, cpu_r);
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
                blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_nrefine)) - 1U) /
                  static_cast<real_T>(cpu_nrefine));
                if (s >= -2.147483648E+9) {
                  eint = static_cast<int32_T>(s);
                } else {
                  eint = MIN_int32_T;
                }

                threadDims[0] = eint;
                threadDims[1] = cpu_nrefine;
                nw = cpu_opts_x->size[1];
                if (cpu_r < 2.147483648E+9) {
                  if (cpu_r >= -2.147483648E+9) {
                    fb_CutOff = static_cast<int32_T>(cpu_r);
                  } else {
                    fb_CutOff = MIN_int32_T;
                  }
                } else {
                  fb_CutOff = MAX_int32_T;
                }

                fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                  floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
                if (fc >= -2.147483648E+9) {
                  dim = static_cast<int32_T>(fc);
                } else {
                  dim = MIN_int32_T;
                }

                if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff)) {
                  ix = MIN_int32_T;
                } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                            - fb_CutOff)) {
                  ix = MAX_int32_T;
                } else {
                  ix = fb_CutOff + cpu_csz[0];
                }

                if (ix >= -2147483647) {
                  ix--;
                }

                eint = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
                m_cpu_expanded->size[0] = ix;
                emxEnsureCapacity_real_T(m_cpu_expanded, eint, &xc_emlrtRTEI);
                if (cpu_opts_x->size[1] > MAX_int32_T - cpu_opts_x->size[1]) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_opts_x->size[1] + cpu_opts_x->size[1];
                }

                eint = m_cpu_expanded->size[0] * m_cpu_expanded->size[1];
                m_cpu_expanded->size[1] = ix - 1;
                emxEnsureCapacity_real_T(m_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_opts_x->size[1] +
                  cpu_opts_x->size[1]) - 1) - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(m_cpu_expanded, &mb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel454<<<grid, block>>>(b_nx, mb_gpu_expanded);
                }

                b_nx = b_cpu_h->size[0];
                eint = ab_cpu_y->size[0] * ab_cpu_y->size[1];
                ab_cpu_y->size[0] = 1;
                ab_cpu_y->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(ab_cpu_y, eint, &ad_emlrtRTEI);
                ab_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  ab_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv40->size[0];
                cpu_iv40->size[0] = ab_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv40, eint, &xc_emlrtRTEI);
                itime = ab_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ab_cpu_y, &rc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv40, &gpu_iv40, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&rc_gpu_y, ab_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel455<<<grid, block>>>(dim, rc_gpu_y, itime,
                    gpu_iv40);
                }

                cpu_nrefine = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (cpu_opts_x->size[1]) / 2.0)) + static_cast<int32_T>(std::
                  floor((static_cast<real_T>(cpu_opts_x->size[1]) - 1.0) / 2.0));
                omega_tmp2[0] = cpu_iv40->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel456<<<grid, block>>>(b_gpu_h, cpu_nrefine,
                    gpu_iv40, omega_tmp2[0] - 1, mb_gpu_expanded,
                    m_cpu_expanded->size[0U]);
                }

                if (cpu_csz[0] < -2147483647) {
                  ix = MIN_int32_T;
                } else {
                  ix = cpu_csz[0] - 1;
                }

                if (ix < 0) {
                  b_nx = 0;
                } else {
                  b_nx = ix + 1;
                }

                interval_outdatedOnGpu = false;
                eint = e_cpu_rows->size[0] * e_cpu_rows->size[1];
                e_cpu_rows->size[0] = 1;
                e_cpu_rows->size[1] = b_nx;
                emxEnsureCapacity_int32_T(e_cpu_rows, eint, &ad_emlrtRTEI);
                if (b_nx > 0) {
                  e_cpu_rows->data[0] = 0;
                  interval_outdatedOnGpu = true;
                  nsubs = 0;
                  for (k = 0; k <= b_nx - 2; k++) {
                    nsubs++;
                    e_cpu_rows->data[k + 1] = nsubs;
                  }
                }

                b_nx = cpu_opts_x->size[1];
                eint = c_cpu_cols->size[0] * c_cpu_cols->size[1];
                c_cpu_cols->size[0] = 1;
                c_cpu_cols->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(c_cpu_cols, eint, &ad_emlrtRTEI);
                c_cpu_cols->data[0] = 0;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  c_cpu_cols->data[k + 1] = nsubs;
                }

                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = fb_CutOff;
                d_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real_T(d_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if (fb_CutOff != 0) {
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  eint = threadDims[0];
                  if (threadDims[0] < 0) {
                    eint = 0;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(eint), static_cast<uint32_T>
                    (threadDims[1]), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(c_cpu_cols, &e_gpu_cols, false);
                  gpuEmxEnsureCapacity_int32_T(e_cpu_rows, &hb_gpu_rows,
                    !interval_outdatedOnGpu);
                  gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&e_gpu_cols, c_cpu_cols);
                  if (interval_outdatedOnGpu) {
                    gpuEmxMemcpyCpuToGpu_int32_T(&hb_gpu_rows, e_cpu_rows);
                  }

                  checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                    cudaMemcpyHostToDevice), __FILE__, __LINE__);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel457<<<grid, block>>>(i_gpu_yCol,
                      mb_gpu_expanded, e_gpu_cols, hb_gpu_rows, *gpu_csz,
                      fb_CutOff - 1, nw - 1, w_gpu_w, m_cpu_expanded->size[0U],
                      d_cpu_w->size[0U]);
                  }
                }
              }
            } else {
              if (cpu_csz[0] == 0) {
                nsubs = b_cpu_h->size[0];
              } else {
                nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
              }

              if (cpu_opts_x->size[1] == 0) {
                cpu_nrefine = 1;
              } else {
                cpu_nrefine = cpu_opts_x->size[1];
              }

              eint = d_cpu_w->size[0] * d_cpu_w->size[1];
              d_cpu_w->size[0] = nsubs;
              d_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel458<<<grid, block>>>(itime, w_gpu_w);
              }

              if ((cpu_csz[0] == 0) || (cpu_opts_x->size[1] == 0)) {
                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = nsubs;
                d_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel459<<<grid, block>>>(itime, w_gpu_w);
                }
              } else if ((cpu_csz[0] == 1) && (cpu_opts_x->size[1] == 1) &&
                         (b_cpu_h->size[0] == 1)) {
                eint = k_cpu_c->size[0];
                k_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(k_cpu_c, eint, &vc_emlrtRTEI);
                cpu_r = 1.0;
                b_cpu_r = 0.0;
                gpuEmxEnsureCapacity_real_T(k_cpu_c, &o_gpu_c, true);
                cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                  CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)
                  &k_gpu_x.data[0], 1, (double *)&b_gpu_h.data[0], 1, (double *)
                  &b_cpu_r, (double *)&o_gpu_c.data[0], 1), __FILE__, __LINE__);
                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = nsubs;
                d_cpu_w->size[1] = cpu_nrefine;
                emxEnsureCapacity_real_T(d_cpu_w, eint, &rc_emlrtRTEI);
                itime = nsubs * cpu_nrefine - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                x_data_outdatedOnGpu = false;
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel460<<<grid, block>>>(o_gpu_c, itime, w_gpu_w);
                }
              } else {
                real_T blockDims[3];
                N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                     (b_cpu_h->size[0])) - 1U;
                lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>
                  (N)));
                cpu_nrefine = static_cast<int32_T>(std::fmin(32.0, (static_cast<
                  real_T>(cpu_opts_x->size[1]) + 1.0) - 1.0));
                blockDims[0] = std::floor((static_cast<real_T>(N) + (
                  static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
                blockDims[1] = std::floor(static_cast<real_T>
                  ((static_cast<uint32_T>(cpu_opts_x->size[1]) +
                    static_cast<uint32_T>(cpu_nrefine)) - 1U) /
                  static_cast<real_T>(cpu_nrefine));
                nw = cpu_opts_x->size[1];
                if (N > 2147483647U) {
                  N = 2147483647U;
                }

                fb_CutOff = static_cast<int32_T>(N);
                dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                  (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                  static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
                if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                     MAX_int32_T - static_cast<int32_T>(N))) {
                  ix = MAX_int32_T;
                } else {
                  ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
                }

                eint = l_cpu_expanded->size[0] * l_cpu_expanded->size[1];
                l_cpu_expanded->size[0] = ix - 1;
                emxEnsureCapacity_real_T(l_cpu_expanded, eint, &xc_emlrtRTEI);
                if (cpu_opts_x->size[1] > 2147483646) {
                  ix = MAX_int32_T;
                } else {
                  ix = cpu_opts_x->size[1] + 1;
                }

                eint = l_cpu_expanded->size[0] * l_cpu_expanded->size[1];
                l_cpu_expanded->size[1] = ix - 1;
                emxEnsureCapacity_real_T(l_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                  cpu_opts_x->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(l_cpu_expanded, &nb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel461<<<grid, block>>>(b_nx, nb_gpu_expanded);
                }

                b_nx = cpu_csz[0];
                eint = w_cpu_y->size[0] * w_cpu_y->size[1];
                w_cpu_y->size[0] = 1;
                w_cpu_y->size[1] = cpu_csz[0];
                emxEnsureCapacity_int32_T(w_cpu_y, eint, &ad_emlrtRTEI);
                w_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  w_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv43->size[0];
                cpu_iv43->size[0] = w_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv43, eint, &xc_emlrtRTEI);
                itime = w_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(w_cpu_y, &sc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv43, &gpu_iv43, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&sc_gpu_y, w_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel462<<<grid, block>>>(dim, sc_gpu_y, itime,
                    gpu_iv43);
                }

                b_nx = cpu_opts_x->size[1];
                eint = ub_cpu_y->size[0] * ub_cpu_y->size[1];
                ub_cpu_y->size[0] = 1;
                ub_cpu_y->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_int32_T(ub_cpu_y, eint, &ad_emlrtRTEI);
                ub_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  ub_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv59->size[0];
                cpu_iv59->size[0] = ub_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv59, eint, &xc_emlrtRTEI);
                itime = ub_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(ub_cpu_y, &tc_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv59, &gpu_iv59, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&tc_gpu_y, ub_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel463<<<grid, block>>>(tc_gpu_y, itime, gpu_iv59);
                }

                xt_size[0] = cpu_iv43->size[0];
                xt_size[1] = cpu_iv59->size[0];
                mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size
                  [0] - 1), &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel464<<<grid, block>>>(i_gpu_yCol, xt_size[0],
                    gpu_iv59, gpu_iv43, xt_size[0] - 1, xt_size[1] - 1,
                    nb_gpu_expanded, l_cpu_expanded->size[0U]);
                }

                b_nx = b_cpu_h->size[0];
                eint = m_cpu_rows->size[0] * m_cpu_rows->size[1];
                m_cpu_rows->size[0] = 1;
                m_cpu_rows->size[1] = b_cpu_h->size[0];
                emxEnsureCapacity_int32_T(m_cpu_rows, eint, &ad_emlrtRTEI);
                m_cpu_rows->data[0] = 0;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  m_cpu_rows->data[k + 1] = nsubs;
                }

                eint = d_cpu_w->size[0] * d_cpu_w->size[1];
                d_cpu_w->size[0] = static_cast<int32_T>(N);
                d_cpu_w->size[1] = cpu_opts_x->size[1];
                emxEnsureCapacity_real_T(d_cpu_w, eint, &xc_emlrtRTEI);
                x_data_outdatedOnGpu = true;
                if (static_cast<int32_T>(N) != 0) {
                  if (blockDims[0] < 4.294967296E+9) {
                    if (blockDims[0] >= 0.0) {
                      N = static_cast<uint32_T>(blockDims[0]);
                    } else {
                      N = 0U;
                    }
                  } else if (blockDims[0] >= 4.294967296E+9) {
                    N = MAX_uint32_T;
                  } else {
                    N = 0U;
                  }

                  mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                    dim3(N, static_cast<uint32_T>(blockDims[1]), 1U), dim3(
                    static_cast<uint32_T>(lidx), static_cast<uint32_T>(
                    static_cast<int8_T>(cpu_nrefine)), 1U), &grid, &block);
                  gpuEmxEnsureCapacity_int32_T(m_cpu_rows, &ib_gpu_rows, false);
                  gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
                  x_data_outdatedOnGpu = false;
                  gpuEmxMemcpyCpuToGpu_int32_T(&ib_gpu_rows, m_cpu_rows);
                  validLaunchParams = mwValidateLaunchParameters(grid, block);
                  if (validLaunchParams) {
                    ec_cwt_kernel465<<<grid, block>>>(nb_gpu_expanded,
                      ib_gpu_rows, b_gpu_h, fb_CutOff - 1, nw - 1, w_gpu_w,
                      b_cpu_h->size[0U], l_cpu_expanded->size[0U], d_cpu_w->
                      size[0U]);
                  }
                }
              }
            }

            if (!(intFsq - 1.0 >= 0.0)) {
              fb_y = nullptr;
              m31 = emlrtCreateCharArray(2, &iv22[0]);
              emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m31, &rfmt[0]);
              emlrtAssign(&fb_y, m31);
              mb_y = nullptr;
              m38 = emlrtCreateDoubleScalar(intFsq - 1.0);
              emlrtAssign(&mb_y, m38);
              emlrt_marshallIn(b_sprintf(fb_y, mb_y, &e_emlrtMCI),
                               "<output of sprintf>", unusedExpr);
            }

            dim = 2;
            if (d_cpu_w->size[0] != 1) {
              dim = 1;
            }

            interval_outdatedOnGpu = false;
            fx_data_outdatedOnCpu = false;
            for (itime = 0; itime < 2; itime++) {
              cpu_csz[itime] = d_cpu_w->size[itime];
              fx_data_outdatedOnCpu = true;
              cpu_lshift[itime] = d_cpu_w->size[itime];
              interval_outdatedOnGpu = true;
            }

            if (1 - dim >= 0) {
              cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 -
                static_cast<real_T>(dim))) / 2.0);
              mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
                &block, 2147483647U);
              if (interval_outdatedOnGpu) {
                checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel437<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                  *gpu_lshift);
              }

              checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
                cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            }

            cpu_nrefine = cpu_lshift[0];
            cpu_lshift[0] = cpu_lshift[1];
            cpu_lshift[1] = cpu_nrefine;
            if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
              lidx = 1;
              nw = -1;
            } else {
              lidx = static_cast<int32_T>(intFsq);
              nw = cpu_lshift[0] - 1;
            }

            if (fx_data_outdatedOnCpu) {
              checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            ec_cwt_kernel438<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
              dim, *gpu_csz);
            eint = q_cpu_w->size[0] * q_cpu_w->size[1];
            q_cpu_w->size[0] = div_s32(nw, lidx) + 1;
            q_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(q_cpu_w, eint, &bd_emlrtRTEI);
            itime = nw / lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime),
              &grid, &block, 2147483647U);
            if (x_data_outdatedOnGpu) {
              gpuEmxEnsureCapacity_real_T(d_cpu_w, &w_gpu_w, true);
            }

            gpuEmxEnsureCapacity_real_T(q_cpu_w, &x_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel439<<<grid, block>>>(w_gpu_w, cpu_lshift[0], lidx,
                itime, cpu_nrefine - 1, x_gpu_w, q_cpu_w->size[0U]);
            }

            checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
            eint = hb_cpu_y->size[0] * hb_cpu_y->size[1];
            hb_cpu_y->size[0] = cpu_csz[0];
            hb_cpu_y->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(hb_cpu_y, eint, &rc_emlrtRTEI);
            b_nx = cpu_csz[0] * cpu_csz[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(hb_cpu_y, &mc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel440<<<grid, block>>>(x_gpu_w, b_nx, mc_gpu_y);
            }

            b_cpu_r = std::ceil(((static_cast<real_T>(cpu_opts_x->size[0]) - 1.0)
                                 * cf + static_cast<real_T>(b_cpu_h->size[0])) /
                                intFsq);
            if (!(cpu_csz[0] < b_cpu_r)) {
              if (b_cpu_r < 1.0) {
                cpu_nrefine = 0;
              } else {
                cpu_nrefine = static_cast<int32_T>(b_cpu_r);
              }

              nsubs = y_cpu_w->size[0] * y_cpu_w->size[1];
              y_cpu_w->size[0] = div_s32(nw, lidx) + 1;
              y_cpu_w->size[1] = cpu_lshift[1];
              emxEnsureCapacity_real_T(y_cpu_w, nsubs, &bd_emlrtRTEI);
              itime = nw / lidx;
              mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
                &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(y_cpu_w, &y_gpu_w, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel441<<<grid, block>>>(w_gpu_w, cpu_lshift[0], lidx,
                  itime, cpu_lshift[1] - 1, y_gpu_w, y_cpu_w->size[0U]);
              }

              nsubs = hb_cpu_y->size[0] * hb_cpu_y->size[1];
              hb_cpu_y->size[0] = cpu_nrefine;
              hb_cpu_y->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(hb_cpu_y, nsubs, &uc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1,
                cpu_nrefine - 1), &grid, &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(hb_cpu_y, &mc_gpu_y, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel442<<<grid, block>>>(y_gpu_w, cpu_csz[0],
                  cpu_nrefine - 1, cpu_csz[1] - 1, mc_gpu_y, hb_cpu_y->size[0U]);
              }
            }
          }

          if (std::isnan(err_ok)) {
            eint = bc_cpu_y->size[0] * bc_cpu_y->size[1];
            bc_cpu_y->size[0] = 1;
            bc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(bc_cpu_y, eint, &d_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(bc_cpu_y, &nc_gpu_y, true);
            g_y_needsGpuEnsureCapacity = false;
            ec_cwt_kernel416<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(nc_gpu_y);
          } else if (err_ok < 1.0) {
            bc_cpu_y->size[0] = 1;
            bc_cpu_y->size[1] = 0;
          } else {
            eint = bc_cpu_y->size[0] * bc_cpu_y->size[1];
            bc_cpu_y->size[0] = 1;
            bc_cpu_y->size[1] = static_cast<int32_T>(err_ok - 1.0) + 1;
            emxEnsureCapacity_real_T(bc_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(err_ok
              - 1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(bc_cpu_y, &nc_gpu_y, true);
            g_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel418<<<grid, block>>>(static_cast<int32_T>(err_ok -
                1.0), nc_gpu_y);
            }
          }

          eint = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = static_cast<int32_T>(err_ok);
          cpu_y1->size[1] = 1;
          emxEnsureCapacity_real_T(cpu_y1, eint, &ac_emlrtRTEI);
          mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(err_ok) -
            1), &grid, &block, 2147483647U);
          if (g_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(bc_cpu_y, &nc_gpu_y, true);
          }

          g_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel417<<<grid, block>>>(mc_gpu_y, nc_gpu_y, tol,
              static_cast<int32_T>(err_ok) - 1, gpu_y1);
          }
        } else {
          int32_T cpu_csz[2];
          int32_T cpu_lshift[2];
          q_ok = std::ceil(static_cast<real_T>(cpu_opts_x->size[0]) * cf /
                           intFsq);
          first_iteration = (cpu_opts_x->size[0] == 1);
          if (first_iteration) {
            eint = cpu_xCol->size[0] * cpu_xCol->size[1];
            cpu_xCol->size[0] = cpu_opts_x->size[0] * cpu_opts_x->size[1];
            cpu_xCol->size[1] = 1;
            emxEnsureCapacity_real_T(cpu_xCol, eint, &ic_emlrtRTEI);
            b_nx = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_xCol, &gpu_xCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel494<<<grid, block>>>(gpu_opts_x, b_nx, gpu_xCol);
            }
          } else {
            eint = cpu_xCol->size[0] * cpu_xCol->size[1];
            cpu_xCol->size[0] = cpu_opts_x->size[0];
            cpu_xCol->size[1] = cpu_opts_x->size[1];
            emxEnsureCapacity_real_T(cpu_xCol, eint, &hc_emlrtRTEI);
            b_nx = cpu_opts_x->size[0] * cpu_opts_x->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(cpu_xCol, &gpu_xCol, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel561<<<grid, block>>>(gpu_opts_x, b_nx, gpu_xCol);
            }
          }

          if (!(cf - 1.0 >= 0.0)) {
            x_y = nullptr;
            m13 = emlrtCreateCharArray(2, &iv14[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m13, &rfmt[0]);
            emlrtAssign(&x_y, m13);
            ab_y = nullptr;
            m22 = emlrtCreateDoubleScalar(cf - 1.0);
            emlrtAssign(&ab_y, m22);
            emlrt_marshallIn(b_sprintf(x_y, ab_y, &e_emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          ix = cpu_xCol->size[0] * cpu_xCol->size[1];
          if ((cpu_xCol->size[0] == 1) && (cpu_xCol->size[1] == 1)) {
            dim = 0;
          } else {
            dim = 1;
            if (cpu_xCol->size[0] != 1) {
              dim = 0;
            }
          }

          for (itime = 0; itime < 2; itime++) {
            cpu_csz[itime] = cpu_xCol->size[itime];
          }

          cpu_nrefine = cpu_xCol->size[0] * cpu_xCol->size[1];
          eint = g_cpu_yCol->size[0];
          g_cpu_yCol->size[0] = ix * static_cast<int32_T>(cf);
          emxEnsureCapacity_real_T(g_cpu_yCol, eint, &lc_emlrtRTEI);
          itime = ix * static_cast<int32_T>(cf) - 1;
          mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(g_cpu_yCol, &j_gpu_yCol, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel495<<<grid, block>>>(itime, j_gpu_yCol);
          }

          if ((static_cast<int32_T>(cf) == 0) || (((static_cast<int32_T>(cf) > 0)
                && (cpu_nrefine * static_cast<int32_T>(cf) < 1)) || ((
                 static_cast<int32_T>(cf) < 0) && (cpu_nrefine *
                 static_cast<int32_T>(cf) > 1)))) {
            nw = 1;
            cpu_nrefine = 0;
          } else {
            nw = static_cast<int32_T>(cf);
            cpu_nrefine = ix * static_cast<int32_T>(cf);
          }

          mwGetLaunchParameters1D(computeNumIters(div_s32(cpu_nrefine - 1, nw)),
            &grid, &block, 2147483647U);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel496<<<grid, block>>>(gpu_xCol, nw, div_s32(cpu_nrefine
              - 1, nw), j_gpu_yCol);
          }

          cpu_csz[dim] = cpu_xCol->size[dim] * static_cast<int32_T>(cf);
          eint = j_cpu_x->size[0] * j_cpu_x->size[1];
          j_cpu_x->size[0] = cpu_csz[0];
          j_cpu_x->size[1] = cpu_csz[1];
          emxEnsureCapacity_real_T(j_cpu_x, eint, &rc_emlrtRTEI);
          b_nx = cpu_csz[0] * cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(j_cpu_x, &l_gpu_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel497<<<grid, block>>>(j_gpu_yCol, b_nx, l_gpu_x);
          }

          if ((cpu_csz[0] == 1) && (b_cpu_h->size[0] == 1)) {
            if (cpu_csz[1] < 1) {
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = 1;
              h_cpu_w->size[1] = 1;
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              ec_cwt_kernel498<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(ab_gpu_w);
            } else {
              nsubs = g_cpu_a->size[0];
              g_cpu_a->size[0] = cpu_csz[1];
              emxEnsureCapacity_real_T(g_cpu_a, nsubs, &tc_emlrtRTEI);
              mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1), &grid,
                &block, 2147483647U);
              gpuEmxEnsureCapacity_real_T(g_cpu_a, &i_gpu_a, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel510<<<grid, block>>>(j_gpu_yCol, cpu_csz[1] - 1,
                  i_gpu_a);
              }

              gpuEmxMemcpyGpuToCpu_real_T(b_cpu_h, &b_gpu_h);
              b_cpu_r = b_cpu_h->data[0];
              eint = f_cpu_c->size[0];
              f_cpu_c->size[0] = g_cpu_a->size[0];
              emxEnsureCapacity_real_T(f_cpu_c, eint, &wc_emlrtRTEI);
              b_nx = g_cpu_a->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(f_cpu_c, &p_gpu_c, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel511<<<grid, block>>>(b_nx, p_gpu_c);
              }

              if (g_cpu_a->size[0] == 1) {
                cpu_r = b_cpu_h->data[0];
                eint = f_cpu_c->size[0];
                f_cpu_c->size[0] = 1;
                emxEnsureCapacity_real_T(f_cpu_c, eint, &wc_emlrtRTEI);
                gpuEmxEnsureCapacity_real_T(f_cpu_c, &p_gpu_c, true);
                ec_cwt_kernel512<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(cpu_r,
                  i_gpu_a, p_gpu_c);
              } else {
                int32_T threadDims[3];
                lidx = static_cast<int32_T>(std::fmin(32.0, (static_cast<real_T>
                  (g_cpu_a->size[0]) + 1.0) - 1.0));
                threadDims[0] = static_cast<int32_T>(std::floor
                  ((static_cast<real_T>(static_cast<uint32_T>(g_cpu_a->size[0])
                  + static_cast<uint32_T>(lidx)) - 1.0) / static_cast<real_T>
                   (lidx)));
                fb_CutOff = g_cpu_a->size[0];
                if (g_cpu_a->size[0] > 2147483646) {
                  ix = MAX_int32_T;
                } else {
                  ix = g_cpu_a->size[0] + 1;
                }

                eint = r_cpu_expanded->size[0];
                r_cpu_expanded->size[0] = ix - 1;
                emxEnsureCapacity_real_T(r_cpu_expanded, eint, &xc_emlrtRTEI);
                b_nx = g_cpu_a->size[0] - 1;
                mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_real_T(r_cpu_expanded, &sb_gpu_expanded,
                  true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel514<<<grid, block>>>(b_nx, sb_gpu_expanded);
                }

                b_nx = g_cpu_a->size[0];
                eint = fb_cpu_y->size[0] * fb_cpu_y->size[1];
                fb_cpu_y->size[0] = 1;
                fb_cpu_y->size[1] = g_cpu_a->size[0];
                emxEnsureCapacity_int32_T(fb_cpu_y, eint, &ad_emlrtRTEI);
                fb_cpu_y->data[0] = 1;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  fb_cpu_y->data[k + 1] = nsubs;
                }

                eint = cpu_iv46->size[0];
                cpu_iv46->size[0] = fb_cpu_y->size[1];
                emxEnsureCapacity_int32_T(cpu_iv46, eint, &xc_emlrtRTEI);
                itime = fb_cpu_y->size[1] - 1;
                mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                  2147483647U);
                gpuEmxEnsureCapacity_int32_T(fb_cpu_y, &cd_gpu_y, false);
                gpuEmxEnsureCapacity_int32_T(cpu_iv46, &gpu_iv46, true);
                gpuEmxMemcpyCpuToGpu_int32_T(&cd_gpu_y, fb_cpu_y);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel515<<<grid, block>>>(cd_gpu_y, itime, gpu_iv46);
                }

                omega_tmp2[0] = cpu_iv46->size[0];
                mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1),
                  &grid, &block, 2147483647U);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel516<<<grid, block>>>(i_gpu_a, gpu_iv46,
                    omega_tmp2[0] - 1, sb_gpu_expanded);
                }

                eint = f_cpu_c->size[0];
                f_cpu_c->size[0] = g_cpu_a->size[0];
                emxEnsureCapacity_real_T(f_cpu_c, eint, &xc_emlrtRTEI);
                mwApplyLaunchParameters(computeNumIters(fb_CutOff - 1), dim3(
                  static_cast<uint32_T>(threadDims[0]), 1U, 1U), dim3(
                  static_cast<uint32_T>(static_cast<int8_T>(lidx)), 1U, 1U),
                  &grid, &block);
                gpuEmxEnsureCapacity_real_T(f_cpu_c, &p_gpu_c, true);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel517<<<grid, block>>>(b_cpu_r, sb_gpu_expanded,
                    fb_CutOff - 1, p_gpu_c);
                }
              }

              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = 1;
              h_cpu_w->size[1] = f_cpu_c->size[0];
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              b_nx = f_cpu_c->size[0] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel513<<<grid, block>>>(p_gpu_c, b_nx, ab_gpu_w,
                  h_cpu_w->size[0U]);
              }
            }
          } else if (b_cpu_h->size[0] > cpu_csz[0]) {
            if (cpu_csz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (b_cpu_h->size[0] + cpu_csz[0]) - 1;
            }

            if (cpu_csz[1] == 0) {
              cpu_nrefine = 1;
            } else {
              cpu_nrefine = cpu_csz[1];
            }

            eint = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = nsubs;
            h_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
            itime = nsubs * cpu_nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel518<<<grid, block>>>(itime, ab_gpu_w);
            }

            if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = nsubs;
              h_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel519<<<grid, block>>>(itime, ab_gpu_w);
              }
            } else if ((b_cpu_h->size[0] == 1) && ((cpu_csz[0] == 1) &&
                        (cpu_csz[1] == 1))) {
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = 1;
              h_cpu_w->size[1] = 1;
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              ec_cwt_kernel520<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>
                (j_gpu_yCol, b_gpu_h, ab_gpu_w);
            } else {
              real_T blockDims[3];
              int32_T threadDims[3];
              cpu_r = (static_cast<real_T>(b_cpu_h->size[0]) +
                       static_cast<real_T>(cpu_csz[0])) - 1.0;
              s = std::fmin(32.0, cpu_r);
              cpu_nrefine = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_csz[1]) + 1.0) - 1.0));
              blockDims[0] = std::floor((cpu_r + (s - 1.0)) / s);
              blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) + 1.0)
                - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                static_cast<real_T>(cpu_nrefine));
              if (s >= -2.147483648E+9) {
                eint = static_cast<int32_T>(s);
              } else {
                eint = MIN_int32_T;
              }

              threadDims[0] = eint;
              threadDims[1] = cpu_nrefine;
              nw = cpu_csz[1];
              if (cpu_r < 2.147483648E+9) {
                if (cpu_r >= -2.147483648E+9) {
                  fb_CutOff = static_cast<int32_T>(cpu_r);
                } else {
                  fb_CutOff = MIN_int32_T;
                }
              } else {
                fb_CutOff = MAX_int32_T;
              }

              fc = std::floor(static_cast<real_T>(cpu_csz[0]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_csz[0]) - 1.0) / 2.0);
              if (fc >= -2.147483648E+9) {
                dim = static_cast<int32_T>(fc);
              } else {
                dim = MIN_int32_T;
              }

              if ((fb_CutOff < 0) && (cpu_csz[0] < MIN_int32_T - fb_CutOff)) {
                ix = MIN_int32_T;
              } else if ((fb_CutOff > 0) && (cpu_csz[0] > MAX_int32_T
                          - fb_CutOff)) {
                ix = MAX_int32_T;
              } else {
                ix = fb_CutOff + cpu_csz[0];
              }

              if (ix >= -2147483647) {
                ix--;
              }

              eint = t_cpu_expanded->size[0] * t_cpu_expanded->size[1];
              t_cpu_expanded->size[0] = ix;
              emxEnsureCapacity_real_T(t_cpu_expanded, eint, &xc_emlrtRTEI);
              if ((cpu_csz[1] < 0) && (cpu_csz[1] < MIN_int32_T - cpu_csz[1])) {
                ix = MIN_int32_T;
              } else if ((cpu_csz[1] > 0) && (cpu_csz[1] > MAX_int32_T
                          - cpu_csz[1])) {
                ix = MAX_int32_T;
              } else {
                ix = cpu_csz[1] + cpu_csz[1];
              }

              if (ix >= -2147483647) {
                ix--;
              }

              eint = t_cpu_expanded->size[0] * t_cpu_expanded->size[1];
              t_cpu_expanded->size[1] = ix;
              emxEnsureCapacity_real_T(t_cpu_expanded, eint, &xc_emlrtRTEI);
              b_nx = ((fb_CutOff + cpu_csz[0]) - 1) * ((cpu_csz[1] + cpu_csz[1])
                - 1) - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(t_cpu_expanded, &tb_gpu_expanded, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel521<<<grid, block>>>(b_nx, tb_gpu_expanded);
              }

              b_nx = b_cpu_h->size[0];
              eint = kb_cpu_y->size[0] * kb_cpu_y->size[1];
              kb_cpu_y->size[0] = 1;
              kb_cpu_y->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(kb_cpu_y, eint, &ad_emlrtRTEI);
              kb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (k = 0; k <= b_nx - 2; k++) {
                nsubs++;
                kb_cpu_y->data[k + 1] = nsubs;
              }

              eint = cpu_iv49->size[0];
              cpu_iv49->size[0] = kb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv49, eint, &xc_emlrtRTEI);
              itime = kb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(kb_cpu_y, &dd_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv49, &gpu_iv49, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&dd_gpu_y, kb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel522<<<grid, block>>>(dim, dd_gpu_y, itime, gpu_iv49);
              }

              fc = std::floor(static_cast<real_T>(cpu_csz[1]) / 2.0) + std::
                floor((static_cast<real_T>(cpu_csz[1]) - 1.0) / 2.0);
              if (fc >= -2.147483648E+9) {
                cpu_nrefine = static_cast<int32_T>(fc);
              } else {
                cpu_nrefine = MIN_int32_T;
              }

              omega_tmp2[0] = cpu_iv49->size[0];
              mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
                &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel523<<<grid, block>>>(b_gpu_h, cpu_nrefine, gpu_iv49,
                  omega_tmp2[0] - 1, tb_gpu_expanded, t_cpu_expanded->size[0U]);
              }

              if (cpu_csz[0] < -2147483647) {
                ix = MIN_int32_T;
              } else {
                ix = cpu_csz[0] - 1;
              }

              if (ix < 0) {
                b_nx = 0;
              } else {
                b_nx = ix + 1;
              }

              interval_outdatedOnGpu = false;
              eint = j_cpu_rows->size[0] * j_cpu_rows->size[1];
              j_cpu_rows->size[0] = 1;
              j_cpu_rows->size[1] = b_nx;
              emxEnsureCapacity_int32_T(j_cpu_rows, eint, &ad_emlrtRTEI);
              if (b_nx > 0) {
                j_cpu_rows->data[0] = 0;
                interval_outdatedOnGpu = true;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  j_cpu_rows->data[k + 1] = nsubs;
                }
              }

              if (cpu_csz[1] < -2147483647) {
                ix = MIN_int32_T;
              } else {
                ix = cpu_csz[1] - 1;
              }

              if (ix < 0) {
                b_nx = 0;
              } else {
                b_nx = ix + 1;
              }

              fx_data_outdatedOnCpu = false;
              eint = f_cpu_cols->size[0] * f_cpu_cols->size[1];
              f_cpu_cols->size[0] = 1;
              f_cpu_cols->size[1] = b_nx;
              emxEnsureCapacity_int32_T(f_cpu_cols, eint, &ad_emlrtRTEI);
              if (b_nx > 0) {
                f_cpu_cols->data[0] = 0;
                fx_data_outdatedOnCpu = true;
                nsubs = 0;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  f_cpu_cols->data[k + 1] = nsubs;
                }
              }

              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = fb_CutOff;
              h_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(h_cpu_w, eint, &xc_emlrtRTEI);
              x_data_outdatedOnGpu = true;
              if ((fb_CutOff != 0) && (cpu_csz[1] != 0)) {
                uint32_T b_u;
                if (blockDims[0] < 4.294967296E+9) {
                  if (blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (blockDims[1] < 4.294967296E+9) {
                  if (blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                eint = threadDims[0];
                if (threadDims[0] < 0) {
                  eint = 0;
                }

                nsubs = threadDims[1];
                if (threadDims[1] < 0) {
                  nsubs = 0;
                }

                mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                  dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(eint),
                  static_cast<uint32_T>(nsubs), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(f_cpu_cols, &f_gpu_cols,
                  !fx_data_outdatedOnCpu);
                gpuEmxEnsureCapacity_int32_T(j_cpu_rows, &nb_gpu_rows,
                  !interval_outdatedOnGpu);
                gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
                x_data_outdatedOnGpu = false;
                if (fx_data_outdatedOnCpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&f_gpu_cols, f_cpu_cols);
                }

                if (interval_outdatedOnGpu) {
                  gpuEmxMemcpyCpuToGpu_int32_T(&nb_gpu_rows, j_cpu_rows);
                }

                checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
                  cudaMemcpyHostToDevice), __FILE__, __LINE__);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel524<<<grid, block>>>(j_gpu_yCol, tb_gpu_expanded,
                    f_gpu_cols, nb_gpu_rows, *gpu_csz, fb_CutOff - 1, nw - 1,
                    ab_gpu_w, t_cpu_expanded->size[0U], h_cpu_w->size[0U]);
                }
              }
            }
          } else {
            if (cpu_csz[0] == 0) {
              nsubs = b_cpu_h->size[0];
            } else {
              nsubs = (cpu_csz[0] + b_cpu_h->size[0]) - 1;
            }

            if (cpu_csz[1] == 0) {
              cpu_nrefine = 1;
            } else {
              cpu_nrefine = cpu_csz[1];
            }

            eint = h_cpu_w->size[0] * h_cpu_w->size[1];
            h_cpu_w->size[0] = nsubs;
            h_cpu_w->size[1] = cpu_nrefine;
            emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
            itime = nsubs * cpu_nrefine - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel525<<<grid, block>>>(itime, ab_gpu_w);
            }

            if ((cpu_csz[0] == 0) || (cpu_csz[1] == 0)) {
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = nsubs;
              h_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel526<<<grid, block>>>(itime, ab_gpu_w);
              }
            } else if ((cpu_csz[0] == 1) && (cpu_csz[1] == 1) && (b_cpu_h->size
                        [0] == 1)) {
              eint = n_cpu_c->size[0];
              n_cpu_c->size[0] = 1;
              emxEnsureCapacity_real_T(n_cpu_c, eint, &vc_emlrtRTEI);
              cpu_r = 1.0;
              b_cpu_r = 0.0;
              gpuEmxEnsureCapacity_real_T(n_cpu_c, &q_gpu_c, true);
              cublasCheck(cublasDgemm(getCublasGlobalHandle(), CUBLAS_OP_N,
                CUBLAS_OP_N, 1, 1, 1, (double *)&cpu_r, (double *)&l_gpu_x.data
                [0], 1, (double *)&b_gpu_h.data[0], 1, (double *)&b_cpu_r,
                (double *)&q_gpu_c.data[0], 1), __FILE__, __LINE__);
              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = nsubs;
              h_cpu_w->size[1] = cpu_nrefine;
              emxEnsureCapacity_real_T(h_cpu_w, eint, &rc_emlrtRTEI);
              itime = nsubs * cpu_nrefine - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
              x_data_outdatedOnGpu = false;
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel527<<<grid, block>>>(q_gpu_c, itime, ab_gpu_w);
              }
            } else {
              real_T blockDims[3];
              N = (static_cast<uint32_T>(cpu_csz[0]) + static_cast<uint32_T>
                   (b_cpu_h->size[0])) - 1U;
              lidx = static_cast<int32_T>(std::fmin(32.0, static_cast<real_T>(N)));
              cpu_nrefine = static_cast<int32_T>(std::fmin(32.0,
                (static_cast<real_T>(cpu_csz[1]) + 1.0) - 1.0));
              blockDims[0] = std::floor((static_cast<real_T>(N) +
                (static_cast<real_T>(lidx) - 1.0)) / static_cast<real_T>(lidx));
              blockDims[1] = std::floor((((static_cast<real_T>(cpu_csz[1]) + 1.0)
                - 1.0) + (static_cast<real_T>(cpu_nrefine) - 1.0)) /
                static_cast<real_T>(cpu_nrefine));
              nw = cpu_csz[1];
              if (N > 2147483647U) {
                N = 2147483647U;
              }

              fb_CutOff = static_cast<int32_T>(N);
              dim = static_cast<int32_T>(std::floor(static_cast<real_T>
                (b_cpu_h->size[0]) / 2.0)) + static_cast<int32_T>(std::floor((
                static_cast<real_T>(b_cpu_h->size[0]) - 1.0) / 2.0));
              if ((static_cast<int32_T>(N) > 0) && (b_cpu_h->size[0] >
                   MAX_int32_T - static_cast<int32_T>(N))) {
                ix = MAX_int32_T;
              } else {
                ix = static_cast<int32_T>(N) + b_cpu_h->size[0];
              }

              eint = s_cpu_expanded->size[0] * s_cpu_expanded->size[1];
              s_cpu_expanded->size[0] = ix - 1;
              emxEnsureCapacity_real_T(s_cpu_expanded, eint, &xc_emlrtRTEI);
              if (cpu_csz[1] > 2147483646) {
                ix = MAX_int32_T;
              } else {
                ix = cpu_csz[1] + 1;
              }

              eint = s_cpu_expanded->size[0] * s_cpu_expanded->size[1];
              s_cpu_expanded->size[1] = ix - 1;
              emxEnsureCapacity_real_T(s_cpu_expanded, eint, &xc_emlrtRTEI);
              b_nx = ((static_cast<int32_T>(N) + b_cpu_h->size[0]) - 1) *
                cpu_csz[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_real_T(s_cpu_expanded, &ub_gpu_expanded, true);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel528<<<grid, block>>>(b_nx, ub_gpu_expanded);
              }

              b_nx = cpu_csz[0];
              eint = gb_cpu_y->size[0] * gb_cpu_y->size[1];
              gb_cpu_y->size[0] = 1;
              gb_cpu_y->size[1] = cpu_csz[0];
              emxEnsureCapacity_int32_T(gb_cpu_y, eint, &ad_emlrtRTEI);
              gb_cpu_y->data[0] = 1;
              nsubs = 1;
              for (k = 0; k <= b_nx - 2; k++) {
                nsubs++;
                gb_cpu_y->data[k + 1] = nsubs;
              }

              eint = cpu_iv50->size[0];
              cpu_iv50->size[0] = gb_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv50, eint, &xc_emlrtRTEI);
              itime = gb_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(gb_cpu_y, &ed_gpu_y, false);
              gpuEmxEnsureCapacity_int32_T(cpu_iv50, &gpu_iv50, true);
              gpuEmxMemcpyCpuToGpu_int32_T(&ed_gpu_y, gb_cpu_y);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel529<<<grid, block>>>(dim, ed_gpu_y, itime, gpu_iv50);
              }

              if (cpu_csz[1] < 1) {
                b_nx = 0;
              } else {
                b_nx = cpu_csz[1];
              }

              interval_outdatedOnGpu = false;
              eint = fc_cpu_y->size[0] * fc_cpu_y->size[1];
              fc_cpu_y->size[0] = 1;
              fc_cpu_y->size[1] = b_nx;
              emxEnsureCapacity_int32_T(fc_cpu_y, eint, &ad_emlrtRTEI);
              if (b_nx > 0) {
                fc_cpu_y->data[0] = 1;
                interval_outdatedOnGpu = true;
                nsubs = 1;
                for (k = 0; k <= b_nx - 2; k++) {
                  nsubs++;
                  fc_cpu_y->data[k + 1] = nsubs;
                }
              }

              eint = cpu_iv67->size[0];
              cpu_iv67->size[0] = fc_cpu_y->size[1];
              emxEnsureCapacity_int32_T(cpu_iv67, eint, &xc_emlrtRTEI);
              itime = fc_cpu_y->size[1] - 1;
              mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
                2147483647U);
              gpuEmxEnsureCapacity_int32_T(fc_cpu_y, &fd_gpu_y,
                !interval_outdatedOnGpu);
              gpuEmxEnsureCapacity_int32_T(cpu_iv67, &gpu_iv67, true);
              if (interval_outdatedOnGpu) {
                gpuEmxMemcpyCpuToGpu_int32_T(&fd_gpu_y, fc_cpu_y);
              }

              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel530<<<grid, block>>>(fd_gpu_y, itime, gpu_iv67);
              }

              xt_size[0] = cpu_iv50->size[0];
              xt_size[1] = cpu_iv67->size[0];
              mwGetLaunchParameters1D(computeNumIters(xt_size[1] - 1, xt_size[0]
                - 1), &grid, &block, 2147483647U);
              validLaunchParams = mwValidateLaunchParameters(grid, block);
              if (validLaunchParams) {
                ec_cwt_kernel531<<<grid, block>>>(j_gpu_yCol, xt_size[0],
                  gpu_iv67, gpu_iv50, xt_size[0] - 1, xt_size[1] - 1,
                  ub_gpu_expanded, s_cpu_expanded->size[0U]);
              }

              b_nx = b_cpu_h->size[0];
              eint = u_cpu_rows->size[0] * u_cpu_rows->size[1];
              u_cpu_rows->size[0] = 1;
              u_cpu_rows->size[1] = b_cpu_h->size[0];
              emxEnsureCapacity_int32_T(u_cpu_rows, eint, &ad_emlrtRTEI);
              u_cpu_rows->data[0] = 0;
              nsubs = 0;
              for (k = 0; k <= b_nx - 2; k++) {
                nsubs++;
                u_cpu_rows->data[k + 1] = nsubs;
              }

              eint = h_cpu_w->size[0] * h_cpu_w->size[1];
              h_cpu_w->size[0] = static_cast<int32_T>(N);
              h_cpu_w->size[1] = cpu_csz[1];
              emxEnsureCapacity_real_T(h_cpu_w, eint, &xc_emlrtRTEI);
              x_data_outdatedOnGpu = true;
              if ((static_cast<int32_T>(N) != 0) && (cpu_csz[1] != 0)) {
                uint32_T b_u;
                if (blockDims[0] < 4.294967296E+9) {
                  if (blockDims[0] >= 0.0) {
                    N = static_cast<uint32_T>(blockDims[0]);
                  } else {
                    N = 0U;
                  }
                } else if (blockDims[0] >= 4.294967296E+9) {
                  N = MAX_uint32_T;
                } else {
                  N = 0U;
                }

                if (blockDims[1] < 4.294967296E+9) {
                  if (blockDims[1] >= 0.0) {
                    b_u = static_cast<uint32_T>(blockDims[1]);
                  } else {
                    b_u = 0U;
                  }
                } else if (blockDims[1] >= 4.294967296E+9) {
                  b_u = MAX_uint32_T;
                } else {
                  b_u = 0U;
                }

                eint = cpu_nrefine;
                if (cpu_nrefine < 0) {
                  eint = 0;
                }

                mwApplyLaunchParameters(computeNumIters(nw - 1, fb_CutOff - 1),
                  dim3(N, b_u, 1U), dim3(static_cast<uint32_T>(lidx),
                  static_cast<uint32_T>(eint), 1U), &grid, &block);
                gpuEmxEnsureCapacity_int32_T(u_cpu_rows, &ob_gpu_rows, false);
                gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
                x_data_outdatedOnGpu = false;
                gpuEmxMemcpyCpuToGpu_int32_T(&ob_gpu_rows, u_cpu_rows);
                validLaunchParams = mwValidateLaunchParameters(grid, block);
                if (validLaunchParams) {
                  ec_cwt_kernel532<<<grid, block>>>(ub_gpu_expanded, ob_gpu_rows,
                    b_gpu_h, fb_CutOff - 1, nw - 1, ab_gpu_w, b_cpu_h->size[0U],
                    s_cpu_expanded->size[0U], h_cpu_w->size[0U]);
                }
              }
            }
          }

          if (!(intFsq - 1.0 >= 0.0)) {
            tb_y = nullptr;
            m37 = emlrtCreateCharArray(2, &iv25[0]);
            emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 7, m37, &rfmt[0]);
            emlrtAssign(&tb_y, m37);
            ub_y = nullptr;
            m43 = emlrtCreateDoubleScalar(intFsq - 1.0);
            emlrtAssign(&ub_y, m43);
            emlrt_marshallIn(b_sprintf(tb_y, ub_y, &e_emlrtMCI),
                             "<output of sprintf>", unusedExpr);
          }

          dim = 2;
          if (h_cpu_w->size[0] != 1) {
            dim = 1;
          }

          interval_outdatedOnGpu = false;
          fx_data_outdatedOnCpu = false;
          for (itime = 0; itime < 2; itime++) {
            cpu_csz[itime] = h_cpu_w->size[itime];
            fx_data_outdatedOnCpu = true;
            cpu_lshift[itime] = h_cpu_w->size[itime];
            interval_outdatedOnGpu = true;
          }

          if (1 - dim >= 0) {
            cpu_nrefine = static_cast<int32_T>((2.0 - (1.0 - static_cast<real_T>
              (dim))) / 2.0);
            mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1), &grid,
              &block, 2147483647U);
            if (interval_outdatedOnGpu) {
              checkCudaError(cudaMemcpy(*gpu_lshift, cpu_lshift, 8UL,
                cudaMemcpyHostToDevice), __FILE__, __LINE__);
            }

            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel499<<<grid, block>>>(1 - dim, cpu_nrefine - 1,
                *gpu_lshift);
            }

            checkCudaError(cudaMemcpy(cpu_lshift, *gpu_lshift, 8UL,
              cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          }

          cpu_nrefine = cpu_lshift[0];
          cpu_lshift[0] = cpu_lshift[1];
          cpu_lshift[1] = cpu_nrefine;
          if ((intFsq == 0.0) || ((intFsq > 0.0) && (cpu_lshift[0] < 1))) {
            lidx = 1;
            nw = -1;
          } else {
            lidx = static_cast<int32_T>(intFsq);
            nw = cpu_lshift[0] - 1;
          }

          if (fx_data_outdatedOnCpu) {
            checkCudaError(cudaMemcpy(*gpu_csz, cpu_csz, 8UL,
              cudaMemcpyHostToDevice), __FILE__, __LINE__);
          }

          ec_cwt_kernel500<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(lidx, nw,
            dim, *gpu_csz);
          eint = cb_cpu_w->size[0] * cb_cpu_w->size[1];
          cb_cpu_w->size[0] = div_s32(nw, lidx) + 1;
          cb_cpu_w->size[1] = cpu_nrefine;
          emxEnsureCapacity_real_T(cb_cpu_w, eint, &bd_emlrtRTEI);
          itime = nw / lidx;
          mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime), &grid,
            &block, 2147483647U);
          if (x_data_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(h_cpu_w, &ab_gpu_w, true);
          }

          gpuEmxEnsureCapacity_real_T(cb_cpu_w, &bb_gpu_w, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel501<<<grid, block>>>(ab_gpu_w, cpu_lshift[0], lidx,
              itime, cpu_nrefine - 1, bb_gpu_w, cb_cpu_w->size[0U]);
          }

          checkCudaError(cudaMemcpy(cpu_csz, *gpu_csz, 8UL,
            cudaMemcpyDeviceToHost), __FILE__, __LINE__);
          eint = tb_cpu_y->size[0] * tb_cpu_y->size[1];
          tb_cpu_y->size[0] = cpu_csz[0];
          tb_cpu_y->size[1] = cpu_csz[1];
          emxEnsureCapacity_real_T(tb_cpu_y, eint, &rc_emlrtRTEI);
          b_nx = cpu_csz[0] * cpu_csz[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          gpuEmxEnsureCapacity_real_T(tb_cpu_y, &yc_gpu_y, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel502<<<grid, block>>>(bb_gpu_w, b_nx, yc_gpu_y);
          }

          b_cpu_r = std::ceil(((static_cast<real_T>(cpu_xCol->size[0]) - 1.0) *
                               cf + static_cast<real_T>(b_cpu_h->size[0])) /
                              intFsq);
          if (!(cpu_csz[0] < b_cpu_r)) {
            if (b_cpu_r < 1.0) {
              cpu_nrefine = 0;
            } else {
              cpu_nrefine = static_cast<int32_T>(b_cpu_r);
            }

            nsubs = db_cpu_w->size[0] * db_cpu_w->size[1];
            db_cpu_w->size[0] = div_s32(nw, lidx) + 1;
            db_cpu_w->size[1] = cpu_lshift[1];
            emxEnsureCapacity_real_T(db_cpu_w, nsubs, &bd_emlrtRTEI);
            itime = nw / lidx;
            mwGetLaunchParameters1D(computeNumIters(cpu_lshift[1] - 1, itime),
              &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(db_cpu_w, &cb_gpu_w, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel503<<<grid, block>>>(ab_gpu_w, cpu_lshift[0], lidx,
                itime, cpu_lshift[1] - 1, cb_gpu_w, db_cpu_w->size[0U]);
            }

            nsubs = tb_cpu_y->size[0] * tb_cpu_y->size[1];
            tb_cpu_y->size[0] = cpu_nrefine;
            tb_cpu_y->size[1] = cpu_csz[1];
            emxEnsureCapacity_real_T(tb_cpu_y, nsubs, &uc_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(cpu_csz[1] - 1, cpu_nrefine
              - 1), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(tb_cpu_y, &yc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel504<<<grid, block>>>(cb_gpu_w, cpu_csz[0],
                cpu_nrefine - 1, cpu_csz[1] - 1, yc_gpu_y, tb_cpu_y->size[0U]);
            }
          }

          if (first_iteration) {
            omega_tmp2[0] = tb_cpu_y->size[0] * tb_cpu_y->size[1];
            eint = md_cpu_y->size[0] * md_cpu_y->size[1];
            md_cpu_y->size[0] = 1;
            md_cpu_y->size[1] = omega_tmp2[0];
            emxEnsureCapacity_real_T(md_cpu_y, eint, &cd_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(omega_tmp2[0] - 1), &grid,
              &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(md_cpu_y, &ad_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel505<<<grid, block>>>(yc_gpu_y, omega_tmp2[0] - 1,
                ad_gpu_y, md_cpu_y->size[0U]);
            }

            eint = tb_cpu_y->size[0] * tb_cpu_y->size[1];
            tb_cpu_y->size[0] = 1;
            tb_cpu_y->size[1] = md_cpu_y->size[1];
            emxEnsureCapacity_real_T(tb_cpu_y, eint, &ed_emlrtRTEI);
            itime = md_cpu_y->size[1] - 1;
            mwGetLaunchParameters1D(computeNumIters(itime), &grid, &block,
              2147483647U);
            gpuEmxEnsureCapacity_real_T(tb_cpu_y, &yc_gpu_y, true);
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel506<<<grid, block>>>(ad_gpu_y, itime, yc_gpu_y);
            }
          }

          if (std::isnan(q_ok)) {
            eint = lc_cpu_y->size[0] * lc_cpu_y->size[1];
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = 1;
            emxEnsureCapacity_real_T(lc_cpu_y, eint, &d_emlrtRTEI);
            gpuEmxEnsureCapacity_real_T(lc_cpu_y, &bd_gpu_y, true);
            j_y_needsGpuEnsureCapacity = false;
            ec_cwt_kernel507<<<dim3(1U, 1U, 1U), dim3(32U, 1U, 1U)>>>(bd_gpu_y);
          } else if (q_ok < 1.0) {
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = 0;
          } else {
            eint = lc_cpu_y->size[0] * lc_cpu_y->size[1];
            lc_cpu_y->size[0] = 1;
            lc_cpu_y->size[1] = static_cast<int32_T>(q_ok - 1.0) + 1;
            emxEnsureCapacity_real_T(lc_cpu_y, eint, &d_emlrtRTEI);
            mwGetLaunchParameters1D(computeNumIters(static_cast<int32_T>(q_ok -
              1.0)), &grid, &block, 2147483647U);
            gpuEmxEnsureCapacity_real_T(lc_cpu_y, &bd_gpu_y, true);
            j_y_needsGpuEnsureCapacity = false;
            validLaunchParams = mwValidateLaunchParameters(grid, block);
            if (validLaunchParams) {
              ec_cwt_kernel509<<<grid, block>>>(static_cast<int32_T>(q_ok - 1.0),
                bd_gpu_y);
            }
          }

          cpu_nrefine = tb_cpu_y->size[1];
          eint = cpu_y1->size[0] * cpu_y1->size[1];
          cpu_y1->size[0] = lc_cpu_y->size[1];
          cpu_y1->size[1] = tb_cpu_y->size[1];
          emxEnsureCapacity_real_T(cpu_y1, eint, &ac_emlrtRTEI);
          itime = lc_cpu_y->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(cpu_nrefine - 1, itime), &grid,
            &block, 2147483647U);
          if (j_y_needsGpuEnsureCapacity) {
            gpuEmxEnsureCapacity_real_T(lc_cpu_y, &bd_gpu_y, true);
          }

          j_y_needsGpuEnsureCapacity = false;
          gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
          interval_outdatedOnGpu = false;
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel508<<<grid, block>>>(yc_gpu_y, bd_gpu_y, tol, itime,
              cpu_nrefine - 1, gpu_y1, cpu_y1->size[0U], tb_cpu_y->size[0U]);
          }
        }

        if ((cpu_opts_x->size[0] == 1) || (cpu_opts_x->size[1] == 1)) {
          N = static_cast<uint32_T>(cpu_y1->size[0]);
          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = cpu_xCh->size[0];
          cpu_opts_x->size[1] = cpu_y1->size[0];
          emxEnsureCapacity_real_T(cpu_opts_x, eint, &nc_emlrtRTEI);
          b_nx = cpu_xCh->size[0] * static_cast<int32_T>(N) - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
          }

          gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel401<<<grid, block>>>(gpu_y1, b_nx, gpu_opts_x);
          }
        } else {
          eint = cpu_opts_x->size[0] * cpu_opts_x->size[1];
          cpu_opts_x->size[0] = cpu_y1->size[1];
          cpu_opts_x->size[1] = cpu_y1->size[0];
          emxEnsureCapacity_real_T(cpu_opts_x, eint, &nc_emlrtRTEI);
          b_nx = cpu_y1->size[0] - 1;
          itime = cpu_y1->size[1] - 1;
          mwGetLaunchParameters1D(computeNumIters(b_nx, itime), &grid, &block,
            2147483647U);
          if (interval_outdatedOnGpu) {
            gpuEmxEnsureCapacity_real_T(cpu_y1, &gpu_y1, true);
          }

          gpuEmxEnsureCapacity_real_T(cpu_opts_x, &gpu_opts_x, true);
          validLaunchParams = mwValidateLaunchParameters(grid, block);
          if (validLaunchParams) {
            ec_cwt_kernel402<<<grid, block>>>(gpu_y1, itime, b_nx, gpu_opts_x,
              cpu_opts_x->size[0U], cpu_y1->size[0U]);
          }
        }
      }

      nsubs = y_data[y_size_idx_1].f1->size[0] * y_data[y_size_idx_1].f1->size[1];
      y_data[y_size_idx_1].f1->size[0] = cpu_opts_x->size[0];
      emxEnsureCapacity_real_T(y_data[y_size_idx_1].f1, nsubs, &ec_emlrtRTEI);
      eint = y_data[y_size_idx_1].f1->size[0] * y_data[y_size_idx_1].f1->size[1];
      y_data[y_size_idx_1].f1->size[1] = cpu_opts_x->size[1];
      emxEnsureCapacity_real_T(y_data[y_size_idx_1].f1, eint, &ec_emlrtRTEI);
      for (eint = 0; eint < cpu_opts_x->size[0] * cpu_opts_x->size[1]; eint++) {
        if (opts_x_outdatedOnCpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_opts_x, &gpu_opts_x);
        }

        opts_x_outdatedOnCpu = false;
        y_data[y_size_idx_1].f1->data[eint] = cpu_opts_x->data[eint];
      }

      //  Downsample
    } else {
      // 'ec_cwt:42' else
      // 'ec_cwt:43' y{ch} = xCh;
      nsubs = y_data[y_size_idx_1].f1->size[0] * y_data[y_size_idx_1].f1->size[1];
      y_data[y_size_idx_1].f1->size[0] = cpu_xCh->size[0];
      emxEnsureCapacity_real_T(y_data[y_size_idx_1].f1, nsubs, &eb_emlrtRTEI);
      eint = y_data[y_size_idx_1].f1->size[0] * y_data[y_size_idx_1].f1->size[1];
      y_data[y_size_idx_1].f1->size[1] = cpu_xCh->size[1];
      emxEnsureCapacity_real_T(y_data[y_size_idx_1].f1, eint, &eb_emlrtRTEI);
      for (eint = 0; eint < cpu_xCh->size[0] * cpu_xCh->size[1]; eint++) {
        if (interval_outdatedOnGpu) {
          gpuEmxMemcpyGpuToCpu_real_T(cpu_xCh, &gpu_xCh);
        }

        interval_outdatedOnGpu = false;
        y_data[y_size_idx_1].f1->data[eint] = cpu_xCh->data[eint];
      }
    }
  }

  emxFree_real_T(&db_cpu_w);
  emxFree_real_T(&md_cpu_y);
  emxFree_real_T(&cb_cpu_w);
  emxFree_real_T(&bb_cpu_w);
  emxFree_real_T(&ab_cpu_w);
  emxFree_real_T(&y_cpu_w);
  emxFree_real_T(&ld_cpu_y);
  emxFree_real_T(&kd_cpu_y);
  emxFree_real_T(&jd_cpu_y);
  emxFree_real_T(&id_cpu_y);
  emxFree_real_T(&x_cpu_w);
  emxFree_real_T(&w_cpu_w);
  emxFree_real_T(&hd_cpu_y);
  emxFree_real_T(&v_cpu_w);
  emxFree_real_T(&u_cpu_w);
  emxFree_real_T(&t_cpu_w);
  emxFree_real_T(&s_cpu_w);
  emxFree_real_T(&r_cpu_w);
  emxFree_real_T(&q_cpu_w);
  emxFree_real_T(&p_cpu_w);
  emxFree_real_T(&o_cpu_w);
  emxFree_real_T(&n_cpu_w);
  emxFree_real_T(&m_cpu_w);
  emxFree_real_T(&l_cpu_w);
  emxFree_real_T(&cpu_b0);
  emxFree_int32_T(&sb_cpu_rows);
  emxFree_int32_T(&rb_cpu_rows);
  emxFree_int32_T(&cpu_iv94);
  emxFree_int32_T(&qb_cpu_rows);
  emxFree_int32_T(&pb_cpu_rows);
  emxFree_int32_T(&ob_cpu_rows);
  emxFree_int32_T(&nb_cpu_rows);
  emxFree_int32_T(&cpu_iv93);
  emxFree_int32_T(&mb_cpu_rows);
  emxFree_int32_T(&lb_cpu_rows);
  emxFree_int32_T(&kb_cpu_rows);
  emxFree_int32_T(&jb_cpu_rows);
  emxFree_int32_T(&ib_cpu_rows);
  emxFree_int32_T(&hb_cpu_rows);
  emxFree_int32_T(&cpu_iv89);
  emxFree_int32_T(&gb_cpu_rows);
  emxFree_int32_T(&cpu_iv87);
  emxFree_int32_T(&cpu_iv86);
  emxFree_int32_T(&cpu_iv85);
  emxFree_int32_T(&fb_cpu_rows);
  emxFree_int32_T(&eb_cpu_rows);
  emxFree_int32_T(&cpu_iv84);
  emxFree_int32_T(&db_cpu_rows);
  emxFree_int32_T(&cb_cpu_rows);
  emxFree_int32_T(&cpu_iv83);
  emxFree_int32_T(&bb_cpu_rows);
  emxFree_int32_T(&cpu_iv81);
  emxFree_int32_T(&f_cpu_cols);
  emxFree_int32_T(&cpu_iv80);
  emxFree_int32_T(&ab_cpu_rows);
  emxFree_int32_T(&y_cpu_rows);
  emxFree_int32_T(&x_cpu_rows);
  emxFree_int32_T(&w_cpu_rows);
  emxFree_int32_T(&v_cpu_rows);
  emxFree_int32_T(&gd_cpu_y);
  emxFree_int32_T(&cpu_iv79);
  emxFree_int32_T(&cpu_iv78);
  emxFree_int32_T(&u_cpu_rows);
  emxFree_int32_T(&fd_cpu_y);
  emxFree_int32_T(&t_cpu_rows);
  emxFree_int32_T(&cpu_iv77);
  emxFree_int32_T(&cpu_iv76);
  emxFree_int32_T(&s_cpu_rows);
  emxFree_int32_T(&cpu_iv75);
  emxFree_int32_T(&cpu_iv74);
  emxFree_int32_T(&r_cpu_rows);
  emxFree_int32_T(&cpu_iv73);
  emxFree_real_T(&yb_cpu_expanded);
  emxFree_real_T(&xb_cpu_expanded);
  emxFree_int32_T(&q_cpu_rows);
  emxFree_int32_T(&e_cpu_cols);
  emxFree_int32_T(&cpu_iv71);
  emxFree_int32_T(&p_cpu_rows);
  emxFree_int32_T(&d_cpu_cols);
  emxFree_int32_T(&cpu_iv69);
  emxFree_int32_T(&c_cpu_cols);
  emxFree_int32_T(&cpu_iv68);
  emxFree_int32_T(&ed_cpu_y);
  emxFree_int32_T(&dd_cpu_y);
  emxFree_int32_T(&cd_cpu_y);
  emxFree_int32_T(&cpu_iv67);
  emxFree_int32_T(&bd_cpu_y);
  emxFree_int32_T(&cpu_iv66);
  emxFree_int32_T(&o_cpu_rows);
  emxFree_int32_T(&ad_cpu_y);
  emxFree_int32_T(&cpu_iv65);
  emxFree_int32_T(&n_cpu_rows);
  emxFree_int32_T(&yc_cpu_y);
  emxFree_int32_T(&m_cpu_rows);
  emxFree_int32_T(&xc_cpu_y);
  emxFree_int32_T(&wc_cpu_y);
  emxFree_int32_T(&l_cpu_rows);
  emxFree_int32_T(&b_cpu_cols);
  emxFree_int32_T(&cpu_iv64);
  emxFree_real_T(&wb_cpu_expanded);
  emxFree_real_T(&vb_cpu_expanded);
  emxFree_int32_T(&k_cpu_rows);
  emxFree_int32_T(&cpu_cols);
  emxFree_int32_T(&cpu_iv63);
  emxFree_real_T(&ub_cpu_expanded);
  emxFree_real_T(&tb_cpu_expanded);
  emxFree_real_T(&sb_cpu_expanded);
  emxFree_real_T(&rb_cpu_expanded);
  emxFree_real_T(&qb_cpu_expanded);
  emxFree_real_T(&pb_cpu_expanded);
  emxFree_int32_T(&vc_cpu_y);
  emxFree_int32_T(&uc_cpu_y);
  emxFree_int32_T(&j_cpu_rows);
  emxFree_int32_T(&i_cpu_rows);
  emxFree_int32_T(&tc_cpu_y);
  emxFree_int32_T(&cpu_iv62);
  emxFree_int32_T(&sc_cpu_y);
  emxFree_int32_T(&h_cpu_rows);
  emxFree_int32_T(&rc_cpu_y);
  emxFree_int32_T(&cpu_iv61);
  emxFree_int32_T(&qc_cpu_y);
  emxFree_int32_T(&cpu_iv60);
  emxFree_int32_T(&cpu_iv59);
  emxFree_int32_T(&pc_cpu_y);
  emxFree_real_T(&ob_cpu_expanded);
  emxFree_real_T(&nb_cpu_expanded);
  emxFree_int32_T(&oc_cpu_y);
  emxFree_real_T(&mb_cpu_expanded);
  emxFree_real_T(&lb_cpu_expanded);
  emxFree_int32_T(&nc_cpu_y);
  emxFree_int32_T(&cpu_iv58);
  emxFree_int32_T(&mc_cpu_y);
  emxFree_real_T(&lc_cpu_y);
  emxFree_real_T(&kb_cpu_expanded);
  emxFree_real_T(&jb_cpu_expanded);
  emxFree_real_T(&ib_cpu_expanded);
  emxFree_real_T(&hb_cpu_expanded);
  emxFree_real_T(&gb_cpu_expanded);
  emxFree_real_T(&fb_cpu_expanded);
  emxFree_int32_T(&cpu_iv57);
  emxFree_int32_T(&kc_cpu_y);
  emxFree_int32_T(&g_cpu_rows);
  emxFree_int32_T(&cpu_iv56);
  emxFree_int32_T(&jc_cpu_y);
  emxFree_int32_T(&f_cpu_rows);
  emxFree_int32_T(&e_cpu_rows);
  emxFree_int32_T(&cpu_iv54);
  emxFree_int32_T(&ic_cpu_y);
  emxFree_int32_T(&cpu_iv53);
  emxFree_int32_T(&hc_cpu_y);
  emxFree_real_T(&gc_cpu_y);
  emxFree_int32_T(&fc_cpu_y);
  emxFree_int32_T(&cpu_iv52);
  emxFree_real_T(&eb_cpu_expanded);
  emxFree_real_T(&db_cpu_expanded);
  emxFree_real_T(&ec_cpu_y);
  emxFree_int32_T(&cpu_iv51);
  emxFree_real_T(&cb_cpu_expanded);
  emxFree_real_T(&bb_cpu_expanded);
  emxFree_real_T(&dc_cpu_y);
  emxFree_int32_T(&cpu_iv50);
  emxFree_int32_T(&d_cpu_rows);
  emxFree_int32_T(&c_cpu_rows);
  emxFree_int32_T(&cpu_iv49);
  emxFree_int32_T(&cc_cpu_y);
  emxFree_real_T(&bc_cpu_y);
  emxFree_real_T(&ac_cpu_y);
  emxFree_int32_T(&yb_cpu_y);
  emxFree_real_T(&xb_cpu_y);
  emxFree_int32_T(&wb_cpu_y);
  emxFree_int32_T(&vb_cpu_y);
  emxFree_int32_T(&ub_cpu_y);
  emxFree_int32_T(&cpu_iv46);
  emxFree_int32_T(&cpu_iv45);
  emxFree_int32_T(&cpu_iv44);
  emxFree_real_T(&ab_cpu_expanded);
  emxFree_real_T(&y_cpu_expanded);
  emxFree_int32_T(&cpu_iv43);
  emxFree_real_T(&tb_cpu_y);
  emxFree_real_T(&sb_cpu_y);
  emxFree_int32_T(&cpu_iv42);
  emxFree_real_T(&rb_cpu_y);
  emxFree_int32_T(&cpu_iv41);
  emxFree_int32_T(&cpu_iv40);
  emxFree_real_T(&f_cpu_result);
  emxFree_int32_T(&qb_cpu_y);
  emxFree_int32_T(&pb_cpu_y);
  emxFree_int32_T(&ob_cpu_y);
  emxFree_int32_T(&nb_cpu_y);
  emxFree_int32_T(&mb_cpu_y);
  emxFree_int32_T(&cpu_iv39);
  emxFree_int32_T(&cpu_iv38);
  emxFree_int32_T(&lb_cpu_y);
  emxFree_int32_T(&cpu_iv37);
  emxFree_int32_T(&cpu_iv36);
  emxFree_int32_T(&cpu_iv35);
  emxFree_int32_T(&kb_cpu_y);
  emxFree_real_T(&x_cpu_expanded);
  emxFree_real_T(&w_cpu_expanded);
  emxFree_int32_T(&cpu_iv34);
  emxFree_real_T(&jb_cpu_y);
  emxFree_real_T(&v_cpu_expanded);
  emxFree_real_T(&u_cpu_expanded);
  emxFree_int32_T(&cpu_iv33);
  emxFree_real_T(&ib_cpu_y);
  emxFree_real_T(&hb_cpu_y);
  emxFree_int32_T(&gb_cpu_y);
  emxFree_real_T(&e_cpu_result);
  emxFree_real_T(&d_cpu_result);
  emxFree_real_T(&q_cpu_c);
  emxFree_real_T(&c_cpu_result);
  emxFree_int32_T(&fb_cpu_y);
  emxFree_real_T(&t_cpu_expanded);
  emxFree_real_T(&s_cpu_expanded);
  emxFree_int32_T(&cpu_iv32);
  emxFree_int32_T(&cpu_iv31);
  emxFree_real_T(&eb_cpu_y);
  emxFree_int32_T(&db_cpu_y);
  emxFree_real_T(&cb_cpu_y);
  emxFree_int32_T(&bb_cpu_y);
  emxFree_int32_T(&ab_cpu_y);
  emxFree_real_T(&r_cpu_expanded);
  emxFree_real_T(&b_cpu_result);
  emxFree_int32_T(&y_cpu_y);
  emxFree_real_T(&cpu_result);
  emxFree_int32_T(&x_cpu_y);
  emxFree_int32_T(&w_cpu_y);
  emxFree_real_T(&p_cpu_c);
  emxFree_int32_T(&v_cpu_y);
  emxFree_real_T(&q_cpu_expanded);
  emxFree_real_T(&p_cpu_expanded);
  emxFree_real_T(&o_cpu_c);
  emxFree_int32_T(&u_cpu_y);
  emxFree_real_T(&o_cpu_expanded);
  emxFree_real_T(&n_cpu_expanded);
  emxFree_int32_T(&t_cpu_y);
  emxFree_real_T(&m_cpu_expanded);
  emxFree_real_T(&l_cpu_expanded);
  emxFree_int32_T(&s_cpu_y);
  emxFree_int32_T(&r_cpu_y);
  emxFree_int32_T(&b_cpu_rows);
  emxFree_int32_T(&cpu_rows);
  emxFree_real_T(&n_cpu_c);
  emxFree_int32_T(&q_cpu_y);
  emxFree_real_T(&k_cpu_expanded);
  emxFree_int32_T(&p_cpu_y);
  emxFree_real_T(&j_cpu_expanded);
  emxFree_real_T(&i_cpu_expanded);
  emxFree_int32_T(&o_cpu_y);
  emxFree_real_T(&h_cpu_expanded);
  emxFree_real_T(&g_cpu_expanded);
  emxFree_int32_T(&n_cpu_y);
  emxFree_real_T(&f_cpu_expanded);
  emxFree_real_T(&e_cpu_expanded);
  emxFree_int32_T(&cpu_iv30);
  emxFree_int32_T(&cpu_iv29);
  emxFree_real_T(&d_cpu_expanded);
  emxFree_real_T(&m_cpu_c);
  emxFree_real_T(&c_cpu_expanded);
  emxFree_real_T(&l_cpu_c);
  emxFree_real_T(&k_cpu_c);
  emxFree_real_T(&j_cpu_c);
  emxFree_real_T(&i_cpu_c);
  emxFree_real_T(&m_cpu_y);
  emxFree_real_T(&i_cpu_a);
  emxFree_real_T(&h_cpu_a);
  emxFree_int32_T(&l_cpu_y);
  emxFree_int32_T(&k_cpu_y);
  emxFree_real_T(&h_cpu_c);
  emxFree_real_T(&g_cpu_c);
  emxFree_real_T(&g_cpu_a);
  emxFree_real_T(&b_cpu_expanded);
  emxFree_real_T(&cpu_expanded);
  emxFree_real_T(&f_cpu_c);
  emxFree_real_T(&j_cpu_y);
  emxFree_real_T(&f_cpu_a);
  emxFree_real_T(&e_cpu_a);
  emxFree_real_T(&d_cpu_a);
  emxFree_real_T(&e_cpu_c);
  emxFree_real_T(&d_cpu_c);
  emxFree_real_T(&k_cpu_w);
  emxFree_real_T(&c_cpu_c);
  emxFree_real_T(&c_cpu_a);
  emxFree_real_T(&b_cpu_a);
  emxFree_real_T(&b_cpu_c);
  emxFree_real_T(&cpu_c);
  emxFree_real_T(&m_cpu_x);
  emxFree_real_T(&j_cpu_w);
  emxFree_real_T(&i_cpu_w);
  emxFree_real_T(&h_cpu_w);
  emxFree_real_T(&l_cpu_x);
  emxFree_real_T(&k_cpu_x);
  emxFree_real_T(&g_cpu_w);
  emxFree_real_T(&j_cpu_x);
  emxFree_real_T(&f_cpu_w);
  emxFree_real_T(&e_cpu_w);
  emxFree_real_T(&d_cpu_w);
  emxFree_real_T(&j_cpu_yCol);
  emxFree_real_T(&c_cpu_w);
  emxFree_real_T(&i_cpu_x);
  emxFree_real_T(&b_cpu_w);
  emxFree_real_T(&h_cpu_x);
  emxFree_real_T(&g_cpu_x);
  emxFree_real_T(&i_cpu_yCol);
  emxFree_real_T(&h_cpu_yCol);
  emxFree_real_T(&f_cpu_x);
  emxFree_real_T(&e_cpu_x);
  emxFree_real_T(&g_cpu_yCol);
  emxFree_real_T(&i_cpu_y);
  emxFree_real_T(&f_cpu_yCol);
  emxFree_real_T(&e_cpu_yCol);
  emxFree_real_T(&d_cpu_yCol);
  emxFree_real_T(&c_cpu_yCol);
  emxFree_real_T(&b_cpu_yCol);
  emxFree_real_T(&cpu_yCol);
  emxFree_int32_T(&cpu_IPIV);
  emxFree_ptrdiff_t(&jpvt_t);
  emxFree_real_T(&h_cpu_y);
  emxFree_real_T(&cpu_tau);
  emxFree_real_T(&cpu_xCol);
  emxFree_real_T(&cpu_dv21);
  emxFree_int32_T(&cpu_jpvt);
  emxFree_real_T(&d_cpu_x);
  emxFree_real_T(&cpu_dv20);
  emxFree_real_T(&cpu_a);
  emxFree_real_T(&cpu_y1);
  emxFree_real_T(&cpu_b);
  emxFree_int32_T(&cpu_iv6);
  emxFree_real_T(&cpu_sinc4A);
  emxFree_uint32_T(&g_cpu_y);
  emxFree_real_T(&cpu_sinc3A);
  emxFree_real_T(&b_cpu_h);
  emxFree_real_T(&cpu_sinc2A);
  emxFree_real_T(&cpu_sinc1A);
  emxFree_real_T(&cpu_G);
  emxFree_real_T(&cpu_k);
  emxFree_real_T(&cpu_m);
  emxFree_real_T(&cpu_h);
  emxFree_real_T(&cpu_h1);
  emxFree_real_T(&cpu_dv18);
  emxFree_real_T(&cpu_opts_x);
  emxFree_real_T(&cpu_opts_filter);
  emxFree_real_T(&cpu_xCh);
  emxFree_real_T(&f_cpu_y);
  emxFree_creal_T(&cpu_cfsposdft);
  emxFree_real_T(&c_cpu_x);
  emxFree_creal_T(&cpu_xposdft);
  emxFree_real_T(&cpu_xv);
  emxFree_creal_T(&cpu_cfspos);
  emxFree_real_T(&cpu_daughter);
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
  gpuEmxMemcpyGpuToCpu_real_T(cpu_freqs, &gpu_freqs);
  gpuEmxFree_real_T(&b_gpu_x);
  gpuEmxFree_real_T(&gpu_freqs);
  checkCudaError(mwCudaFree(gpu_dc6), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_dc1), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_nrefine), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(gpu_r), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_wav), __FILE__, __LINE__);
  gpuEmxFree_int32_T(&gpu_omega_tmp1);
  checkCudaError(mwCudaFree(*gpu_wname), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_omega_tmp2);
  checkCudaError(mwCudaFree(b_gpu_r), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_interval), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_fb_Omega);
  checkCudaError(mwCudaFree(*gpu_subs), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_x_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_fb_Scales);
  checkCudaError(mwCudaFree(*b_gpu_x_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_xt_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_y);
  checkCudaError(mwCudaFree(*gpu_y_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&b_gpu_y);
  checkCudaError(mwCudaFree(*d_gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&ld_gpu_y);
  checkCudaError(mwCudaFree(*b_gpu_a_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&md_gpu_y);
  checkCudaError(mwCudaFree(*gpu_dv10_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv4_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*c_gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_daughter);
  gpuEmxFree_real_T(&gpu_f);
  gpuEmxFree_real_T(&b_gpu_somega);
  gpuEmxFree_real_T(&gpu_somega);
  gpuEmxFree_real_T(&db_gpu_w);
  gpuEmxFree_real_T(&gpu_absomega);
  gpuEmxFree_real_T(&gpu_expnt);
  checkCudaError(mwCudaFree(*b_gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_powscales);
  checkCudaError(mwCudaFree(*gpu_a_data), __FILE__, __LINE__);
  gpuEmxFree_real_T(&gpu_x);
  gpuEmxFree_real_T(&kd_gpu_y);
  checkCudaError(mwCudaFree(*gpu_dv16_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_dv13_data), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_fx_data), __FILE__, __LINE__);
  gpuEmxFree_creal_T(&gpu_cfspos);
  gpuEmxFree_real_T(&gpu_xv);
  gpuEmxFree_creal_T(&gpu_xposdft);
  gpuEmxFree_real_T(&c_gpu_x);
  gpuEmxFree_creal_T(&gpu_cfsposdft);
  gpuEmxFree_real_T(&c_gpu_y);
  gpuEmxFree_real_T(&gpu_xCh);
  gpuEmxFree_real_T(&gpu_opts_filter);
  gpuEmxFree_real_T(&gpu_opts_x);
  gpuEmxFree_real_T(&gpu_dv18);
  gpuEmxFree_real_T(&gpu_h1);
  gpuEmxFree_real_T(&gpu_h);
  gpuEmxFree_real_T(&gpu_m);
  gpuEmxFree_real_T(&gpu_k);
  gpuEmxFree_real_T(&gpu_G);
  gpuEmxFree_real_T(&gpu_sinc1A);
  gpuEmxFree_real_T(&gpu_sinc2A);
  gpuEmxFree_real_T(&b_gpu_h);
  gpuEmxFree_real_T(&gpu_sinc3A);
  gpuEmxFree_uint32_T(&f_gpu_y);
  gpuEmxFree_real_T(&gpu_sinc4A);
  gpuEmxFree_int32_T(&gpu_iv6);
  gpuEmxFree_real_T(&gpu_b);
  gpuEmxFree_real_T(&gpu_y1);
  gpuEmxFree_real_T(&gpu_a);
  gpuEmxFree_real_T(&gpu_dv20);
  gpuEmxFree_real_T(&m_gpu_x);
  gpuEmxFree_int32_T(&gpu_jpvt);
  gpuEmxFree_real_T(&gpu_dv21);
  gpuEmxFree_real_T(&gpu_xCol);
  gpuEmxFree_real_T(&gpu_tau);
  gpuEmxFree_real_T(&d_gpu_y);
  gpuEmxFree_int32_T(&gpu_IPIV);
  gpuEmxFree_real_T(&g_gpu_yCol);
  gpuEmxFree_real_T(&e_gpu_yCol);
  gpuEmxFree_real_T(&b_gpu_yCol);
  gpuEmxFree_real_T(&i_gpu_yCol);
  gpuEmxFree_real_T(&f_gpu_yCol);
  gpuEmxFree_real_T(&c_gpu_yCol);
  gpuEmxFree_real_T(&e_gpu_y);
  gpuEmxFree_real_T(&j_gpu_yCol);
  gpuEmxFree_real_T(&h_gpu_x);
  gpuEmxFree_real_T(&e_gpu_x);
  gpuEmxFree_real_T(&d_gpu_yCol);
  gpuEmxFree_real_T(&gpu_yCol);
  gpuEmxFree_real_T(&k_gpu_x);
  gpuEmxFree_real_T(&i_gpu_x);
  gpuEmxFree_real_T(&m_gpu_w);
  gpuEmxFree_real_T(&f_gpu_x);
  gpuEmxFree_real_T(&d_gpu_w);
  gpuEmxFree_real_T(&h_gpu_yCol);
  gpuEmxFree_real_T(&w_gpu_w);
  gpuEmxFree_real_T(&p_gpu_w);
  gpuEmxFree_real_T(&g_gpu_w);
  gpuEmxFree_real_T(&l_gpu_x);
  gpuEmxFree_real_T(&s_gpu_w);
  gpuEmxFree_real_T(&g_gpu_x);
  gpuEmxFree_real_T(&d_gpu_x);
  gpuEmxFree_real_T(&ab_gpu_w);
  gpuEmxFree_real_T(&j_gpu_w);
  gpuEmxFree_real_T(&gpu_w);
  gpuEmxFree_real_T(&j_gpu_x);
  gpuEmxFree_real_T(&i_gpu_c);
  gpuEmxFree_real_T(&c_gpu_c);
  gpuEmxFree_real_T(&f_gpu_a);
  gpuEmxFree_real_T(&c_gpu_a);
  gpuEmxFree_real_T(&n_gpu_c);
  gpuEmxFree_real_T(&t_gpu_w);
  gpuEmxFree_real_T(&k_gpu_c);
  gpuEmxFree_real_T(&e_gpu_c);
  gpuEmxFree_real_T(&h_gpu_a);
  gpuEmxFree_real_T(&g_gpu_a);
  gpuEmxFree_real_T(&d_gpu_a);
  gpuEmxFree_real_T(&gc_gpu_y);
  gpuEmxFree_real_T(&p_gpu_c);
  gpuEmxFree_real_T(&ib_gpu_expanded);
  gpuEmxFree_real_T(&hb_gpu_expanded);
  gpuEmxFree_real_T(&i_gpu_a);
  gpuEmxFree_real_T(&g_gpu_c);
  gpuEmxFree_real_T(&gpu_c);
  gpuEmxFree_int32_T(&jc_gpu_y);
  gpuEmxFree_int32_T(&ic_gpu_y);
  gpuEmxFree_real_T(&e_gpu_a);
  gpuEmxFree_real_T(&b_gpu_a);
  gpuEmxFree_real_T(&hc_gpu_y);
  gpuEmxFree_real_T(&j_gpu_c);
  gpuEmxFree_real_T(&d_gpu_c);
  gpuEmxFree_real_T(&o_gpu_c);
  gpuEmxFree_real_T(&l_gpu_c);
  gpuEmxFree_real_T(&s_gpu_expanded);
  gpuEmxFree_real_T(&f_gpu_c);
  gpuEmxFree_real_T(&c_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv29);
  gpuEmxFree_int32_T(&gpu_iv30);
  gpuEmxFree_real_T(&u_gpu_expanded);
  gpuEmxFree_real_T(&t_gpu_expanded);
  gpuEmxFree_int32_T(&mb_gpu_y);
  gpuEmxFree_real_T(&e_gpu_expanded);
  gpuEmxFree_real_T(&d_gpu_expanded);
  gpuEmxFree_int32_T(&m_gpu_y);
  gpuEmxFree_real_T(&lb_gpu_expanded);
  gpuEmxFree_real_T(&ab_gpu_expanded);
  gpuEmxFree_int32_T(&ob_gpu_y);
  gpuEmxFree_real_T(&j_gpu_expanded);
  gpuEmxFree_int32_T(&o_gpu_y);
  gpuEmxFree_real_T(&q_gpu_c);
  gpuEmxFree_int32_T(&eb_gpu_rows);
  gpuEmxFree_int32_T(&db_gpu_rows);
  gpuEmxFree_int32_T(&nb_gpu_y);
  gpuEmxFree_int32_T(&n_gpu_y);
  gpuEmxFree_real_T(&nb_gpu_expanded);
  gpuEmxFree_real_T(&mb_gpu_expanded);
  gpuEmxFree_int32_T(&qc_gpu_y);
  gpuEmxFree_real_T(&cb_gpu_expanded);
  gpuEmxFree_real_T(&bb_gpu_expanded);
  gpuEmxFree_int32_T(&xb_gpu_y);
  gpuEmxFree_real_T(&h_gpu_c);
  gpuEmxFree_real_T(&l_gpu_expanded);
  gpuEmxFree_real_T(&k_gpu_expanded);
  gpuEmxFree_int32_T(&x_gpu_y);
  gpuEmxFree_real_T(&b_gpu_c);
  gpuEmxFree_int32_T(&sc_gpu_y);
  gpuEmxFree_int32_T(&ac_gpu_y);
  gpuEmxFree_real_T(&c_gpu_result);
  gpuEmxFree_int32_T(&ab_gpu_y);
  gpuEmxFree_real_T(&gpu_result);
  gpuEmxFree_real_T(&sb_gpu_expanded);
  gpuEmxFree_int32_T(&rc_gpu_y);
  gpuEmxFree_int32_T(&yb_gpu_y);
  gpuEmxFree_real_T(&ib_gpu_y);
  gpuEmxFree_int32_T(&y_gpu_y);
  gpuEmxFree_real_T(&i_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv31);
  gpuEmxFree_int32_T(&gpu_iv32);
  gpuEmxFree_real_T(&ub_gpu_expanded);
  gpuEmxFree_real_T(&tb_gpu_expanded);
  gpuEmxFree_int32_T(&cd_gpu_y);
  gpuEmxFree_real_T(&e_gpu_result);
  gpuEmxFree_real_T(&m_gpu_c);
  gpuEmxFree_real_T(&d_gpu_result);
  gpuEmxFree_real_T(&b_gpu_result);
  gpuEmxFree_int32_T(&ed_gpu_y);
  gpuEmxFree_real_T(&mc_gpu_y);
  gpuEmxFree_real_T(&ub_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv33);
  gpuEmxFree_real_T(&r_gpu_expanded);
  gpuEmxFree_real_T(&q_gpu_expanded);
  gpuEmxFree_real_T(&u_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv34);
  gpuEmxFree_real_T(&b_gpu_expanded);
  gpuEmxFree_real_T(&gpu_expanded);
  gpuEmxFree_int32_T(&dd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv35);
  gpuEmxFree_int32_T(&gpu_iv36);
  gpuEmxFree_int32_T(&gpu_iv37);
  gpuEmxFree_int32_T(&lb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv38);
  gpuEmxFree_int32_T(&gpu_iv39);
  gpuEmxFree_int32_T(&l_gpu_y);
  gpuEmxFree_int32_T(&pb_gpu_y);
  gpuEmxFree_int32_T(&kb_gpu_y);
  gpuEmxFree_int32_T(&p_gpu_y);
  gpuEmxFree_int32_T(&k_gpu_y);
  gpuEmxFree_real_T(&f_gpu_result);
  gpuEmxFree_int32_T(&gpu_iv40);
  gpuEmxFree_int32_T(&gpu_iv41);
  gpuEmxFree_real_T(&jb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv42);
  gpuEmxFree_real_T(&j_gpu_y);
  gpuEmxFree_real_T(&yc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv43);
  gpuEmxFree_real_T(&kb_gpu_expanded);
  gpuEmxFree_real_T(&jb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv44);
  gpuEmxFree_int32_T(&gpu_iv45);
  gpuEmxFree_int32_T(&gpu_iv46);
  gpuEmxFree_int32_T(&tc_gpu_y);
  gpuEmxFree_int32_T(&pc_gpu_y);
  gpuEmxFree_int32_T(&bc_gpu_y);
  gpuEmxFree_real_T(&gb_gpu_y);
  gpuEmxFree_int32_T(&bb_gpu_y);
  gpuEmxFree_real_T(&g_gpu_y);
  gpuEmxFree_real_T(&nc_gpu_y);
  gpuEmxFree_int32_T(&oc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv49);
  gpuEmxFree_int32_T(&q_gpu_rows);
  gpuEmxFree_int32_T(&c_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv50);
  gpuEmxFree_real_T(&wb_gpu_y);
  gpuEmxFree_real_T(&w_gpu_expanded);
  gpuEmxFree_real_T(&v_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv51);
  gpuEmxFree_real_T(&w_gpu_y);
  gpuEmxFree_real_T(&g_gpu_expanded);
  gpuEmxFree_real_T(&f_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv52);
  gpuEmxFree_int32_T(&fd_gpu_y);
  gpuEmxFree_real_T(&kc_gpu_y);
  gpuEmxFree_int32_T(&rb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv53);
  gpuEmxFree_int32_T(&r_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv54);
  gpuEmxFree_int32_T(&hb_gpu_rows);
  gpuEmxFree_int32_T(&w_gpu_rows);
  gpuEmxFree_int32_T(&qb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv56);
  gpuEmxFree_int32_T(&i_gpu_rows);
  gpuEmxFree_int32_T(&q_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv57);
  gpuEmxFree_real_T(&pb_gpu_expanded);
  gpuEmxFree_real_T(&ob_gpu_expanded);
  gpuEmxFree_real_T(&eb_gpu_expanded);
  gpuEmxFree_real_T(&db_gpu_expanded);
  gpuEmxFree_real_T(&n_gpu_expanded);
  gpuEmxFree_real_T(&m_gpu_expanded);
  gpuEmxFree_real_T(&bd_gpu_y);
  gpuEmxFree_int32_T(&vc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv58);
  gpuEmxFree_int32_T(&dc_gpu_y);
  gpuEmxFree_real_T(&y_gpu_expanded);
  gpuEmxFree_real_T(&x_gpu_expanded);
  gpuEmxFree_int32_T(&db_gpu_y);
  gpuEmxFree_real_T(&i_gpu_expanded);
  gpuEmxFree_real_T(&h_gpu_expanded);
  gpuEmxFree_int32_T(&uc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv59);
  gpuEmxFree_int32_T(&gpu_iv60);
  gpuEmxFree_int32_T(&cc_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv61);
  gpuEmxFree_int32_T(&tb_gpu_y);
  gpuEmxFree_int32_T(&r_gpu_rows);
  gpuEmxFree_int32_T(&cb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv62);
  gpuEmxFree_int32_T(&t_gpu_y);
  gpuEmxFree_int32_T(&d_gpu_rows);
  gpuEmxFree_int32_T(&nb_gpu_rows);
  gpuEmxFree_int32_T(&sb_gpu_y);
  gpuEmxFree_int32_T(&s_gpu_y);
  gpuEmxFree_real_T(&wb_gpu_expanded);
  gpuEmxFree_real_T(&vb_gpu_expanded);
  gpuEmxFree_real_T(&rb_gpu_expanded);
  gpuEmxFree_real_T(&qb_gpu_expanded);
  gpuEmxFree_real_T(&gb_gpu_expanded);
  gpuEmxFree_real_T(&fb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv63);
  gpuEmxFree_int32_T(&c_gpu_cols);
  gpuEmxFree_int32_T(&o_gpu_rows);
  gpuEmxFree_real_T(&p_gpu_expanded);
  gpuEmxFree_real_T(&o_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv64);
  gpuEmxFree_int32_T(&gpu_cols);
  gpuEmxFree_int32_T(&gpu_rows);
  gpuEmxFree_int32_T(&hd_gpu_y);
  gpuEmxFree_int32_T(&xc_gpu_y);
  gpuEmxFree_int32_T(&ib_gpu_rows);
  gpuEmxFree_int32_T(&fc_gpu_y);
  gpuEmxFree_int32_T(&x_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv65);
  gpuEmxFree_int32_T(&fb_gpu_y);
  gpuEmxFree_int32_T(&j_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv66);
  gpuEmxFree_int32_T(&gd_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv67);
  gpuEmxFree_int32_T(&wc_gpu_y);
  gpuEmxFree_int32_T(&ec_gpu_y);
  gpuEmxFree_int32_T(&eb_gpu_y);
  gpuEmxFree_int32_T(&gpu_iv68);
  gpuEmxFree_int32_T(&e_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv69);
  gpuEmxFree_int32_T(&d_gpu_cols);
  gpuEmxFree_int32_T(&t_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv71);
  gpuEmxFree_int32_T(&b_gpu_cols);
  gpuEmxFree_int32_T(&f_gpu_rows);
  gpuEmxFree_real_T(&yb_gpu_expanded);
  gpuEmxFree_real_T(&xb_gpu_expanded);
  gpuEmxFree_int32_T(&gpu_iv73);
  gpuEmxFree_int32_T(&fb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv74);
  gpuEmxFree_int32_T(&gpu_iv75);
  gpuEmxFree_int32_T(&s_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv76);
  gpuEmxFree_int32_T(&gpu_iv77);
  gpuEmxFree_int32_T(&e_gpu_rows);
  gpuEmxFree_int32_T(&jd_gpu_y);
  gpuEmxFree_int32_T(&ob_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv78);
  gpuEmxFree_int32_T(&gpu_iv79);
  gpuEmxFree_int32_T(&id_gpu_y);
  gpuEmxFree_int32_T(&kb_gpu_rows);
  gpuEmxFree_int32_T(&ab_gpu_rows);
  gpuEmxFree_int32_T(&p_gpu_rows);
  gpuEmxFree_int32_T(&l_gpu_rows);
  gpuEmxFree_int32_T(&b_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv80);
  gpuEmxFree_int32_T(&f_gpu_cols);
  gpuEmxFree_int32_T(&gpu_iv81);
  gpuEmxFree_int32_T(&jb_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv83);
  gpuEmxFree_int32_T(&y_gpu_rows);
  gpuEmxFree_int32_T(&v_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv84);
  gpuEmxFree_int32_T(&k_gpu_rows);
  gpuEmxFree_int32_T(&h_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv85);
  gpuEmxFree_int32_T(&gpu_iv86);
  gpuEmxFree_int32_T(&gpu_iv87);
  gpuEmxFree_int32_T(&u_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv89);
  gpuEmxFree_int32_T(&g_gpu_rows);
  gpuEmxFree_int32_T(&qb_gpu_rows);
  gpuEmxFree_int32_T(&mb_gpu_rows);
  gpuEmxFree_int32_T(&gb_gpu_rows);
  gpuEmxFree_int32_T(&cb_gpu_rows);
  gpuEmxFree_int32_T(&n_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv93);
  gpuEmxFree_int32_T(&pb_gpu_rows);
  gpuEmxFree_int32_T(&lb_gpu_rows);
  gpuEmxFree_int32_T(&bb_gpu_rows);
  gpuEmxFree_int32_T(&m_gpu_rows);
  gpuEmxFree_int32_T(&gpu_iv94);
  gpuEmxFree_int32_T(&sb_gpu_rows);
  gpuEmxFree_int32_T(&rb_gpu_rows);
  gpuEmxFree_real_T(&gpu_b0);
  gpuEmxFree_real_T(&u_gpu_w);
  gpuEmxFree_real_T(&n_gpu_w);
  gpuEmxFree_real_T(&e_gpu_w);
  gpuEmxFree_real_T(&k_gpu_w);
  gpuEmxFree_real_T(&b_gpu_w);
  gpuEmxFree_real_T(&x_gpu_w);
  gpuEmxFree_real_T(&q_gpu_w);
  gpuEmxFree_real_T(&h_gpu_w);
  gpuEmxFree_real_T(&v_gpu_w);
  gpuEmxFree_real_T(&o_gpu_w);
  gpuEmxFree_real_T(&f_gpu_w);
  gpuEmxFree_real_T(&lc_gpu_y);
  gpuEmxFree_real_T(&l_gpu_w);
  gpuEmxFree_real_T(&c_gpu_w);
  gpuEmxFree_real_T(&vb_gpu_y);
  gpuEmxFree_real_T(&hb_gpu_y);
  gpuEmxFree_real_T(&v_gpu_y);
  gpuEmxFree_real_T(&h_gpu_y);
  gpuEmxFree_real_T(&y_gpu_w);
  gpuEmxFree_real_T(&r_gpu_w);
  gpuEmxFree_real_T(&i_gpu_w);
  gpuEmxFree_real_T(&bb_gpu_w);
  gpuEmxFree_real_T(&ad_gpu_y);
  gpuEmxFree_real_T(&cb_gpu_w);
  checkCudaError(mwCudaFree(*gpu_csz), __FILE__, __LINE__);
  checkCudaError(mwCudaFree(*gpu_lshift), __FILE__, __LINE__);
}

void ec_cwt_atexit()
{
  mexFunctionCreateRootTLS();
  try {
    emlrtPushHeapReferenceStackR2021a(emlrtRootTLSGlobal, false, nullptr, (void *)
      &emlrtExitTimeCleanupDtorFcn, nullptr, nullptr, nullptr);
    emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
    emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
    emlrtExitTimeCleanup(&emlrtContextGlobal);
  } catch (...) {
    emlrtCleanupOnException((emlrtCTX *)emlrtRootTLSGlobal);
    throw;
  }

  cusolverDestroyWorkspace();
  cusolverEnsureDestruction();
  mwCudaFree(*global_gpu_cv);
  mwCudaFree(*global_gpu_table100);
}

void ec_cwt_initialize()
{
  emlrtInitGPU(emlrtRootTLSGlobal);
  cudaGetLastError();
  mexFunctionCreateRootTLS();
  emlrtClearAllocCountR2012b(emlrtRootTLSGlobal, false, 0U, nullptr);
  emlrtEnterRtStackR2012b(emlrtRootTLSGlobal);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "distrib_computing_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "wavelet_toolbox", 2);
  emlrtLicenseCheckR2022a(emlrtRootTLSGlobal,
    "EMLRT:runTime:MexFunctionNeedsLicense", "signal_toolbox", 2);
  cublasEnsureInitialization(CUBLAS_POINTER_MODE_HOST);
  cusolverEnsureInitialization();
  if (emlrtFirstTimeR2012b(emlrtRootTLSGlobal)) {
    ec_cwt_once();
  }
}

void ec_cwt_terminate()
{
  cudaError_t errCode;
  errCode = cudaGetLastError();
  if (errCode != cudaSuccess) {
    emlrtThinCUDAError(static_cast<uint32_T>(errCode), (char_T *)
                       cudaGetErrorName(errCode), (char_T *)cudaGetErrorString
                       (errCode), (char_T *)"SafeBuild", emlrtRootTLSGlobal);
  }

  emlrtDestroyRootTLS(&emlrtRootTLSGlobal);
  cublasEnsureDestruction();
}

// End of code generation (ec_cwt.cu)
