function [errors,n,x] = ec_wCoherence(sbj,task,o,n,x,arg)
%% electroCUDA: time-frequency decomposition
% This function performs time-frequency decomposition on channel or IC timecourses
% (output of 'ec_preproc' or 'ec_preprocICA'). Decomposition is performed via
% continuous wavelet transform (CWT) using Morse wavelets, which account
% for unequal variance-covariance across frequencies (unlike other wavelets).
% L1-norm is applied to mitigate the 1/frequency decay of neuronal field potentials.
%
% SEE WIKI FOR MORE INFO: github.com/kevmtan/electroCUDA/wiki
%
% INPUTS:
%    sbj = subject name
%    task = task name
%    o = struct of options & parameters (TO DO: describe all options)
%    n = preloaded 'n' info output from ec_initialize or robustPreproc (OPTIONAL)
%    x = preloaded EEG recordings: rows=frames, columns=channels (OPTIONAL)
%    arg = Name-Value Arguments (see "Input validation" below)
%
% OUTPUTS:
%   errors = cell array of any errors or warnings
%   n = Struct of preprocessing info & results
%   x = Preprocessed EEG data indexed as: x(timeframe,channel)
%      NOTE: 'n' and 'x' are saved to disk by default
%
% ACKNOWLEDGEMENTS:
%    * Stanford Parvizi Lab (Pedro Pinhiero-Chagas, Amy Daitch, Su Liu, et al.)
%    * Laboratoire des Systèmes Perceptifs (NoiseTools: Alain de Cheveigné, et al.)
%    * Full acknowledgements in Wiki (github.com/kevmtan/electroCUDA/wiki)
%
% LICENSE: General Public License (GNU GPLv3)
% DISCLAIMERS:
%    Use and distribution of this software must comply with GNU GPLv3.
%    This software may be subject to University of California intellectual
%    property rights.
%    Use this code at your own risk. Users assume full responsibility for
%    any eventualities related to the content herein.
%    This code is for research purposes only and NOT INTENDED FOR CLINICAL USE.
%
%
%                 Kevin Tan, 2022 (github.io/kevmtan)

%% Input validation
arguments
    sbj {istext,isnumeric} = ""
    task {mustBeText} = ""
    o struct = struct % options struct (see "Options struct validation" below)
    n struct = [] % preloaded 'n' struct from ec_preproc (OPTIONAL)
    x {isfloat} = [] % preloaded EEG recordings: rows=frames, columns=channels (OPTIONAL)
    arg.dirs struct = [] % Directory paths struct
    arg.ica logical = false % Input data from ICA?
    arg.save logical = false
    arg.test logical = false
    arg.redoN logical = false
end
dirs = arg.dirs;
% n=[]; x=[]; o=os; arg.ica=0; arg.save=0; arg.test=1;

%% Input validation
if sbj==""; sbj = o.sbj; end
if task==""; task = o.task; end
if ~isstruct(dirs); dirs = ec_getDirs(dirs,sbj,task); end

% Options struct
if ~isfield(o,'fName');       o.fName="spec"; end     % Name of frequency analysis
if ~isfield(o,'fLims');       o.fLims=[1 300]; end    % Frequency limits in hz; HFB=[70 200]
if ~isfield(o,'fVoices');     o.fVoices=12; end       % Voices per octave (default=10, HFB=18)
if ~isfield(o,'dsTarg');      o.dsTarg=[]; end        % Downsample target in Hz (default=[]: no downsample)
if ~isfield(o,'single');      o.single=true; end      % Run & save as single (single much faster on GPU)
if ~isfield(o,'singleOut');   o.halfOut=true; end     % Save as half-precision float (16-bit) to save memory
if ~isfield(o,'doGPU');       o.doGPU=false; end      % Run on GPU, see MATLAB gpuArray requirements (default=false)
% if ~isfield(o,'GPUmex');      o.GPUmex=false; end
% if ~isfield(o,'norm');        o.norm=false; end         % Convert absolute values (log-normal) to normal distribution

%% Setup & initialize
tic; errors={};

% Load EEG data
if isempty(x) || arg.test
    if arg.ica && o.suffix==""; o.suffix="i"; end
    [n,x,psy,trialNfo,chNfo] = ec_loadSbj(dirs,o.suffix);
end
if arg.test; xOg=x; chNfoOg=chNfo; end %#ok<NASGU>

% Convert to single-precision
if o.single; x=single(x); end

% Load metadata
sbjID = n.sbjID;
nRuns = n.nRuns;
n.task = task;
n.suffix = o.suffix;
fsOg = floor(n.fs);
if o.suffix==""; sfx=""; else; sfx="_"+o.suffix; end
if ~isfield(o,'dirOut'); o.dirOut=dirs.procSbj; end % Output directory
if ~isfield(o,'fnStr');  o.fnStr="s"+sbjID+"_"+task+".mat"; end % Filename ending string


% Get downsampling factor & anti-aliasing filter
if ~isempty(o.dsTarg)
    [ds1,ds2] = rat(o.dsTarg/fsOg);
    if ds1>ds2; error(sbj+" downsampling target > iEEG sampling rate"); end
else
    ds1=1; ds2=1;
end

% Only keep good channels (ICA chans rn)
idx = chNfo.ica;
x = x(:,idx);
chNfo = chNfo(idx,:);
nChs = nnz(idx);

% Calculate channel pairs
cc = uint16(1:nChs);
cc = combinations(cc,cc);
cc = renamevars(cc,[1 2],["i1" "i2"]);
cc = cc(cc.i1~=cc.i2,:); % Remove same-channel pairs

% Keep unique channel pairs only
for p = 1:nChs
    idx = cc.i1>p & cc.i2==p;
    cc = cc(~idx,:);
end
cc.ch1 = chNfo.ch(cc.i1);
cc.ch2 = chNfo.ch(cc.i2);
nPairs = height(cc);
c1=cc.i1; c2=cc.i2;

% Reset GPU, move vars to GPU, get free VRAM
if o.doGPU
    if ~isempty(gcp('nocreate')); parfevalOnAll(@gpuDevice,0,[]); delete(gcp('nocreate')); end
	try reset(gpuDevice()); catch; end
    %fsOg=gpuArray(fsOg); fLims=gpuArray(fLims); fVoices=gpuArray(fVoices);
    %ds1=gpuArray(ds1); ds2=gpuArray(ds2); halfOut=gpuArray(halfOut);
    c1=gpuArray(c1); c2=gpuArray(c2);
    memMax = gpuDevice().AvailableMemory; % see available vram
else
    try ppool = parpool('threads'); catch;end %#ok<NASGU>
end
% Reshape per run
x = mat2cell(x,n.runIdxOg(:,2));
xa = cell(nRuns,1);


%% Run wavelet coherence
cwtHz = cell(nRuns,1);
for r = 1:nRuns % CWT within-run (avoid edge artifacts at run transitions)
    if arg.test; tic; end
    % Get block iEEG data
    run = n.runs(r);
    xr = x{r}; rLength=height(xr);
    
    % Generate wavelet filters
    cwtHz{r} = cwtfilterbank(SignalLength=rLength,VoicesPerOctave=o.fVoices,...
        SamplingFrequency=n.fs,FrequencyLimits=o.fLims,Wavelet="amor");
    cwtHz{r} = cwtHz{r}.centerFrequencies';
    nFrqs = numel(cwtHz{r});

    if o.doGPU
        xr = gpuArray(xr);
        %[xx,xxa] = arrayfun(@(i1,i2) wtc_lfn(xr(:,i1),xr(:,i2),fsOg,fLims,...
        %        fVoices,ds1,ds2,false),c1(1:24),c2(1:24),UniformOutput=false);
        for p = 1:nPairs
            [xx{p},xxa{p}] = wtc_lfn(xr(:,c1(p)),xr(:,c2(p)),fsOg,fLims,...
                fVoices,ds1,ds2,false);
            if (gpuDevice().AvailableMemory/memMax) < 0.1
                xx = cellfun(@gather,xx,UniformOutput=false);
                xxa = cellfun(@gather,xxa,UniformOutput=false);
            end
        end
    else
        xx=cell(1,nPairs); xxa=cell(1,nPairs);
        parfor p = 1:nPairs
            [xx{p},xxa{p}] = wtc_lfn(xr(:,c1(p)),xr(:,c2(p)),fsOg,fLims,...
                fVoices,ds1,ds2,halfOut);
        end
    end

    toc;

    
    %%
    % Reshape & concactenate
    x{r} = permute(cat(3,xx{:}),[1 3 2]);
    xa{r} = permute(cat(3,xxa{:}),[1 3 2]);

    % Copy to main
    x{r} = xr; disp("[preprocTimeFreq] Finished CWT loop: "+sbj+"_run"+run+" time="+toc);
end
if doGPU; ds2=gather(ds2); fMean=gather(fMean); end

%% Organize & clear memory
x = vertcat(x{:});
if ~fMean
    x = flip(x,3); % Sort freqs from low to high
end
n.xFrames = size(x,1);
n.xChs = size(x,2);
n.nFreqs = size(x,3);
n.freqs = flip(cwtHz{1});
n.freqsRun = vertcat(cwtHz{:});

% % Resample behavioral data
% [err,o,n] = ec_initialize(sbj,task,o,n,dirs=dirs,save=arg.save,ica=arg.ica,...
%     dsTarg=o.dsTarg);
% if isany(err); errors{end+1}=err; end


%% Finalize
% Convert to single if specified
if singleOut; x = single(x); end

% Reset GPU
if doGPU
	if ~isempty(gcp('nocreate')); parfevalOnAll(@gpuDevice,0,[]); end
	try reset(gpuDevice()); catch; end
end

% Save
if arg.save
    % Save chNfo
    if o.doBadFrames && ~arg.ica
        fn = o.dirOut+"chNfo_"+o.fnStr;
        save(fn,'chNfo','-v7'); disp("SAVED: "+fn);
    end

    % Save n struct
    fn = o.dirOut+"n"+sfx+"_"+o.fnStr;
    save(fn,"n","-v7"); disp("SAVED: "+fn);

    % Save processed iEEG data
    fn = o.dirOut+"x"+sfx+"_"+o.fnStr;
    savefast(fn,'x'); disp("SAVED: "+fn+" time="+toc);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Wavelet coherence - GPU
function [xx,yy] = wtcGPU_lfn(xr,cc,n,o,ds1,ds2,nFrqs,run,memMax)
tic; 

% Get vars
nPairs=height(cc); xx=cell(1,nPairs); yy=cell(1,nPairs);

% Calculate simultaneous iterations that fit in VRAM
memIn = whos("xr").bytes/nPairs;
memIn = memIn*nFrqs;


memChs=floor(memMax/memIn); memItr=ceil(nPairs/memChs); memChs=ceil(nPairs/memItr);
disp("[ec_preprocTimeFreq] gpuArrayFun start: "+sbj+" "+run+" memChs="+gather(memChs)+"/"+nPairs+" time="+toc);

% GPU arrayfun (fast, requires Nvidia GPU)
chFin=gpuArray(false(nPairs,1)); memChs=gpuArray(memChs); memItr=gpuArray(memItr)

c1=gpuArray(cc.i1); c2=gpuArray(cc.i2); pairs=gpuArray(uint16(1:height(cc)));




for p = pairs
    [xx{p},xxa{p}] = wtc_lfn(xr(:,c1(p)),xr(:,c2(p)),fsOg,fLims,...
        fVoices,ds1,ds2,false);
    if (gpuDevice().AvailableMemory/memMax) < 0.1
        xx = cellfun(@gather,xx,UniformOutput=false);
        xxa = cellfun(@gather,xxa,UniformOutput=false);
    end
end


%% Wavelet coherence - local function
function [x,y] = wtc_lfn(x,y,fsOg,fLims,fVoices,ds1,ds2,halfOut)

% Calculate wavelet coherence
[x,y] = wcoherence(x,y,fsOg,FrequencyLimits=fLims,VoicesPerOctave=fVoices);
x=x'; y=y'; % Flip to correct dim

% Downsample
if ds2 > 1
    x = resample(x,ds1,ds2);
    y = resample(y,ds1,ds2);
    % x = x(1:ds2:end,:);
    % y = y(1:ds2:end,:);
end

% Convert wavelet to phase angle
y = angle(y);

% Convert to 16-bit float (half precision)
if halfOut
    x = half(x);
    y = half(y);
end



%% Depreciated
% %% Normalize & downsample if not yet applied
% if ds2>ds1 && length(xr{1})>=rLength
%     if isa(xr{1},'single'); xr=cellfun(@double,xr,UniformOutput=false); end
%     xr = arrayfun(@(xx) resample(xx{:},ds1,ds2),xr,UniformOutput=false);
%     if singleIn||singleOut; xr=cellfun(@single,xr,UniformOutput=false); end
%     disp("Downsampled (CPU): "+sbj+" "+run+" time="+toc);
% end
