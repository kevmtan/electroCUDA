function [errors,n,x] = ec_wtc(sbj,task,o,n,x,arg)
%% electroCUDA: time-frequency decomposition
% This function performs time-frequency decomposition on channel or IC timecourses
% (output of 'ec_preproc' or 'ec_preprocICA'). Decomposition is performed via
% continuous wavelet transform (CWT) using Morse wavelets, which account
% for unequal variance-covariance across frequencies (unlike other wavelets).
% L1-norm is applied to mitigate the 1/frequency decay of neuronal field potentials.
%
% SEE WIKI FOR MORE INFO: github.com/kevmtan/electroCUDA/wiki
%
% INPUTS:
%    sbj = subject name
%    task = task name
%    o = struct of options & parameters (TO DO: describe all options)
%    n = preloaded 'n' info output from ec_initialize or robustPreproc (OPTIONAL)
%    x = preloaded EEG recordings: rows=frames, columns=channels (OPTIONAL)
%    arg = Name-Value Arguments (see "Input validation" below)
%
% OUTPUTS:
%   errors = cell array of any errors or warnings
%   n = Struct of preprocessing info & results
%   x = Preprocessed EEG data indexed as: x(timeframe,channel)
%      NOTE: 'n' and 'x' are saved to disk by default
%
% ACKNOWLEDGEMENTS:
%    * Stanford Parvizi Lab (Pedro Pinhiero-Chagas, Amy Daitch, Su Liu, et al.)
%    * Laboratoire des Systèmes Perceptifs (NoiseTools: Alain de Cheveigné, et al.)
%    * Full acknowledgements in Wiki (github.com/kevmtan/electroCUDA/wiki)
%
% LICENSE: General Public License (GNU GPLv3)
% DISCLAIMERS:
%    Use and distribution of this software must comply with GNU GPLv3.
%    This software may be subject to University of California intellectual
%    property rights.
%    Use this code at your own risk. Users assume full responsibility for
%    any eventualities related to the content herein.
%    This code is for research purposes only and NOT INTENDED FOR CLINICAL USE.
%
%
%                 Kevin Tan, 2022 (github.io/kevmtan)

%% Input validation
arguments
    sbj {istext,isnumeric} = ""
    task {mustBeText} = ""
    o struct = struct % options struct (see "Options struct validation" below)
    n struct = [] % preloaded 'n' struct from ec_preproc (OPTIONAL)
    x {isfloat} = [] % preloaded EEG recordings: rows=frames, columns=channels (OPTIONAL)
    arg.dirs struct = [] % Directory paths struct
    arg.ica logical = false % Input data from ICA?
    arg.save logical = false
    arg.test logical = false
    arg.redoN logical = false
end
dirs = arg.dirs;
% n=[]; x=[]; o=os; arg.ica=0; arg.save=0; arg.test=1;


%% Options validation
if sbj==""; sbj = o.sbj; end
if task==""; task = o.task; end
if ~isstruct(dirs); dirs = ec_getDirs(dirs,sbj,task); end

% Options struct
if ~isfield(o,'fName');       o.fName="spec"; end     % Name of frequency analysis
if ~isfield(o,'fLims');       o.fLims=[1 300]; end    % Frequency limits in hz; HFB=[70 200]
if ~isfield(o,'fVoices');     o.fVoices=12; end       % Voices per octave (default=10, HFB=18)
if ~isfield(o,'dsTarg');      o.dsTarg=[]; end        % Downsample target in Hz (default=[]: no downsample)
if ~isfield(o,'single');      o.single=true; end      % Run & save as single (single much faster on GPU)
if ~isfield(o,'singleOut');   o.halfOut=true; end     % Save as half-precision float (16-bit) to save memory
if ~isfield(o,'doGPU');       o.doGPU=false; end      % Run on GPU, see MATLAB gpuArray requirements (default=false)
% if ~isfield(o,'GPUmex');      o.GPUmex=false; end
% if ~isfield(o,'norm');        o.norm=false; end         % Convert absolute values (log-normal) to normal distribution


%% Setup & initialize
tic; errors={};

% Load EEG data
if isempty(x) || arg.test
    if arg.ica && o.suffix==""; o.suffix="i"; end
    [n,x,~,~,chNfo] = ec_loadSbj(dirs,o.suffix);
end
if arg.test; xOg=x; chNfoOg=chNfo; end %#ok<NASGU>

% Convert to single-precision
if o.single; x=single(x); end

% Load metadata
sbjID = n.sbjID;
nRuns = n.nRuns;
n.task = task;
n.suffix = o.suffix;
fsOg = floor(n.fs);
if o.suffix==""; sfx=""; else; sfx="_"+o.suffix; end
if ~isfield(o,'dirOut'); o.dirOut=dirs.procSbj; end % Output directory
if ~isfield(o,'fnStr');  o.fnStr="s"+sbjID+"_"+task+".mat"; end % Filename ending string

% Get downsampling factor & anti-aliasing filter
if ~isempty(o.dsTarg)
    [ds(1),ds(2)] = rat(o.dsTarg/fsOg);
    if ds(1)>ds(2); error(sbj+" downsampling target > iEEG sampling rate"); end
else
    ds(1)=1; ds(2)=1;
end

% Only keep good channels (ICA chans rn)
idx = chNfo.ica;
x = x(:,idx);
chNfo = chNfo(idx,:);
nChs = nnz(idx);

% Calculate channel pairs
cc = uint16(1:nChs);
cc = combinations(cc,cc);
cc = renamevars(cc,[1 2],["i1" "i2"]);
cc = cc(cc.i1~=cc.i2,:); % Remove same-channel pairs
% Keep unique channel pairs only
for p = 1:nChs 
    idx = cc.i1>p & cc.i2==p;
    cc = cc(~idx,:);
end
cc.ch1 = chNfo.ch(cc.i1);
cc.ch2 = chNfo.ch(cc.i2);
nPairs = height(cc);

% Reset GPU, move vars to GPU, get free VRAM
if o.doGPU
    if ~isempty(gcp('nocreate')); parfevalOnAll(@gpuDevice,0,[]); delete(gcp('nocreate')); end
	try reset(gpuDevice()); catch; end
    memMax = gpuDevice().AvailableMemory; % see available vram
else
    try ppool = parpool('process'); catch;end %#ok<NASGU>
end

% Reshape per run
x = mat2cell(x,n.runIdxOg(:,2));
y = cell(nRuns,1);
cwtHz = cell(nRuns,1);
disp("[ec_wtc] Starting WTC: s"+n.sbjID+"_r"+run+" time="+toc);


%% Wavelet coherence (within-run to avoid edge artifacts)
for r = 1:nRuns
    % Get frequencies
    cwtHz{r} = cwtfilterbank(SignalLength=height(x{r}),VoicesPerOctave=o.fVoices,...
        SamplingFrequency=n.fs,FrequencyLimits=o.fLims,Wavelet="amor");
    cwtHz{r} = cwtHz{r}.centerFrequencies';
    nFrqs = numel(cwtHz{r});

    % Run wavelet coherence
    if o.doGPU
        [x{r},y{r}] = gpu_lfn2(x{r},cc,n,o,ds(1),ds(2),run);
        [x{r},y{r}] = gpu_lfn(x{r},cc,n,o,ds(1),ds(2),nFrqs,run,memMax);
    else
        [x{r},y{r}] = cpu_lfn(x{r},cc,ds(1),ds(2),n.fs,o.fLims,o.fVoices,n.sbjID,run);
    end

    %% Reshape & concactenate


    x{r} = permute(cat(3,x{r}{:}),[1 3 2]);
    y{r} = permute(cat(3,y{r}{:}),[1 3 2]);
    disp("[ec_wtc] Finished WTC: s"+n.sbjID+"_r"+run+" time="+toc);
end


%% Organize & clear memory
x = vertcat(x{:});
if ~fMean
    x = flip(x,3); % Sort freqs from low to high
end
n.xFrames = size(x,1);
n.xChs = nChs;
n.nFreqs = size(x,3);
n.freqs = flip(cwtHz{1});
n.freqsRun = vertcat(cwtHz{:});




%% Finalize
% Convert to single if specified
if singleOut; x = single(x); end

% Reset GPU
if doGPU
	if ~isempty(gcp('nocreate')); parfevalOnAll(@gpuDevice,0,[]); end
	try reset(gpuDevice()); catch; end
end

% Save
if arg.save
    % Save chNfo
    if o.doBadFrames && ~arg.ica
        fn = o.dirOut+"chNfo_"+o.fnStr;
        save(fn,'chNfo','-v7'); disp("SAVED: "+fn);
    end

    % Save n struct
    fn = o.dirOut+"n"+sfx+"_"+o.fnStr;
    save(fn,"n","-v7"); disp("SAVED: "+fn);

    % Save processed iEEG data
    fn = o.dirOut+"x"+sfx+"_"+o.fnStr;
    savefast(fn,'x'); disp("SAVED: "+fn+" time="+toc);
end




%%%%%%%%%%%%%%%%%%%%%%%%% SUBFUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




function [xx,yy] = gpu_lfn(xr,cc,n,o,ds,nFrqs,run,memMax)
%% Wavelet coherence within-run (GPU)
tic; 
% Get vars
nPairs=height(cc); c1=cc.i1; c2=cc.i2; xx=cell(1,nPairs); yy=xx;

% Calculate simultaneous iterations that fit in VRAM
mIn = whos("xr").bytes/width(xr);
mIn = mIn*nFrqs*2;
if ds(2)>ds(1); mIn = mIn*(ds(1)/ds(2))*(ds(2)/4); end
mItr = ceil(nPairs/floor(memMax/mIn));
mPairs = ceil(nPairs/mItr);

% Load to GPU
xr=gpuArray(xr); pFin=gpuArray(false(nPairs,1)); mItr=gpuArray(mItr);
disp("[ec_wtc] gpu_lfn start: s"+n.sbjID+"_r"+run+" pairs="+mPairs+"/"+nPairs+" time="+toc);

% Loop across gpuArrayFun iterations
for v = 1:mItr
    idx = find(~pFin,mPairs);
    [xx(idx),yy(idx)] = arrayfun(@(i1,i2) wtc_lfn(xr(:,i1),xr(:,i2),n.fs,...
        o.fLims,o.fVoices,ds(1),ds(2)), c1(idx),c2(idx),UniformOutput=false);
    xx(idx) = cellfun(@gather,xx(idx),UniformOutput=false);
    yy(idx) = cellfun(@gather,yy(idx),UniformOutput=false);
    pFin(idx) = true;
end

disp("[ec_wtc] gpu_lfn end: s"+n.sbjID+"_r"+run+" time="+toc);



function [xx,yy] = gpu_lfn2(xr,cc,n,o,ds(1),ds(2),run)
%% Wavelet coherence within-run (GPU)
tic; 
% Get vars
nPairs=height(cc); xx=cell(1,nPairs); yy=xx;

% Load to GPU
xr=gpuArray(xr); c1=gpuArray(cc.i1); c2=gpuArray(cc.i2);

% Loop across gpuArrayFun iterations
for p = gpuArray(uint16(1:24))
    [xx{p},yy{p}] = wtc_lfn(xr(:,c1(p)),xr(:,c2(p)),n.fs,o.fLims,...
        o.fVoices,ds(1),ds(2));
end

disp("[ec_wtc] gpu_lfn end: s"+n.sbjID+"_r"+run+" time="+toc);


function [xx,yy] = cpu_lfn(xr,cc,ds(1),ds(2),fs,fLims,fVoices,sbj,run)
%% Wavelet coherence within-run (GPU)
tic; 

% Get vars
nPairs=height(cc); c1=cc.i1; c2=cc.i2; xx=cell(1,nPairs); yy=xx;
disp("[ec_wtc] cpu_lfn start: s"+sbj+"_r"+run+" time="+toc);

parfor p = 1:nPairs
    [xx{p},yy{p}] = wtc_lfn(xr(:,c1(p)),xr(:,c2(p)),fs,fLims,...
        fVoices,ds(1),ds(2));
end
disp("[ec_wtc] cpu_lfn end: s"+sbj+"_r"+run+" time="+toc);


function [x,y] = wtc_lfn(x,y,fs,fLims,fVoices,ds(1),ds(2))
%% Wavelet coherence - local function

% Calculate wavelet coherence
[x,y] = wcoherence(x,y,fs,FrequencyLimits=fLims,VoicesPerOctave=fVoices);

% Downsample
if ds(2) > ds(1)
    x = resample(x,ds(1),ds(2),Dimension=2);
    y = resample(y,ds(1),ds(2),Dimension=2);
end

% Convert wavelet to phase angle
y = angle(y);